<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="栈是一种先进后出的数据结构，本示例讲述在开发《名为怪物的游戏》中巧妙的使用栈解决菜单系统按键冲突问题。"><meta name="keywords" content="游戏开发,技术"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>游戏菜单系统开发之栈的妙用 | 火兔博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="火兔博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">菜单系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">知识总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">这里是火兔博客，火兔兔的小窝。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">61</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">17</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="http://huotuyouxi.com">游戏博客</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">游戏菜单系统开发之栈的妙用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/">通用技术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="菜单系统"><a href="#菜单系统" class="headerlink" title="菜单系统"></a>菜单系统</h2><p>菜单是所有游戏必不可少的一个系统。</p>
<p>在游戏场景中，按 X 键可以呼出菜单，在菜单中按上下键可以切换菜单选项，再按 Z 键可以选中菜单，然后进入子页面的操作，子页面的菜单中也有子菜单，子菜单的操作与父级菜单一致。当打开菜单的状态，再按 X 键会返回上一级的菜单，直到主菜单返回游戏场景。</p>
<p>演示效果如下：</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GGIL5j.gif" alt="名为怪物的游戏 - 游戏菜单"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现菜单系统，最关键的地方在于防止按键冲突。</p>
<p>主菜单有按键事件，子菜单中也有按键事件，因此在主菜单中选中了子菜单，就要解除主菜单的监听事件而绑定子菜单的监听事件，多级菜单同理，可以归纳为：打开菜单——解除上一级的监听事件——绑定当前菜单的监听事件。</p>
<p>游戏的例子可能让从未接触过游戏的开发者难以理解，那么再看下一个例子。</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GGLnsI.png" alt="电商菜单"></p>
<p>上图为某电商首页的 UI，假如产品经理提出一个需求，在这个网页上按 X 键可以展开商品分类的菜单，然后通过键盘的按键可以选择二级菜单，选中一个分类再按 Z 键展开三级菜单，在展开菜单的情况下按 X 键会返回上一级菜单，你应该如何实现此功能？</p>
<p>如果使用正常的方法，用变量来判断打开了哪些菜单，然后再绑定对应的事件，你会发现很难实现无限级的菜单系统，而且业务代码会变得乱糟糟的。</p>
<p>比如情报页面有线索二级菜单，线索菜单又可以进入到线索列表三级菜单，而角色状态可能只有一个显示角色信息的 UI，只有切换角色的按钮，没有三级菜单。</p>
<p>每个主菜单的选项都可能是不同的，它们没有共同点，因此你无法使用继承的关系把相同的操作提取出来，每一个菜单都要单独判断，简直是 <code>if-else</code> 地狱，不难想象代码会乱成什么样子。</p>
<p>在这里我们可以用“栈”的特性来优雅的实现菜单系统。</p>
<blockquote>
<p>栈：一种先进后出的数据结构</p>
</blockquote>
<p>栈是一种先进先出的结构，与队列正好相反，而我们打开菜单，按 X 键也正好是逐级向上返回，符合了栈的特性——先打开的菜单最后关闭。</p>
<p>在这里核心点是 <strong>监听事件与解除监听</strong>，无需关心具体的业务逻辑。</p>
<blockquote>
<p>示例语言为 TypeScript，cocos creator 游戏引擎开发</p>
</blockquote>
<p>首先我们定义一个父类 <code>StackComponent</code> 这个父类是需要调用栈的组件必须继承的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 Scene_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default abstract class NewClass extends cc.Component &#123;</span><br><span class="line"></span><br><span class="line">    /** 添加监听按键 */</span><br><span class="line">    addListener() &#123;</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 移除监听按键 */</span><br><span class="line">    removeListener() &#123;</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract onKeyDown(event: cc.Event.EventKeyboard): void;</span><br><span class="line">    abstract onKeyUp(event: cc.Event.EventKeyboard): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>addListener</code> 方法添加按键监听，而 <code>removeListener</code> 方法则移除监听的事件，具体的按键事件进行了抽象，由子类来实现。</p>
<ul>
<li>onKeyDown：键盘按下的时候触发</li>
<li>onKeyUp：键盘弹起的时候触发</li>
</ul>
<p>接着定义一个栈结构，栈非常简单就可以实现，用一个数组来保存数据，用 <code>pop</code> 方法即可弹出最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 System_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line">import System_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class NewClass extends cc.Component &#123;</span><br><span class="line">    private _componentStacks: System_StackComponent[] = [];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空栈</span><br><span class="line">     */</span><br><span class="line">    flushStack() &#123;</span><br><span class="line">        this._componentStacks = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从栈取出最后一个元素</span><br><span class="line">     */</span><br><span class="line">    popStack() &#123;</span><br><span class="line">        var len = this._componentStacks.length;</span><br><span class="line">        if (len == 0) &#123;</span><br><span class="line">            cc.error(&#x27;栈已空，调用失败&#x27;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 弹出当前窗口</span><br><span class="line">        let pop = this._componentStacks.pop();</span><br><span class="line">        pop.removeListener();</span><br><span class="line">        // 最后一个元素添加监听</span><br><span class="line">        if (this._componentStacks.length != 0) &#123;</span><br><span class="line">            let last = this._componentStacks[this._componentStacks.length - 1];</span><br><span class="line">            last.addListener();</span><br><span class="line"></span><br><span class="line">            cc.log(&#x27;窗口出栈,剩余：&#x27; + this._componentStacks.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜单组件入栈</span><br><span class="line">     * @param  component </span><br><span class="line">     */</span><br><span class="line">    pushStack(component: System_StackComponent) &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">            cc.error(&#x27;这是一个空的元素&#x27;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 原来最后一个元素移除监听</span><br><span class="line">        let len = this._componentStacks.length;</span><br><span class="line">        if (len != 0) &#123;</span><br><span class="line">            let last = this._componentStacks[len - 1];</span><br><span class="line">            last.removeListener();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前元素添加监听</span><br><span class="line">        component.addListener();</span><br><span class="line"></span><br><span class="line">        this._componentStacks.push(component);</span><br><span class="line"></span><br><span class="line">        cc.log(&quot;入栈：&quot;, this._componentStacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>popStack</code> 方法弹出栈最顶层的元素，并且移除监听事件，同时监听新的顶层元素事件。</p>
<p><code>pushStack</code> 方法将新的菜单入栈，监听当前菜单事件并且移除原来菜单的事件。</p>
<p>栈中所有的元素都继承 <code>System_StackComponent</code> 栈组件，因此它们都具有 <code>addListener</code> 方法和 <code>removeListener</code> 方法。</p>
<p>接下来为了方便，我们把对象保存在 JavaScript 的系统对象 window 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window[&quot;__game&quot;][&quot;stack&quot;] = new System_Stack;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过 <code>__game.stack</code> 来调用栈的方法了。</p>
<p>主菜单脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line">import Scene_Menu_Item from &quot;./Scene_Menu_Item&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class Scene_Menu extends Scene_StackComponent &#123;</span><br><span class="line"></span><br><span class="line">    /** 关闭菜单 */</span><br><span class="line">    closeMenu() &#123;</span><br><span class="line">        // 弹出当前菜单事件</span><br><span class="line">        __game.stack.popStack();</span><br><span class="line">        // 销毁菜单节点（让菜单消失）</span><br><span class="line">        this.node.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 显示情报面板 */</span><br><span class="line">    showInformationPanel() &#123;</span><br><span class="line">        // 读取情报面板的预制资源</span><br><span class="line">        cc.loader.loadRes(&quot;/prefab/SceneInformation&quot;, (err, res) =&gt; &#123;</span><br><span class="line">            let clueNode = cc.instantiate(res);</span><br><span class="line">            let clue = clueNode.getComponent(&quot;Scene_Information&quot;);</span><br><span class="line">            // 把菜单脚本压入栈</span><br><span class="line">            __game.stack.pushStack(clue);</span><br><span class="line">            // 调用菜单脚本的初始化方法</span><br><span class="line">            clue.init();</span><br><span class="line">            // 把菜单节点添加到场景（显示菜单 UI）</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(clueNode);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 具体的监听事件</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        // 判断当前选项在“情报”菜单，如果此时按 Z 键则调用 showInformationPanel 方法显示情报页</span><br><span class="line">        // 判断按 X 键调用 closeMenu 方法关闭菜单</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        // 业务逻辑忽略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>closeMenu</code> 方法关闭当前菜单，并且弹出栈，在所有菜单关闭的时候都调用这个方法。</p>
<p><code>onKeyUp</code> 是键盘弹起事件，暂时不用理会。</p>
<p>在游戏场景加载中，为了能随时随地呼出菜单，我们再定义一个新的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// System_Menu.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line"></span><br><span class="line">import Scene_Menu from &quot;./Scene_Menu&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class System_Menu extends Scene_StackComponent &#123;</span><br><span class="line">    private _menuNode: cc.Node = null;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        __game.stack.pushStack(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听 X 键</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        switch (event.keyCode) &#123;</span><br><span class="line">            case cc.macro.KEY.x:</span><br><span class="line">                this.show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 显示菜单 */</span><br><span class="line">    show() &#123;</span><br><span class="line">        // 加载菜单预制资源并添加到场景</span><br><span class="line">        cc.loader.loadRes(&quot;/prefab/Menu&quot;, (err, res) =&gt; &#123;</span><br><span class="line">            let node = cc.instantiate(res);</span><br><span class="line">            let menu: Scene_Menu = node.getComponent(&quot;Scene_Menu&quot;);</span><br><span class="line">            // 将主菜单入栈</span><br><span class="line">            __game.stack.pushStack(menu);</span><br><span class="line">            this._menuNode = node;</span><br><span class="line">            // 添加到场景</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(node);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将这个类添加到 window 系统对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加到 window 对象</span><br><span class="line">window[&quot;__game&quot;][&quot;menu&quot;] = new System_Menu;</span><br><span class="line">// 执行初始化操作（入栈）</span><br><span class="line">__game.menu.init();</span><br></pre></td></tr></table></figure>

<p>如此一来，我们就可以随时随地通过全局的方法 <code>__game.menu.show()</code> 调出菜单了！</p>
<p>注意！<code>System_Menu</code> 脚本并没有出栈的操作，因为如果这个脚本出栈了，那就不能监听 X 呼出菜单的事件，保留最底层的监听以便随时呼出菜单。</p>
<h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>由于菜单是一级一级往上打开，而关闭的时候是一级一级向下关闭，因此它符合栈的结构，当一个菜单节点入栈时，我们为它绑定监听事件，同时解除上一级菜单的监听事件；当一个菜单出栈时，我们就解除这个菜单的监听事件，然后再给栈新的顶层节点绑定监听事件，无论有多少级的菜单都能够用这种结构来实现，只要让它们继承 <code>StackComponent</code> 类即可实现栈的调用控制事件的监听与解除，比起用变量来判断打开了哪些菜单，是不是优雅得多呢？</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://huotublog.com/2020/04/02/game-developer-stack/">http://huotublog.com/2020/04/02/game-developer-stack/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/09/mysql-memory-optimize/"><i class="fa fa-chevron-left">  </i><span>MySQL占用内存过高优化记录</span></a></div><div class="next-post pull-right"><a href="/2020/04/01/javascript-object-issue/"><span>Javascript使用对象必须知道的一件事</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By 火烧兔子</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="魔术方法是 PHP 类中特殊的方法，以双下划线 `__` 开头，具有特殊用途，比如我们常用的 `__construct` 构造函数就属于魔术方法。"><meta name="keywords" content="PHP,技术"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>PHP中的魔术方法 | 火兔博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="火兔博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">魔术方法是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP-%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">PHP 中的魔术方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#construct"><span class="toc-number">3.1.</span> <span class="toc-text">__construct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destruct"><span class="toc-number">3.2.</span> <span class="toc-text">__destruct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">3.3.</span> <span class="toc-text">__get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">3.4.</span> <span class="toc-text">__set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">3.5.</span> <span class="toc-text">__toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">3.6.</span> <span class="toc-text">__call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#callStatic"><span class="toc-number">3.7.</span> <span class="toc-text">__callStatic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invoke"><span class="toc-number">3.8.</span> <span class="toc-text">__invoke</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">3.9.</span> <span class="toc-text">__clone</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">更多的魔术方法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">这里是火兔博客，火兔兔的小窝。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">63</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">18</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="http://huotuyouxi.com">游戏博客</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">PHP中的魔术方法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/PHP/">PHP</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="魔术方法是什么？"><a href="#魔术方法是什么？" class="headerlink" title="魔术方法是什么？"></a>魔术方法是什么？</h2><p>魔术方法是 PHP 类中特殊的方法，以双下划线 <code>__</code> 开头，具有特殊用途，比如我们常用的 <code>__construct</code> 构造函数就属于魔术方法，构造函数的作用是类实例化自动调用的方法。</p>
<p>魔术方法的名称都是系统预定义的，无法修改，我们在写 PHP 代码的时候，为了避免与系统预定义函数相同，不建议用双下划线 <code>__</code> 作为函数的前缀。</p>
<p>魔术方法的作用可以归纳为：<strong>对象在 xxx 的时候，应该实现的功能。</strong></p>
<p>比如，上述构造函数可以理解为：对象在“实例化”的时候，应该实现的功能。</p>
<p>除此之外，与构造函数相对的 <strong>析构函数</strong> <code>__destruct</code> 可以在对象被回收时自动调用。</p>
<p>如果有 Java 基础，你可以发现类默认有一种 <code>toString</code> 方法，可以把对象转化成字符串。其实 PHP 中也存在同样的魔术方法 <code>__toString</code>，当类的对象被当做字符串调用时会自动执行此方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;Just a dog.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure>

<p>执行的结果会输出：Just a dog.</p>
<p>为什么在上述代码中，echo 可以输出一个对象呢？</p>
<p>这是因为我们设置了 <code>__toString</code> 方法，当对象被当做字符串调用时会自动触发 <code>__toString</code> 方法。</p>
<p>换而言之，<strong>魔术方法是一类由系统预定义了函数名称，在某些情况下被动触发的函数</strong>。</p>
<p>所有的魔术方法都不是用来主动调用的，如下错误示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 错误示范</span><br><span class="line">$obj = new MyClass();</span><br><span class="line">$obj-&gt;__construct();</span><br></pre></td></tr></table></figure>

<p>魔术方法也是类的方法，上述代码逻辑上没有问题而且可以运行且不会报错。不会报错不代表这么写没问题，魔术方法中<strong>不应该</strong>放入业务逻辑相关的代码。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>魔术方法大都用于框架且与设计模式关联紧密，日常业务除了构造方法之外几乎很少接触到其他魔术方法。<br>Laravel 框架将魔术方法用到了极致，被称为“优雅”的框架。</p>
<h2 id="PHP-中的魔术方法"><a href="#PHP-中的魔术方法" class="headerlink" title="PHP 中的魔术方法"></a>PHP 中的魔术方法</h2><p>下面介绍 PHP 常见的魔术方法以及应用场景和示例代码。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>俗称类的构造方法，当类被实例化为对象时自动调用。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Just a dog.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br></pre></td></tr></table></figure>

<p>输出：Just a dog.</p>
<blockquote>
<p>void __construct ([ mixed $args [, $… ]] )</p>
</blockquote>
<p>构造函数的几大特征：</p>
<ul>
<li>构造函数可以接受参数，能够在创建对象时赋值给对象属性</li>
<li>构造函数可以调用类方法或其他函数</li>
<li>构造函数可以调用其他类的构造函数</li>
<li>构造函数的权限可以被修改</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;This is animal.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 父类构造函数不会自动调用，需要手动进行调用</span><br><span class="line">        parent::__construct();</span><br><span class="line">        </span><br><span class="line">        // 对象赋值</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line"></span><br><span class="line">        // 调用类中的方法</span><br><span class="line">        $this-&gt;jump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function jump()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name . &#x27; jump.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog(&#x27;小白&#x27;);</span><br></pre></td></tr></table></figure>

<p>最后一条：<strong>构造函数的权限可以被修改。</strong></p>
<p>在设计模式中会用到，例如单例模式，为了防止子类被实例化，会将构造函数限制为 <code>private</code> 私有化。</p>
<p>一个比较标准的单例模式示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Singleton &#123;</span><br><span class="line">    // 私有属性，用于保存实例</span><br><span class="line">    private static $instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化，防止外部创建实例</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 公有方法，用于获取实例</span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        // 没有的话创建实例并返回，有的话直接返回</span><br><span class="line">        if(!(self::$instance instanceof self))&#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 克隆方法私有化，防止复制实例</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h3><p>俗称析构函数，当对象被回收时自动调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;The dog is dead.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">unset($dog);</span><br></pre></td></tr></table></figure>

<p>输出：The dog is dead.</p>
<blockquote>
<p>void __destruct ( void )</p>
</blockquote>
<p>析构函数的特征：</p>
<ul>
<li>析构函数不能接受参数</li>
<li>析构函数不能抛出异常</li>
</ul>
<p>由于析构函数在对象被回收时触发，因此如果抛出异常将无法被捕获，抛出异常情况下将报出致命错误。</p>
<p>和构造函数一样，父类的析构函数不会被隐式调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用： <code>parent::__destruct();</code></p>
<h3 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h3><p>当调用对象中不存在的属性时，自动触发该方法。</p>
<p>Laravel 框架里几乎随处可见，如 Model 对象调用表的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::find(1);</span><br><span class="line">echo $user-&gt;name;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs = [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure>

<p>输出：NULL</p>
<p>通常情况下，如果直接调用对象中不存在的属性会产生报错，但是设置了 <code>__get</code> 方法后，如果调用了不存在的属性则会转而调用这个方法处理。通常 <code>__get</code> 要结合 <code>__set</code> 一起使用。</p>
<h3 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h3><p>当设置对象中不存在的属性时，自动触发该方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs = [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __set($name, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;attrs[$name] = $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;name = &#x27;小白&#x27;;</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure>

<p>输出：string(6) “小白”</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h3><p>当对象被当成字符串调用时，自动触发该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;Dog name is &#x27; . $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog(&#x27;小黑&#x27;);</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure>

<p>输出：Dog name is 小黑</p>
<p>这个魔术方法在调试的时候非常有用，可以把对象中的参数信息打印出来，记录到日志里。</p>
<h3 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h3><p>当对象调用了一个类中不存在的方法或者没有权限调用的方法时，自动触发。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function aPrivateMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Im private.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;fly(&#x27;666&#x27;);</span><br><span class="line">$dog-&gt;aPrivateMethod();</span><br></pre></td></tr></table></figure>

<p>第一个 fly 方法，不存在 Dog 类中；第二个 aPrivateMethod 是私有方法，不能直接被对象调用，因而触发了 <code>__call</code> 方法。</p>
<p>在 Laravel 中也可以看到许多 <code>__call</code> 应用的场景，还是 Model 类的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::whereName(&#x27;xiaobai&#x27;)-&gt;first();</span><br><span class="line">dd($user);</span><br></pre></td></tr></table></figure>

<p>这里的 where 后面接大驼峰方式的参数，相当于如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user = User::where(&#x27;name&#x27;, &#x27;xiaobai&#x27;)-&gt;first();</span><br></pre></td></tr></table></figure>

<p>通过 <code>__call</code> 方法实现简写的目的。</p>
<p><code>__call</code> 方法接收两个参数，第一个参数是调用方法的名称，第二个参数是调用方法时传入的参数，数组格式。</p>
<h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic"></a>__callStatic</h3><p>当对象调用了一个不存在的静态方法时，自动触发。</p>
<p><code>__callStatic</code> 与 <code>__call</code> 的作用基本相似，只不过 <code>__callStatic</code> 针对的是静态方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public static function __callStatic($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog::whatsYourProblem();</span><br></pre></td></tr></table></figure>

<p>这样的设计在 Laravel 框架中也能看到，依然是 Model 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users = User::all();</span><br><span class="line">$items = Item::where(&#x27;price&#x27;, &#x27;&gt;&#x27;, 100)-&gt;paginate(20);</span><br></pre></td></tr></table></figure>

<p>Laravel 中的 Model 并不是把方法真的当做静态方法，而是利用 <code>__callStatic</code> 让你产生“静态调用”的错觉。</p>
<h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h3><p>当尝试以调用方法的形式来调用一个对象时，自动触发该方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __invoke($parm1, $parm2)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($parm1,$parm2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog(&#x27;小白&#x27;,&#x27;小黑&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">string(6) &quot;小黑&quot;</span><br></pre></td></tr></table></figure>

<p><code>__invoke</code> 可以接收自定义的任意参数，与函数的形参规则一致。</p>
<p>我们知道这种方法有点奇怪，谁也不会把一个对象当成方法来用吧？</p>
<p>让我们来康康 Laravel 框架是怎么利用 <code>__invoke</code> 让代码变得更“优雅”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1、指定路由及对应的方法</span><br><span class="line">Route::get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;);</span><br><span class="line"></span><br><span class="line">// 2、不指定对应的方法，自动调用 __invoke</span><br><span class="line">Route::get(&#x27;/user/default&#x27;, &#x27;UserController&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    // 1、/user 调用 index 方法</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2、/user/default 没有指定方法，自动调用 __invoke</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不指定具体的方法时，Laravel 的路由会把对象当做方法来执行，从而调用 <code>__invoke</code> 方法，简化了路由部分的代码。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="__clone"></a>__clone</h3><p>当对象被克隆时，自动调用。</p>
<p>PHP 中存在一个关键词 clone 可以复制对象，并且复制出来的对象为独立的个体，与原对象不存在互相影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;new dog birth.&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;name = &#x27;小白&#x27;;</span><br><span class="line"></span><br><span class="line">// 克隆出来的对象属性与原对象一模一样</span><br><span class="line">$cloneDog = clone $dog;</span><br><span class="line">var_dump($cloneDog-&gt;name);</span><br><span class="line"></span><br><span class="line">// 修改克隆对象的属性，不会影响原对象</span><br><span class="line">$cloneDog-&gt;name = &#x27;小黑&#x27;;</span><br><span class="line">var_dump($dog, $cloneDog);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new dog birth.</span><br><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">object(Dog)#1 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(6) &quot;小白&quot;</span><br><span class="line">&#125;</span><br><span class="line">object(Dog)#2 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(6) &quot;小黑&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现，克隆出来的对象修改了属性，但是原来对象的属性保持不变，它们是互相独立的个体，也就是说并非引用关系，clone 会开辟一块新的内存来存储复制出来的新对象。</p>
<p><code>__clone</code> 方法在 clone 出新对象时自动调用。</p>
<p>clone 业务中用得比较少，应用场景能想到的一个是重构代码，我们需要增加一个新的接口来应对新的需求，但同时又不希望破坏旧接口的内部结构，也不希望直接在旧接口的代码上修改，此时可以使用 clone，既可以向下兼容作用，又能在旧接口上添加新功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class NewDogAction</span><br><span class="line">&#123;</span><br><span class="line">    // 新接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OldDogAction</span><br><span class="line">&#123;</span><br><span class="line">    // 旧版接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    // 动作类对象</span><br><span class="line">    private $action;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action = new OldDogAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action = new NewDogAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 clone 出来的时候，action 被替换成新的接口代码。</p>
<p>换成比较形象的例子：</p>
<p>鸣人使用多重影分身之术，可以看成是 clone 出很多个分身，但是这些分身并不能 100% 继承本体的能力，本体的能力可以看成上面的 <code>oldDogAction</code>，而分身的能力则是 <code>newDogAction</code>，分身除了 action 属性之外其他的地方与本体并无差异。</p>
<h2 id="更多的魔术方法"><a href="#更多的魔术方法" class="headerlink" title="更多的魔术方法"></a>更多的魔术方法</h2><p>如果有兴趣了解全部的魔术方法，请访问 <a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP：魔术方法</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://huotublog.com/2020/03/10/php-magic-methods/">http://huotublog.com/2020/03/10/php-magic-methods/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PHP/">PHP</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/10/php-reflex/"><i class="fa fa-chevron-left">  </i><span>PHP中的反射</span></a></div><div class="next-post pull-right"><a href="/2020/03/10/supervisord/"><span>进程管理工具 Supervisord</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By 火烧兔子</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
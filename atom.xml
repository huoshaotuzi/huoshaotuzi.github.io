<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的文档</title>
  
  <subtitle>开发日记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.idce.com/"/>
  <updated>2020-04-02T05:42:44.952Z</updated>
  <id>https://www.idce.com/</id>
  
  <author>
    <name>火烧兔子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏菜单系统开发之栈的妙用</title>
    <link href="https://www.idce.com/game-developer-stack/"/>
    <id>https://www.idce.com/game-developer-stack/</id>
    <published>2020-04-02T03:43:09.000Z</published>
    <updated>2020-04-02T05:42:44.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="菜单系统"><a href="#菜单系统" class="headerlink" title="菜单系统"></a>菜单系统</h2><p>菜单是所有游戏必不可少的一个系统。</p><p>在游戏场景中，按 X 键可以呼出菜单，在菜单中按上下键可以切换菜单选项，再按 Z 键可以选中菜单，然后进入子页面的操作，子页面的菜单中也有子菜单，子菜单的操作与父级菜单一致。当打开菜单的状态，再按 X 键会返回上一级的菜单，直到主菜单返回游戏场景。</p><p>演示效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/02/GGIL5j.gif" alt="名为怪物的游戏 - 游戏菜单"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现菜单系统，最关键的地方在于防止按键冲突。</p><p>主菜单有按键事件，子菜单中也有按键事件，因此在主菜单中选中了子菜单，就要解除主菜单的监听事件而绑定子菜单的监听事件，多级菜单同理，可以归纳为：打开菜单——解除上一级的监听事件——绑定当前菜单的监听事件。</p><p>游戏的例子可能让从未接触过游戏的开发者难以理解，那么再看下一个例子。</p><p><img src="https://s1.ax1x.com/2020/04/02/GGLnsI.png" alt="电商菜单"></p><p>上图为某电商首页的 UI，假如产品经理提出一个需求，在这个网页上按 X 键可以展开商品分类的菜单，然后通过键盘的按键可以选择二级菜单，选中一个分类再按 Z 键展开三级菜单，在展开菜单的情况下按 X 键会返回上一级菜单，你应该如何实现此功能？</p><p>如果使用正常的方法，用变量来判断打开了哪些菜单，然后再绑定对应的事件，你会发现很难实现无限级的菜单系统，而且业务代码会变得乱糟糟的。</p><p>比如情报页面有线索二级菜单，线索菜单又可以进入到线索列表三级菜单，而角色状态可能只有一个显示角色信息的 UI，只有切换角色的按钮，没有三级菜单。</p><p>每个主菜单的选项都可能是不同的，它们没有共同点，因此你无法使用继承的关系把相同的操作提取出来，每一个菜单都要单独判断，简直是 <code>if-else</code> 地狱，不难想象代码会乱成什么样子。</p><p>在这里我们可以用“栈”的特性来优雅的实现菜单系统。</p><blockquote><p>栈：一种先进后出的数据结构</p></blockquote><p>栈是一种先进先出的结构，与队列正好相反，而我们打开菜单，按 X 键也正好是逐级向上返回，符合了栈的特性——先打开的菜单最后关闭。</p><p>在这里核心点是 <strong>监听事件与解除监听</strong>，无需关心具体的业务逻辑。</p><blockquote><p>示例语言为 TypeScript，cocos creator 游戏引擎开发</p></blockquote><p>首先我们定义一个父类 <code>StackComponent</code> 这个父类是需要调用栈的组件必须继承的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件名 Scene_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default abstract class NewClass extends cc.Component &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 添加监听按键 *&#x2F;</span><br><span class="line">    addListener() &#123;</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 移除监听按键 *&#x2F;</span><br><span class="line">    removeListener() &#123;</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract onKeyDown(event: cc.Event.EventKeyboard): void;</span><br><span class="line">    abstract onKeyUp(event: cc.Event.EventKeyboard): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addListener</code> 方法添加按键监听，而 <code>removeListener</code> 方法则移除监听的事件，具体的按键事件进行了抽象，由子类来实现。</p><ul><li>onKeyDown：键盘按下的时候触发</li><li>onKeyUp：键盘弹起的时候触发</li></ul><p>接着定义一个栈结构，栈非常简单就可以实现，用一个数组来保存数据，用 <code>pop</code> 方法即可弹出最后一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件名 System_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line">import System_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class NewClass extends cc.Component &#123;</span><br><span class="line">    private _componentStacks: System_StackComponent[] &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空栈</span><br><span class="line">     *&#x2F;</span><br><span class="line">    flushStack() &#123;</span><br><span class="line">        this._componentStacks &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从栈取出最后一个元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    popStack() &#123;</span><br><span class="line">        var len &#x3D; this._componentStacks.length;</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            cc.error(&#39;栈已空，调用失败&#39;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 弹出当前窗口</span><br><span class="line">        let pop &#x3D; this._componentStacks.pop();</span><br><span class="line">        pop.removeListener();</span><br><span class="line">        &#x2F;&#x2F; 最后一个元素添加监听</span><br><span class="line">        if (this._componentStacks.length !&#x3D; 0) &#123;</span><br><span class="line">            let last &#x3D; this._componentStacks[this._componentStacks.length - 1];</span><br><span class="line">            last.addListener();</span><br><span class="line"></span><br><span class="line">            cc.log(&#39;窗口出栈,剩余：&#39; + this._componentStacks.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 菜单组件入栈</span><br><span class="line">     * @param  component </span><br><span class="line">     *&#x2F;</span><br><span class="line">    pushStack(component: System_StackComponent) &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">            cc.error(&#39;这是一个空的元素&#39;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 原来最后一个元素移除监听</span><br><span class="line">        let len &#x3D; this._componentStacks.length;</span><br><span class="line">        if (len !&#x3D; 0) &#123;</span><br><span class="line">            let last &#x3D; this._componentStacks[len - 1];</span><br><span class="line">            last.removeListener();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前元素添加监听</span><br><span class="line">        component.addListener();</span><br><span class="line"></span><br><span class="line">        this._componentStacks.push(component);</span><br><span class="line"></span><br><span class="line">        cc.log(&quot;入栈：&quot;, this._componentStacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popStack</code> 方法弹出栈最顶层的元素，并且移除监听事件，同时监听新的顶层元素事件。</p><p><code>pushStack</code> 方法将新的菜单入栈，监听当前菜单事件并且移除原来菜单的事件。</p><p>栈中所有的元素都继承 <code>System_StackComponent</code> 栈组件，因此它们都具有 <code>addListener</code> 方法和 <code>removeListener</code> 方法。</p><p>接下来为了方便，我们把对象保存在 JavaScript 的系统对象 window 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window[&quot;__game&quot;][&quot;stack&quot;] &#x3D; new System_Stack;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过 <code>__game.stack</code> 来调用栈的方法了。</p><p>主菜单脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line">import Scene_Menu_Item from &quot;.&#x2F;Scene_Menu_Item&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class Scene_Menu extends Scene_StackComponent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 关闭菜单 *&#x2F;</span><br><span class="line">    closeMenu() &#123;</span><br><span class="line">        &#x2F;&#x2F; 弹出当前菜单事件</span><br><span class="line">        __game.stack.popStack();</span><br><span class="line">        &#x2F;&#x2F; 销毁菜单节点（让菜单消失）</span><br><span class="line">        this.node.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 显示情报面板 *&#x2F;</span><br><span class="line">    showInformationPanel() &#123;</span><br><span class="line">        &#x2F;&#x2F; 读取情报面板的预制资源</span><br><span class="line">        cc.loader.loadRes(&quot;&#x2F;prefab&#x2F;SceneInformation&quot;, (err, res) &#x3D;&gt; &#123;</span><br><span class="line">            let clueNode &#x3D; cc.instantiate(res);</span><br><span class="line">            let clue &#x3D; clueNode.getComponent(&quot;Scene_Information&quot;);</span><br><span class="line">            &#x2F;&#x2F; 把菜单脚本压入栈</span><br><span class="line">            __game.stack.pushStack(clue);</span><br><span class="line">            &#x2F;&#x2F; 调用菜单脚本的初始化方法</span><br><span class="line">            clue.init();</span><br><span class="line">            &#x2F;&#x2F; 把菜单节点添加到场景（显示菜单 UI）</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(clueNode);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 具体的监听事件</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断当前选项在“情报”菜单，如果此时按 Z 键则调用 showInformationPanel 方法显示情报页</span><br><span class="line">        &#x2F;&#x2F; 判断按 X 键调用 closeMenu 方法关闭菜单</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        &#x2F;&#x2F; 业务逻辑忽略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>closeMenu</code> 方法关闭当前菜单，并且弹出栈，在所有菜单关闭的时候都调用这个方法。</p><p><code>onKeyUp</code> 是键盘弹起事件，暂时不用理会。</p><p>在游戏场景加载中，为了能随时随地呼出菜单，我们再定义一个新的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; System_Menu.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line"></span><br><span class="line">import Scene_Menu from &quot;.&#x2F;Scene_Menu&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class System_Menu extends Scene_StackComponent &#123;</span><br><span class="line">    private _menuNode: cc.Node &#x3D; null;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        __game.stack.pushStack(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 监听 X 键</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        switch (event.keyCode) &#123;</span><br><span class="line">            case cc.macro.KEY.x:</span><br><span class="line">                this.show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 显示菜单 *&#x2F;</span><br><span class="line">    show() &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载菜单预制资源并添加到场景</span><br><span class="line">        cc.loader.loadRes(&quot;&#x2F;prefab&#x2F;Menu&quot;, (err, res) &#x3D;&gt; &#123;</span><br><span class="line">            let node &#x3D; cc.instantiate(res);</span><br><span class="line">            let menu: Scene_Menu &#x3D; node.getComponent(&quot;Scene_Menu&quot;);</span><br><span class="line">            &#x2F;&#x2F; 将主菜单入栈</span><br><span class="line">            __game.stack.pushStack(menu);</span><br><span class="line">            this._menuNode &#x3D; node;</span><br><span class="line">            &#x2F;&#x2F; 添加到场景</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(node);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将这个类添加到 window 系统对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加到 window 对象</span><br><span class="line">window[&quot;__game&quot;][&quot;menu&quot;] &#x3D; new System_Menu;</span><br><span class="line">&#x2F;&#x2F; 执行初始化操作（入栈）</span><br><span class="line">__game.menu.init();</span><br></pre></td></tr></table></figure><p>如此一来，我们就可以随时随地通过全局的方法 <code>__game.menu.show()</code> 调出菜单了！</p><p>注意！<code>System_Menu</code> 脚本并没有出栈的操作，因为如果这个脚本出栈了，那就不能监听 X 呼出菜单的事件，最底层的监听还是要保留滴！</p><p>其实这个底层的节点也可以出栈（比如角色对话的时候不能呼出菜单，而是转移到监听对话按键），等对话结束后再重新入栈。</p><p>总之，所有需要监听按键的组件都可以用栈组件来实现！</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>由于菜单是一级一级往上打开，而关闭的时候是一级一级向下关闭，因此它符合栈的结构，当一个菜单节点入栈时，我们为它绑定监听事件，同时解除上一级菜单的监听事件；当一个菜单出栈时，我们就解除这个菜单的监听事件，然后再给栈新的顶层节点绑定监听事件，无论有多少级的菜单都能够用这种结构来实现，只要让它们继承 <code>StackComponent</code> 类即可实现栈的调用控制事件的监听与解除，比起用变量来判断打开了哪些菜单，是不是优雅得多呢？</p>]]></content>
    
    <summary type="html">
    
      栈是一种先进后出的数据结构，本示例讲述在开发《名为怪物的游戏》中巧妙的使用栈解决菜单系统按键冲突问题。
    
    </summary>
    
    
      <category term="通用技术" scheme="https://www.idce.com/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://www.idce.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="https://www.idce.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Javascript使用对象必须知道的一件事</title>
    <link href="https://www.idce.com/javascript-object-issue/"/>
    <id>https://www.idce.com/javascript-object-issue/</id>
    <published>2020-04-01T08:32:49.000Z</published>
    <updated>2020-04-01T08:51:34.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 中，对象即引用。</p><p>我们知道引用的特性：</p><p>将对象赋值给另一个变量，另一个变量的值如果改变，原对象的值也会改变。</p><p>引用即是内存地址的指向，将对象赋值给另一个变量，相当于另一个变量也指向了同一块内存地址，因此改变值时，原对象的值也会跟着变。通过下面的例子来了解一下引用的特性。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 将json对象赋值给另一个变量</span><br><span class="line">let data &#x3D; json;</span><br><span class="line">data.aa &#x3D; &quot;no ok!&quot;;</span><br><span class="line">&#x2F;&#x2F; 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>在控制面板上的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们原本是希望把 json 变量的值赋值给另一个变量 data，本意是不希望修改 json 的值，但由于 JavaScript 中对象即引用的特性会导致原来的值发生改变。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用 <code>Object.assign(target, source)</code> 方法将 source 对象复制一份给 target 变量，类似 PHP 中的 clone，复制出来的变量会独立占据一片内存空间，而不是原对象的引用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 复制对象到data</span><br><span class="line">let data &#x3D; &#123;&#125;;</span><br><span class="line">Obejct.assign(data, json);</span><br><span class="line">&#x2F;&#x2F; 修改aa的值</span><br><span class="line">data.aa &#x3D; &quot;no ok!&quot;;</span><br><span class="line">&#x2F;&#x2F; 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;Im aa&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，原来的 json 对象的值没有改变。</p><p>在 TypeScript 中，不能直接使用 <code>Object.assign</code> 方法，而是要使用 <code>(&lt;any&gt;Object).assign</code>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 复制对象到data</span><br><span class="line">let data &#x3D; &#123;&#125;;</span><br><span class="line">(&lt;any&gt;Object).assign(data, json);</span><br></pre></td></tr></table></figure><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>由于 cocos creator 使用的是 JavaScript 和 TypeScript 开发，今天在制作游戏的事件系统，遇到一个神秘的 BUG，排查了好久一直没找到原因，突然想起来以前也遇到过同样的问题，为了涨点记性，特此记录。</p>]]></content>
    
    <summary type="html">
    
      JavaScript中，对象即引用。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://www.idce.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.idce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Linux自定义别名——大幅提高工作效率！</title>
    <link href="https://www.idce.com/linux-alias/"/>
    <id>https://www.idce.com/linux-alias/</id>
    <published>2020-03-30T17:29:34.000Z</published>
    <updated>2020-03-30T17:34:01.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-系统命令"><a href="#Linux-系统命令" class="headerlink" title="Linux 系统命令"></a>Linux 系统命令</h2><p>在 <code>Linux</code> 系统中，诸如 <code>ls</code>、<code>top</code>、<code>ps</code> 此类为 <code>Linux</code> 系统内置的命令，我们希望通过自定义命令来作为某些复杂命令的组合，如自定义 <code>ll</code> 为 <code>ls -alF</code> 的简写，通过简写可以大幅缩短输入命令的时间，还可以避免输错命令，何乐而不为呢？</p><h2 id="自定义-Linux-命令-添加别名-Alias"><a href="#自定义-Linux-命令-添加别名-Alias" class="headerlink" title="自定义 Linux 命令 / 添加别名 Alias"></a>自定义 Linux 命令 / 添加别名 Alias</h2><p>自定义命令其实就是添加一个别名，执行如下命令创建别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure><p>在这个文件里输入需要创建的别名，例如 <code>ll</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll&#x3D;&#39;ls -alF&#39;</span><br></pre></td></tr></table></figure><p>然后保存，再执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>现在，使用 <code>ll</code> 等价于输入 <code>ls -alF</code>。</p><p>可以将常用的命令组合简写，例如我们常用来查看进程的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias psp&#x3D;&#39;ps -ef|grep&#39;</span><br></pre></td></tr></table></figure><p>以后只需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 PHP 进程</span><br><span class="line">psp php</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">FireRabbitdeMacBook-Pro:~ firerabbit$ psp php</span><br><span class="line">  501 89356     1   0 二07下午 ??        29:02.94 &#x2F;Applications&#x2F;PhpStorm.app&#x2F;Contents&#x2F;MacOS&#x2F;phpstorm</span><br><span class="line">  501 99412 99183   0  9:20下午 ttys005    0:00.00 grep php</span><br></pre></td></tr></table></figure><p>对于记不住命令的小金鱼们来说，利用好别名可以事半功倍哟！</p><h2 id="注意事项！"><a href="#注意事项！" class="headerlink" title="注意事项！"></a>注意事项！</h2><p>别名的使用只有定义者自己知道，因此不适合多人协作的工作。在日常的开发中（如在个人的 Mac），可以自定义一些常用的别名来提高自己工作的效率。</p>]]></content>
    
    <summary type="html">
    
      Linux 系统需要使用繁多的命令，有时候你可以把常用的命令设置为别名（相当于缩写），大大提高工作效率。
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.idce.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.idce.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis添加密码验证</title>
    <link href="https://www.idce.com/redis-add-permission/"/>
    <id>https://www.idce.com/redis-add-permission/</id>
    <published>2020-03-30T17:24:22.000Z</published>
    <updated>2020-03-30T17:28:37.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要为-Redis-添加密码验证？"><a href="#为什么要为-Redis-添加密码验证？" class="headerlink" title="为什么要为 Redis 添加密码验证？"></a>为什么要为 Redis 添加密码验证？</h2><p>默认情况下，<code>redis</code> 不需要使用密码即可连接，而由于默认开放端口为 6379（用户一般不会去修改这个端口），导致基本信息完全暴露给试图攻击服务器者。</p><blockquote><p>IDCE.COM 建站之初未设置 redis 密码，结果被注入了挖矿病毒 %&gt;_&lt;%</p></blockquote><p>没有任何密码验证，意味着任何人都能访问到服务器的 Redis 服务，可能造成重要的信息泄露或者被访问者恶意删除造成严重后果！</p><p>总而言之，如果要使用 Redis 服务，那么最好为 <code>redis</code> 加上密码验证可以增加系统的安全性。</p><h2 id="开启-redis-密码验证"><a href="#开启-redis-密码验证" class="headerlink" title="开启 redis 密码验证"></a>开启 redis 密码验证</h2><p>以 <code>Linux</code> 系统为例，首先找到 <code>redis.conf</code> 配置文件，如果不知道文件在哪可以使用命令 <code>find / -name redis.conf</code> 找到。</p><p>添加 <code>requirepass</code> 字段，后面即你需要设置的密码，建议生成一个足够长的随机字符串来作为密码。</p><p><img src="https://i.loli.net/2019/08/29/l7msnYqtQeOiUNp.png" alt="image.png"></p><p>完成后保存，重启 <code>redis</code> 即可！</p><h2 id="Redis-cli-验证密码"><a href="#Redis-cli-验证密码" class="headerlink" title="Redis-cli 验证密码"></a>Redis-cli 验证密码</h2><p>在 <code>cli</code> 模式下，如果设置了密码需要验证之后才能执行 <code>redis</code> 操作，进入 <code>redis</code> 服务，然后执行 <code>auth 密码</code> 即可。</p><p><img src="https://i.loli.net/2019/08/29/VqJUpRx25HbELGA.png" alt="image.png"></p><h2 id="PHP-验证-Redis-密码"><a href="#PHP-验证-Redis-密码" class="headerlink" title="PHP 验证 Redis 密码"></a>PHP 验证 Redis 密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$redis &#x3D; new Redis(); </span><br><span class="line">$redis-&gt;connect(&#39;127.0.0.1&#39;, 6379); &#x2F;&#x2F;连接Redis</span><br><span class="line">$redis-&gt;auth(&#39;123456&#39;); &#x2F;&#x2F;密码验证</span><br><span class="line">$redis-&gt;select(2);&#x2F;&#x2F;选择数据库2</span><br><span class="line">$redis-&gt;set( &quot;testKey&quot; , &quot;Hello Redis&quot;); &#x2F;&#x2F;设置测试key</span><br><span class="line">echo $redis-&gt;get(&quot;testKey&quot;);&#x2F;&#x2F;输出value</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Redis 如果没有设置密码，那么任何人都能通过端口访问到服务器上的 Redis，这是一个极大的安全隐患。
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.idce.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.idce.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Docker更换镜像源</title>
    <link href="https://www.idce.com/docker-change-mirrors/"/>
    <id>https://www.idce.com/docker-change-mirrors/</id>
    <published>2020-03-30T17:21:03.000Z</published>
    <updated>2020-03-30T17:23:13.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国内镜像源"><a href="#国内镜像源" class="headerlink" title="国内镜像源"></a>国内镜像源</h2><h3 id="Docker-官方镜像中国区"><a href="#Docker-官方镜像中国区" class="headerlink" title="Docker 官方镜像中国区"></a>Docker 官方镜像中国区</h3><p><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>阿里的镜像异常麻烦，本着求真的角度，还是把这一部分补充了 %&gt;_&lt;%。</p><p>首先需要注册成为阿里开发者，前往：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云开发者中心</a>。</p><p>注册并登陆后，点击右上角的<strong>控制台</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141265-f297c080-ce39-11e9-92ca-1c89280fe717.png" alt="image"></p><p>想吐槽阿里云的界面设计，阿里云是一个超级聚合体……里面的服务实在太多，如果不写这样一个图文教程很难找到自己想要的功能，操作步骤如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141431-91242180-ce3a-11e9-87d2-6edc56597f8c.png" alt="image"></p><p>进入容器镜像服务，点击左侧菜单的<strong>镜像中心-镜像加速器</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141511-e5c79c80-ce3a-11e9-8fe4-037f95849052.png" alt="image"></p><p>根据阿里的提示操作即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;93m46zjd.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>这里的 <code>https://93m46zjd.mirror.aliyuncs.com</code> 是我的个人镜像源加速地址，建议自己申请一个。</p><h2 id="更换-Docker-镜像源"><a href="#更换-Docker-镜像源" class="headerlink" title="更换 Docker 镜像源"></a>更换 Docker 镜像源</h2><h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h3><p>Docker 使用 <code>daemon.json</code> 作为配置文件，如果没有的话则创建，编辑 <code>daemon.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p>添加仓库地址（以中科大镜像源为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成并保存，重启 docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>作为一个学府，中科大还十分贴心的写了帮助文档：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">Docker 镜像使用帮助</a></p><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>Docker for Window 可以直接通过右键右下角小鲸鱼，选择 Settings，选择 Daemon 选项卡，在右下角的 Registry mirrors 添加对应的镜像源地址即可。</p><h3 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><p>如果你是下载了 Docker 桌面版的 Mac 系统用户，启动 Docker，选择右上角的小鲸鱼图标，选择菜单中的 <code>Preferences</code>：</p><p><img src="https://i.loli.net/2019/09/03/PeijKIqDGrZVgct.png" alt="image.png"></p><p>在选项卡中选择 Daemon，点击 <code>Registry mirrors</code> 下方的加号，输入需要添加的国内镜像源地址，完成后点击底部的 <code>Apply &amp; Restart</code> 应用配置并重启 Docker：</p><p><img src="https://user-images.githubusercontent.com/28209810/64140700-f4f91b00-ce37-11e9-8e02-e5c4d2b1682c.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      更换 Docker 默认的镜像源为国内镜像，可以大幅提高镜像的下载速度。
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.idce.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.idce.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mac系统安装Pecl</title>
    <link href="https://www.idce.com/mac-install-pecl/"/>
    <id>https://www.idce.com/mac-install-pecl/</id>
    <published>2020-03-30T17:15:19.000Z</published>
    <updated>2020-03-30T17:20:28.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PECL-简介"><a href="#PECL-简介" class="headerlink" title="PECL 简介"></a>PECL 简介</h2><p>PECL（The PHP Extension Community Library）是 PHP 扩展的存储库，为 PHP 所有的扩展提供提供托管和下载服务。</p><p>一些常用及优秀的 PHP 扩展均被收录在 PECL 中，如：yaf、swoole 等等，我们可以方便的使用 pecl 命令来安装这些扩展。</p><p>PECL 支持的扩展：<a href="http://pecl.php.net/" target="_blank" rel="noopener">PECL All Packages</a></p><p>在 Mac 系统或 Linux 系统中可能没有默认安装 pear，因此无法使用 pecl 命令，本文将介绍如何安装 pear。</p><h2 id="PEAR-安装方法"><a href="#PEAR-安装方法" class="headerlink" title="PEAR 安装方法"></a>PEAR 安装方法</h2><p>官方文档：<a href="https://pear.php.net/manual/en/installation.getting.php" target="_blank" rel="noopener">Getting and installing the PEAR package manager</a></p><h3 id="1、下载-PEAR"><a href="#1、下载-PEAR" class="headerlink" title="1、下载 PEAR"></a>1、下载 PEAR</h3><p>使用 curl 命令下载即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;pear.php.net&#x2F;go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="2、-安装-PEAR"><a href="#2、-安装-PEAR" class="headerlink" title="2、 安装 PEAR"></a>2、 安装 PEAR</h3><p>下载完成后，执行下面命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo php -d detect_unicode&#x3D;0 go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p>安装过程需要配置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Below is a suggested file layout for your new PEAR installation.  To</span><br><span class="line">change individual locations, type the number in front of the</span><br><span class="line">directory.  Type &#39;all&#39; to change all of them or simply press Enter to</span><br><span class="line">accept these locations.</span><br><span class="line"></span><br><span class="line"> 1. Installation base ($prefix)                   : &#x2F;usr</span><br><span class="line"> 2. Temporary directory for processing            : &#x2F;tmp&#x2F;pear&#x2F;install</span><br><span class="line"> 3. Temporary directory for downloads             : &#x2F;tmp&#x2F;pear&#x2F;install</span><br><span class="line"> 4. Binaries directory                            : &#x2F;usr&#x2F;bin</span><br><span class="line"> 5. PHP code directory ($php_dir)                 : &#x2F;usr&#x2F;share&#x2F;pear</span><br><span class="line"> 6. Documentation directory                       : &#x2F;usr&#x2F;docs</span><br><span class="line"> 7. Data directory                                : &#x2F;usr&#x2F;data</span><br><span class="line"> 8. User-modifiable configuration files directory : &#x2F;usr&#x2F;cfg</span><br><span class="line"> 9. Public Web Files directory                    : &#x2F;usr&#x2F;www</span><br><span class="line">10. System manual pages directory                 : &#x2F;usr&#x2F;man</span><br><span class="line">11. Tests directory                               : &#x2F;usr&#x2F;tests</span><br><span class="line">12. Name of configuration file                    : &#x2F;private&#x2F;etc&#x2F;pear.conf</span><br><span class="line"></span><br><span class="line">1-12, &#39;all&#39; or Enter to continue:</span><br></pre></td></tr></table></figure><p>修改安装时的根目录，输入 1，再输入 <code>/usr/local/pear</code>，回车；</p><p>修改命令的安装目录，输入 4，再输入 <code>/usr/local/bin</code>，回车；</p><p>其它选项使用默认即可，一路回车。</p><h3 id="4、测试是否安装成功"><a href="#4、测试是否安装成功" class="headerlink" title="4、测试是否安装成功"></a>4、测试是否安装成功</h3><p>输入命令 <code>pear version</code>，如果成功安装将会看到类似如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PEAR Version: 1.10.9</span><br><span class="line">PHP Version: 7.1.23</span><br><span class="line">Zend Engine Version: 3.1.0</span><br><span class="line">Running on: Darwin hongjiahuangdeMac-mini.local 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2&#x2F;RELEASE_X86_64 x86_64</span><br></pre></td></tr></table></figure><p>接下来就可以使用 <code>pecl install &lt;扩展名称:版本号&gt;</code> 安装各种被 PECL 收录的扩展了。</p>]]></content>
    
    <summary type="html">
    
      PECL 是 PHP 扩展的存储库，可以使用 pecl install 命令来安装被 PECL 库收录的 PHP 扩展。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Redis淘汰机制</title>
    <link href="https://www.idce.com/redis-delete-policy/"/>
    <id>https://www.idce.com/redis-delete-policy/</id>
    <published>2020-03-30T17:11:39.000Z</published>
    <updated>2020-03-30T17:13:21.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>redis 的配置文件为 <code>redis.conf</code>，当 redis 占用的内存达到配置的最大内存时，再使用 redis 增加新的值时会触发淘汰机制将占用的内存释放出来，以创建新的键值。</p><p>redis 允许占用的最大内存，约在 567 行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>找到 <code>maxmemory</code> 去掉前面的 <code>#</code> 井号， 将 <code>&lt;bytes&gt;</code>（单位：字节） 改为需要设置的最大内存值，一般而言，建议设置为服务器总内存的 50%~75%（需根据服务器情况确定），如果服务器其他进程占用较多内存的话，可以减少这个值。</p><p>当 redis 内存占用达到设置的最大值，触发的淘汰策略，约在 598 行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>去掉前面的 <code>#</code> 井号，后面即为淘汰的策略，淘汰策略有许多种，下面进行介绍。不过在此之前，我们可以理解一下 redis 如何淘汰掉键值。</p><p>我们通过给一个键值设置过期时间，来让它“自动过期”，但实际上，即使到了过期时间，这个键其实并没有立即被删除，而是当下次取这个键值的时候进行判断，如果这个键设置了过期时间，同时已经过了过期时间再进行删除，这是一种惰性的删除策略。</p><p>此外，除了这种被动删除的策略之外还有主动删除策略，例如定期扫描过期的键值，扫描也不可能将全部的键都扫秒一遍，而是通过某种随机算法获取某些键，判断键是否过期再决定是否删除。</p><p>为什么键设定了过期时间不能在到期后立即删除呢？因为从技术的角度上来考虑这是一件十分困难的事，如果要追踪一个键值的过期时间，可能需要启动一个进程来追踪并且在过期时“杀掉”这个键，这样使用 redis 的优势就全部没有了，反而要消耗更多的系统资源。</p><p>redis 过期的键太多而没有删除，会造成内存资源的浪费，反之，如果过于频繁的去检查过期的键，希望在第一时间释放出内存资源，频繁的检查也是十分耗费资源的事，因此两者之间必须存在一个平衡，这就需要依靠 redis 的淘汰策略。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>redis 有如下淘汰策略：</p><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧</p><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</p><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</p><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</p>]]></content>
    
    <summary type="html">
    
      当 Redis 占用的内存达到预设值的时候，将触发淘汰机制（删除策略）将某些键值删除来释放内存。
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.idce.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.idce.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://www.idce.com/redis-base/"/>
    <id>https://www.idce.com/redis-base/</id>
    <published>2020-03-30T17:06:41.000Z</published>
    <updated>2020-03-30T17:09:16.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是由 ANSI C（标准C语言）写的键值对存储系统，由于是存储在内存中的，所以性能极高，但我们知道存储在内存中一旦电脑关闭就会丢失数据，Redis 还提供了数据持久化的功能，也就是说，Redis 的数据也可以保存在本地硬盘中。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>所谓原子操作指的是不可再分割的操作，要么都成功，要么都失败。</p><p>Redis 的操作结果一定是确定的，例如将商品库存存储在 Redis 中，此时由于高并发场景有 1000 个请求进入，判断减少库存，总库存为 999 个，那么第 1000 个请求会因为高并发的场景而判断失误吗？答案是不会。</p><p>同理，一些抽奖活动将奖品数量存储在 Redis 进行操作，不会出现奖品被人领光还能领到奖品的情况，当有面试官问你就这么告诉他。</p><p>以抽奖场景示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取数据库奖品余额</span><br><span class="line">$count &#x3D; PrizeModel::getCount();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否还有可以领取的奖品</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理领奖逻辑，并且减少奖品数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，涉及到读后写的问题，在读取奖品余额后更新奖品数量，由于读写操作是分开的，可能因为请求的先后而产生不同结果；比如 A 进来领取奖品，奖品的库存是 1，此时 B 也进来领取奖品，这个时候他也判断了奖品库存是 1，这个时候奖品的数量只剩 1 个，却有两个人被判断为可以领取奖品，就出现奖品库存变为负数的情况。</p><p>导致问题的根本原因在于读操作与写操作是分离的，中间如果有其他的请求进来，那么读操作的结果就是不准确的，可以使用 Redis 的 <code>decr</code>（自减）来操作商品库存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis &#x3D; new Redis();</span><br><span class="line">$count &#x3D; $redis-&gt;decr(&#39;prize&#39;);</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理领奖逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 的 <code>decr</code> 命令将值减 1，并且返回了计算后的结果，实现了读写同步的操作，因此不会产生因为高并发场景读取了错误数据的情况。</p><p>这些都是依赖 Redis 的原子操作，之所以能够实现原子操作，是因为 <strong>Redis 是单线程</strong>。</p><p>假如对方问你，为什么单线程就是原子操作？</p><blockquote><p>扩展阅读：<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101" target="_blank" rel="noopener">什么是线程</a></p></blockquote><p>操作系统调度任务以线程为基本单位，Redis 所有的指令都在一个线程中进行，不会扩展出额外的线程；多线程，比如 MySQL 启动的时候是一个进程，而执行增删改查操作就是一个新的线程。多线程指的是可以同时干很多件事，而单线程只能一件事一件事的干，做完一件事才做下一件事，从效率上来说多线程远远超出单线程，但单线程的优势是每一步的执行结果都是确定的，要么都成功，要么都失败。</p><p>实际上，Redis 虽然是单线程但效率也是非常高的，因为它完全基于内存操作。</p><h2 id="键"><a href="#键" class="headerlink" title="键"></a>键</h2><p>Redis 使用键值对的形式存储数据，键类似于变量名字，键是一个字符串，最大长度 512MB，与开发语言不同的是　Redis 中的键可以使用一些开发语言中不能作为命名的符合，如：冒号、横杠。</p><p>键名称太长，会占用更多的内存空间，此外，太长的键名也会多查找造成影响；名称太短，又会造成语义不清，所以在取键名的时候需要有规范。</p><p><strong>键的名称区分大小写</strong>，不建议大小写混用，要么全部大写，要么全部小写，取名“见名知意”为佳。</p><p>可以参考如下规则：</p><p>第一段为项目名称或者缩写形式（非必需），如：project 或 pro<br>第二段为表的名字，如：user<br>第三段为区分键的字段，如：MySQL 主键的列名，属性名<br>第四段为键的特征字段，可以作为查询依据，如：MySQL 中主键 ID 的值</p><p>键的各个字段通常用冒号隔开。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 根据 ID</span><br><span class="line">idce:users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">idce:users:name</span><br></pre></td></tr></table></figure><p>前缀增加项目名称的用途是：当一个 Redis 服务器部署了多个项目可以进行区分，如果是单个项目，则可以去掉项目名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">users:name</span><br></pre></td></tr></table></figure><p>在项目中，最好有一个统一管理键名称的地方，否则后期无法进行维护。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis 支持如下数据结构：</p><ul><li>String：字符串</li><li>Hash：哈希</li><li>List：列表</li><li>Set：集合</li><li>Sorted Set：有序集合</li></ul><h2 id="PHP-使用-Redis"><a href="#PHP-使用-Redis" class="headerlink" title="PHP 使用 Redis"></a>PHP 使用 Redis</h2><p>PHP 想要使用 Redis 需要安装 redis 相关的扩展：<a href="https://pecl.php.net/package/redis" target="_blank" rel="noopener">PECL - REDIS 扩展下载</a>。</p><p>也可以不使用扩展，直接下载 predis：<a href="https://github.com/nrk/predis" target="_blank" rel="noopener">Github - Predis 下载</a></p><p>将下载的包使用 <code>require</code> 命令引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &quot;.&#x2F;lib&#x2F;predis-1.1&#x2F;autoload.php&quot;;</span><br></pre></td></tr></table></figure><h2 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于其高性能的特性可以作为数据缓存，对于频繁查询但是不经常更新的数据可以将其缓存到 Redis 中，从而减少数据库查询压力，例如商品的库存、金额，需要注意的是当这些数据更新的时候也必须同步更新缓存数据。</p><p>此外，对于像微博的阅读量此类频繁更新的数据，也可以用缓存处理。方法是获取一条微博详情的时候，先判断是否有缓存，有的话先从缓存读取阅读量的数据，没有的话就从数据库读取，然后保存在 Redis 中；当用户访问时，直接在 Redis 操作访问量的增加，然后设置一个定时器程序，定期将缓存中的阅读量写入数据库，不过，这种类型的数据一般是比较不重要的，因为有可能会发生意外服务器重启导致数据丢失而没有正常写入数据库。</p><p>当某种数据需要频繁的查询或更新时可以使用 Redis 作为缓存。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>我们经常会收到亲朋好友要求帮忙给他们家的小盆友投票（一般是才艺表演之类的），根据点赞数进行排行，排在前几名的会有奖励之类的。排行榜的数据变化十分频繁，这个时候就可以使用 Redis 的有序集合结构来存储排行数据。</p><h3 id="分布式锁、本地锁"><a href="#分布式锁、本地锁" class="headerlink" title="分布式锁、本地锁"></a>分布式锁、本地锁</h3><p>Redis 中有一种命令 <code>setnx</code> 意为 <code>set if not exists</code>，即当不存在时设置数据，否则不进行操作，利用这种特性可以实现分布式锁。当成功设置的时候就执行后面的逻辑，如果未能成功设置代表之前已经执行过了，就不再走后面的逻辑。</p><p>锁的作用是防止重复动作，比如用户在点击领取奖励的时候，发现没有响应（网络延迟导致），结果用户以为自己没点下去就多点了几次，如果不做防止重复提交的处理，很有可能会造成领取到多次奖励的 BUG。</p><p>分布式就是多台机子间，而本地锁指的是本机，其原理类似，比如设置一个带有过期时间的 String 类型的缓存，如果这个键不为空则代表加过锁了。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中的列表结构由于读取头尾的速度非常快，因此适合作为消息队列的容器，将任务队列存储在 Redis 中可以大大提高程序的执行效率（与传统的数据库存储相比）。</p><h2 id="Redis-安全隐患"><a href="#Redis-安全隐患" class="headerlink" title="Redis 安全隐患"></a>Redis 安全隐患</h2><p>其中一个是未设置密码问题：<a href="https://idce.com/archive/PLlWREOZ?id=VDej" target="_blank" rel="noopener">Redis 未设置密码导致服务器被安装挖矿病毒</a></p><p>此外，Redis 即使正常使用也可能存在安全隐患。</p><p>缓存分为过期缓存和不过期缓存，不过期缓存过多可能造成内存溢出，而过期缓存又可能带来新的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的是查询一个缓存中不存在的数据，比如我们设置了一个根据用户 ID 来获取用户信息的缓存，此时如果我们输入 -1 或者其他不存在的 ID，那么系统将会判断缓存不存在，接着就去数据库查询。</p><p>这种“绕过”缓存查询数据库的行为类似于直接穿透了 Redis。</p><p>如果有人利用了这一点编写程序大量查询不存在的用户 ID 就很可能造成数据库崩溃。</p><p>解决方法是即使不存在的用户 ID 也设置一个空的缓存的键值，不过此类键值需要设置一个较短的过期时间，否则也可能会被恶意查询造成内存溢出。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>雪崩指的是一种短期内产生的爆发性冲击，在 Redis 中，如果有许多缓存在同一时刻过期，就会造成大量的数据需要从数据库查询，面对冲击性涌入的查询，数据库很可能造成崩溃。</p><p>解决方法是尽可能的让缓存的过期时间不一样，热门数据的缓存时间更长一些，对于同类型的数据可以设置一个额外的随机时间来让同类型的数据也会在不同时刻过期。</p><p>除此之外，还可以设计多级缓存结构来防止缓存雪崩。</p><p>当第一层的缓存过期了，不从数据库读取，而是判断第二层缓存是否存在，如果有就直接取数据，如果没有再判断下一层缓存……以此类推。这样的结构称为多级缓存，多级缓存结构比较复杂，其中第一层缓存叫做一级缓存，第二层叫做二级缓存……多级缓存结构可以防止突发性的冲击造成数据库崩溃，不过这样系统的复杂性会变高，多级缓存需要有一个程序来定期维护下级缓存，一般由架构师进行设计。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿与缓存雪崩有些类似，不过不同的是缓存击穿指的是某个单一的键值过期，但是此时却有大量的流量涌入，造成所有的请求都直接到数据库那边，相当于在某个点凿出了一个洞，因此叫做“击穿”。</p><p>防止缓存击穿的方法：</p><p>方法（一）：后台增加一个定期任务刷新缓存的过期时间。</p><p>方法（二）：将缓存的过期时间也保存在值里面，当获取这个缓存数据的时候判断过期时间，在超过设置的阀值时更新这个缓存的过期时间。</p><p>方法（三）：可以使用缓存雪崩所说的多级缓存方法。</p><p>方法（四）：增加锁机制，当缓存过期查询数据库时，判断锁，只允许一个请求进来，其他请求都进入等待状态，进入的请求在查好数据后更新缓存，此时等待中的请求就可以获取到数据了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 还有许多应用，持续保持学习中……</p>]]></content>
    
    <summary type="html">
    
      Redis 是主流的高效键值对存储系统，尤其是希望成为游戏开发的后端人员，这是一个核心的知识技能。
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.idce.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.idce.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Window环境下安装Docker的坑</title>
    <link href="https://www.idce.com/window-install-docker-issue/"/>
    <id>https://www.idce.com/window-install-docker-issue/</id>
    <published>2020-03-30T17:03:50.000Z</published>
    <updated>2020-03-30T17:05:21.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近下载了 Docker for Window 搭建 Win10 系统的 PHP 环境，结果遇到了一大堆问题，网络上搜索答案极少，而且也很难找到能解决问题的方法，通过不断尝试和推测，踩了很多坑，也找到了填坑的办法，在此记录下来。</p><p>Docker for Window 下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站下载</a></p><h2 id="Docker-Hub-登录问题"><a href="#Docker-Hub-登录问题" class="headerlink" title="Docker Hub 登录问题"></a>Docker Hub 登录问题</h2><p>需要注册一个 Docker Hub 来进行登录，登录的帐号只能是 Docker ID，也就是注册时的用户名，而不是邮箱，此处需要注意，在使用 <code>docker login</code> 命令时经常会犯错而无法成功登录。</p><h2 id="Hyper-V-缺失问题"><a href="#Hyper-V-缺失问题" class="headerlink" title="Hyper-V 缺失问题"></a>Hyper-V 缺失问题</h2><p>Docker for Window 依赖 Hyper-V（微软的虚拟机系统），只有 Window 专业版才有这个功能，家庭版如果需要开启此功能就需要升级到专业版。</p><blockquote><p>查看电脑系统的方法：右键我的电脑，选择属性即可看到 Window 版本信息。</p></blockquote><p>家庭版也可以不升级，安装另一个 Docker 的产品——Docker Tool。</p><p>Docker Tool 不依赖 Hyper-V，而是 VirtualBox（也是一种虚拟机软件），如果安装了 Docker Tool，则会自动安装 VirtualBox。Docker Tool 的操作方法与 Docker for Window 不太一样，更复杂一些，虽然本人也尝试下载过，但是感觉十分不便，因此最后卸载了。（由于安装了 Docker Tool，这里又挖了一个新坑，后面进行介绍）</p><p>本人用的是 Win10 专业版系统，却发现没有 Hyper-V 这个选项，原来是因为下载了精简版的 ISO 作为装机镜像，一些装机系统那边下载的软件都是经过二次封装的，削减了一部分的功能，因此推荐用那些精简过的系统。</p><p>找了许多装机的 ISO 镜像，最后决定下载微软官方原版的 ISO 镜像（十分干净，不带第三方软件），然后重新安装了 Win10 专业版。</p><p>Window MSDN 镜像下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN 我告诉你</a></p><p>选择左侧的系统，根据个人需求安装即可，不过据说对 Window 版本有一定的要求，太早的版本可能还是没有这个功能，建议至少 Win 8 以上(专业版)。</p><p>查看 Hyper-V 的方法是打开 <strong>控制面板</strong>，然后选择 <strong>程序</strong>，再选择 <strong>启用或关闭 Windows 功能</strong>。</p><p>重装后的系统已经可以看到 Hyper-V 这个选项了，如下图所示：</p><p><img src="https://i.loli.net/2019/10/20/uHBJOYP3Mtze6jc.png" alt="image.png"></p><p>勾选后选择确定，重新启动电脑。</p><h2 id="开启-Hyper-V-导致无法开机问题"><a href="#开启-Hyper-V-导致无法开机问题" class="headerlink" title="开启 Hyper-V 导致无法开机问题"></a>开启 Hyper-V 导致无法开机问题</h2><p>在开启 Hyper-V 的过程中，又遇到新的问题，如果将 Hyper-V 勾选起来点击确定，系统会安装软件然后提示重新启动，此时重新启动会导致电脑无法开机，一直在开始界面，并且提示“系统正在自动修复”。</p><p>只有进入到安全模式，将 Hyper-V 取消掉才能正常开机；又或者多次重启失败，系统自动恢复最后一次正确的配置。网上查了很多资料都没有找到解决方法，于是推测是因为相关的虚拟机服务没有启动导致的。</p><p>解决方法是进入服务管理，将 Hyper-V 的相关服务调整为“自动启动”，点击开始，选择运行（或者直接按 Win+R 快捷键），然后输入 <code>services.msc</code> 进入服务管理。</p><p><img src="https://i.loli.net/2019/10/20/75OeL1pd4x6QtzS.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/hkmugev9KtBzlZ3.png" alt="image.png"></p><p>然后打开 Hyper-V，再重启就可以了。</p><h2 id="Docker-命令被占用"><a href="#Docker-命令被占用" class="headerlink" title="Docker 命令被占用"></a>Docker 命令被占用</h2><p>在安装好了 Docker for Window 后，打开命令行使用 docker 命令，却提示如下的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unable to resolve docker endpoint: open C:\Users\Administrator\.docker\machi....</span><br></pre></td></tr></table></figure><p>大致意思是找不到某个文件，而 <code>docker-machine</code> 是 Docker Tool 用到的东西，在翻找了许多资料后才发现原来是卸载时残留的环境变量导致的问题，Docker Tool 虽然卸载了，但是环境变量还在，这就导致了使用 docker 命令用的环境变量路径还是 Docker Tool 设置的路径，由于软件被卸载了，路径自然就找不到了。</p><p>解决方法是删掉残留的环境变量。</p><p>右键我的电脑，高级系统设置，环境变量。</p><p><img src="https://i.loli.net/2019/10/20/VLGM5XjYpJhZEeW.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/1HFzeVMgtSoLRb7.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/QYVrGO3k2M8By1D.png" alt="image.png"></p><p>然后在用户变量与系统变量中，找到 Docker 相关的变量全部删除，然后卸载掉 Docker for Window，重装一遍，即可解决（建议重启一次电脑）。</p><h2 id="磁盘共享"><a href="#磁盘共享" class="headerlink" title="磁盘共享"></a>磁盘共享</h2><p>Docker 恢复正常以后，本人使用的是自己封装的一套 docker-compose 系统，由于里面用到了容器卷，在 Window 系统中还存在磁盘共享问题。</p><p>在使用 <code>docker-compose up -d</code> 的时候遇到如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot create container for service redis: b&#39;Drive sharing failed for an unk...</span><br></pre></td></tr></table></figure><p>大致意思是说磁盘共享失败。</p><p>解决方法是打开 Docker for Window 的 Settings，右键右下角的小鲸鱼图标进入设置界面，在设置界面中选择 Shared Drives 选项卡，将需要共享的磁盘勾选起来，然后点击 Apply（应用）保存设置，这个过程可能需要输入 Window 系统的用户名和密码，如果没有设置密码则需要设置一个。</p><p><img src="https://i.loli.net/2019/10/20/RCuri4gzwynGNeH.png" alt="image.png"></p><h2 id="Docker-Compose-路径问题"><a href="#Docker-Compose-路径问题" class="headerlink" title="Docker-Compose 路径问题"></a>Docker-Compose 路径问题</h2><p>接着又遇到新的问题，执行 <code>docker-compose up -d</code> 弹出如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: for workspace_redis_1  Cannot start service redis: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;process_linux.go:430: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;&#x2F;etc&#x2F;localtime\\\&quot; to rootfs \\\&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27&#x2F;merged\\\&quot; at \\\&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27&#x2F;merged&#x2F;usr&#x2F;share&#x2F;zonStarting workspace_mysql_1 ... error</span><br></pre></td></tr></table></figure><p>这是由于我在 <code>docker-compose.yml</code> 文件中写了一个错误的路径，<code>/etc/localtime</code> 是 Linux 系统里面的路径，将它去掉就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">        build: redis&#x2F;</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">          - .&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">          - .&#x2F;var&#x2F;logs&#x2F;redis.log:&#x2F;var&#x2F;log&#x2F;redis.log</span><br><span class="line">          - &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime</span><br><span class="line">        ports:</span><br><span class="line">          - &quot;6379:6379&quot;</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br></pre></td></tr></table></figure><p>去掉后就可以正常运行了。</p><h2 id="Vmware、Hyper-V-不兼容问题"><a href="#Vmware、Hyper-V-不兼容问题" class="headerlink" title="Vmware、Hyper-V 不兼容问题"></a>Vmware、Hyper-V 不兼容问题</h2><p>第一次因为 Hyper-V 缺失而无法安装时，曾经尝试过使用 Vmware 来安装虚拟机，想要在虚拟机里面装一个 MacOS 系统，结果也是一个大坑，默认情况下的 Vmware 不支持 MacOS，而需要安装一个补丁，结果折腾了半天也没搞定，MacOS 的镜像高达 7 个 G，还因为百度网盘暂停会导致重新开始……折腾得心累，于是放弃了。</p><p>Hyper-V 与 Vmware 是不兼容的，一山不容二虎，如果要使用其中的一种，需要卸载掉另外一种。否则可能会因为服务的问题导致软件不能正常启动。</p><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>在中途曾经放弃过安装 Docker 的念头，而是手动安装了 PHP、MySQL、Redis、Nginx 等环境，但是后面又发现许多 PHP 扩展在 Window 系统的安装都十分麻烦，比如 swoole 扩展还需要安装 cygwin，折腾的心累于是放弃了。</p><p>真是艰辛的过程<del>~</del></p>]]></content>
    
    <summary type="html">
    
      相比于 Linux 系统，要在 Window 系统安装 Docker 相对要麻烦得多。
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.idce.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.idce.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主键详解</title>
    <link href="https://www.idce.com/mysql-primary-key/"/>
    <id>https://www.idce.com/mysql-primary-key/</id>
    <published>2020-03-30T17:01:50.000Z</published>
    <updated>2020-03-30T17:03:12.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从书本上学到的 MySQL 主键知识十分有限，我们只是知道基础的理论。</p><p>在一次面试中，面试官提问：主键索引与普通索引有什么区别？</p><p>当场懵逼。</p><p>为了深入学习 MySQL 记录下此文。</p><h2 id="MySQL-主键（Primary-Key）"><a href="#MySQL-主键（Primary-Key）" class="headerlink" title="MySQL 主键（Primary Key）"></a>MySQL 主键（Primary Key）</h2><p>MySQL 中的键即某种约束，键具有索引的作用，通过约束条件可以使得数据更快的被查到。</p><p><strong>主键</strong> 是基本每张表都会用到的，一般类型为整型（integer、bigInteger）或者无符号整型（unsigned integer)并按照自然数的顺序自增。</p><p>主键是唯一的。</p><p>主键是一种索引，可以加快查询效率。</p><p>这是我们通常理解的主键，那么主键作为索引，又与普通索引有什么不同？为什么表需要主键？</p><h2 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h2><p>主键的字段名称一般设置为 ID，当这个 ID 与业务无关时，称为逻辑主键（即 ID 没有实际的意义），如果将用户名（name） 字段设置为主键，该字段是业务中会用到的字段，称为业务主键。</p><p>由于主键是业务中经常会用到的键，而业务又经常变更，因此不适合将业务字段作为主键，而是设置一个与业务毫无关系的（ID）字段作为主键。</p><p>如果将业务字段用来做主键，例如上面的例子中的 name，系统后台需要修改某个用户的 name 字段，意味着主键也跟着变更了。</p><p>如果存在以下场景：</p><p>用户个人空间的地址为：<code>http://domain.com/:name</code>，<code>:name</code> 是用户名（即数据库中的 name 字段）。</p><p>主键一旦变更，某些页面如个人空间也会跟着变更，假如我收藏了某个用户的空间到浏览器：<code>http://domain.com/user/xiaoming</code>，结果因为用户改名为：xiaohong，这个用户的空间地址就变成了：<code>http://domain.com/user/xiaohong</code>，那我收藏的地址就 404 了，除了这方面的原因，由于可以随意修改主键，也就导致你改了主键的值，其他人又改成之前用过的主键，会产生许多问题，如果某个人又将 xiaogang 的名字改成 xiaoming，那我收藏的地址就会变成原名为 xiaogang 的个人空间，业务变得十分混乱。</p><p>主键通常是不能变更的值，因此建议设置一个与业务毫无关系的字段作为主键的值，之所以要用整型是因为查询效率比字符串更高、所需空间更小，可以使用自增自动生成唯一的值。</p><p>其他类型如字符串作为主键，由于在插入数据时需要生成唯一字符串，同时还需要判断是否已存在该值，故在插入数据的时候效率也会降低。</p><p>除了将单个字段设置为主键，也可以将多个字段绑定在一起作为联合主键（也称复合主键）。</p><p>主键设计原则：</p><ul><li>主键的值 <strong>应该</strong> 无法被修改</li><li>主键的值 <strong>不应该</strong> 与业务有关</li><li>主键的值 <strong>建议</strong> 使用系统自动生成（如自增整型）</li><li><strong>建议</strong> 使用单个字段作为主键</li><li>每张表都 <strong>建议</strong> 设置主键</li></ul><h2 id="为什么表需要主键"><a href="#为什么表需要主键" class="headerlink" title="为什么表需要主键"></a>为什么表需要主键</h2><p>想一下如果没有主键，需要删改查除某条数据的时候会有多麻烦：“帮我删掉 name 为 xiaohong 的那条数据”，而 name 属性又没有设置唯一键，存在很多条同名数据，到底是删除哪条？</p><p>而当我们设置了 ID 作为主键，那我们就可以说：“删除 ID 为 6 的数据”、“帮我把 ID 为 6 的 name 字段改成 xiaohong”。</p><p>主键的其中一个作用即指向该行的数据，<strong>键具有约束作用</strong>，主键约束可以令数据具有唯一性，设置身份证为主键，那么这个主键就决定了一个人的个人资料，从千千万万个人当中，可以用身份证来指代唯一的一个人。</p><p>此外，主键索引可以提升查询效率，将一个字段设置为主键时，便会创建主键索引。</p><p>（下文介绍主键索引与普通索引区别）</p><h2 id="MySQL-主键与唯一键（Unique-Key）的区别"><a href="#MySQL-主键与唯一键（Unique-Key）的区别" class="headerlink" title="MySQL 主键与唯一键（Unique Key）的区别"></a>MySQL 主键与唯一键（Unique Key）的区别</h2><p>主键字段的值是唯一的，唯一键也要求字段值唯一，这两者的区别在于唯一键的值可以为 NULL，并且可以存在重复的 NULL 数据。</p><p>梳理如下：</p><p>唯一键的值 <strong>可以为空</strong>，且不能存在除空值以外重复的值。</p><p>主键的值必须 <strong>不为空</strong> 且不存在重复。</p><p>每张表中 <strong>只能</strong> 存在一个主键，可以存在 <strong>多个</strong> 唯一键。</p><p>从存在意义上来说，主键的作用是指代这一行的数据（如身份证代表一个人），而唯一键只是一种约束作用，用来约束这个字段在这张表不能存在相同值（如限制用户手机号码只能注册一个账号）。</p><h2 id="主键索引与普通索引（Normal-Index）的区别"><a href="#主键索引与普通索引（Normal-Index）的区别" class="headerlink" title="主键索引与普通索引（Normal Index）的区别"></a>主键索引与普通索引（Normal Index）的区别</h2><blockquote><p>扩展阅读：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p></blockquote><p>普通索引的作用只是加快查询效率，并且可以存在重复的值，而主键索引的值是唯一的，它也可以提高查询效率，普通索引的值可以为 NULL，查询一个存在 NULL 的普通索引会导致查询效率提升的作用失效，当一个列设置了索引，同时也应当将其设置为 NOT NULL。</p><p>主键索引与普通索引的结构也不同。</p><h3 id="聚簇索引和非聚簇索引（二级索引）"><a href="#聚簇索引和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引和非聚簇索引（二级索引）"></a>聚簇索引和非聚簇索引（二级索引）</h3><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</li></ul><p>Innodb 存储引擎中，数据表 table 由 table.frm、table.idb 组成。table.frm 保存表结构的定义，table.idb 保存的是数据和索引，这样的结构称为聚簇索引。</p><p>Myisam 存储引擎中，数据表 table 由 table.frm、table.myi、table.myd 组成。table.frm 保存表结构的定义，table.myi 保存索引，table.myd 保存数据。在用到索引时，先到 table.myi(索引树)中进行查找，取到数据所在 table.myd 的行位置，拿到数据。所以 Myisam 引擎的索引文件和数据文件是独立分开的，称之为非聚簇索引。</p><p>聚簇索引是按照数据存放的物理位置为顺序的，聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索更快。</p><p>在 Innodb 中，主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>在表结构中只存在一个聚簇索引（主键索引），除此之外都是非聚簇索引（普通索引）。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一种特殊情况可以不通过聚簇索引查询数据，那就是通过创建联合索引（多个字段作为索引），如果查询的数据在索引中可以直接获取到，那就不需要再到数据行进行查询了。</p><p>例如创建索引：idx_name_email</p><p>name 字段 和 email 字段是联合索引，当我们使用如下语句查询时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name where email &#x3D; &quot;xxx@idce.com&quot;</span><br></pre></td></tr></table></figure><p>通过 email 来查询 name，由于它们是一组联合索引，因此可以直接从索引中拿到对应的数据。</p><p>覆盖索引查询数据只需要从索引中获得，而不需要到数据表中获取，因此可以极大的提高查询效率。</p><p>之所以能够从索引中得到数据，是因为索引的结构中保存了对应字段的值。</p><p>容易混淆的一个地方：上面介绍的聚簇索引才能保存数据，那为什么普通索引也能保存数据？</p><p>其实这里指的是表的数据，通过聚簇索引找到的数据是直接找到表对应行的一整行数据，而索引保存的数据是这个字段的值，因此可以通过索引得到对应字段的值。</p><p>面试官曾经问我的问题：索引会保存字段的值吗？</p><p>当时觉得不会，应该是保存对应行的所在地址才对。但其实是会保存的，因为只有保存了这个数据，查询索引字段才能快速进行数据对比从而筛选数据，如果能不回到表查询，则不回到表查询，回到表查询的效率比直接从索引拿数据低得多。</p><p>索引的结构，一侧是字段的值，另一侧是下一个数据的地址：</p><p><img src="https://i.loli.net/2019/11/26/hArR2ISmwPLzNCy.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      MySQL 的主键是什么？为什么每张表都要安排一个主键？
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.idce.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.idce.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx SSL证书配置问题</title>
    <link href="https://www.idce.com/nginx-ssl-issue/"/>
    <id>https://www.idce.com/nginx-ssl-issue/</id>
    <published>2020-03-30T16:57:16.000Z</published>
    <updated>2020-03-30T17:39:19.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSL-问题"><a href="#SSL-问题" class="headerlink" title="SSL 问题"></a>SSL 问题</h2><p>Nginx 重启时，报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;xxx.conf:57</span><br></pre></td></tr></table></figure><p>通常我们会在 server 有如下 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssl on;</span><br><span class="line">ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;xxx.com.pem;</span><br><span class="line">ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;xxx.com.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure><p>访问网页提示错误代码 <code>ERR_SSL_PROTOCOL_ERROR</code>。</p><p><img src="https://i.loli.net/2019/12/05/R3GCLPZ8tsbpzS2.png" alt="image.png"></p><p>原因在于 Nginx 升级到 1.15 版之后，SSL 的配置不再使用 <code>ssl on</code>，把这一句去掉就可以。</p><p>这时再执行：<code>nginx -s reload</code> 平滑重启 Nginx 就不会报错了。</p><h2 id="CURL-无法正常访问"><a href="#CURL-无法正常访问" class="headerlink" title="CURL 无法正常访问"></a>CURL 无法正常访问</h2><p>按照上面的步骤重启 Nginx 后，使用 curl 尝试连接到网站，结果依然报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (35) SSL received a record that exceeded the maximum permissible length.</span><br></pre></td></tr></table></figure><p>这其实也是升级后配置发生了变化，第一个步骤的提示信息已经给与了提示：<code>use the &quot;listen ... ssl&quot;</code>，再次编辑 <code>xxx.conf</code>，将 <code>listen 443</code> 修改为：<code>listen 443 ssl</code>：</p><pre><code>server {    listen       443 ssl;    server_name  idce.com;    // ...此处省略}</code></pre><p>保存，然后再执行重启，OK！</p>]]></content>
    
    <summary type="html">
    
      Nginx 配置 SSl 证书时提示：the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in /etc/nginx/conf.d/xxx.conf:57
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.idce.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://www.idce.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>PHPStorm逼死强迫症患者解决方法</title>
    <link href="https://www.idce.com/phpstorm-no-ext-tip-issue/"/>
    <id>https://www.idce.com/phpstorm-no-ext-tip-issue/</id>
    <published>2020-03-30T16:40:47.000Z</published>
    <updated>2020-03-30T16:55:58.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h2><p>在使用 JSON 函数的时候，会报如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext-json missing in composer.json</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/26/sYow5WKkvbRdXOV.png" alt="image.png"></p><p>花花绿绿看得猛男落泪，简直要逼死强迫症啊！</p><p>原因可能是因为使用了 Docker 或者其他的环境，由于扩展是安装在虚拟机上就导致本机无法正确识别 PHP 的扩展，并不是本机上没有安装这个扩展，代码没有问题也不会报错，就是看得难受。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>所幸，这里提供了两种方法可以根治此问题。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>针对缺失的扩展，在 <code>composer.json</code> 文件的 <code>require</code> 字段进行添加。</p><p>例如：<code>&quot;ext-json&quot;: &quot;*&quot;</code>：</p><p><img src="https://i.loli.net/2019/11/26/IH3GgJQB4XWpz8y.png" alt="image.png"></p><p>如果没有 <code>composer.json</code> 文件，在项目根目录下自行创建一个即可。</p><p>这种方法针对特定的扩展，除了 JSON 扩展，常见的还有 CURL 扩展也无法正常识别，用相同的方法即可解决，扩展不多的时候可以用这种方法，要是使用了诸多第三方扩展而 PHPStorm 无法识别，可以参考下面的方案二一次性解决问题。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>关闭 PHPStorm 缺失扩展提示。</p><p>打开左上角 <code>File-&gt;Settings</code> 搜 PHP，然后找到下方一行的 <code>Inspections</code>，在右侧搜索 <code>extension</code>，找到 <code>Extension is mission in composer.json</code> 取消勾选保存即可，见下图：</p><p><img src="https://i.loli.net/2019/11/26/bB9RVYwCf6DtmGL.png" alt="image.png"></p><p>以上方法任选一种即可。</p><p><img src="https://i.loli.net/2019/11/26/UZdEPz9Hg5MkXyt.png" alt="image.png"></p><p>猛的一顿操作之后——舒服多了！！</p>]]></content>
    
    <summary type="html">
    
      PHPStorm 在使用某些扩展提供的函数时，会报扩展在 composer.json 缺失的问题，如使用 json 相关的函数会提示 “ext-json missing in composer.json”，虽然并不是真正的报错，但是这种提示对于强迫症来说实在太难受了，看完这篇文章，强迫症患者就舒服了。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP-CLI 常用命令参数</title>
    <link href="https://www.idce.com/php-cli-arguments/"/>
    <id>https://www.idce.com/php-cli-arguments/</id>
    <published>2020-03-15T04:15:44.000Z</published>
    <updated>2020-03-15T06:07:14.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行-PHP-文件"><a href="#运行-PHP-文件" class="headerlink" title="运行 PHP 文件"></a>运行 PHP 文件</h2><p>可以直接使用 <code>php &lt;文件路径&gt;</code> 执行 PHP 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php &#x2F;var&#x2F;www&#x2F;html&#x2F;project&#x2F;index.php;</span><br></pre></td></tr></table></figure><h2 id="进入命令行模式"><a href="#进入命令行模式" class="headerlink" title="进入命令行模式"></a>进入命令行模式</h2><p>使用命令 <code>php -a</code> 可以进入命令行模式，在这里可以直接运行 PHP 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; echo &quot;hello world&quot;;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="加载指定配置文件"><a href="#加载指定配置文件" class="headerlink" title="加载指定配置文件"></a>加载指定配置文件</h2><p>使用 <code>php -c</code> 可以加载指定的配置文件 <code>php.ini</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c &#x2F;test&#x2F;my_php.ini</span><br></pre></td></tr></table></figure><h2 id="显示当前配置文件路径"><a href="#显示当前配置文件路径" class="headerlink" title="显示当前配置文件路径"></a>显示当前配置文件路径</h2><p>使用命令 <code>php --ini</code> 查看当前加载的配置文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --ini</span><br><span class="line">Configuration File (php.ini) Path: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php</span><br><span class="line">Loaded Configuration File:         &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini</span><br><span class="line">Scan for additional .ini files in: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d</span><br><span class="line">Additional .ini files parsed:      &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-bcmath.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-gd.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-gmp.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-mysqli.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-opcache.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-pdo_mysql.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-redis.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-sockets.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-sodium.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-swoole.ini</span><br></pre></td></tr></table></figure><h2 id="启动一个-WebServer"><a href="#启动一个-WebServer" class="headerlink" title="启动一个 WebServer"></a>启动一个 WebServer</h2><p>Web Server（网页服务）一般是由 Apache、Nginx 或是 Windows 系统的 IIS 提供。</p><p>从 <code>PHP 5.4.0</code> 起，也可以使用 cli 模式来启动 PHP 内置的 Web Server。</p><blockquote><p>这个内置的 Web 服务器主要用于本地开发使用，不可用于线上产品环境。</p></blockquote><p>使用命令 <code>php -S localhost:&lt;端口号&gt; [文件路径]</code> 来启动一个 WebServer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -S localhost:999</span><br><span class="line">[Sun Mar 15 04:25:52 2020] PHP 7.4.1 Development Server (http:&#x2F;&#x2F;localhost:999) started</span><br></pre></td></tr></table></figure><blockquote><p>localhost 等价于 127.0.0.1</p></blockquote><p>启动 PHP WebServer 时可以指定一个文件作为启动脚本（如框架的入口文件），在该文件注册所需要的插件及分发路由等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 test.php</span><br></pre></td></tr></table></figure><p>命令添加 <code>-t</code> 参数，将会以目录作为 WebServer 的启动目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 -t public&#x2F;</span><br></pre></td></tr></table></figure><p>关掉命令行窗口或者按 <code>Ctrl + C</code> 即可退出 PHP WebServer。</p><h2 id="PHP-版本号"><a href="#PHP-版本号" class="headerlink" title="PHP 版本号"></a>PHP 版本号</h2><p>使用 <code>php -v</code> 命令可以查看 PHP 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -v</span><br><span class="line">PHP 7.4.1 (cli) (built: Dec 28 2019 20:56:41) ( NTS )</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br><span class="line">    with Zend OPcache v7.4.1, Copyright (c), by Zend Technologies</span><br></pre></td></tr></table></figure><h2 id="PHP-扩展"><a href="#PHP-扩展" class="headerlink" title="PHP 扩展"></a>PHP 扩展</h2><p>使用 <code>php -m</code> 命令可以查看 PHP 安装的扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -m</span><br><span class="line">[PHP Modules]</span><br><span class="line">bcmath</span><br><span class="line">Core</span><br><span class="line">ctype</span><br><span class="line">curl</span><br><span class="line">date</span><br><span class="line">dom</span><br><span class="line">fileinfo</span><br><span class="line">filter</span><br><span class="line">ftp</span><br><span class="line">gd</span><br></pre></td></tr></table></figure><h2 id="PHP-参数"><a href="#PHP-参数" class="headerlink" title="PHP 参数"></a>PHP 参数</h2><p>使用 <code>php -i</code> 命令可以查看 PHP / 扩展的配置参数，等价于 <code>phpinfo</code>。</p><h2 id="语法查错"><a href="#语法查错" class="headerlink" title="语法查错"></a>语法查错</h2><p>可以用 <code>php -l &lt;文件路径&gt;</code> 来检测该 php 文件是否有语法错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -l index.php</span><br><span class="line">No syntax errors detected in index.php</span><br></pre></td></tr></table></figure><h2 id="执行一段代码"><a href="#执行一段代码" class="headerlink" title="执行一段代码"></a>执行一段代码</h2><p>使用 <code>php -r &quot;代码&quot;</code> 来执行一段 PHP 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -r &quot;echo &#39;ok&#39;;&quot;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="查看扩展详情"><a href="#查看扩展详情" class="headerlink" title="查看扩展详情"></a>查看扩展详情</h2><p>使用命令 <code>php --ri &lt;扩展名称&gt;</code> 获取扩展配置详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --ri swoole</span><br><span class="line"></span><br><span class="line">swoole</span><br><span class="line"></span><br><span class="line">Swoole &#x3D;&gt; enabled</span><br><span class="line">Author &#x3D;&gt; Swoole Team &lt;team@swoole.com&gt;</span><br><span class="line">Version &#x3D;&gt; 4.4.14</span><br><span class="line">Built &#x3D;&gt; Jan  6 2020 07:22:54</span><br><span class="line">coroutine &#x3D;&gt; enabled</span><br><span class="line">epoll &#x3D;&gt; enabled</span><br><span class="line">eventfd &#x3D;&gt; enabled</span><br><span class="line">signalfd &#x3D;&gt; enabled</span><br><span class="line">cpu_affinity &#x3D;&gt; enabled</span><br><span class="line">spinlock &#x3D;&gt; enabled</span><br><span class="line">rwlock &#x3D;&gt; enabled</span><br><span class="line">openssl &#x3D;&gt; OpenSSL 1.1.1d  10 Sep 2019</span><br><span class="line">http2 &#x3D;&gt; enabled</span><br><span class="line">zlib &#x3D;&gt; 1.2.11</span><br><span class="line">mutex_timedlock &#x3D;&gt; enabled</span><br><span class="line">pthread_barrier &#x3D;&gt; enabled</span><br><span class="line">futex &#x3D;&gt; enabled</span><br><span class="line">mysqlnd &#x3D;&gt; enabled</span><br><span class="line">async_redis &#x3D;&gt; enabled</span><br><span class="line"></span><br><span class="line">Directive &#x3D;&gt; Local Value &#x3D;&gt; Master Value</span><br><span class="line">swoole.enable_coroutine &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.enable_library &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.enable_preemptive_scheduler &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">swoole.display_errors &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.use_shortname &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.unixsock_buffer_size &#x3D;&gt; 8388608 &#x3D;&gt; 8388608</span><br></pre></td></tr></table></figure><h2 id="查看扩展提供的方法"><a href="#查看扩展提供的方法" class="headerlink" title="查看扩展提供的方法"></a>查看扩展提供的方法</h2><p>使用命令 <code>php --re &lt;扩展名称&gt;</code> 获取扩展的所有方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php --re swoole</span><br></pre></td></tr></table></figure><h2 id="获取函数详情"><a href="#获取函数详情" class="headerlink" title="获取函数详情"></a>获取函数详情</h2><p>使用命令 <code>php --rf &lt;函数名称&gt;</code> 获取函数详情，可以用来检测函数是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --rf array_columns</span><br><span class="line">Exception: Function array_columns() does not exist</span><br><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --rf array_column</span><br><span class="line">Function [ &lt;internal:standard&gt; function array_column ] &#123;</span><br><span class="line"></span><br><span class="line"> - Parameters [3] &#123;</span><br><span class="line">    Parameter #0 [ &lt;required&gt; $arg ]</span><br><span class="line">    Parameter #1 [ &lt;required&gt; $column_key ]</span><br><span class="line">    Parameter #2 [ &lt;optional&gt; $index_key ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      PHP 常用命令及参数整理。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Trait - 优雅的复用方法</title>
    <link href="https://www.idce.com/trait/"/>
    <id>https://www.idce.com/trait/</id>
    <published>2020-03-14T16:40:51.000Z</published>
    <updated>2020-03-14T17:59:31.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>为了解决单继承问题，从 PHP 5.4 开始新增了 <code>trait</code> 关键字来实现代码的复用。<code>trait</code> 定义的代码块在类的内部引入，类就能获得由 <code>trait</code> 定义的属性及方法。</p><p>通过定义一个 <code>SingletonTrait</code>，来实现单例模式的类共用代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trait SingletonTrait</span><br><span class="line">&#123;</span><br><span class="line">    protected static $instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() &#123;</span><br><span class="line">        if (null &#x3D;&#x3D;&#x3D; self::$instance) &#123;</span><br><span class="line">            self::$instance &#x3D; new static();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要引用 <code>Trait</code> 十分简单，只要在类的内部使用 <code>use</code> 关键字即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SomeService</span><br><span class="line">&#123;</span><br><span class="line">    use SingletonTrait;</span><br><span class="line"></span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;ok!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$service &#x3D; SomeService::getInstance();</span><br><span class="line">$service-&gt;test();</span><br></pre></td></tr></table></figure><p>通过引用 <code>SingletonTrait</code> 代码块 <code>SomeService</code> 直接获得了 <code>trait</code> 定义的方法及属性，通过 <code>trait</code> 引用实现复用单例模式方法，而不是直接复制粘贴同样的代码到每个单例的类中，让代码变得更加优雅！</p><blockquote><p>Trait 的实现原理是简单的把代码块拷贝到类</p></blockquote><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在类的继承关系中，如果父类的属性或方法使用了 <code>private</code> 声明，子类是无法调用的，但是在 Trait 中不同，因为 Trait 相当于把代码引入到类里面，也就是变成了类的一部分，因此当 Trait 声明了私有属性或方法，在类的内部是可以直接使用的。</p><p>Trait 定义的代码块同样可以使用 <code>static</code>、<code>abstract</code> 等修饰符。</p><h2 id="多个-Trait"><a href="#多个-Trait" class="headerlink" title="多个 Trait"></a>多个 Trait</h2><p>一个类可以引用多个 Trait，中间使用逗号隔开。</p><p>当引入的多个 Trait 里面存在同名方法时，需要通过两种方式来解决冲突，否则会报出致命异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Fatal error:  Trait method xxx has not been applied, because there are collisions with other trait methods on Test in xxx</span><br></pre></td></tr></table></figure><h3 id="insteadof"><a href="#insteadof" class="headerlink" title="insteadof"></a>insteadof</h3><p>使用 <code>insteadof</code> 关键字来让其中一个 Trait 的方法覆盖另一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A,B &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用 A trait 中的 hello 覆盖 B 的 hello</span><br><span class="line">        A:: hello insteadof B;</span><br><span class="line">        &#x2F;&#x2F; 使用 B trait 中的 world 覆盖 A 的 world</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test &#x3D; new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:hello</span><br><span class="line">B:world</span><br></pre></td></tr></table></figure><h3 id="as-方法重命名"><a href="#as-方法重命名" class="headerlink" title="as 方法重命名"></a>as 方法重命名</h3><p>如果需要保留两者的方法，可以使用 <code>as</code> 重命名，然后再用另一个的方法进行覆盖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A, B &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 A trait 中的方法重命名</span><br><span class="line">        A::hello as ahello;</span><br><span class="line">        A::world as aworld;</span><br><span class="line">        &#x2F;&#x2F; 再使用 insteadof 关键字覆盖冲突的方法</span><br><span class="line">        B:: hello insteadof A;</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test &#x3D; new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br><span class="line">$test-&gt;ahello();</span><br><span class="line">$test-&gt;aworld();</span><br></pre></td></tr></table></figure><p>注意，即使重命名了也需要使用 <code>insteadof</code> 覆盖原来的代码，不然同样会产生致命报错。</p><h2 id="Trait-嵌套"><a href="#Trait-嵌套" class="headerlink" title="Trait 嵌套"></a>Trait 嵌套</h2><p>Trait 里面也可以引用其他 Trait。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当 Trait 中定义的方法或属性与类或其父类相同时，其优先级如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类 &gt; trait &gt; 父类</span><br></pre></td></tr></table></figure><h2 id="Trait-的意义"><a href="#Trait-的意义" class="headerlink" title="Trait 的意义"></a>Trait 的意义</h2><p>Trait 能实现代码块的复用，但是继承（extends）、实现（implements）同样可以复用父类的方法或实现接口的方法，它们之间有什么区别呢？</p><p>我们知道面向对象编程里代码的关联性十分重要，例如继承关系即把子类的属性和方法进行了抽象，接口同样是把相同的东西抽象出来，然后在子类进行实现，这样有时候我们遇到像“水陆两栖动物”这种特殊的类型，既要让它继承水生动物的特性，又要让它继承陆生动物的特性，而 PHP 不支持多继承，要实现这种效果会变得十分麻烦。</p><p>而 Trait 定义的代码块，并没有严格意义上的关联性，仅仅只是为了复用代码块而被设计。Trait 的作用更像是一个功能块，不论是谁，只要让其他的类“嵌入”这个功能块就能让它具有对应的效果。</p><p>就好比 LOL 里的提莫，你可以出帽子、法穿棒等纯粹的 AP 装让它变成 AP 提莫，也可以出纳什之牙、飓风让提莫变成一个普攻型的 APC（远程输出单位），Trait 的作用类似于装备效果，任何人都可以出这件装备，只要装备了就能得到对应的能力。</p><p>在 Laravel 框架里，要实现“软删除”功能十分简单，只需要在数据库迁移中添加字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(&#39;orders&#39;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;bigIncrements(&#39;id&#39;);</span><br><span class="line">            &#x2F;&#x2F; .. 省略其他字段</span><br><span class="line">            $table-&gt;softDeletes();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>然后在 Model 里直接引入 Trait：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line">use Illuminate\Database\Eloquent\SoftDeletes;</span><br><span class="line"></span><br><span class="line">class Order extends Model</span><br><span class="line">&#123;</span><br><span class="line">    use SoftDeletes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可让一个模型具有软删除的功能。</p><p>Laravel 还有许多地方存在此类的应用，通过这样的设计让代码更加优雅！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>凡是在开发过程中，只要意识到自己通过 Ctrl+C、Ctrl+V 复制了同一份的代码，就表明这个地方写的不够好，一定存在优化的空间。</p>]]></content>
    
    <summary type="html">
    
      从 PHP 的 5.4.0 版本开始,PHP 提供了一种全新的代码复用的概念，那就是 Trait。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="https://www.idce.com/mini-server/"/>
    <id>https://www.idce.com/mini-server/</id>
    <published>2020-03-14T12:57:38.000Z</published>
    <updated>2020-03-14T13:45:32.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微服务是一种服务架构模式，目标是架构师的话，当然不能放过这个知识点。</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>一般的项目架构有两种形式：单体应用和微服务。</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>单体应用就是用一套代码实现全部功能。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务就是把单体应用的代码按照功能拆分出来，形成多套独立的代码，通过某种方式让它们连接在一起，实现完整功能。</p><p>单体应用好比早期的网站开发，用 PHP 搭建的网站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php echo &quot;hello world!&quot; ?&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>HTML 代码与 PHP 代码混合在一起。</p><p>而随着技术的发展，又推出了 MVC 模式，实现模型、视图、控制器的分离。</p><p>然而问题的本质依然没有改变，还不是要一个人去完成同样的工作？</p><p>技术从未停下发展的脚本，职业的分工越来越明确，开始出现专门写 HTML 和 JavaScript 的前端人员和专门写 PHP 代码的后端人员，前端人员通过一项技术“Ajax”调用后端人员写的接口，使他们看似分离但却紧紧的联系到一起，共同实现一个完整的项目。</p><p>这样的分工方式就叫做微服务。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>比如有一套系统，包括如下业务：</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3518914240,1325113277&fm=26&gp=0.jpg" alt="微服务架构"></p><p>把这些业务拆分出来，单独做成一套系统，然后以某种方式让独立的项目之前能够进行通信，这就完成了一套微服务架构。</p><h2 id="微服务通信模式"><a href="#微服务通信模式" class="headerlink" title="微服务通信模式"></a>微服务通信模式</h2><h3 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h3><h3 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h2 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h2><p>优点</p><ul><li>大型项目解耦，提高整体性能</li><li>每个服务都很小，开发人员可以聚焦自己负责的功能模块。</li><li>只需要极少的人来维护一套代码</li><li>可以用不同的语言开发</li></ul><p>缺点</p><ul><li>架构需要花费一定的精力，如果架构得不好，后期反而会变成麻烦</li><li>由于服务分散成很多个，因此难以快速定位错误</li><li>管理成本提高</li></ul>]]></content>
    
    <summary type="html">
    
      微服务是一种应用部署的架构模式。
    
    </summary>
    
    
      <category term="架构" scheme="https://www.idce.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://www.idce.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM</title>
    <link href="https://www.idce.com/php-fpm/"/>
    <id>https://www.idce.com/php-fpm/</id>
    <published>2020-03-14T12:24:27.000Z</published>
    <updated>2020-03-14T12:26:28.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学 PHP 的时候，搜索网上教程一顿操作配置了 LNMP（Linux + Nginx + MySQL + PHP）环境，在配置 Nginx 的时候听说了 PHP-FPM，然而却没有进行深究，只知道让 Nginx 转发就完事了。</p><p>为了进一步的学习 PHP，需要了解 PHP-FPM 是什么。</p><h2 id="CGI-通用网关接口"><a href="#CGI-通用网关接口" class="headerlink" title="CGI 通用网关接口"></a>CGI 通用网关接口</h2><p>通用网关接口（Common Gateway Interface，CGI）是一个为用户和 WEB 服务（如 Nginx）与其他应用（如 PHP）提供交互的程序。</p><p>早期的 WEB 应用只处理静态的页面，用户访问站点只要请求指定的 <code>.htm</code> 或 <code>.html</code> 文件，静态文件可以直接输出给浏览器，所以 Nginx 不需要做额外的处理。</p><p>随着互联网的发展，只有静态的页面已经不能满足人们的需求了。</p><p>Nginx 本身不处理文件，只是分发请求，比如用户请求 <code>/index.html</code>，它会去服务器寻找这个文件，找到了就输出给浏览器，没找到就返回 404。这里分发的是静态数据，但如果用户请求的是 <code>/index.php</code>，这是一个 PHP 文件，不能像 <code>.html</code> 文件一样直接返回给浏览器。</p><p>这个时候就犯难了，Nginx 应该如何处理非静态的文件呢？</p><p>为了解决如何处理非静态文件的问题，CGI 诞生了。</p><p>CGI 做的事情就是解析用户的请求，然后将请求的结果解析成 HTML 返回给浏览器，开发者可以使用任何语言处理 Web Server 发来的请求，生成动态的内容。</p><p>上面的例子，用户访问 <code>/index.php</code> 文件，由于 Nginx 无法处理这种格式的文件，于是将请求（包括参数等等）转发给 CGI 程序（可理解为语言解释器）进行处理，这里的 CGI 就是 PHP-CGI，PHP-CGI 可以解析 PHP 文件，<code>index.php</code> 文件在 PHP-CGI 程序进行解析和处理后才会输出给浏览器。</p><p><code>index.php</code> 文件就交给 PHP 程序去处理，<code>.jsp</code> 文件就让 Java 去处理，每种动态语言都有对应的 CGI，Nginx 只需要将请求转发给 CGI 就可以了，再通过 CGI 输出数据给浏览器。</p><h2 id="FastCGI-快速网关接口"><a href="#FastCGI-快速网关接口" class="headerlink" title="FastCGI 快速网关接口"></a>FastCGI 快速网关接口</h2><p>CGI 在高并发时存在性能问题，作为改进版的 FastCGI 便出现了。</p><p>快速网关接口（Fast Common Gateway Interface，FastCGI）是 CGI 的增强版。</p><h3 id="CGI-原理"><a href="#CGI-原理" class="headerlink" title="CGI 原理"></a>CGI 原理</h3><p>在接收到请求时，先 fork 出 CGI 进程，然后处理请求，处理完后结束这个进程，这就是 fork-and-execute 模式。</p><p>所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 进程，每个进程都会加载解析配置文件，初始化执行环境，那么当高并发请求时，会大量挤占系统的资源如内存，CPU 等，造成效能低下。</p><h3 id="FastCGI-原理"><a href="#FastCGI-原理" class="headerlink" title="FastCGI 原理"></a>FastCGI 原理</h3><p>FastCGI 进程管理器启动时会创建一个主（Master）进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接。</p><p>Web 服务器接收 HTTP 请求后，将 CGI 报文通过 UNIX 或 TCP Socket 进行通信，将环境变量和请求数据写入标准输入，转发到 CGI 解释器进程。</p><p>CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器。</p><p>CGI 解释器进程变为空闲状态，等待下一个 HTTP 请求的到来。</p><p>由于 FastCGI 模式在启动时便创建了很多个子进程，这些子进程常驻内存中，一旦接收到请求就可以立即进入工作状态，而传统的 CGI 模式，只有在接收到请求的时候才会去创建进程，重新读取配置文件等一系列初始化操作，毫无疑问性能会相差很多。</p><h2 id="PHP-FPM-FastCGI-进程管理器"><a href="#PHP-FPM-FastCGI-进程管理器" class="headerlink" title="PHP-FPM FastCGI 进程管理器"></a>PHP-FPM FastCGI 进程管理器</h2><p>PHP 的 FastCGI进程管理器（FastCGI Process Manager，PHP-FPM），PHP-FPM 即 FastCGI 的具体实现。</p><p>PHP 的解释器是 PHP-CGI，它本身只会解析请求返回结果，不能进行进程的调度，而 PHP-FPM（进程管理器）所做的事情便是管理进程。</p><p>PHP-FPM 包含了一个 <code>master</code> 进程和许多个 <code>worker</code> 进程，<code>worker</code> 进程的数量是可以动态调节的，创建和销毁全部由 <code>master</code> 进程来控制。</p><p><img src="https://user-images.githubusercontent.com/28209810/64397840-35090980-d095-11e9-959e-eda11f5cb000.png" alt="image"></p><p>其中，<code>master</code> 进程负责分发请求，首先 <code>master</code> 进程检测是否有可用的 <code>worker</code> 进程，如果没有则返回错误（502），然后将请求分发给空闲的 <code>worker</code> 进程处理，然后接取下一个请求，再将请求分发给空闲的 <code>worker</code>，如果 <code>worker</code> 进程处理请求超时则返回错误（504）。</p><p>这样的协作方式大大的提高了程序处理并发请求的性能，<code>worker</code> 进程的数量可以通过 <code>php.ini</code> 文件进行配置。</p><p>理论上进程越多，可以处理的请求也越多，但空闲的进程太多反而会造成内存的浪费。</p><h2 id="Nginx-与-PHP-FPM-通信"><a href="#Nginx-与-PHP-FPM-通信" class="headerlink" title="Nginx 与 PHP-FPM 通信"></a>Nginx 与 PHP-FPM 通信</h2><p>Nginx 与 PHP-FPM 的通信方式有两种：TCP SOCKET 和 Unix SOCKET。</p><p>TCP socket 的优点是可以跨服务器，Nginx 服务器不需要与 PHP-FPM 在同一台服务器上，由于跨服务器的特性，还可以实现分布式部署。</p><p>Unix socket 用于实现同一主机上的进程间通信，相较于 TCP socket，Unix socket 跳过了许多验证的步骤，因此 Unix socket 的效率比 TCP socket 要高，但是不稳定。</p><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>一个基于 TCP socket 的 PHP 站点 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root &#x2F;www&#x2F;web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><p>Nginx 的 FastCGI 模块提供了 fastcgi_param 来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量，fastcgi_param 是一个文件，包含了 Nginx 中的变量映射关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">fastcgi_param  REQUEST_SCHEME     $scheme;</span><br><span class="line">fastcgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI&#x2F;1.1;</span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx&#x2F;$nginx_version;</span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br></pre></td></tr></table></figure><p>除此之外，还有一个重要的指令 <code>fastcgi_pass</code>，这个指令用于指定 FPM 进程监听的地址，Nginx 会把所有的 PHP 请求翻译成 FastCGI 请求之后再发送到这个地址。</p><p>上面的 Nginx 配置文件中，我们配置了 <code>fastcgi_pass 127.0.0.1:9000;</code>，其含义是将请求转发到本机 9000 端口（PHP-FPM 进程）处理，这样的方式叫做 TCP socket。</p><p>TCP socket 的好处是可以将 Nginx 服务器与 FPM 服务器进行分离，因此可以实现分布式 PHP-FPM 架构：</p><p><img src="https://user-images.githubusercontent.com/28209810/64407389-c5a41180-d0b6-11e9-8d5f-5b5ef39a52ce.png" alt="image"></p><p>配置 <code>upstream</code> 来指定 PHP-FPM 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upstream php-fpm &#123;</span><br><span class="line">    server 127.0.0.1:9000;</span><br><span class="line">    server 127.0.0.2:9000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root &#x2F;www&#x2F;web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass php-fpm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unix-socket"><a href="#Unix-socket" class="headerlink" title="Unix socket"></a>Unix socket</h3><p>基于 Unix socket 的 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fasrcgi_pass &#x2F;usr&#x2F;run&#x2F;php-fpm.sock</span><br></pre></td></tr></table></figure><p>PHP-FPM 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line"># 或者</span><br><span class="line">listen &#x3D; &#x2F;var&#x2F;run&#x2F;php-fpm.sock</span><br></pre></td></tr></table></figure><blockquote><p>socket 的本质是一个文件，因此还存在权限问题，所以需要注意 Nginx 所在的用户组是否有该文件的操作权限。</p></blockquote><p>Unix socket 通信方式需要在本机生成 sock 文件，因此 Nginx 服务器与 PHP-FPM 必须在同一台机子。</p><p>关于两者的取舍，当并发量较小时（比如几百），可以选择 Unix socket 以提高处理效率，在并发量较大时，可以选择 TCP socket 以保持连接的稳定性。</p>]]></content>
    
    <summary type="html">
    
      FastCGI 进程管理器。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂Nginx</title>
    <link href="https://www.idce.com/nginx-introduction/"/>
    <id>https://www.idce.com/nginx-introduction/</id>
    <published>2020-03-10T14:20:15.000Z</published>
    <updated>2020-03-18T05:42:25.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx-是什么？"><a href="#Nginx-是什么？" class="headerlink" title="Nginx 是什么？"></a>Nginx 是什么？</h2><p>Nginx 是高性能 HTTP 和反向代理 WEB 服务器，还提供了邮件代理服务。</p><p>简而言之即<strong>分发服务器请求的软件</strong>。</p><p>访问一个网站的本质：</p><ul><li>在浏览器输入网址</li><li>DNS 服务商将网址解析成服务器 IP 地址</li><li>访问此 IP 的服务器</li><li>服务器收到请求，建立连接</li><li>服务器上的 Nginx 解析请求并转发给对应程序处理</li><li>程序处理请求</li><li>程序返回请求的结果（响应）</li></ul><p>在此过程，Nginx 负责分发请求给指定的程序处理。</p><p>Nginx 在分发请求的时候，会携带请求参数和请求头等其他信息，Nginx 自身无法处理请求，它只是将请求转发给对应程序处理，如果是 PHP 搭建的网站，则转发给 PHP-CGI，由 PHP-CGI 返回结果给客户端。</p><blockquote><p>PHP-CGI 是处理 PHP 文件的程序</p></blockquote><h2 id="Nginx-起源"><a href="#Nginx-起源" class="headerlink" title="Nginx 起源"></a>Nginx 起源</h2><p>Nginx 是伊戈尔·赛索耶夫为俄罗斯访问量第二的 rambler.ru 站点设计开发的。</p><p>第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。</p><p>从发布至今，凭借开源的力量，已经接近成熟与完善。</p><p>中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h2 id="URI-是什么？"><a href="#URI-是什么？" class="headerlink" title="URI 是什么？"></a>URI 是什么？</h2><p>在了解 Nginx 是如何分发请求之前需要先了解什么是 URI。</p><p>URI 统一资源标识符(Uniform Resource Identifier， URI)，它由三个部分组成：</p><ul><li>协议</li><li>主机</li><li>资源路径</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.huotuyouxi.com&#x2F;img&#x2F;1.jpg</span><br></pre></td></tr></table></figure><ul><li>https：协议</li><li>blog.huotuyouxi.com：主机</li><li>/img/1.jpg：资源路径</li></ul><p>上面也提到了，访问网址的本质是访问服务器上某个文件，示例的网址访问 blog.huotuyouxi.com 所在服务器上的 1.jpg 这个文件。</p><p>如果这样理解不能，换句话说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\games\Lol\Lol.exe</span><br></pre></td></tr></table></figure><p>访问服务器上的文件与访问本地 F 盘并无太大的差别，区别在于访问网址相当于访问远程服务器上的文件。</p><p>通俗的讲 URI 就是远程服务器文件的路径。</p><p>至于协议部分，协议即一种人为约定的规则，除了 http、https 协议，还有 ftp、sftp 等等各种协议，请求协议跟后文没有多大关系，有兴趣可以自行查阅当做扩展阅读。</p><h2 id="Nginx-如何分发请求？"><a href="#Nginx-如何分发请求？" class="headerlink" title="Nginx 如何分发请求？"></a>Nginx 如何分发请求？</h2><p>客户端请求 URI 对应的文件，Nginx 是如何处理的呢？</p><p>在分发请求之前，Nginx 首先需要解析请求。</p><p>假如我们把域名：blog.huotuyouxi.com 解析到 IP 为 xxx.xxx.xxx.xxx 的服务器上。</p><p>然后在该服务器上安装 Nginx，并且添加如下配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听 80 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    # 对应的域名</span><br><span class="line">    server_name  blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    # 项目根目录</span><br><span class="line">    root &#x2F;www&#x2F;blog&#x2F;public;</span><br><span class="line"></span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 字符集</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    # 匹配 URI 以 &#x2F; 开头（因为所有的 URI 都是以 &#x2F; 开头，所以会匹配到所有请求）</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 尝试获取这几种文件</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 匹配后缀为 .php 的请求</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>小知识：80 是 http 默认端口，443 是 https 默认端口，访问域名时无需指定端口即可访问，使用其他端口时，就需要在域名后面加上 :端口号才能访问，例如：<a href="http://blog.huotuyouxi.com:81" target="_blank" rel="noopener">http://blog.huotuyouxi.com:81</a></p></blockquote><p><code>location</code> 是 Nginx 主要的模块之一，用来匹配 URI，满足条件时进入到模块内执行，我们在这个配置文件里设置了两个 <code>location</code> 模块匹配资源文件。</p><p>第一个 <code>location</code> 定制了规则 <code>/</code>，匹配以 <code>/</code> 开头的所有 URI，由于所有的 URI 都是以 / 开头，所以会匹配到所有请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try_files</code> 按顺序检查文件是否存在，返回第一个找到的文件，至少需要两个参数，当前面的文件都找不到时，会内部重定向到最后一个参数：</p><ul><li>$uri</li><li>$uri/</li><li>/index.php?$query_string</li></ul><p><code>$uri</code> 指的是完全匹配的文件，<code>$uri/</code> 指的是文件夹，当前面两个都没有时，会访问 <code>/index.php</code>，而后面的 <code>?$query_string</code> 指的是携带请求参数，如果不携带参数，使用 <code>$_GET</code> 会获取不到任何参数。</p><p>访问目录是以配置的项目相对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root &#x2F;www&#x2F;blog&#x2F;public;</span><br></pre></td></tr></table></figure><p>最后的值访问 <code>index.php</code> 即访问 <code>/www/blog/public/index.php</code>。</p><p>接着第二个 <code>location</code>，<code>~</code> 是一种标识符，用于正则匹配 URI，区分大小写，正则匹配规则为：<code>.php$</code> 也就是以 <code>.php</code> 结尾的文件，当满足条件时进入此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri &#x3D;404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意！反斜杠 \ 一定要存在，因为 .（点）也是正则表达式，需要加上反斜杠转义才能匹配 .php 后缀 </p></blockquote><p><code>location</code> 在配置文件里的前后顺序并不是匹配的顺序，<code>location</code> 匹配的规则及顺序后文介绍，在这个例子中 <code>/</code> 的匹配优先级低于 <code>~</code>，也就是先匹配 <code>.php</code> 后缀的文件，如果匹配不到再匹配 <code>/</code> 规则。</p><p>假如某个用户访问：blog.huotuyouxi.com/php-fpm</p><p>此时，在 Nginx 中的处理流程是：</p><p>首先匹配到了 <code>server_name</code>：blog.huotuyouxi.com，进入当前配置文件进行处理。</p><p>接着解析 $uri（文件路径）即 <code>server_name</code> 后面的部分 <code>/php-fpm</code>，然后优先匹配规则 <code>~ .php</code>，发现它并没有 <code>.php</code> 结尾，接着往下级匹配 <code>/</code>，满足条件，进入到该模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    # 尝试获取这几种文件</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try_files 会尝试获取 <code>/www/blog/public/php-fpm</code> 文件，发现没有，继续匹配第二个参数；<code>$uri/</code> 比之前的参数多加了一个 <code>/</code> 结尾，指的是文件夹，发现也没有 <code>/www/blog/public/php-fpm</code> 这个目录，前面两个参数都匹配完了，因此请求会变为内部重定向到最后一个参数 <code>index.php</code> 这个文件，然后重新开始匹配，此时正好匹配了规则 <code>.php</code> 结尾，进入 <code>location ~ .php</code> 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri &#x3D;404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到这个模块后，实际上是将请求转发给了 PHP-CGI 进行处理，前面几个字段暂时不用理会，只需要知道请求被转发给了 <code>fastcgi_pass</code> 这个字段，也就是 <code>127.0.0.1:9000</code>（PHP-FPM 本机端口），CGI 处理完请求后将结果返回给客户端。</p><p>以上就是 Nginx 解析和分发请求的过程。</p><h2 id="Nginx-匹配规则及优先级"><a href="#Nginx-匹配规则及优先级" class="headerlink" title="Nginx 匹配规则及优先级"></a>Nginx 匹配规则及优先级</h2><p>Nginx 配置文件中的 <code>location</code> 即匹配规则，匹配规则可以有任意个，按照优先级逐个匹配，匹配成功时停止往下匹配。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>Nginx 的 <code>location</code> 模块包含 4 种匹配标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标识符描述</span><br><span class="line">&#x3D;精确匹配：当 $uri 完全匹配。</span><br><span class="line">~正则匹配：正则表达式匹配 $uri，区分大小写。</span><br><span class="line">~*正则匹配：正则表达式匹配 $uri，不区分大小写。</span><br><span class="line">^~非正则匹配：匹配到前缀最多的 $uri 后就结束，该模式匹配成功后，不会使用正则匹配。</span><br></pre></td></tr></table></figure><p>标识符置于 <code>location</code> 语句后面，标识符后面为匹配规则。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location [标识符] &lt;匹配规则&gt; &#123;</span><br><span class="line">    # 匹配成功时执行的代码块</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了标识符之外，可以不使用标识符进行前缀匹配（最长字符匹配）。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><blockquote><p><code>location</code> 的匹配优先级与 <code>location</code> 在配置文件的书写顺序无关</p></blockquote><p>Nginx <code>location</code> 匹配优先级为：</p><p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>,</del>* 正则顺序) &gt; (location 部分起始路径) &gt; (location /)</p><p>换而言之，即：</p><p>（精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location 通配）</p><h3 id="“-”精准匹配"><a href="#“-”精准匹配" class="headerlink" title="“=”精准匹配"></a>“=”精准匹配</h3><p>使用精准匹配时，URI 必须完全相同才能匹配成功。</p><p>如下面的匹配规则，只有 URI 等于 <code>/php-fpm</code> 时才会触发成功，模块里的 <code>return 403;</code> 将会返回一个 <code>403 Forbidden</code> 提示信息，模拟我们不希望用户能直接访问的目录或文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F;php-fpm &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 <code>server_name</code> 字段修改为 <code>localhost</code> 方便本地调试。</p><blockquote><p>修改 Nginx 配置需要重启或平滑重启使配置生效，平滑重启命令：nginx -s reload</p></blockquote><p>请求 URI：<code>127.0.0.1/php-fpm</code></p><p>可以使用 <code>curl</code> 命令来测试，即 <code>curl 127.0.0.1/php-fpm</code>，也可以直接打开浏览器输入这个地址查看结果。</p><p>返回结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm/1.jpg</code></p><p>匹配失败，<code>=</code> 号必须完全匹配。</p><h3 id="“-”正则匹配，区分大小写"><a href="#“-”正则匹配，区分大小写" class="headerlink" title="“~”正则匹配，区分大小写"></a>“~”正则匹配，区分大小写</h3><p><code>location</code> 后跟波浪线标识符 <code>~</code>，可以实现按照正则表达式规则进行匹配，<code>~</code> 波浪线标识符正则匹配时会区分大小写，下面的规则表示不希望用户访问所有后缀为 <code>.php</code> 的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>第二个请求里，最后一个字母 P 为大写，因此匹配失败。</p><p>在波浪线前面加上感叹号，形成 <code>!~</code> 标识符，表示<strong>不匹配</strong>正则表达式（区分大小写）的规则，也就是跟 <code>~</code> 的作用相反。</p><h3 id="“-”正则匹配，不区分大小写"><a href="#“-”正则匹配，不区分大小写" class="headerlink" title="“~*”正则匹配，不区分大小写"></a>“~*”正则匹配，不区分大小写</h3><p>波浪线后加上星号 <code>~*</code> 标识符将不区分大小写进行正则匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .php&#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>结果：403</p><p>由于使用了不区分大小写的规则，因此最后一个 P 改成大写也能匹配成功。</p><p>在波浪线前面加上感叹号，形成 <code>!~*</code> 标识符，表示<strong>不匹配</strong>正则表达式（不区分大小写）的规则，也就是跟 <code>~*</code> 的作用相反。</p><h3 id="“-”非正则匹配前缀"><a href="#“-”非正则匹配前缀" class="headerlink" title="“^~”非正则匹配前缀"></a>“^~”非正则匹配前缀</h3><p>“^~” 非正则匹配，后面的参数为匹配的路径，只要 URI 满足了这个前缀就匹配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F;encrpyt&#x2F; &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/encrpyt/</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt</code></p><p>匹配失败，<code>/encrpyt</code> 没有满足 <code>/encrpyt/</code>，缺少了后面的 <code>/</code>。</p><p>请求 URI：<code>127.0.0.1/encrpyt/1.jpg</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt/images/1.jpg</code></p><p>结果：403</p><p>也就是说，只要前缀满足了这个条件就匹配成功，上面的匹配规则含义是 <code>encrypt</code> 目录下所有的文件都禁止访问。</p><h3 id="不使用标识符"><a href="#不使用标识符" class="headerlink" title="不使用标识符"></a>不使用标识符</h3><p>不使用标识符即按照最长字符串匹配，优先匹配最长的字符串，只要完全匹配就停止继续往下匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;files&#x2F;encrypt&#x2F; &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;post.php &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/post.php</code></p><p>首先会查找最长的字符串规则：<code>/files/encrypt/</code> 发现不匹配，接着匹配第二长的规则：<code>/post.php</code>，匹配成功，返回 403。</p><p>请求 URI：<code>127.0.0.1/files/encrypt/post.php</code></p><p>首先查找最长字符串规则：<code>/files/encrypt/</code> 前缀满足条件，匹配成功，停止往下匹配。</p><blockquote><p>注意！测试匹配规则时，如果你拷贝了上面完整的 Nginx 配置文件，.php 结尾是有 location ~ .php$ 规则的，记得删掉，否则会优先匹配到正则规则，建议测试时删除多余的所有规则，避免干扰结果，只建立一个对照组进行测试</p></blockquote><h2 id="Nginx-配置文件"><a href="#Nginx-配置文件" class="headerlink" title="Nginx 配置文件"></a>Nginx 配置文件</h2><p>Nginx 包括主配置文件与子配置文件，默认路径为：</p><ul><li>/etc/nginx/nginx.conf（主配置）</li><li>/etc/nginx/conf.d/（子配置目录）</li></ul><p>Nginx 提供了官方的中文文档可供查阅：<a href="https://www.nginx.cn/doc/index.html" target="_blank" rel="noopener">Nginx - 官方中文文档</a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p>主配置文件可以让所有子配置文件共享通用的配置，可以定义 Nginx 基本参数等。</p><p>编辑主配置文件 <code>/etc/nginx/nginx.conf</code>，对应参数及作用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># Nginx 运行时的用户和用户组</span><br><span class="line">user  nginx;</span><br><span class="line"></span><br><span class="line"># Nginx 工作进程数，推荐设置为 CPU 核心数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 全局错误日志存储路径及类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;nginx_error.log warn;</span><br><span class="line"></span><br><span class="line"># 进程 PID 文件路径</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"># 事件模块</span><br><span class="line">events &#123;</span><br><span class="line">    # 每个工作进程的最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 服务</span><br><span class="line">http &#123;</span><br><span class="line">    # 文件扩展名与文件类型映射表</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    </span><br><span class="line">    # 默认文件类型</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"> </span><br><span class="line">    # 日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    # 全局访问日志目录</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;nginx_access.log  main;</span><br><span class="line">    </span><br><span class="line">    # 是否调用 sendfile 函数输出文件</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    # 此选项仅在使用 sendfile 的时候使用</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    # http 层面的连接超时时长（单位：秒），如一个网页打开 65 秒后服务器还没给出响应，则显示超时</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    # 是否开启 gzip 压缩，开启时可以压缩文件体积减少网络传输，使得网页打开更快，但是会消耗 CPU 资源</span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    # 读取子配置文件</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>events</code> 模块包含了 Nginx 处理连接的设置，常见的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">    # 设置网路连接序列化，防止惊群现象发生，默认为 on</span><br><span class="line">    accept_mutex on;</span><br><span class="line">    # 设置一个进程是否同时接受多个网络连接，默认为 off</span><br><span class="line">    multi_accept on;</span><br><span class="line">    # 事件驱动模型，select|poll|kqueue|epoll|resig|&#x2F;dev&#x2F;poll|eventport</span><br><span class="line">    use epoll;</span><br><span class="line">    # 最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Events 模块的更多配置项：<a href="https://www.nginx.cn/doc/core/events.html" target="_blank" rel="noopener">Nginx - 指令</a></p><p><code>log_format</code> 字段可以定义日志的输出格式，具体可设置的参数格式及说明如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>219.227.111.255</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>—</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18/Jul/2014:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET /article-10000.html HTTP/1.1”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.blog.huotuyouxi.com" target="_blank" rel="noopener">www.blog.huotuyouxi.com</a> 198.98.120.87</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>1547</td></tr><tr><td>$http_referer</td><td>url跳转来源</td><td><a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户终端浏览器等信息</td><td>“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.36.10.80:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.165</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr></tbody></table><p><code>server</code> 模块用于配置站点，可以在主配置文件添加，但是后期不方便维护，我们可以单独为每个站点编辑一份配置文件。</p><h3 id="子配置文件"><a href="#子配置文件" class="headerlink" title="子配置文件"></a>子配置文件</h3><p>子配置文件是一个包含 <code>server</code> 模块的配置文件，由自己来创建，推荐为每个站点单独创建一个配置文件。</p><p>命名规则一般是根据站点名称，如：<code>blog.huotuyouxi.com.conf</code>。</p><p>当然这个没有严格要求，也可以写成：<code>blog.conf</code>。</p><p>当子配置文件多的时候方便区分即可。</p><p>使用命令 <code>vim/etc/nginx/conf.d/blog.conf</code> 来创建博客的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    return 301 https:&#x2F;&#x2F;blog.huotuyouxi.com$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # https</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    root &#x2F;www&#x2F;blog;</span><br><span class="line">    index index.html;</span><br><span class="line">    </span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 以下为 SSL 相关配置</span><br><span class="line">    ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;3527929_blog.huotuyouxi.com.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;3527929_blog.huotuyouxi.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件将默认的 http 80 端口重定向到了 https 的链接上。</p><p>编辑完成后运行：<code>nginx -s reload</code> 平滑重启即可使配置生效。</p><p>在子配置里可以单独设置访问日志和错误日志，让每个站点都有独立的日志记录文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 访问日志存储位置</span><br><span class="line">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line"></span><br><span class="line"># 错误日志存储位置</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br></pre></td></tr></table></figure><p>access_log：访问日志主要记录客户端的请求。客户端向 Nginx 服务器发起的每一次请求都记录在这里。客户端 IP，浏览器信息，referer，请求处理时间，请求 URL 等都可以在访问日志中得到。当然具体要记录哪些信息，你可以通过 log_format 指令定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]]; # 设置访问日志</span><br><span class="line">access_log off; # 关闭访问日志</span><br></pre></td></tr></table></figure><ul><li>path 指定日志的存放位置。</li><li>format 指定日志的格式。默认使用预定义的 combined。</li><li>buffer 用来指定日志写入时的缓存大小。默认是 64k。</li><li>gzip 日志写入前先进行压缩。压缩率可以指定，从 1 到 9 数值越大压缩比越高，同时压缩的速度也越慢。默认是 1。</li><li>flush 设置缓存的有效时间。如果超过 flush 指定的时间，缓存中的内容将被清空。</li><li>if 条件判断。如果指定的条件计算为 0 或空字符串，那么该请求不会写入日志。</li></ul><p>error_log：记录服务器和请求处理过程中的错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log path [level];</span><br></pre></td></tr></table></figure><ul><li>path：指定错误日志的存储位置</li><li>level：指定要记录的错误级别，只有发生错误的级别大于等于 level 的时候才会记录错误，可取值为：debug, info, notice, warn, error, crit, alert,emerg，默认值为 error。</li></ul><p>如果没有配置单独的日志文件，则会记录在全局日志里。</p><h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p>代理指的是中介服务。</p><p>分为正向代理与反向代理。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理可以理解成代购模式，例如你的朋友要去国外旅游，于是你拜托他帮忙购买你需要的商品，他从国外买好回来再交给你。</p><p>在这里你就是客户端，而你的朋友就是代理服务器。</p><p>这样直接由代理服务器去完成某件事的过程，叫做正向代理。</p><p>正向代理的应用例子——VPN：</p><p>由于国内无法访问到国外的某些网站，比如谷歌；但不是所有的国外服务器都被墙了，因此你可以买一台没有被墙的国外服务器，当你需要访问国外网站的时候，就让服务器去访问，然后再让服务器把结果转发给你。</p><p>正向代理的特征是你知道自己委托了谁去干这件事。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理与正向代理不同的地方在于：客户委托中介完成一件事，结果中介私底下把需求转交给了别人去干，客户不知道究竟是谁帮自己做完了需求，但是得到了自己想要的结果就够了。</p><p>好比游戏里面的公会，村民可以把自己的委托贴在公会告示板上，然后公会的看板娘会把委托的需求分配给适合的冒险者来完成。</p><p>反向代理的应用例子——负载均衡：</p><p>“负载”可以理解成负荷，用户访问一个非静态网站，程序需要读取数据库、渲染 HTML 页面、维持 TCP 连接等操作需要消耗 CPU、内存资源，会给服务器带来一定的负荷。</p><p>假如服务器可以承受的压力为 100N（物理学单位）</p><p>在某个瞬间，每有一名用户访问这个网站，会给服务器带来 5N 的压力，那么这个瞬间最大承载量就是 20 名用户，当服务器压力超过 100N 时就会崩溃。</p><p>要解决这个问题，可以进行硬件提升或者优化项目代码。</p><p>硬件提升可以提升服务器最大承受压力值，比如双核的服务器升级到 4 核，使服务器的最大承受压力从 100N 提升到 200N。</p><p>软件优化可以减少每个访客造成的压力，比如某些数据库 N+1 的问题严重影响了数据库的性能，造成数据库卡顿，优化了这个问题后，访客造成的压力值从 5N 降低到了 4N。</p><p>但是这两种方法提升都有一个临界点，比如硬件优化继续往上提升，服务器的价格就越来越贵，也不可能存在无限核心数的服务器；软件优化到一定程度后已经很难再找到优化的空间。</p><p>达到临界值后就无法再继续优化了，单机的性能已经达到了极致。</p><p>此时，如果能再买一台同样的服务器并且部署同一套项目，是不是可以使最大承载访客数翻倍呢？</p><p>确实可以，只要有两台服务器，那么它们的处理能力就会翻倍！</p><p>只要把一半的请求转发给另一台相同的服务器，平均分担压力。</p><p>但是应该怎么让请求分别进入到不同的服务器呢？</p><p>答案是通过 Nginx，利用上文介绍的反向代理功能。</p><p><img src="http://p3.pstatp.com/large/pgc-image/1534991903053fc12397bd0" alt="负载均衡"></p><p>这个过程称为“均衡”，负责维持均衡的那台服务器只负责分发请求，把请求转发给其他能完成功能的服务器处理，由其他服务器返回结果。</p><p>负责分发请求的服务器称为“均衡调度器”，Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream huotu-server &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">    server 192.168.0.16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;huotu-server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>upstream</code> 字段定义了代理服务器的 IP 地址，当访客进来的时候，Nginx 会按照某种规则将请求分发给其中一个服务器处理。</p><p><code>server</code> 模块里通过 <code>proxy_pass http://huotu-server;</code> 将匹配到规则的请求转发给代理服务器来处理。</p><p>当用户访问：blog.huotuyouxi.com</p><p>Nginx 会把请求转发给某台服务器处理，因此每次访问网站看到的返回 IP 可能都会不同。</p><h2 id="Nginx-模块"><a href="#Nginx-模块" class="headerlink" title="Nginx 模块"></a>Nginx 模块</h2><p>Nginx 发展迅速的原因除了开源之外，还可以使用官方提供的模块或用户自定义开发的模块，由于模块化使得 Nginx 的定制能力很强，可以使用第三方扩展模块让 Nginx 适应各种场景，有能力的大神也可以分享自己写好的模块让其他人直接使用，像这样可以自由 DIY 的软件，有谁会不喜欢呢？</p><p>例如，由淘宝的工程师清无（王晓哲）和春来（章亦春）所开发的 nginx_lua_module 可以将 Lua 语言嵌入到 Nginx 配置中，从而利用 Lua 极大增强了 Nginx 本身的编程能力，甚至可以不用配合其它脚本语言（如 PHP 或 Python 等），只靠 Nginx 本身就可以实现复杂业务的处理。</p><p>Nginx 本身支持多种模块，如 HTTP 模块、EVENT 模块和 MAIL 模块等。</p><p>前文提到，在 HTTP 请求中，Nginx 的工作仅仅只是分析请求然后转发给匹配规则的 <code>location</code> 去处理，<code>location</code> 模块中的内容才是真正干活的人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 匹配规则</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 实际的工作者</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已安装模块可以用命令：<code>nginx -V</code> 查看，输出结果类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) </span><br><span class="line">built with OpenSSL 1.1.0j  20 Nov 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-g -O2 -fdebug-prefix-map&#x3D;&#x2F;data&#x2F;builder&#x2F;debuild&#x2F;nginx-1.15.12&#x2F;debian&#x2F;debuild-base&#x2F;nginx-1.15.12&#x3D;. -fstack-protector-strong -Wformat -Werror&#x3D;format-security -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fPIC&#39; --with-ld-opt&#x3D;&#39;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#39;</span><br></pre></td></tr></table></figure><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>Nginx 有许多可以自定义安装的模块，下面以 echo 为例。</p><p>echo 仓库地址：<a href="https://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">Github - echo-nginx-module</a></p><p>安装 echo 模块 <code>echo-nginx-module</code> 可以使 Nginx 具有输出字符串的能力，这个功能可以用来简单的调试，如输出参数等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;hello &#123; </span><br><span class="line">    return 200 &#39;hello!&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;hello_echo &#123; </span><br><span class="line">    echo &quot;hello, echo!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方模块"><a href="#官方模块" class="headerlink" title="官方模块"></a>官方模块</h3><p>官方模块是 Nginx 官方提供的可扩展模块。</p><p>例如 Nginx 预制的模块 stub_status 可以用来查看 Nginx 的运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line">    stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问后的输出页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 3 3 2 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure><p>更多 Nginx 官方模块以使用方法：<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a></p><p>如上面的 <code>stub_status</code>，可以通过查询手册：<a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html" target="_blank" rel="noopener">ngx_http_stub_status_module</a> 来获取如何使用。</p><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>可以通过搜索 Github 寻找来自全世界开发者分享的模块：<a href="https://github.com/search?q=nginx+module" target="_blank" rel="noopener">Github - Nginx 扩展模块</a></p><p>具体的使用方法可以参照作者写的 README 文档。</p><h2 id="Nginx-应用场景"><a href="#Nginx-应用场景" class="headerlink" title="Nginx 应用场景"></a>Nginx 应用场景</h2><p>最后再来总结一下，Nginx 具体的应用场景。</p><h3 id="HTTP-服务"><a href="#HTTP-服务" class="headerlink" title="HTTP 服务"></a>HTTP 服务</h3><p>Nginx 可以为站点提供 HTTP 服务。</p><p>利用 <code>location</code> 模块匹配 URI 规则，再将其分发到对应的程序进行处理。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Nginx 的反向代理服务，可以实现分发请求的功能。</p><p>具体方法是配置 <code>upstream</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        server 127.0.0.1:8000 weight&#x3D;3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">        server 127.0.0.1:8003;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">        server_name www.domain.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;myproject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡有以下几种模式：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>轮询模式</td><td>Nginx 默认配置，当客户端访问服务的时候，请求按时间顺序逐一分配到不同的后端服务器，如果有某台服务器挂了，Nginx 会自动剔除</td></tr><tr><td>权重模式</td><td>可以为每个服务器配置不同的权重，权重值越高的越容易被分发到请求，当多台服务器性能存在差异时，可以让配置高的服务器分配更高的权重</td></tr><tr><td>IP 哈希</td><td>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。解决 Session 丢失的问题，保证每个用户访问到同一台服务器。</td></tr><tr><td>第三方插件</td><td>可以通过安装第三方插件实现更多的模式</td></tr></tbody></table><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>当自己网站的图片、视频等静态资源被其他人引用时，其他人访问了别人的网站，就会请求到我们服务器上的资源，给我们的服务器带来压力。</p><p>Nginx 可以验证来源网站 referers 来判断请求是否是本站点，如果是其他的站点则不让它们获取到图片资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    root html</span><br><span class="line">    valid_referers none blocked *.huotuyouxi.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDN-服务器"><a href="#CDN-服务器" class="headerlink" title="CDN 服务器"></a>CDN 服务器</h3><p>可以用 Nginx 搭建 CDN 服务器。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>Nginx 的 <code>ngx_http_limit_req_module</code> 模块可以限制访问频率和并发连接数。</p><p>HttpLimit zone：<a href="https://www.nginx.cn/doc/standard/httplimitzone.html" target="_blank" rel="noopener">HttpLimit zone</a></p><p>HttpLimitReqest：<a href="https://www.nginx.cn/doc/standard/httplimitrequest.html" target="_blank" rel="noopener">HttpLimitReqest</a></p><h3 id="黑-白名单"><a href="#黑-白名单" class="headerlink" title="黑/白名单"></a>黑/白名单</h3><p>可以禁止某些 IP 访问，或允许指定 IP 访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    deny 8.8.8.8;</span><br><span class="line">    allow 9.9.9.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>以 Ajax 方式访问非本站点的链接时，浏览器出于安全考虑会禁止访问，也就是跨域问题（HTTP 访问限制，CORS）。</p><p>在 Nginx 中只需要配置允许访问的来源类型即可解决跨域问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 允许访问的来源，* 指的是全部，可以是 IP 地址或者域名</span><br><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line"># 允许请求的类型</span><br><span class="line">add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line"># 允许请求的方法</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br></pre></td></tr></table></figure><h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>Nginx 提供了邮件代理服务，具体参照官方文档：<a href="https://www.nginx.cn/doc/mail/mailcore.html" target="_blank" rel="noopener">Nginx - MailCore</a></p>]]></content>
    
    <summary type="html">
    
      一篇文章学会侃侃而谈 Nginx。
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.idce.com/categories/Nginx/"/>
    
    
      <category term="Linux" scheme="https://www.idce.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.idce.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>PHP中的反射</title>
    <link href="https://www.idce.com/php-reflex/"/>
    <id>https://www.idce.com/php-reflex/</id>
    <published>2020-03-10T09:55:28.000Z</published>
    <updated>2020-03-10T12:04:46.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h2><p>反射原本指的是一种光学现象，光在传播时照射在物体上会产生返回原物体的现象。在 PHP 中，反射的作用类似光的传播，PHP 可以通过反射机制拿到代码本身，也就是通过代码得到代码，反射一词十分形象。</p><p>通过反射机制可以获取类中的变量、方法名称甚至是注释等等，在正常的开发环境中几乎不会用到，一般都是在框架设计时使用，目的是增加框架的扩展性。</p><p>Laravel、Swoft 框架都用到了反射机制，Swoft 注解的实现原理就是使用反射机制来实现的。</p><p>一些 API 文档插件可以通过注释来编译生成 API 文档，其原理同样是使用了 PHP 的反射机制。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义一个类，类里面有常量、私有属性（private 声明的变量）、类的注释和方法的注释等等。</p><p>思考下面几个业务中几乎不会用到的问题：</p><p>如果我们要获取类里面的所有常量，应该怎么做？</p><p>如果我们要获取方法的注释，或者类的注释，应该怎么做？</p><p>如果我们要获得类的命名空间，又该怎么做？</p><p>此时习惯了做业务的我们肯定一脸懵逼，PHP 中的反射就是为了解决这一类的问题，通过反射提供的 API 可以拿到一个类的所有信息。</p><p>通过下面的代码举例，你马上就会弄懂什么是反射了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 类的注释</span><br><span class="line"> *&#x2F;</span><br><span class="line">class User</span><br><span class="line">&#123;</span><br><span class="line">    const BOY &#x3D; 1;</span><br><span class="line">    const GIRL &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    private $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name) &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;hello!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class &#x3D; new ReflectionClass(&#39;User&#39;);  &#x2F;&#x2F; 将类名User作为参数，即可建立User类的反射类</span><br><span class="line">$properties &#x3D; $class-&gt;getProperties();  &#x2F;&#x2F; 获取User类的所有属性，返回ReflectionProperty的数组</span><br><span class="line">$property &#x3D; $class-&gt;getProperty(&#39;name&#39;); &#x2F;&#x2F; 获取User类的属性ReflectionProperty</span><br><span class="line">$methods &#x3D; $class-&gt;getMethods();   &#x2F;&#x2F; 获取User类的所有方法，返回ReflectionMethod数组</span><br><span class="line">$method &#x3D; $class-&gt;getMethod(&#39;sayHello&#39;);  &#x2F;&#x2F; 获取User类的方法的ReflectionMethod</span><br><span class="line">$constants &#x3D; $class-&gt;getConstants();   &#x2F;&#x2F; 获取所有常量，返回常量定义数组</span><br><span class="line">$constant &#x3D; $class-&gt;getConstant(&#39;BOY&#39;);   &#x2F;&#x2F; 获取常量</span><br><span class="line">$namespace &#x3D; $class-&gt;getNamespaceName();  &#x2F;&#x2F; 获取类的命名空间</span><br><span class="line">$comment_class &#x3D; $class-&gt;getDocComment();  &#x2F;&#x2F; 获取User类的注释文档，即定义在类之前的注释</span><br><span class="line">$comment_method &#x3D; $class-&gt;getMethod(&#39;sayHello&#39;)-&gt;getDocComment();  &#x2F;&#x2F; 获取User类中方法的注释文档</span><br><span class="line"></span><br><span class="line">var_dump($comment_method);</span><br></pre></td></tr></table></figure><p>上面的代码会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(39) &quot;&#x2F;**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     *&#x2F;&quot;</span><br></pre></td></tr></table></figure><h2 id="反射-API"><a href="#反射-API" class="headerlink" title="反射 API"></a>反射 API</h2><p>PHP 官方手册：<a href="https://www.php.net/reflection" target="_blank" rel="noopener">https://www.php.net/reflection</a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>反射机制会打破类的封装性，日常业务也不需要获取代码的注释。</p><p>因此在日常开发中几乎不会直接用到，但是在框架或者插件的设计上却能发挥很大的作用。</p><h3 id="生成-API-文档"><a href="#生成-API-文档" class="headerlink" title="生成 API 文档"></a>生成 API 文档</h3><p>由于反射可以拿到类的属性、方法，就可以自动生成类的文档。</p><p>典型例子：<a href="https://apidocjs.com/" target="_blank" rel="noopener">API DOC</a></p><p>通过在方法名称上添加注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;get&#125; &#x2F;user&#x2F;:id Request User information</span><br><span class="line"> * @apiName GetUser</span><br><span class="line"> * @apiGroup User</span><br><span class="line"> *</span><br><span class="line"> * @apiParam &#123;Number&#125; id Users unique ID.</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccess &#123;String&#125; firstname Firstname of the User.</span><br><span class="line"> * @apiSuccess &#123;String&#125; lastname  Lastname of the User.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>然后运行编译程序就可以直接生成一个美观、排版整齐的 API 文档。</p><p><img src="https://apidocjs.com/img/example.png" alt="APIDOC"></p><p>一些 IDE 提示工具也利用反射获取类的注释，然后实现提示的功能，注释时需要根据一定的规范。</p><p>注释示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试方法</span><br><span class="line"> * @param $a</span><br><span class="line"> * @param $b</span><br><span class="line"> *&#x2F;</span><br><span class="line">function test($a,$b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量复刻文件"><a href="#批量复刻文件" class="headerlink" title="批量复刻文件"></a>批量复刻文件</h3><p>既然可以拿到类的所有成员，那么以类为母版，克隆出子类文件轻而易举，在一些框架或插件中经常用到。</p><p>Laravel 框架可以使用 <code>php artisan make:controller UserController</code> 命令创建一个控制器类的模板，还可以加上参数 <code>-r</code> 生成一个 RESTful 风格的 API 控制器类。</p><p>还有数据库迁移工具（Laravel 内置了此插件），可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php vendor&#x2F;bin&#x2F;phinx create MyMigration</span><br></pre></td></tr></table></figure><p>直接生成一个数据库迁移文件。</p><p>直接用命令的方式生成文件，可以少写很多重复的代码。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>先不需要知道依赖注入是什么，看下面的例子，Laravel 很普通的控制器类的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct(UserService $service)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service &#x3D; $service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users &#x3D; $this-&gt;service-&gt;getAllUsers();</span><br><span class="line">        </span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过构造函数赋予了属性 <code>$service</code>，但问题是——控制器类并没有被实例化！</p><p>一般情况下，我们需要这样把参数传给构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$service &#x3D; new UserService();</span><br><span class="line">$user &#x3D; new UserController($service);</span><br></pre></td></tr></table></figure><p>上面的例子并没有 <code>UserController</code> 的实例化操作，而且在 PHP 中参数前面加上类名称，只是起到变量类型限制的作用。</p><p>到底是哪里传来实例化的 <code>UserService</code> 呢？</p><p>其实是通过反射机制实现的，通过反射获取到了控制器类的构造方法，然后将这个控制器所需要<strong>依赖</strong>的类实例化后生成的对象<strong>注入</strong>到控制器里，所以这个叫做依赖注入。</p><p>依赖注入这个概念是从 Java 中传过来的，并非 Laravel 特有。</p><p>假设不使用反射机制注入依赖，那么我们的控制器是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service &#x3D; new UserService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users &#x3D; $this-&gt;service-&gt;getAllUsers();</span><br><span class="line"></span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯……？代码量好像差不多！</p><p>依赖注入是一种设计模式，运行的结果没有差别。</p><p>其实在学 Laravel 的时候，我发现了一个很奇怪的地方。</p><p>比如存在路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;&#x2F;users&#39;, &#39;UserController@index&#39;)-&gt;name(&#39;users.index&#39;);</span><br><span class="line">Route::get(&#39;&#x2F;users&#x2F;&#123;id&#125;&#39;, &#39;UserController@show&#39;)-&gt;name(&#39;users.show&#39;);</span><br></pre></td></tr></table></figure><p>然后控制器的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function show(Request $request, $id)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request, $id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index 方法的第一个<code>Illuminate\Http\Request</code> 类型的参数，我们在路由中没有任何参数，既然不是通过匹配路由得到的参数，这个参数又是怎么来的呢？</p><p>更不可思议的是第二个路由的 show 方法，我们在声明路由的时候只指明了一个参数 <code>/users/{id}</code>，但我们现在却在方法中写了两个参数，又是怎么精确地匹配到 ID 值的？</p><p>其实同样是用了依赖注入的方法实现的，在学习了反射之后，它们的原理就大概知道了。</p><p>首先通过反射得到一个方法的参数，如果这个参数定义了某些类型，就将其实例化后再传递给该方法，在 Laravel 中有专门的解析类在处理这些参数。</p><h3 id="通过注释生成路由"><a href="#通过注释生成路由" class="headerlink" title="通过注释生成路由"></a>通过注释生成路由</h3><p>Swoft 框架把注释当做定义路由的方法，称为“注解”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use Swoft\Http\Message\Request;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\Controller;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\RequestMapping;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Class Home</span><br><span class="line"> *</span><br><span class="line"> * @Controller(prefix&#x3D;&quot;home&quot;)</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Home</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 该方法路由地址为 &#x2F;home&#x2F;index</span><br><span class="line">     *</span><br><span class="line">     * @RequestMapping(route&#x3D;&quot;&#x2F;index&quot;, method&#x3D;&quot;post&quot;)</span><br><span class="line">     *</span><br><span class="line">     * @param Request $request</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 PHP 的反射机制可以做一些奇奇怪怪的事，这也算是 Swoft 独特的风格吧。</p>]]></content>
    
    <summary type="html">
    
      反射原本指的是一种光学现象，光在传播时照射在物体上会产生返回原物体的现象。在 PHP 中，反射的作用类似光的传播，PHP 可以通过反射机制拿到代码本身，也就是通过代码得到代码。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
      <category term="技术" scheme="https://www.idce.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>PHP中的魔术方法</title>
    <link href="https://www.idce.com/php-magic-methods/"/>
    <id>https://www.idce.com/php-magic-methods/</id>
    <published>2020-03-10T05:42:44.000Z</published>
    <updated>2020-03-10T08:38:31.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="魔术方法是什么？"><a href="#魔术方法是什么？" class="headerlink" title="魔术方法是什么？"></a>魔术方法是什么？</h2><p>魔术方法是 PHP 类中特殊的方法，以双下划线 <code>__</code> 开头，具有特殊用途，比如我们常用的 <code>__construct</code> 构造函数就属于魔术方法，构造函数的作用是类实例化自动调用的方法。</p><p>魔术方法的名称都是系统预定义的，无法修改，我们在写 PHP 代码的时候，为了避免与系统预定义函数相同，不建议用双下划线 <code>__</code> 作为函数的前缀。</p><p>魔术方法的作用可以归纳为：<strong>对象在 xxx 的时候，应该实现的功能。</strong></p><p>比如，上述构造函数可以理解为：对象在“实例化”的时候，应该实现的功能。</p><p>除此之外，与构造函数相对的 <strong>析构函数</strong> <code>__destruct</code> 可以在对象被回收时自动调用。</p><p>如果有 Java 基础，你可以发现类默认有一种 <code>toString</code> 方法，可以把对象转化成字符串。其实 PHP 中也存在同样的魔术方法 <code>__toString</code>，当类的对象被当做字符串调用时会自动执行此方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;Just a dog.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>执行的结果会输出：Just a dog.</p><p>为什么在上述代码中，echo 可以输出一个对象呢？</p><p>这是因为我们设置了 <code>__toString</code> 方法，当对象被当做字符串调用时会自动触发 <code>__toString</code> 方法。</p><p>换而言之，<strong>魔术方法是一类由系统预定义了函数名称，在某些情况下被动触发的函数</strong>。</p><p>所有的魔术方法都不是用来主动调用的，如下错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误示范</span><br><span class="line">$obj &#x3D; new MyClass();</span><br><span class="line">$obj-&gt;__construct();</span><br></pre></td></tr></table></figure><p>魔术方法也是类的方法，上述代码逻辑上没有问题而且可以运行且不会报错。不会报错不代表这么写没问题，魔术方法中<strong>不应该</strong>放入业务逻辑相关的代码。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>魔术方法大都用于框架且与设计模式关联紧密，日常业务除了构造方法之外几乎很少接触到其他魔术方法。<br>Laravel 框架将魔术方法用到了极致，被称为“优雅”的框架。</p><h2 id="PHP-中的魔术方法"><a href="#PHP-中的魔术方法" class="headerlink" title="PHP 中的魔术方法"></a>PHP 中的魔术方法</h2><p>下面介绍 PHP 常见的魔术方法以及应用场景和示例代码。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>俗称类的构造方法，当类被实例化为对象时自动调用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;Just a dog.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br></pre></td></tr></table></figure><p>输出：Just a dog.</p><blockquote><p>void __construct ([ mixed $args [, $… ]] )</p></blockquote><p>构造函数的几大特征：</p><ul><li>构造函数可以接受参数，能够在创建对象时赋值给对象属性</li><li>构造函数可以调用类方法或其他函数</li><li>构造函数可以调用其他类的构造函数</li><li>构造函数的权限可以被修改</li></ul><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;This is animal.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 父类构造函数不会自动调用，需要手动进行调用</span><br><span class="line">        parent::__construct();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对象赋值</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用类中的方法</span><br><span class="line">        $this-&gt;jump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function jump()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name . &#39; jump.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog(&#39;小白&#39;);</span><br></pre></td></tr></table></figure><p>最后一条：<strong>构造函数的权限可以被修改。</strong></p><p>在设计模式中会用到，例如单例模式，为了防止子类被实例化，会将构造函数限制为 <code>private</code> 私有化。</p><p>一个比较标准的单例模式示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 私有属性，用于保存实例</span><br><span class="line">    private static $instance;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构造方法私有化，防止外部创建实例</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 公有方法，用于获取实例</span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        &#x2F;&#x2F; 没有的话创建实例并返回，有的话直接返回</span><br><span class="line">        if(!(self::$instance instanceof self))&#123;</span><br><span class="line">            self::$instance &#x3D; new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 克隆方法私有化，防止复制实例</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h3><p>俗称析构函数，当对象被回收时自动调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;The dog is dead.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">unset($dog);</span><br></pre></td></tr></table></figure><p>输出：The dog is dead.</p><blockquote><p>void __destruct ( void )</p></blockquote><p>析构函数的特征：</p><ul><li>析构函数不能接受参数</li><li>析构函数不能抛出异常</li></ul><p>由于析构函数在对象被回收时触发，因此如果抛出异常将无法被捕获，抛出异常情况下将报出致命错误。</p><p>和构造函数一样，父类的析构函数不会被隐式调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用： <code>parent::__destruct();</code></p><h3 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h3><p>当调用对象中不存在的属性时，自动触发该方法。</p><p>Laravel 框架里几乎随处可见，如 Model 对象调用表的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::find(1);</span><br><span class="line">echo $user-&gt;name;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：NULL</p><p>通常情况下，如果直接调用对象中不存在的属性会产生报错，但是设置了 <code>__get</code> 方法后，如果调用了不存在的属性则会转而调用这个方法处理。通常 <code>__get</code> 要结合 <code>__set</code> 一起使用。</p><h3 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h3><p>当设置对象中不存在的属性时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __set($name, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;attrs[$name] &#x3D; $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;name &#x3D; &#39;小白&#39;;</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：string(6) “小白”</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h3><p>当对象被当成字符串调用时，自动触发该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;Dog name is &#39; . $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog(&#39;小黑&#39;);</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>输出：Dog name is 小黑</p><p>这个魔术方法在调试的时候非常有用，可以把对象中的参数信息打印出来，记录到日志里。</p><h3 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h3><p>当对象调用了一个类中不存在的方法或者没有权限调用的方法时，自动触发。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function aPrivateMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;Im private.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;fly(&#39;666&#39;);</span><br><span class="line">$dog-&gt;aPrivateMethod();</span><br></pre></td></tr></table></figure><p>第一个 fly 方法，不存在 Dog 类中；第二个 aPrivateMethod 是私有方法，不能直接被对象调用，因而触发了 <code>__call</code> 方法。</p><p>在 Laravel 中也可以看到许多 <code>__call</code> 应用的场景，还是 Model 类的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::whereName(&#39;xiaobai&#39;)-&gt;first();</span><br><span class="line">dd($user);</span><br></pre></td></tr></table></figure><p>这里的 where 后面接大驼峰方式的参数，相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::where(&#39;name&#39;, &#39;xiaobai&#39;)-&gt;first();</span><br></pre></td></tr></table></figure><p>通过 <code>__call</code> 方法实现简写的目的。</p><p><code>__call</code> 方法接收两个参数，第一个参数是调用方法的名称，第二个参数是调用方法时传入的参数，数组格式。</p><h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic"></a>__callStatic</h3><p>当对象调用了一个不存在的静态方法时，自动触发。</p><p><code>__callStatic</code> 与 <code>__call</code> 的作用基本相似，只不过 <code>__callStatic</code> 针对的是静态方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public static function __callStatic($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog::whatsYourProblem();</span><br></pre></td></tr></table></figure><p>这样的设计在 Laravel 框架中也能看到，依然是 Model 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users &#x3D; User::all();</span><br><span class="line">$items &#x3D; Item::where(&#39;price&#39;, &#39;&gt;&#39;, 100)-&gt;paginate(20);</span><br></pre></td></tr></table></figure><p>Laravel 中的 Model 并不是把方法真的当做静态方法，而是利用 <code>__callStatic</code> 让你产生“静态调用”的错觉。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h3><p>当尝试以调用方法的形式来调用一个对象时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __invoke($parm1, $parm2)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($parm1,$parm2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog(&#39;小白&#39;,&#39;小黑&#39;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">string(6) &quot;小黑&quot;</span><br></pre></td></tr></table></figure><p><code>__invoke</code> 可以接收自定义的任意参数，与函数的形参规则一致。</p><p>我们知道这种方法有点奇怪，谁也不会把一个对象当成方法来用吧？</p><p>让我们来康康 Laravel 框架是怎么利用 <code>__invoke</code> 让代码变得更“优雅”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、指定路由及对应的方法</span><br><span class="line">Route::get(&#39;&#x2F;user&#39;, &#39;UserController@index&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、不指定对应的方法，自动调用 __invoke</span><br><span class="line">Route::get(&#39;&#x2F;user&#x2F;default&#39;, &#39;UserController&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1、&#x2F;user 调用 index 方法</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2、&#x2F;user&#x2F;default 没有指定方法，自动调用 __invoke</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不指定具体的方法时，Laravel 的路由会把对象当做方法来执行，从而调用 <code>__invoke</code> 方法，简化了路由部分的代码。</p><h3 id="clone"><a href="#clone" class="headerlink" title="__clone"></a>__clone</h3><p>当对象被克隆时，自动调用。</p><p>PHP 中存在一个关键词 clone 可以复制对象，并且复制出来的对象为独立的个体，与原对象不存在互相影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;new dog birth.&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;name &#x3D; &#39;小白&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 克隆出来的对象属性与原对象一模一样</span><br><span class="line">$cloneDog &#x3D; clone $dog;</span><br><span class="line">var_dump($cloneDog-&gt;name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改克隆对象的属性，不会影响原对象</span><br><span class="line">$cloneDog-&gt;name &#x3D; &#39;小黑&#39;;</span><br><span class="line">var_dump($dog, $cloneDog);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new dog birth.</span><br><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">object(Dog)#1 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]&#x3D;&gt;</span><br><span class="line">  string(6) &quot;小白&quot;</span><br><span class="line">&#125;</span><br><span class="line">object(Dog)#2 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]&#x3D;&gt;</span><br><span class="line">  string(6) &quot;小黑&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，克隆出来的对象修改了属性，但是原来对象的属性保持不变，它们是互相独立的个体，也就是说并非引用关系，clone 会开辟一块新的内存来存储复制出来的新对象。</p><p><code>__clone</code> 方法在 clone 出新对象时自动调用。</p><p>clone 业务中用得比较少，应用场景能想到的一个是重构代码，我们需要增加一个新的接口来应对新的需求，但同时又不希望破坏旧接口的内部结构，也不希望直接在旧接口的代码上修改，此时可以使用 clone，既可以向下兼容作用，又能在旧接口上添加新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class NewDogAction</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 新接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OldDogAction</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 旧版接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 动作类对象</span><br><span class="line">    private $action;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action &#x3D; new OldDogAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action &#x3D; new NewDogAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 clone 出来的时候，action 被替换成新的接口代码。</p><p>换成比较形象的例子：</p><p>鸣人使用多重影分身之术，可以看成是 clone 出很多个分身，但是这些分身并不能 100% 继承本体的能力，本体的能力可以看成上面的 <code>oldDogAction</code>，而分身的能力则是 <code>newDogAction</code>，分身除了 action 属性之外其他的地方与本体并无差异。</p><h2 id="更多的魔术方法"><a href="#更多的魔术方法" class="headerlink" title="更多的魔术方法"></a>更多的魔术方法</h2><p>如果有兴趣了解全部的魔术方法，请访问 <a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">PHP：魔术方法</a></p>]]></content>
    
    <summary type="html">
    
      魔术方法是 PHP 类中特殊的方法，以双下划线 `__` 开头，具有特殊用途，比如我们常用的 `__construct` 构造函数就属于魔术方法。
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.idce.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.idce.com/tags/PHP/"/>
    
      <category term="技术" scheme="https://www.idce.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>进程管理工具 Supervisord</title>
    <link href="https://www.idce.com/supervisord/"/>
    <id>https://www.idce.com/supervisord/</id>
    <published>2020-03-09T16:56:30.000Z</published>
    <updated>2020-03-09T18:00:31.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Supervisord-是什么？"><a href="#Supervisord-是什么？" class="headerlink" title="Supervisord 是什么？"></a>Supervisord 是什么？</h2><p>Supervisord 是一个进程管理工具，它可以用来执行一些需要在后台持续存在的进程（守护进程）的启动命令。</p><p>比如前端的 Nuxt 框架使用 SSR（服务端渲染），需要启动服务端的进程，会使用 pm2 来管理进程的启动。</p><p>Supervisord 同样是一种进程管理工具。</p><p>下文将演示 Supervisord 管理 Laravel 的队列任务进程。 </p><h2 id="安装-Supervisord"><a href="#安装-Supervisord" class="headerlink" title="安装 Supervisord"></a>安装 Supervisord</h2><p>以 Centos 为例，直接使用 yum 安装即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、安装 epel-release</span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"># 2、安装 supervisor</span><br><span class="line">yum install -y supervisor</span><br><span class="line"></span><br><span class="line"># 3、将 supervisor 设置为开机启动</span><br><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure><p>以上就安装完成了，但是还没有启动 supervisor，先不用着急启动。</p><h2 id="Supervisor-配置文件"><a href="#Supervisor-配置文件" class="headerlink" title="Supervisor 配置文件"></a>Supervisor 配置文件</h2><p>supervisor 的配置文件默认路径为：<code>/etc/supervisor/supervisord.conf</code>，使用 <code>vim</code> 命令编辑，大致可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod&#x3D;0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">&quot;&#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf&quot; 28L, 1178C                 8,1           Top</span><br><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod&#x3D;0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</span><br><span class="line">                                                                                                                                                                                          19,36         All</span><br></pre></td></tr></table></figure><p>如果不一样说明版本不同，通过下面的命令可以查看自己安装的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 版本</span><br><span class="line">supervisord -v</span><br><span class="line"></span><br><span class="line"># 我下载的版本是 3.3.5</span><br></pre></td></tr></table></figure><p>需要注意的地方只有最底下的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</span><br></pre></td></tr></table></figure><p>在一些旧的版本这里会有差别，这里的意思是说包含了路径 <code>/etc/supervisor/conf.d</code> 文件夹里面所有后缀为 <code>.conf</code> 的文件，现在不需要改动这个文件。</p><p><code>/etc/supervisor/conf.d/</code> 文件夹下默认是空的，我们要自己创建新的配置文件。</p><p>使用命令：<code>vim /etc/supervisor/conf.d/my.conf</code>，编辑并保存如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:myprogram]</span><br><span class="line">process_name&#x3D;%(program_name)s_%(process_num)02d</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php &#x2F;www&#x2F;myproject&#x2F;artisan queue:work --quiet --tries&#x3D;3 --sleep&#x3D;3</span><br><span class="line">directory&#x3D;&#x2F;www&#x2F;myproject</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">user&#x3D;www-data</span><br><span class="line">numprocs&#x3D;1</span><br><span class="line">redirect_stderr&#x3D;true</span><br></pre></td></tr></table></figure><p>这里我们启动了一个守护进程，用来执行 Laravel 的队列任务：<code>php artisan queue:work</code>。</p><p>配置项说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># program:&lt;进程名字&gt;</span><br><span class="line">[program:myprogram]</span><br><span class="line"></span><br><span class="line"># 进程的名字规则，按照下面的配置就可以了</span><br><span class="line">process_name&#x3D;%(program_name)s_%(process_num)02d</span><br><span class="line"></span><br><span class="line"># 执行的命令 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php 是 PHP 二进制文件位置，相当于在 Laravel 下执行 php artisan 一样</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php &#x2F;www&#x2F;myproject&#x2F;artisan queue:work --quiet --tries&#x3D;3 --sleep&#x3D;3</span><br><span class="line"></span><br><span class="line"># 项目所在目录，注意这里一定要填，网上搜的教程很多都忽略了这个字段</span><br><span class="line">directory&#x3D;&#x2F;www&#x2F;myproject</span><br><span class="line"></span><br><span class="line"># 是否在 supervisor 启动的时候自动启动进程</span><br><span class="line">autostart&#x3D;true</span><br><span class="line"></span><br><span class="line"># 当进程在 running 状态下 exit 时，是否自动重启</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line"></span><br><span class="line"># 这里一定要填对，如果你是用 Laravel 执行队列任务，那跟我填的一样就可以，如果你执行其他任务，请填写所属的用户组，不然会有权限问题</span><br><span class="line">user&#x3D;www-data</span><br><span class="line"></span><br><span class="line"># 启动多少个子进程，一般启动 1 个就够了</span><br><span class="line">numprocs&#x3D;1</span><br><span class="line"></span><br><span class="line"># 设置为 true 时，将进程报错的输出内容写到 supervisor 的输出文件 stdout 里，建议为 true，这样报错了可以查错误信息</span><br><span class="line">redirect_stderr&#x3D;true</span><br></pre></td></tr></table></figure><blockquote><p>注意把上面的 myproject 替换成自己项目的路径</p></blockquote><p>保存好配置文件后，就可以启动 supervisor 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种方法皆可启动 supervisor</span><br><span class="line"></span><br><span class="line"># 1、指定配置文件的方式启动 supervisor（推荐）</span><br><span class="line">supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line"># 2、服务的方式启动</span><br><span class="line">systemctl start supervisord</span><br></pre></td></tr></table></figure><p>执行成功的情况下，你会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unlinking stale socket &#x2F;var&#x2F;run&#x2F;supervisor.sock</span><br></pre></td></tr></table></figure><p>如果不是这个信息，说明你的配置文件有问题，检查一下 <code>command</code> 和 <code>directory</code> 路径是否填写正确，99% 启动不成功都是这两个字段填写不正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 进程</span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line"># 可以看到下面的输出结果</span><br><span class="line">myproject:myprogram                 RUNNING   pid 17, uptime 0:01:40</span><br></pre></td></tr></table></figure><p>显示为 <code>RUNNING</code> 则说明正常运行，如果不是这个状态就是配置文件出错了。</p><p>如果修改了配置文件，或者创建了新的配置文件，需要重载才能读取到新的配置，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重新读取配置文件</span><br><span class="line">supervisorctl reread</span><br><span class="line"></span><br><span class="line"># 更新运行状态</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h2 id="Laravel-队列任务无法写入-Log-日志问题"><a href="#Laravel-队列任务无法写入-Log-日志问题" class="headerlink" title="Laravel 队列任务无法写入 Log 日志问题"></a>Laravel 队列任务无法写入 Log 日志问题</h2><p>用 supervisor 执行队列任务时发现 Laravel 的日志系统 Log 竟然无法写入日志文件，查了下也没有任何报错信息，问题的原因是所在用户组没有权限。</p><p>也就是配置文件中的，user 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user&#x3D;www-data</span><br></pre></td></tr></table></figure><p>这里一定要填写运行程序的用户组，比如 PHP 的用户组是 <code>www-data</code>，如果你填的是 <code>root</code>，这样就没有权限操作日志文件了。</p>]]></content>
    
    <summary type="html">
    
      Supervisord 是一个进程管理工具，可以管理队列任务进程或者其他需要处理的进程任务。
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.idce.com/categories/Linux/"/>
    
    
      <category term="Supervisord" scheme="https://www.idce.com/tags/Supervisord/"/>
    
      <category term="技术" scheme="https://www.idce.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>

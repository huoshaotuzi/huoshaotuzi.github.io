{"meta":{"title":"火兔の小窝","subtitle":"开发日记","description":"开发日记。","author":"火烧兔子","url":"https://blog.huotuyouxi.com","root":"/"},"pages":[{"title":"分类","date":"2020-03-01T12:59:10.000Z","updated":"2020-03-01T13:57:44.248Z","comments":true,"path":"categories/index.html","permalink":"https://blog.huotuyouxi.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-01T12:59:59.000Z","updated":"2020-03-01T13:57:39.492Z","comments":true,"path":"tags/index.html","permalink":"https://blog.huotuyouxi.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-01T08:31:50.000Z","updated":"2020-03-01T08:38:11.807Z","comments":true,"path":"about/index.html","permalink":"https://blog.huotuyouxi.com/about/index.html","excerpt":"","text":"作者信息昵称：火烧兔子 QQ：874811226 游戏开发者、热爱写作、分享、沉迷研究技术的程序员。 游戏作品火兔游戏官方网站：https://huotuyouxi.com 魔王传说 宠物战纪 黑暗刻印 冒险物语 月之幻想 路人甲的故事 名为怪物的游戏"}],"posts":[{"title":"程序猿提升自我修养的网站推荐","slug":"programmer-recommend-website","date":"2020-03-09T14:27:59.000Z","updated":"2020-03-09T15:46:43.920Z","comments":true,"path":"programmer-recommend-website/","link":"","permalink":"https://blog.huotuyouxi.com/programmer-recommend-website/","excerpt":"","text":"前言作为程序猿，阅读其他人分享的技术文章除了学习新的技术之外，对于提升自己的思维能力也有很大的帮助。比起自己摸爬滚打尝试出来所耗费的时间，也许别人一句简单的提醒就能使你豁然开朗。 当然，对于一些刚刚入坑的新人来说，也许依赖别人不是一个好的建议，自己摸索可以提升自学能力，作为新入道途的小司机来说，在听取别人的建议后，别忘了加入自己的思考。 对老司机老说，关键的学习能力和处理问题的能力已经在日常业务中得到锻炼，与其不断摸索不如听取建议以最快的速度解决问题。然后再细细回味其中的道理。 下面推荐一些自己平时经常去的论坛或社区，自己在早晨上班的时候都会花 30 分钟左右去阅（mo）读（yu）别人分享的文章，虽然不一定能学到什么，但这种无差别的阅读会成为你知识的积淀，说不定在哪一刻你突然听到同事谈到某个专业术语，你会惊奇的发现——这不是我早上读的那篇文章提到的东西吗！？ 前端人员前端人员不能满足于当个切图仔只会网页布局和 CSS 样式，JS 用的 JQuery 别的就不懂了。其实现在前后端的区分度已经不大了，从 nodeJS 出现以后，前端的格局就改变了，不要把自己的思维局限在“前端只是做网页样式”而已，如果你还保留这种思想，建议早点舍弃。前端学点后端的思维跟后端学点 HTML、CSS 都是很普通的事情。 除了 WEB 前端，安卓前端、IOS 前端同理。 下面的推荐顺序没有排名，纯粹是想到什么就写下来。 掘金社区前端技术有一个比较火的社区，而且里面也有许多大佬，这个社区叫做“掘金”： 传送门：大佬之家 - 掘金社区 掘金社区会有大佬发布技术相关的文章，也会有人告诉你面试的技巧 （还能相亲） 。 但是里面有一个地方我建议不要点开，那就是“沸点”，要是沉迷在沸点就跟刷微博差不多了。 前不久还上线了“掘金小册”，可以将自己的知识进行变现。 掘金是一个前端大佬云集的地方。 V2EX这也是一个神奇的社区，不过内容比较综合，各种东西都会有，偶尔还有大佬出现，也有人喜欢在这里刷帖摸鱼，鱼龙混杂的地方。 V2EX 可以让你发现许多黑科技，提升自己的姿势水平，偶尔会有人把自己异想天开的想法发到这里进行讨论，还有一些企业的黑幕（如暴力裁员等黑料）。 总之，在这里更多的是提升自己的阅历。 传送门：八卦与涨姿势的地方 - V2EX 这个社区的名字究竟是何义至今不明。 思否 &amp; stackOverFlow思否是国内比较大的交流讨论社区，应该是致敬国外的 stackOverFlow，从 UI 看起来两者非常相似。 可以把思否当做国内版的 stackOverFlow。 先来介绍国外的 stackOverFlow。 传送门：解决问题的宝库 - stackOverFlow 根据个人阅读的帖子来看，这里主要是解决问题的帖子居多，很多时候你搜索某个报错信息，跳出来的就是这个网站的帖子，而且你经常可以从帖子里找到解决问题的方法。 所以，这个网站给我的感觉是一个可以帮助你快速查错和解决问题的平台。如果遇到开发上的难题或者不明的报错信息，可以到这个平台上搜索看看（对英文稍有要求），大多数情况下都可以找到解决问题的方法。 接着是我们国内的思否，个人非常喜欢这个社区，因为这边文章详情页的排版、字体、背景颜色十分协调，可以拥有十分良好的阅读体验。 传送门：享受阅读的乐趣 - Segmentfault 这个社区同样也有许多解决问题的帖子，同时还有许多分享技术的帖子，也有人把这个平台当做了自己个人博客记录的地方。 思否上面提供了“视频课程”，价格上来看还算蛮便宜的，比起报培训班流水线式的作业，倒不如拿那些钱支持一些真正有技术的作者。 后端人员其实前面介绍的几个也有后端的文章，后端开发也可以去逛逛。 因为我的本职是 PHP 开发，所以这里推荐的是偏向 PHP 的社区。 Laravel - China现在更名为 LearnKu 了，PHP 较为出名的一个社区，也是 Laravel 框架最大的交流论坛之一。 传送门：刻意学习，与日精进 - LearnKu LearnKu 社区是 Summer 个人开发的 Laravel 技术论坛，如今已经扩展了更多的板块，不再局限于 Laravel 或是 PHP 语言，诸如 Python、Java 等语言也拥有独立的板块了。 LearnKu 里面比较有意思的一个地方是可以翻译国外的文档，然后留下你的大名，虽然本人的英文水平不咋样，但是也曾翻译过几篇文章的段落，成就感十足！ 除此之外，个人感觉要学习 Laravel 框架的话，首选 LearnKu，因为这里有最全、最新的 Laravel 文档（并且阅读体验良好）。 LearnKu 的前身 Laravel - China 曾经是国内最早一批提供 Composer 国内镜像源的地方，个人感觉 Summer 在推动 Laravel 框架在国内的推广做出了十分巨大的贡献，如果没有翻译国外的文档和提供 Composer 国内镜像源，想要入门这个“优雅”的框架可不容易。 LearnKu 是集文档、技术分享、问题提问的综合社区，想要入门 Laravel 的萌新，选择 LearnKu 准没错！ LearnKu 这个名字听起来怪怪的，难道是 learn Kungfu 的缩写！？ Laravel 学院现在改名为学院君（感觉之前的名字更好）。 Laravel 学院也是学习 Laravel 的好去处，只不过这里比较偏向于查阅资料的地方，虽然提供了“问题”的板块，但是讨论的氛围还是偏向于冷清。 传送门：优质的 Laravel 中文学习资料 - 学院君 Laravel 学院也为 Laravel 在国内的推广做出了重要贡献，在搜索 Laravel 相关问题的时候，经常能搜到 Laravel 学院的网站，而且从中找到解决问题的方法。 所以，个人感觉 Laravel 学院偏向于查资料与搜索问题。 本站点的起源本人尚不清楚，但是从文档的分享者来看居然全部都是同一个人——学院君。 只凭借网站本身的力量竟然能够整理出如此众多的文档，令人钦佩。 Laravel 学院除了文档之外，还有项目的实践教程，而且每一步都十分详细甚至还有配图，萌新想学不会都难！","categories":[{"name":"资料","slug":"资料","permalink":"https://blog.huotuyouxi.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"WebSite","slug":"WebSite","permalink":"https://blog.huotuyouxi.com/tags/WebSite/"}]},{"title":"composer配置参数详解","slug":"composer-config","date":"2020-03-08T06:48:10.000Z","updated":"2020-03-08T06:54:07.730Z","comments":true,"path":"composer-config/","link":"","permalink":"https://blog.huotuyouxi.com/composer-config/","excerpt":"","text":"composer.jsonComposer 使用配置文件 composer.json 来指明依赖关系或者包信息。 一个简单的 composer.json 配置文件如下所示： 12345678910111213141516171819&#123; &quot;require&quot;: &#123; &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;, &#125;, &quot;require-dev&quot;: &#123; &quot;robmorgan&#x2F;phinx&quot;: &quot;^0.10.8&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\Library\\\\&quot;: &quot;application&#x2F;library&quot;, &#125; &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&quot; &#125; &#125;&#125; 开发配置项如果你不打算将自己的包开源，或者这个配置文件并不是一个库，而是你的项目依赖第三方包的配置文件，那么许多字段都是不需要用到的，以下是几个比较核心的配置字段。 require : 项目依赖关系执行 composer install 或者 composer update 将会下载依赖的包。 示例： 12345&#123; &quot;require&quot;: &#123; &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;, &#125;&#125; 这里我们声明了我们需要下载安装的包 phpmailer/phpmailer 和对应的版本信息 ^6.0。 require 也可以用来指明 PHP 的版本信息。 示例： 123&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;&#x3D;5.5.0&quot;,&#125; 它要求使用者的 PHP 版本至少是 5.5.0 以上的。 require-dev : 只在开发环境的依赖有时候，我们可能需要一些帮助我们调试的第三方包，但是线上环境并不需要用到这些包，这个时候可以将它们放在 require-dev 中进行声明： 12345&#123; &quot;require-dev&quot;: &#123; &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;, &#125;&#125; 线上环境在执行 composer install 或者 composer update 的时候，需要添加 --no-dev 参数来跳过 require-dev 依赖的包。 如果直接使用 composer install，则 require-dev 依赖的包也会被安装。 autoload : 自动加载通过配置 autoload 可以实现类的自动加载。 示例： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\Library\\\\&quot;: &quot;application&#x2F;library&quot;, &#125; &#125;&#125; 上面的例子中，我们使用了 psr-4 的自动加载规范来加载 library 中的类。 除了 psr-4 还有几种可选的类型： psr-0 classmap files repositories : 仓库地址声明依赖所在仓库的地址，默认情况下使用 Packagist 官方网站：https://packagist.org。 国内镜像源： 12345&#x2F;&#x2F; 阿里https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&#x2F; Composer 中文网https:&#x2F;&#x2F;packagist.phpcomposer.com 此外，还可以搭建自己的仓库地址。 示例： 123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&quot; &#125; &#125; 支持以下类型（type）的包资源库： composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和/或 source 信息。这个 packages.json 文件是用一个 PHP 流加载的。你可以使用 options 参数来设定额外的流信息。 vcs: 从 git、svn 和 hg 取得资源。 pear: 从 pear 获取资源。 package: 如果你依赖于一个项目，它不提供任何对 composer 的支持，你就可以使用这种类型。你基本上就只需要内联一个 composer.json 对象。 开源项目配置项如果你的包希望上传到 Packagist 提供给他人使用，需要提供包的基本信息，如作者、包的描述等等。 一个开源的项目，PHPMailer 的配置文件示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;name&quot;: &quot;phpmailer&#x2F;phpmailer&quot;, &quot;type&quot;: &quot;library&quot;, &quot;description&quot;: &quot;PHPMailer is a full-featured email creation and transfer class for PHP&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Marcus Bointon&quot;, &quot;email&quot;: &quot;phpmailer@synchromedia.co.uk&quot; &#125;, &#123; &quot;name&quot;: &quot;Jim Jagielski&quot;, &quot;email&quot;: &quot;jimjag@gmail.com&quot; &#125;, &#123; &quot;name&quot;: &quot;Andy Prevost&quot;, &quot;email&quot;: &quot;codeworxtech@users.sourceforge.net&quot; &#125;, &#123; &quot;name&quot;: &quot;Brent R. Matzelle&quot; &#125; ], &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;&#x3D;5.5.0&quot;, &quot;ext-ctype&quot;: &quot;*&quot;, &quot;ext-filter&quot;: &quot;*&quot; &#125;, &quot;require-dev&quot;: &#123; &quot;friendsofphp&#x2F;php-cs-fixer&quot;: &quot;^2.2&quot;, &quot;phpdocumentor&#x2F;phpdocumentor&quot;: &quot;2.*&quot;, &quot;phpunit&#x2F;phpunit&quot;: &quot;^4.8 || ^5.7&quot;, &quot;zendframework&#x2F;zend-serializer&quot;: &quot;2.7.*&quot;, &quot;doctrine&#x2F;annotations&quot;: &quot;1.2.*&quot;, &quot;zendframework&#x2F;zend-eventmanager&quot;: &quot;3.0.*&quot;, &quot;zendframework&#x2F;zend-i18n&quot;: &quot;2.7.3&quot; &#125;, &quot;suggest&quot;: &#123; &quot;psr&#x2F;log&quot;: &quot;For optional PSR-3 debug logging&quot;, &quot;league&#x2F;oauth2-google&quot;: &quot;Needed for Google XOAUTH2 authentication&quot;, &quot;hayageek&#x2F;oauth2-yahoo&quot;: &quot;Needed for Yahoo XOAUTH2 authentication&quot;, &quot;stevenmaguire&#x2F;oauth2-microsoft&quot;: &quot;Needed for Microsoft XOAUTH2 authentication&quot;, &quot;ext-mbstring&quot;: &quot;Needed to send email in multibyte encoding charset&quot;, &quot;symfony&#x2F;polyfill-mbstring&quot;: &quot;To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;PHPMailer\\\\PHPMailer\\\\&quot;: &quot;src&#x2F;&quot; &#125; &#125;, &quot;autoload-dev&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;PHPMailer\\\\Test\\\\&quot;: &quot;test&#x2F;&quot; &#125; &#125;, &quot;license&quot;: &quot;LGPL-2.1-only&quot;&#125; name : 包名包的名称，它包括供应商名称和项目名称，使用 / 分隔，左边为供应商名称，右边为项目名称。 示例： 12monolog&#x2F;monologigorw&#x2F;event-source 对于需要发布的包（库），这是必须填写的。 description : 描述一个包的简短描述，通常用来描述包的功能，最长只有一行。 对于需要发布的包（库），这是必须填写的。 version : 版本version 不是必须的，并且建议忽略。 它应该符合 ‘X.Y.Z’ 或者 ‘vX.Y.Z’ 的形式， -dev、-patch、-alpha、-beta 或 -RC 这些后缀是可选的。在后缀之后也可以再跟上一个数字。 示例： 1.0.0 1.0.2 1.0.0-dev 1.0.0-alpha3 1.0.0-beta2 1.0.0-RC5 type : 安装类型包的安装类型，默认为 library。 composer 原生支持以下4种类型： library: 这是默认类型，它会简单的将文件复制到 vendor 目录。 project: 这表示当前包是一个项目，而不是一个库。例：框架应用程序 Symfony standard edition，内容管理系统 SilverStripe installer 或者完全成熟的分布式应用程序。使用 IDE 创建一个新的工作区时，这可以为其提供项目列表的初始化。 metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。详细请查看 自定义安装类型。仅在你需要一个自定义的安装逻辑时才使用它。建议忽略这个属性，采用默认的 library。 keywords : 关键字非必选，但建议填写。 该包相关的关键词的数组，可用于搜索和过滤，相当于在 composer 中的 SEO，有助于让更多的人搜索到你的包。 homepage : 项目主页该项目网站的 URL 地址，可选。 time : 版本发布时间必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式，可选。 license : 许可协议包的许可协议，它可以是一个字符串或者字符串数组。 最常见的许可协议的推荐写法： Apache-2.0 BSD-2-Clause BSD-3-Clause BSD-4-Clause GPL-2.0 GPL-2.0+ GPL-3.0 GPL-3.0+ LGPL-2.1 LGPL-2.1+ LGPL-3.0 LGPL-3.0+ MIT 可选，但强烈建议提供此内容。 authors : 作者包的作者，这是一个对象数组。 这个对象必须包含以下属性： name: 作者的姓名，通常使用真名。 email: 作者的 email 地址。 homepage: 作者主页的 URL 地址。 role: 该作者在此项目中担任的角色（例：开发人员 或 翻译）。 示例： 12345678910111213141516&#123; &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Nils Adermann&quot;, &quot;email&quot;: &quot;naderman@naderman.de&quot;, &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;www.naderman.de&quot;, &quot;role&quot;: &quot;Developer&quot; &#125;, &#123; &quot;name&quot;: &quot;Jordi Boggiano&quot;, &quot;email&quot;: &quot;j.boggiano@seld.be&quot;, &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;seld.be&quot;, &quot;role&quot;: &quot;Developer&quot; &#125; ]&#125; 可选，但强烈建议提供此内容。 support : 支持信息获取项目支持的向相关信息对象。 这个对象必须包含以下属性： email: 项目支持 email 地址。 issues: 跟踪问题的 URL 地址。 forum: 论坛地址。 wiki: Wiki 地址。 irc: IRC 聊天频道地址，类似于 irc://server/channel。 source: 网址浏览或下载源。 示例： 123456&#123; &quot;support&quot;: &#123; &quot;email&quot;: &quot;support@example.org&quot;, &quot;irc&quot;: &quot;irc:&#x2F;&#x2F;irc.freenode.org&#x2F;composer&quot; &#125;&#125; 可选。 minimum-stability (root-only)这定义了通过稳定性过滤包的默认行为。默认为 stable（稳定）。因此如果你依赖于一个 dev（开发）包，你应该明确的进行定义。 对每个包的所有版本都会进行稳定性检查，而低于 minimum-stability 所设定的最低稳定性的版本，将在解决依赖关系时被忽略。对于个别包的特殊稳定性要求，可以在 require 或 require-dev 中设定。 可用的稳定性标识：dev、alpha、beta、RC、stable。 prefer-stable (root-only)当此选项被激活时，Composer 将优先使用更稳定的包版本。 使用 “prefer-stable”: true 来激活它。","categories":[{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/categories/composer/"}],"tags":[{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/tags/composer/"}]},{"title":"从零开始开发自己的Composer包","slug":"composer-package","date":"2020-03-08T06:42:18.000Z","updated":"2020-03-08T06:54:07.736Z","comments":true,"path":"composer-package/","link":"","permalink":"https://blog.huotuyouxi.com/composer-package/","excerpt":"","text":"前言在使用 composer 的时候，我们几乎都是在用其他人分享出来的包，久而久之，难免会产生开发自己包的想法，不仅可以加深对 composer 的理解程度，同时还可以把自己常用的功能封装起来，作为自己的“小金库”储备起来。 使用 composer 开发依赖包是一项非常考验能力的事情，它涉及到一个微型系统的架构，阅读设计模式有助于帮助我们开发一个优秀的 composer 依赖包。 开发自己的第一个 Composer 包composer.json 是 composer 的基础，文件夹目录下存在 composer.json 文件，那么这个文件夹就是一个资源包。 我们可以手动创建 composer.json 文件，不过，我们推荐使用 composer init 命令。 composer init 命令帮助我们自动生成 composer.json，文件可以修改，不必担心按错了什么会产生不好的影响。 创建配置文件composer.json 配置项的字段较多，后续步骤如果对配置文件的字段抱有疑问，可以返回此处查看：composer.json 详解。 现在，不需要了解这些。 创建包目录我们的操作是在命令行界面操作的，如果是 Windows 系统，则需要进入 CMD 界面，进入到你的工作磁盘目录下，使用快捷键 Shift + 鼠标右键，在菜单栏中选择进入命令行（DOS 界面）。 首先，我们需要创建一个包的目录 packagist： 12345678# Mac OS 系统mkdir packagist# Windows 系统(可以直接右键创建）md packagist# 创建完成后进入文件夹cd packagist 输入包的名字在 packagist 目录下，执行 composer init，composer 会提示我们设置配置参数信息，如下图： 1Package name (&lt;vendor&gt;&#x2F;&lt;name&gt;) [firerabbit&#x2F;packagist]: 提示让你输入包的名字，格式为 &lt;vendor&gt;/&lt;name&gt;，vendor 为服务商名字，个人开发可以使用自己在 GitHub 中使用的昵称，name 为包的名字，&lt;vendor&gt;/&lt;name&gt; 不能存在同名，这里设置的名字即后面使用 composer require 的名字。 中括号内的 [firerabbit/packagist] 是默认值，直接按回车的话就会使用这个名字。 输入包的描述信息包名输入完成后，接下来需要设置 Description （描述）字段，这个字段是包的功能性描述，作为练习包就随便输入啦： 输入作者信息接下来设置 Author (作者信息)，格式为 name example@email.com，输入 n 可以跳过： minimum-stability 最小稳定版本通过设置 minimum-stability 的值，来告诉 Composer 当前开发的项目的依赖要求的包的全局稳定性级别，它的值包括：dev、alpha、beta、RC、stable，stable 是默认值。 稳定性介绍：理解 Composer 的稳定性（Stability）标识 我们直接按回车默认值即可。 Package Type 包类型接下来设置包的类型： composer 原生支持以下4种类型： library: 默认类型，它会简单的将文件复制到 vendor 目录。 project: 一个项目，而不是一个库。 metapackage: 空的包，包含依赖并且需要触发依赖的安装。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。 这里我们直接按回车，采用默认的 library。 License 许可协议接下来输入包的许可协议： 包的许可协议，它可以是一个字符串或者字符串数组。 最常见的许可协议的推荐写法： Apache-2.0 BSD-2-Clause BSD-3-Clause BSD-4-Clause GPL-2.0 GPL-2.0+ GPL-3.0 GPL-3.0+ LGPL-2.1 LGPL-2.1+ LGPL-3.0 LGPL-3.0+ MIT 这里我们输入 MIT （开源许可协议）。 定义依赖项接下来设置依赖项： 123Define your dependencies.Would you like to define your dependencies (require) interactively [yes]? 我们的练习项目不需要设置此项，输入 no。 dev 依赖项设置 dev 环境依赖项： 1Would you like to define your dev dependencies (require-dev) interactively [yes]? 同上，输入 no。 最后一步：确认信息最后一步，确认包的信息： 输入 yes，回车，然后查看当前目录即可看到 composer.json 文件。 composer init 命令帮助你自动生成文件，实际上你可以直接在包的目录下创建 composer.json，并且输入以下内容： 123456789101112&#123; &quot;name&quot;: &quot;huotu&#x2F;test&quot;, &quot;description&quot;: &quot;我的第一个包。&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;火兔兔子&quot;, &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot; &#125; ], &quot;require&quot;: &#123;&#125;&#125; 本质上两种方式都是一样的。 依赖包的基本结构一个 composer 依赖包的基本结构，以我们上面的 packagist 为例： packagist src 类文件 … tests 单元测试文件 … README.md composer.json LICENSE src 文件夹src 是包所在的路径，一般我们都会将其命名为 src（业界共识），不建议改成其他的名字。 开发包的工作就是在这个目录下进行的，你可以在这个目录下创建更多的文件夹来划分不同功能的类。 tests 文件夹tests 文件夹用来存放单元测试的，如果你不写的话，这个文件夹可以不要。 README.md 文件README.md 是包描述的 Markdown 语法的介绍文档，在 GitHub 中将会自动解析这个文件并且展示出来，每一个包都应该要包含 README.md 文件，用来介绍这个包的基本信息和操作方法。 创建 README.md 文件的方法： 123456# Mac OSvim README.md# Windows 系统创建 README.txt，保存后改成 .md如需编辑，右键以文本文档打开即可 composer.json 文件包的配置信息。 LICENSE许可协议文本，文本格式。 练习项目中，我们只需要 src 和 README.md 即可。 推荐使用 PHPstorm 作为编辑工具，最后我们的包目录结构如图所示： 配置自动加载规则为了防止命名空间冲突，开发的包需要配置自动加载，修改 composer.json 添加 autoload 字段： 12345&quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;src&#x2F;&quot; &#125; &#125; 我们采用 psr-4 的规范来自动加载包目录下 src 文件夹内的类文件，这里的 &quot;Huotu\\\\Test\\\\&quot; 是我们使用的命名空间，\\\\ 不能写成 \\，一般而言，命名空间以包的名字来命名。 完整的 composer.json 配置如下： 1234567891011121314151617&#123; &quot;name&quot;: &quot;huotu&#x2F;test&quot;, &quot;description&quot;: &quot;我的第一个包。&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;火兔兔子&quot;, &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot; &#125; ], &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;src&#x2F;&quot; &#125; &#125;&#125; 创建包的类文件在 src 目录下创建 Robot.php 文件，我们希望写一个可以自动打招呼的机器人（类）： 12345678910&lt;?phpnamespace Huotu\\Test;class Robot&#123; public function sayHello($name) &#123; echo &#39;hello,&#39; . $name . PHP_EOL; &#125;&#125; 这样我们就完成了一个依赖包的开发，使用者只需要引入这个包就可以调用 Robot 的 sayHello 方法。 测试包的功能我们现在已经写好了一个包，但是开发过程以及准备发布的时候，我们都需要对功能进行调试，你可以在目录下创建一个 test.php，然后运行 php test.php 来测试，不过这样总是不太方便的，尤其是某些有其他依赖的操作（如需要连接数据库、Redis）等等。最好的方法是将包文件放在一个真实的项目里进行测试，下面模拟创造一个 project 来作为我们实际的项目。 在 packagist 同级目录下，创建一个文件夹 project。 由于我们本地开发的包并未上传的 Packagist，无法通过 composer require 进行安装，因此我们必须手动配置加载目录，进入 project 文件夹，创建 composer.json： project composer.json 编辑 composer.json，输入如下内容： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;..&#x2F;packagist&#x2F;src&#x2F;&quot; &#125; &#125;&#125; 创建完成后，我们需要执行 composer dump-autoload 来生成自动加载文件。 如果对依赖包添加了新的类或者删除了类，涉及到类文件数量、名称改变的，都需要重新执行 composer dump-autoload，否则无法读取到最新的类文件 执行完成后，在当前目录下生成了 vendor 文件夹，这个文件夹里即包含了我们依赖包的自动加载信息。 接着一个文件用来测试结果 test.php： project composer.json test.php vendor composer … autoload.php 输入如下内容： 12345678&lt;?phprequire &#39;.&#x2F;vendor&#x2F;autoload.php&#39;;use Huotu\\Test\\Robot;$robot &#x3D; new Robot();$robot-&gt;sayHello(&#39;IDCE.COM&#39;); 终端中输入 php test.php 执行结果： 可以看到我们成功调用自己开发的包了！ 必须将 autoload 引入才能实现自动加载，如果提示找不到类可能就是没有正确引入的关系或者 composer.json 配置的 psr-4 路径不正确。 上传到 GitHub开发完成后，我们需要把包文件上传到 GitHub，如果没有账号则注册一个。 进入个人主页，在左侧的 Repositories（仓库）选择 New 创建一个新的仓库： 仓库信息，权限要选择 public（公开的），完成后点击 Create repository： 创建好的项目： GitHub 十分友好的提示了上传文件的步骤，我们只需要执行以下几个步骤即可： 12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin https:&#x2F;&#x2F;github.com&#x2F;huoshaotuzi&#x2F;test.gitgit push -u origin master 返回 packagist 目录下，我们按照 GitHub 上提示的内容，执行 git init，并添加文件： 注！由于 ide 产生的文件是必须添加 .gitigonre 排除的 然后添加上传的仓库信息，并执行 push 推送到 GitHub 的仓库： 返回 GitHub 仓库，刷新页面即可看到上传文件的信息： 上传到 Packagist如果希望自己的包被其他人安装，就需要将包上传到 Packagist 官网上。 Packagist 官网：https://packagist.org/ 如果没有账号可以注册一个，或者直接使用 GitHub 登录（推荐）。 登录后，选择右上角的 Submit（提交）： 在提交页面会提示你输入 GitHub 上仓库的地址： 输入刚才创建的仓库地址，点击 Check： 这边会提示一些同名的包，并且出现了 Submit 按钮，我们直接点击 Submit，此时会进入包页面，update 会进入转圈圈状态，表示正在同步包信息，稍等一会刷新页面即可看到包信息。 到目前为止，已经将包上传到 Packagist 官网了，但是我们还没有设置版本信息，需要返回到包目录下，给这个包打上标签。 输入以下命令： 12git tag -a v1.0 -m &quot;初始版本&quot;git push origin v1.0 然后返回 Packagist 官网，点击 update 同步包信息，然后刷新页面就能看到刚刚提交的版本信息了。 现在，用户可以使用 composer require 命令下载你的包了。 1composer require huotu&#x2F;test:1.0 自动同步版本更新每次更新包都需要手动点击 update 十分不便，实际上 GitHub 提供了钩子可以用来推送更新信息到 Packagist，默认情况下已经帮助我们打开了自动更新功能。 回到 GitHub 的仓库地址，选择 Setting，左侧菜单 Webhook，可以看到配置的推送信息： 每当我们推送新的版本标签到 GitHub 时，Packagist 就会接收到一个 GitHub 的 Hook（钩子）发出的 POST 请求，这样 Packagist 上的包就会与 GitHub 上的同步了。 如果你不需要自动更新功能，可以点击右侧的 Delete 将其删除，删除后每次更新包都要前往 Packagist 点击 Update 手动进行更新。 开启自动更新情况下，每次 push 标签后都会自动同步到 Packagist，刷新页面即可看到最新提交的版本： 依赖包编写小建议开发依赖包需要要丰富的开发经验，可以多参考其他开源包，尤其是具有团队进行维护的，观察他们是如何区分目录和封装类的，可以学到很多知识。 推荐阅读：PHP 设计模式 编写依赖包能得到锻炼和成长的机会，开源自己的包也是一件十分具有成就感的事。 分享，是最好的学习方式 —— IDCE.COM","categories":[{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/categories/composer/"}],"tags":[{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/tags/composer/"}]},{"title":"SSH免密登录原理及方法","slug":"ssh-no-password-method","date":"2020-03-07T14:50:10.000Z","updated":"2020-03-08T06:54:07.719Z","comments":true,"path":"ssh-no-password-method/","link":"","permalink":"https://blog.huotuyouxi.com/ssh-no-password-method/","excerpt":"","text":"SSH 命令使用 ssh 用户名@服务器IP 可以连接到服务器，这样做的缺点是每次都要输入密码，一方面是不安全，另一方面是麻烦。 SSH 免密登录服务器在本地主机上使用 ssh-keygen -t rsa 生成密匙对，这里的 -t rsa 指的是用 rsa 加密方式生成密匙： 第一步，输入密匙存放目录，使用默认路径直接按回车即可： 12Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa): 第二步，输入密码，建议直接回车使用空密码： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 如果输入了密码则需要再输入一次确认密码。这里的密码不是指远程登录主机的密码，而是使用密匙时的密码，既然我们是希望免密登录了，自然不希望再输入任何密码，因此此处填空即可。 1234567891011+---[RSA 2048]----+| .. . || o. . . o || o...+* + || .o+*+O || . &#x3D;+So+o || . . . @.*B. || o . . Eoo. || o * .. || ..o o. |+----[SHA256]-----+ 上面会生成 randomart image 图案，这个图案是根据密匙生成的，因此每个人看到的都不同。 趣味小科普：为什么要生成这种图案呢？这是由于密匙对是一个很长的随机字符串，比起加密的字符串人们更容易接受图片，可以说是很贴心了 生成的密匙包含一对，公钥和私匙（其实叫做私钥，但感觉这样比较有意思所以就这么写）： 12Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub. 我们根据路径可以找到文件所在位置： 123[root@VM_0_8_centos ~]# cd &#x2F;root&#x2F;.ssh[root@VM_0_8_centos .ssh]# lsauthorized_keys id_rsa id_rsa.pub 这两个密匙文件分别是： id_rsa 生成的私钥文件 id_rsa.pub 生成的公钥文件 另外一个 authorized_keys 是保存远程免密登录公钥的文件，主要通过这个文件记录多台机器的公钥，我们要做的就是把本机的公钥发送到服务器主机的这个文件里。 接着，把公钥发到需要登录的服务器主机上： 1ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub 服务器IP地址:&#x2F;root&#x2F;.ssh&#x2F;authorized_keys 接着会要求你输入一次密码，输入完成后就可以实现免密登录了。 在本机上执行 ssh 用户名@服务器IP，不再需要输入密码验证。 SSH 添加别名网络上的教程一般到上一步就结束了，在这里传授一个小技巧可以事半功倍。 虽然我们现在跳过了输入密码这个步骤，但是每次都要输入 IP 也是很蛋疼的一件事，我们甚至想要不输入 IP 就能登录到远程服务器 ？ 这也能做到！ 在本地进入 .ssh 目录： 12# 进入 .ssh 目录FireRabbitdeMacBook-Pro:.ssh firerabbit$ cd ~&#x2F;.ssh 使用 vim config 编辑文件并且输入以下内容： 1234Host devHostName 127.0.0.1User rootPort 22 这里的 dev 是我们给远程主机起的别名，127.0.0.1 是远程主机的地址，请替换成你的服务器 IP，User 即登录的用户名，Port 为服务器访问端口，如果修改了端口在这里也要修改。 现在我们的目录应该是这样的： 12FireRabbitdeMacBook-Pro:.ssh firerabbit$ lsconfig id_rsa id_rsa.pub known_hosts known_hosts 是连接过的主机记录，可以随意删除。 接着在命令行输入：ssh dev 即可连接到服务器！ 阅读至此，恭喜你！Linux Exp + 1 报错问题如果出现如下报错： 1&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: ERROR: ssh: Could not resolve hostname xxx:&#x2F;root&#x2F;.ssh&#x2F;authorized_keys: nodename nor servname provided, or not known 网上查了下，大都是说 hosts 文件的问题。 可以尝试修改 /etc/hosts 看看是否有如下行，如果没有则添加： 1127.0.0.1 localhost 经过本人尝试结果无效，可用别的方法。 那就是——手动上传！！！ 编辑本地主机的密匙文件： 1vim ~&#x2F;.ssh&#x2F;id_rsa.pub 把密匙内容全部拷贝下来。 接着先用 ssh root@远程主机IP 用密码登录进去，然后在远程主机中 vim /root/.ssh/authorized_keys。 把复制的密钥直接粘贴下来就可以啦！ 免密登录原理网上的教程一般都是直接贴出代码和操作步骤，但这样我们根本不清楚它的原理是什么。 我们希望能像侦探一样追根究底，查清楚它的原理是什么。 真正理解后的知识才能永远刻入你的脑海里 上面的步骤，我们在本机生成一个密匙对，一共包含两个文件，一个是公钥，一个是私匙，公钥是发送到服务器主机的，私匙是留在本地的。 这样包含一对公钥私匙的加密叫做“非对称加密”。 对称加密在了解非对称加密之前需要先了解对称加密，所有新事物的出现必然伴随着某种需求。 小红和小明私底下正在交往，但又不希望被别人发现，于是他们约定了一种加密算法，每个字母向后移动一位，如 a 往后移一位是 b，b 往后移一位是 c……z往后移是 a。 那么，ni hao 就变成了 oj ibp。 由于双方约定好了同样的加密算法，所以小红发给小明消息时，就可以按照约定好的算法进行解密。 于是他们大胆的在班级群里用加密后的消息进行聊天，其他同学一脸茫然的看着不明觉厉的消息。 但是此时，名侦探小刚破解了他们约定好的加密算法，并且截获了（截获很简单，毕竟他们公然秀恩爱）他们互通的消息，此时小红和小明的聊天记录就被小刚一清二楚的知道了！ 非对称加密聊天记录被小刚公开后，小明和小红十分尴尬，于是机智的小明想出了一种方法，把前面约定的加密算法做了一些小的改进，小明告诉小红，我发给你一个密匙串，你用这个给消息进行加密（某种加密算法），你发给我消息后，我再用我这边的密匙进行解密，我发给你的密匙和我本地的密匙是不同的，只有我本地的密匙才能解密你加密过的内容。 问题又来了……现在只有小明破解小红的消息，小明用公钥加密消息发给小红，小红是解密不了的；如果需要双向沟通的话，自然是用同样的方法，小红也给小明一个密匙，小红本地存有另外一个用来解密的密匙。但是 Linux 免密登录是本机免密登录到服务器，属于单向的沟通，如果你希望服务器也能免密登录本机（一般不会有这种需求），就在服务器用同样的方法生成密匙，把密匙发生到本机就可以了。 接下来的日子，小刚也无法破解他们的聊天记录，恼羞成怒的小刚带着三名小弟放学后去堵小红，逼迫小红把小明给她的加密密匙交出来，小红无奈之下将密匙交出，然而，即使拿到密匙，小刚依然无法破解小红的密码，因为，还需要小明手里的密匙才能解密小红的消息。 非对称加密的存在就是为了避免加密算法被第三者知道，导致密码泄露。上面的故事中小明交给小红的加密串叫做公钥，公钥可以让任何第三者知道，公钥加密过的密码只有小明手里的加密串——私匙才能解密，对于加密和解密使用不同的加密策略，叫做非对称加密。 使用公钥实现免密登录我们通过 ssh-keygen -t rsa 生成了公钥和私匙对，接着我们把公钥发送到服务器上，当连接的时候，服务端会发送一个用公钥加密的字符串过来，本地再使用私匙进行解密，实现了登录验证，从而不需要输入密码就能进行登录。 用盗来的一张图解释： RSA 非对称加密算法参考：百度百科 - RSA 只做兴趣了解，不需要掌握原理，因为我们的研究方向不是这个。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.huotuyouxi.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.huotuyouxi.com/tags/Linux/"}]},{"title":"再战！Docker 安装 Gitlab","slug":"docker-install-gitlab","date":"2020-03-07T14:21:32.000Z","updated":"2020-03-08T06:54:07.725Z","comments":true,"path":"docker-install-gitlab/","link":"","permalink":"https://blog.huotuyouxi.com/docker-install-gitlab/","excerpt":"","text":"前言上一次因为服务器配置太低翻车了，现在重新挑战一次。 Gitlab 硬件要求Gitlab 十分吃机器的配置，Gitlab 官方推荐 2核 4G，最低建议 1 核 2G，再低的话可能会像我上次那样直接翻车或者运行起来十分卡顿。 由于是个人学习，就不打算将其部署到线上的服务器上了，这一次我采用在本地安装的方式搭建 Gitlab。 下载镜像拉取 Gitlab 官方最新版本镜像： 1docker pull gitlab&#x2F;gitlab-ce:latest 由于镜像较大，建议换成国内镜像提高下载速度。 运行镜像下载完成后，再执行 run 启动容器： 123456789sudo docker run --detach \\ --hostname localhost \\ --publish 4443:443 --publish 999:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume ~&#x2F;docker&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab \\ --volume ~&#x2F;docker&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \\ --volume ~&#x2F;docker&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \\ gitlab&#x2F;gitlab-ce:latest run 参数说明： 123456--detach：让容器在后台运行--hostname：主机地址，本地使用 localhost，可以换成域名--publish：宿主机的端口映射到容器的端口，由于我本地已经有其他容器使用了 443 和 80 端口，因此我改成了 4443 和 999 端口。--name：自定义容器的名称--restart：容器重启策略，在退出时容器应该如何重启或不应该重启，always 始终重启 --volume：宿主机映射到容器的卷，用来做容器数据的持久化，这里我将卷的目录设置为 ~&#x2F;docker&#x2F;gitlab run 命令执行后，可以执行如下命令： 12cd ~&#x2F;docker&#x2F;gitlabls 可以看到自动生成了以下几个文件： 1config data logs 这些文件就是宿主机与容器之间通过卷映射的文件（容器数据持久化）。 执行 docker ps 可以看到容器运行状态： Gitlab 初始化容器启动后，需要稍等几分钟，然后再访问 127.0.0.1:999，如果直接访问的话可能 Gitlab 还未完全启动，这个时候是访问不了的。 第一次访问时，需要设置管理员（root 用户）密码： 初始化密码设置完成后，返回到登录页面，使用账户 root 以及刚才设置的密码进行登录： 登录成功后，就可以操作界面啦！ 添加 SSH key在开始使用之前，需要添加 ssh key 才能拉取或者推送到仓库，执行命令： 12cd ~&#x2F;.sshls 查看是否生成过 ssh key，如果当前目录下没有文件，则需要创建新的 ssh key，执行以下命令生成 ssh key，-C 参数后面是你的邮箱地址： 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 完成后在当前目录下会生成 ssh key，包含两个文件，这是一对密匙： 1id_rsa id_rsa.pub 其中，id_rsa.pub 是公钥，我们需要的就是这个文件： 1cat id_rsa.pub 将输出的密匙字符串复制下来（注意是把所有的内容都复制下来，包括邮箱）。 接着返回 Gitlab，点击左上角个人头像，选择 Settings： 选择左侧菜单 SSH Keys，将你的 ssh key 黏贴到方框内，然后点击 Add key 即可： 接下来就可以愉快的开始使用 Gitlab 啦！ 为什么安装后的 Gitlab 可以直接访问？这是由于 Gitlab 内置了 nginx 服务器，所以才能在安装完成后通过地址进行访问。 完结撒花～ ҉٩(´︶`)۶҉ ??","categories":[{"name":"docker","slug":"docker","permalink":"https://blog.huotuyouxi.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.huotuyouxi.com/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://blog.huotuyouxi.com/tags/gitlab/"}]},{"title":"Centos安装Gitlab","slug":"centos-install-gitlab","date":"2020-03-07T14:21:32.000Z","updated":"2020-03-08T06:54:07.722Z","comments":true,"path":"centos-install-gitlab/","link":"","permalink":"https://blog.huotuyouxi.com/centos-install-gitlab/","excerpt":"","text":"1、安准基础依赖安装 Gitlab 所需依赖： 1sudo yum install -y curl policycoreutils-python openssh-server 启动 ssh 服务并设置开机启动： 12sudo systemctl start sshdsudo systemctl enable sshd 2、安装邮件服务Postfix 是一个邮件服务器，GitLab 发送邮件需要用到。 安装 postfix： 1sudo yum install -y postfix 启动 postfix 并设置为开机启动： 12sudo systemctl start postfixsudo systemctl enable postfix 3、开放 ssh 以及 http 服务（80 端口）查看防火墙是否启动： 1systemctl status firewalld 以下为我的服务器上的防火墙状态： 12345[root@ecs-86c0 ~]# systemctl status firewalld● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) 如果看到 Active: inactive (dead)，表示防火墙没有启动，执行下面的命令启动防火墙并且设置为开机启动： 12systemctl start firewalldsystemctl enable firewalld 此时，在查看防火墙状态： 12345678[root@ecs-86c0 ~]# systemctl status firewalld● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled) Active: active (running) since 一 2019-09-02 17:56:23 CST; 2s ago Docs: man:firewalld(1) Main PID: 26477 (firewalld) CGroup: &#x2F;system.slice&#x2F;firewalld.service └─26477 &#x2F;usr&#x2F;bin&#x2F;python -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld --nofork --nopid Active: active (running) 表示防火墙正常运行。 开放 ssh、http 服务： 12sudo firewall-cmd --add-service&#x3D;ssh --permanentsudo firewall-cmd --add-service&#x3D;http --permanent 只有防火墙开启状态才能执行上述命令，否则会报 FirewallD is not running 错误 重新加载防火墙： 1sudo firewall-cmd --reload 4、安装 Gitlab我们使用 Gitlab 的社区版：gitlab-ce，如果需要使用商业版，则安装：gitlab-ee。 4.1、添加 Gitlab 社区版资源包默认情况下 yum 源没有 gitlab-ce 软件包，需要手动下载： 1curl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlab-ce&#x2F;script.rpm.sh | sudo bash 4.2、使用 yum 安装 gitlab-ce在这里强烈推荐阅读：Centos 系统更新 yum 源为国内镜像源 1yum install -y gitlab-ce 软件包的安装大小足足有 1.4 G，更换镜像后只需要数十秒就下载完了。 安装成功后可以看到一个类似“狐狸头像”的图案： 4.3、配置 Gitlab 访问地址Gitlab 安装完成后，配置文件所在路径为 /etc/gitlab/gitlab.rb，编辑配置文件： 1vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb 将 external_url 字段修改为你的域名信息，如果没有域名可以改成 IP:端口 的方式。 12345678910111213## GitLab configuration settings##! This file is generated during initial installation and **is not** modified##! during upgrades.##! Check out the latest version of this file to know about the different##! settings that can be configured by this file, which may be found at:##! https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;omnibus-gitlab&#x2F;raw&#x2F;master&#x2F;files&#x2F;gitlab-config-template&#x2F;gitlab.rb.template## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https:&#x2F;&#x2F;docs.gitlab.com&#x2F;omnibus&#x2F;settings&#x2F;configuration.html#configuring-the-external-url-for-gitlabexternal_url &#39;http:&#x2F;&#x2F;gitlab.example.com&#39; 4.4、启动 Gitlab重新载入配置并启动 Gitlab（如果修改了配置文件需要再运行此命令）。 1sudo gitlab-ctl reconfigure 翻车现场： 报错原文： 123456789101112Running handlers:There was an error running gitlab-ctl reconfigure:Multiple failures occurred:* Chef::Exceptions::MultipleFailures occurred in chef run: Multiple failures occurred:* Errno::ENOMEM occurred in delayed notification: ruby_block[restart_log_service] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 69) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: ruby_block[reload_log_service] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 77) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 408) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: service[gitaly] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: runit_service[gitaly] (gitaly::enable line 75) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: service[gitlab-workhorse] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2) %&gt;_&lt;% 原来是我的测试机内存（1G）不够！ 穷人没有资格安装 Gitlab （╯‵□′）╯︵┴─┴ 4.5、访问 Gitlab如果不出意外，输入 external_url 配置的地址，即可看到 Gitlab 页面。 第一次登陆 Gitlab 时需要设置 root 密码，然后就可以愉快的创建项目了。","categories":[{"name":"docker","slug":"docker","permalink":"https://blog.huotuyouxi.com/categories/docker/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://blog.huotuyouxi.com/tags/gitlab/"},{"name":"centos","slug":"centos","permalink":"https://blog.huotuyouxi.com/tags/centos/"}]},{"title":"Gitlab + Satis 搭建私有 Composer 仓库","slug":"install-gitlab-satis-composer","date":"2020-03-07T14:21:18.000Z","updated":"2020-03-08T06:54:07.728Z","comments":true,"path":"install-gitlab-satis-composer/","link":"","permalink":"https://blog.huotuyouxi.com/install-gitlab-satis-composer/","excerpt":"","text":"Satis 介绍Satis 是开源的静态 Composer 仓库生成器，可用于托管公司私有包的元数据。 环境要求：PHP &gt;= 7.2 安装 GitlabCentos 搭建 Gitlab：Centos 系统安装 GitlabDocker 搭建 Gitlab：再战！Docker 安装 Gitlab 上传 Composer 包Composer 包开发教程：从零开始开发自己的 Composer 包 在 Gitlab 新建一个仓库，把自己开发完成的包上传到这个仓库，上传完成后的仓库如下： 包的配置文件 composer.json 如下： 包的名字叫做：huotu/test，我们后面需要用到。 这个仓库的地址就是我们私有包的地址，接下来拿这个包作为演示。 安装 Satis可以使用两种方式安装 Satis。 1、Composer 安装可以直接使用 composer 命令安装 Satis： 1composer create-project composer&#x2F;satis --stability&#x3D;dev --keep-vcs 2、从 GitHub 下载使用 git clone 将 Satis 下载到本地： 1git clone https:&#x2F;&#x2F;github.com&#x2F;composer&#x2F;satis.git 添加 Satis 配置文件在下载好的 satis 目录下，创建 satis.json 配置文件，一个示例的配置文件如下： 123456789101112131415&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;packages.example.org&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;mycompany&#x2F;privaterepo&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;svn.example.org&#x2F;private&#x2F;repo&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;mycompany&#x2F;privaterepo2&quot; &#125; ], &quot;require&quot;: &#123; &quot;company&#x2F;package&quot;: &quot;*&quot;, &quot;company&#x2F;package2&quot;: &quot;*&quot;, &quot;company&#x2F;package3&quot;: &quot;2.0.0&quot; &#125;, &quot;require-all&quot;: false&#125; name：仓库的名字，将会展示在页面上 homepage：satis 访问地址 repositories：\b包所在的地址 require：获取指定的包 require-all：如果为 true 表示获取所有包 根据自己的情况进行配置，这里我们拿刚刚上传到 Gitlab 的包演示，配置如下文件： 12345678&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test&quot; &#125; ], &quot;require-all&quot;: false&#125; http://satis.com 为 satis 访问页面地址，http://gitlab.com/huotu/test 为私有包所在地址。 Composer 配置由于我们使用 http，在这里需要修改设置： 1composer config -g secure-http false 生成 Satis 索引页面在 satis 目录下执行命令 composer install 安装所需依赖，然后再执行如下命令生成 satis 页面： 1234567php bin&#x2F;satis build &lt;configuration file&gt; &lt;build dir&gt;# 示例 ：php bin&#x2F;satis build satis.json public&#x2F;# 跳过 Gitlab 密码验证php bin&#x2F;satis build -n satis.json public&#x2F; 执行完命令后，在当前目录生成了 public 文件夹，接着配置 nginx，将域名指向这个目录： 1234567891011121314151617server &#123; listen 80; server_name satis.com; root &#x2F;www&#x2F;satis&#x2F;public; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.php?$query_string; &#125; location ~ \\.php$ &#123; include fastcgi_params; try_files $uri &#x3D;404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; &#125;&#125; 重启 nginx，不出意外就可以通过域名访问 satis 了！ 使用域名记得添加解析到服务器 访问 http://satis.com（这个是你配置的域名）： Composer 使用私有仓库我们现在完成了 Satis + Gitlab 的全部安装，接下来我们的项目就可以使用自己搭建的私有 Composer 源了。 新建一个 test 文件夹，在 test 目录下创建 compsoer.json，编辑 composer.json 添加如下内容： 123456789&#123; &quot;require&quot;: &#123; &quot;huotu&#x2F;test&quot;: &quot;*&quot; &#125;, &quot;repositories&quot;: [&#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot; &#125;]&#125; 保存，然后在当前目录下执行 composer install： 成功把自己私有仓库的包下载下来了。 如果有多个包，则添加多个仓库地址： 12345678910&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test2&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test3&quot; &#125;, ], &quot;require-all&quot;: false&#125; 缓存包资源可以把所需要的包都缓存在本地 Satis 上，这样可以避免每次都需要从仓库中 clone，在 satis.json 添加： 12345678&#123; &quot;archive&quot;: &#123; &quot;directory&quot;: &quot;dist&quot;, &quot;format&quot;: &quot;tar&quot;, &quot;prefix-url&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;, &quot;skip-dev&quot;: true &#125;&#125; archive 参数： directory: 表示生成的压缩包存放的目录，会在我们 build 时的目录中 format: 压缩包格式，zip（默认） tar prefix-url: 下载链接的前缀的 Url, 默认从 homepage 中取 skip-dev: 默认为 false，是否跳过开发分支 absolute-directory: 可选，包文件存储到绝对路径的目录 whitelist: 可选，如果设置为包名称列表，则只会转储这些包的 dist 文件 blacklist: 可选，如果设置为包名称列表，则不会转储这些包的 dist 文件 checksum: 可选，默认情况下为 true，禁用时（false）不会为 dist 文件提供 sha1 校验 启用后，所有下载（包括来自 GitHub 和 BitBucket 的下载） 将替换为本地版本。 添加 archive 后，配置的包信息就会下载到本地 Satis 目录下 dist 文件夹中，从 Satis 下载依赖时将从这个文件夹获取资源。 定期更新 Satis需要定期执行 php bin/satis build satis.json public/ 命令来生成最新的 Composer 包信息，可以将此命令作为定期任务执行，或是增加一个钩子 push 来更新 Satis。","categories":[{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/categories/composer/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.huotuyouxi.com/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://blog.huotuyouxi.com/tags/gitlab/"},{"name":"composer","slug":"composer","permalink":"https://blog.huotuyouxi.com/tags/composer/"}]},{"title":"游戏中的抽奖是否应该有保底机制？","slug":"game-draw-card-mechanism","date":"2020-03-07T14:12:52.000Z","updated":"2020-03-07T14:47:55.319Z","comments":true,"path":"game-draw-card-mechanism/","link":"","permalink":"https://blog.huotuyouxi.com/game-draw-card-mechanism/","excerpt":"","text":"前言游戏中的抽奖机制是几乎所有游戏都要面临的问题，在一定程度上来说，抽奖机制可以决定游戏的命运。 当一个打算弃坑的玩家，想在最后抽个爽，结果却出了许多氪金大佬都没有的神宠！在游戏广播下，世界频道异口同声的喊起“狗托”，豹子头“零充”玩家心情自然不言而喻，十有八九会享受万众羡慕的眼神继续愉快的玩耍。 反之，一个氪金大佬怒抽 100 连，砸了 N 个 648 结果还不出货，正气急败坏，却看楼上那位零氪玩家的广播 XXX 玩家抽到 XXX，试问氪金大佬此时作何感想？ 当然，上面的情景仅为 YY，实际上可能并没有那么夸张，举例只是为了说明在某些特定情况下可以决定玩家是否继续玩下去。 游戏中的抽奖机制游戏中的抽奖机制经过不断演变，发展为两种比较常见的形式：无保底机制 与 保底机制。 无保底机制如字面意思，无论抽几次，概率都是一样。 这种模型会造成某些玩家运气好，尤其是零元党在抽到好东西的时候很喜欢在 贴吧秀，对包括零氪、土豪玩家造成暴击伤害，“脸帝”是玩家公敌。 无保底机制的弊端会造成游戏过于依赖运气成分。 脸黑玩家可能永远抽不到，土豪玩家可能连砸 N 个 648 依然得不到。 站在游戏开发者的角度，希望绝大多数玩家可以体验到游戏绝大多数内容，而不是单纯的靠运气决定，这个时候就可以依靠俗话说的“努力就会有回报”。 保底机制玩家通过抽奖，达到一定次数就能得到最好的奖励，这就是保底奖励。 保底奖励又有两种形式。 积分兑换第一种是以累计 “积分” 的形式，玩家可以用积分在商店兑换到最好的奖励。 这种方式的好处是，玩家可以 明确的知道 抽几次一定可以拿到大奖，虽然可能会损失几分惊喜的感觉，但是会让玩家心里感到踏实。即使失败也不会有太大的负面影响，因为失败也会累计积分作为补偿。 幸运值第二种是通过抽奖累计 “幸运值”，每次抽奖都可以使下次抽到大奖的几率提高，幸运值达到满时必定抽到。比如王者荣耀的水晶/积分抽奖，玩家可以通过日常获得的钻石去抽奖，即使没抽到也可以积累幸运值，慢慢积累直到抽到水晶然后兑换韩信这个英雄。有些游戏的强化系统也采用这种形式，每次强化失败，下一次强化的成功几率就会提高。 这种方式的好处是可以让玩家 保持对于抽奖的期待，因为概率不断提高，玩家的内心就会觉得可能下一次就中了，而且有保底满幸运值必中的结果，玩家对于失败的感觉就很淡然了，现在的抽奖已经变为 “可以让我省多少钱”，越早抽到，玩家反而会觉得赚到了。 游戏的抽奖该不该保底？回到标题，让我们思考下面几个问题： 游戏的抽奖该不该保底？ 开发商会因为保底而亏损吗？ 保底抽奖机制到底对哪种类型的玩家更有好处？ 1、个人的看法是游戏抽奖以保底机制更好 我是一个游戏开发者，我希望玩家可以体验到游戏的更多内容（毕竟是我亲自设计的），故意吊玩家的胃口，让某些神宠只让个别人拥有，固然可以提高玩家对神宠的追求，但如果一个永远无法达成的目标，只会让玩家失望，累积越来越多的失望最终就会失去玩家。 2、不会因为保底抽奖而亏损首先保底机制可以减少玩家的流失，这是其一；其二，保底机制也让土豪玩家更有动力去充钱，以上面的积分模型为例，土豪玩家如果想要得到所有最好的奖励，“最坏”的结果已经可以通过计算明确知道了，当人知道最坏结果时，对失败的承担能力就会越强，而且土豪也可以通过计算推出自己 应该充多少钱 才能拿到所有的奖励，土豪并不差钱，但是土豪并不想被 概率 忽悠。 策划也可以通过 临界值 来诱使玩家进行充值，这个方法十分见效，我自己就上过很多次当。 下面是我被网易坑的血泪史（┭┮﹏┭┮）： 网易新出的游戏百闻牌，里面故意设计红玉和蓝玉兑换机制，让玩家误以为充值的就是红玉，其实充值的是蓝玉，需要再兑换成红玉才能抽奖。 （这种欺骗玩家或者诱导玩家错觉的行为极其不可取！） 抽奖处显示抽 10 次就可以得到妖刀姬，我就充了 30（计算得出只要充 30 就可以抽 10 次奖），结果发现充值的是蓝玉，兑换之后只有 5 次抽奖机会（真是神坑！） 好吧，现在已经抽了 5 次，再抽 5 次才能抽到，那我是抽还是不抽呢？这里还涉及到沉默成本，后文介绍。 当然是选择继续抽，而且这次还充了 68，原因是首充有额外赠送。 落入策划步步设计的深坑 ┭┮﹏┭┮ 然后又抽了 5 次才拿到妖刀姬。 这里，由于我之前已经累积了 5 次，只要再抽 5 次就可以拿到大奖，因此我会有驱动力去继续抽下去，如果是在临界值，这个动力就会更强，例如：299/300 的时候，只需要再一次就可以抽到！ 接下来谈一谈 沉默成本。 沉默成本是经济学里面的概念（我大学也是学过经济学的2333）。 比如你投一只股票，当天亏损了 5 万，你会卖掉还是等明天看看？ 很多人都会留着看看，因为这样白白亏损很不甘心。 但实际上，你亏损的 5 万已经成为了事实，已经无法改变，不应该影响下一步的决策。 就像上面我充了 30，结果发现只抽了 5 次，但此时我损失 30 块钱已经是板上钉钉子的事了，但是我的心里面就会想：“我已经充了 30，再充 30 就可以拿到想要的了，不能让之前充的白白浪费”。 这里就是沉默成本在作怪。 实际上，沉默成本也是决定游戏命运至关重要的要素，如果一个策划可以让玩家在游戏里投入更多的时间，那玩家就会越来越难以失去这个游戏，甚至以为是“情怀”什么的，比如魔兽玩家经常会说，“那不是游戏，而是我逝去的青春”，可以说是沉默成本非常形象的说明了。 3、保底机制更利于氪金玩家由于保底机制，只要无限氪金 必然可以得到一切，也就造成了有钱可以为所欲为的情况，难道开发商不希望土豪充更多的钱吗？所以，开发商是绝对不会亏的，这一点可以保证。 由于氪金玩家可以不断充钱得到所有的奖励，如果不是保底机制呢？氪金玩家投入将是无底洞，无论投入多少钱，也许永远都得不到想要的一只英雄或者宠物。 其次，对于零氪玩家来说也是极好的，只是提升的程度没有土豪玩家那么大而已。 保底机制对“脸帝”来说是最大的威胁，由于保底，这样他们根本 秀不起来，他们由于脸好得到的神宠已经是人手可得的普通宠物了，晒这样的宠物已经无法满足他们日渐膨胀的虚荣心。 作为贴吧 13 级的大水比，已经见惯了秀脸贴。 “萌新求问 XXX 有用吗？” 抽奖中的暗箱操作之前看了一期游戏抽奖的视频，介绍了游戏抽奖中的各种暗箱操作。 其中之一是最坑的，下面用一个故事来说明。 隔壁老王有一颗价值 1 万的钻石，他想了一个办法，可以让这颗钻石赚到更多钱。 他做了 300 个空盒子，接着把钻石放在其中一个盒子，其他 299 个盒子都放一颗与钻石等重的碎玻璃，然后他开始在大街上摆摊吆喝：300 个盒子里有一颗价值 1 万的钻石，其他都是玻璃，每个盒子卖 50 块，买盒子的人不能说出自己开到什么东西。 众人听到，纷纷想以 50 博 1 万，结果所有的盒子都卖出去了，老王共得 1.5 万，比直接出售钻石还多赚了 5000。 在这里有一个很坑的点，假设第一个买盒子的人开到钻石，那后面 299 个人必定无法开到钻石，也就是必定亏损的，但是由于 “不能说出自己开到什么” 导致后面来买盒子的人仍然抱有期待，因而继续购买盒子。 在一些游戏中，由于玩家并不能知道游戏的抽奖机制是什么，因此就会有策划想出这种“歪点子”，有些游戏里的大奖每天只会发放一份（或者固定份数），而后续的玩家永远抽不到。 除此之外，还有另一种暗箱操作——奖池机制。 这种方式的特点是全服玩家共享一个奖池，上面的例子也可以归为此类，只不过奖池机制有些不同。 奖池是彩票或者棋牌游戏中的概念，所有玩家一起打牌，每轮都要下赌资，赌资全部汇集到奖池中，直到某个玩家开牌，牌面最大的玩家得到所有奖池的钱。 游戏抽奖机制也存在这种情况，所有玩家都在一个奖池里抽奖，玩家的每次抽奖相当于 “投入赌资”，只有抽奖次数达到一定水平时才会出现大奖，大奖被一个玩家得到以后，奖池清空，开启下一轮的奖池，以此类推。 所以在某些游戏中，垫子之类的说法存在一定道理，一个服务器里面抽奖的玩家越多，抽到大奖的几率就越高，在鬼区没人抽奖的情况下，甚至有可能抽奖几率为负数。 后文在这里写一下个人的想法。 假如作为开发商，自然希望玩家能多充钱，因为开发商开发游戏的目的很明确就是为了赚钱。 作为游戏制作者，我希望玩家可以体验到更多的游戏内容，而不是靠运气和财富差距造成严重游戏体验偏差。至于钱，目前并没有太大的想法，现在只是单纯的因为喜欢游戏而做游戏，也许以后会为了钱设计坑玩家的套路，但是赚到钱（维持生计）的同时，一定会并行开发一款自己真正想做的游戏（单机游戏）。 作为玩家，希望策划别坑！","categories":[{"name":"游戏日记","slug":"游戏日记","permalink":"https://blog.huotuyouxi.com/categories/%E6%B8%B8%E6%88%8F%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.huotuyouxi.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"猴子都能学会的hexo博客安装教程","slug":"easy-to-start-hexo","date":"2020-03-01T02:49:10.000Z","updated":"2020-03-08T06:54:07.733Z","comments":true,"path":"easy-to-start-hexo/","link":"","permalink":"https://blog.huotuyouxi.com/easy-to-start-hexo/","excerpt":"","text":"hexo 简介hexo 是一款开源博客项目。 即使是小白借助 hexo 也能轻松搭建属于自己的博客。 根据下面的教程，你能学会搭建个人博客，并且其他人可以通过外网访问到你的博客！ hexo 官网：https://hexo.io/ 官方中文文档：https://hexo.io/zh-cn/docs/index.html 【FAQ】 需要买服务器和域名吗？ 通过 Github Pages 可以白嫖域名和服务器，所以不用买。 当然，如果你的钱包预算足够，买一款心仪的域名和自己的服务器那就更完美了！ 话不多说，接下来直接进入教学篇。 准备工作本教程主要基于 Linux 系统，如果是 Window 系统也不用急，只是增加一个配置环境变量的步骤，机智的你一定懂得怎么做！ 代码编辑器：VS Code 基础环境hexo 依赖于 node，首先需要安装 node 环境。 1、安装 NodejsWindows 系统 nodejs 官网下载：https://nodejs.org/zh-cn/download/ 如果确实是小白，建议下载 Windows 安装包 (.msi)，msi 安装包会自动配置环境变量，真正实现小白式操作。 Linux 系统 Linux 版本众多，在这里只介绍 Centos 的安装方法。 第一步：安装 node 相关依赖 1yum install -y gcc gcc-c++ openssl-devel epel-release 第二步：安装 nodejs 1yum install -y nodejs 安装完成后，在控制台输入命令： 1node -v 如果可以看得到版本信息说明安装成功。 安装完 node 之后，即可使用 npm 命令，由于 npm 的源是国外网站，速度会很慢，为了节省时间我们可以更换淘宝提供的镜像。 1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 安装完成后就可以使用 cnpm 命令了，在后续的操作用 cnpm 来代替 npm。 2、安装 GitGit 是代码托管工具，整个过程 Git 的戏份很少，不懂的小白也不用担心，安装好就对了！ Windows：https://git-scm.com/download/win. Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install -y git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install -y git-core Mac 用户请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 3、安装 hexo使用 cnpm 命令一键安装 hexo： 1cnpm install -g hexo-cli 安装完成后，在控制台输入命令： 1hexo 如果看得到如下信息说明安装成功： 1234567891011121314151617Usage: hexo &lt;command&gt;Commands: help Get help on a command. init Create a new Hexo folder. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use &#39;hexo help [command]&#39; for the detailed informationor you can check the docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F; 搭建博客！现在开始搭建博客项目，运行命令： 1hexo init blog 这个 blog 是文件夹的名字，你可以随意取，在这里我把它取名 blog。 执行完这个命令会自动在当前目录下创建一个 blog 文件夹，使用命令 cd blog 进入这个文件夹，接着再执行 cnpm install。 安装完成后，文件夹的目录如下所示： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 需要注意两个主要的配置文件： 1、_config.yml网站的配置信息，比如网站的名字什么的，都在这里进行配置。 2、package.json网站依赖的包（小白不用管这个东西），默认已经帮你配置好常用的包了。 以上，你的博客已经搭建完啦！ 访问博客！什么鬼！？这就搭建完了？？ yes，我们打开控制台，在博客目录下执行命令启动博客： 1hexo s 如图所示： 然后打开浏览器，输入 http://localhost:4000 或 127.0.0.1:4000。 你就可以看到搭建好的博客啦！ 如下图所示： 写下第一篇博文！好吧，其实你的第一篇博客已经被系统写好了，也就是你在上图看到的标题为 Hello World 的博文。 接下来我们要手动创建第一篇博客！ 使用命令 hexo n &lt;博文标题&gt; 来创建一篇新的博文。 控制台下输入： 1hexo n &quot;我的第一篇博客&quot; 执行完命令后，可以看到生成了一个 .md 格式的文件 /blog/source/_posts/我的第一篇博客.md，如下图所示： 这个文件就是我们的博文内容，进入 /blog/source/_posts/ 然后打开 我的第一篇博客.md， 可以看到默认内容类似： 123456---title: 我的第一篇博客date: 2020-03-01 10:49:10tags:--- 开头的部分不要动，在结尾部分写自己想写的文章即可，比如： 12345678910---title: 我的第一篇博客date: 2020-03-01 10:49:10tags:---# 兔子的日记今天的天气真好！ 如果你用的是 Markdown 还能看到预览效果！ Markdown 编辑器推荐：有道云笔记 （你可以在其他地方编辑好文章，然后复制过来） 我用的是 PHPstorm，预览效果如下： 文章内容已经写好了，接下来要生成静态页面，按 Ctrl+C 把刚才启动的博客关掉： 然后依次运行如下命令： 1hexo clean 清空数据库，如图所示： 接着输入 hexo g 重新编译生成静态页面： 1hexo g 运行结果如下： 最后，再启动 hexo： 1hexo s 浏览器输入：127.0.0.1:4000 就可以看到自己刚才写的那篇文章了。 如图所示： 至此，hexo 的基本操作已经 OK 了。 再来总结一下怎么发一篇博文。 1、执行 hexo n &lt;标题&gt; 创建博文文件 2、在 Markdown 编辑器完成博文书写，把内容复制到上面生成的博文文件里 3、执行 hexo clean 清空数据 4、执行 hexo g 重新编译生成静态文件 此外，本地调试用 hexo s 开启本地服务，在浏览器输入 127.0.0.1:4000 访问博客项目。 要记住这些步骤和命令对小白来说十分吃力，这是很正常的事情。 如果忘记了怎么操作，回头多看几遍本博文，熟能生巧！ 自定义主题！默认博客页面太丑，想换一个怎么办？ 网上找到其他人分享的主题：https://github.com/zhvala/hexo-material-x-black 然后把它下载下来，点击右侧 Clone or download： 下载下来并且解压，把解压后的文件复制到博客项目的 themes 目录下。 或者直接 clone 到 themes 目录下并且命名为 material-x： 1git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-material-x themes&#x2F;material-x 主题文件都很大，等下载完成就可以了。 主题下载下来以后，目录结构如下： themes 下面的文件夹都是主题。 接着编辑 .config.yml，拉到底部，修改 theme 字段： 1234# Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: material-x theme 默认是 landscape，改成刚刚下载的主题 material-x（即文件夹的名字）。 然后安装主题所需的依赖： 1npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts 接着执行下面几个命令（如果之前启动了博客项目，记得按 Ctrl+C 先关掉）： 123hexo cleanhexo ghexo s 访问 http://localhost:4000，可以发现主题已经被更换成新的了。 在 Github 上还有更多主题可以选择：点击此处获取更多主题 发布博客！上面的步骤只能在自己的电脑打开博客项目，现在我们要把博客发到外网去，让别人来参观你的博客！ — 小剧场 — 你是想要节操，还是想白嫖域名和服务器？ 我是想要节操还把域名和服务器嫖了！ 嫖不成。 啪一声，你把 300 块大洋拍在桌子上。 这个能不能换来节操？ 能，但是钱包空了。 啪一声，你把节操拍在桌子上，300 块大洋收回兜里。 嫖谁的？ GitHub 的！ 就那个全球最大同性交流社区？ 正是。 敢问君为何方神圣？ GitHub 基佬是也。 — 小剧场（完） — 没错，我们要白嫖 GitHub 提供的免费域名和空间——GitHub Pages！ GitHub Pages 提供了免费的服务可以让我们部署博客项目。 Github：https://github.com/ 注册一个账户并登陆。 接着点击左侧 Repositories 旁边的按钮 New 创建一个新的仓库，如图： 仓库的配置有两点需要注意，如果你没按照下面的要求，你的博客就访问不了： 1、仓库名称必须为：你的 GitHub 用户名.github.io，比如我的 Github 用户名是 huoshaotuzi，那么仓库的名字就是：huoshaotuzi.github.io 2、仓库必须为 Public 公开权限，如果选择 Private，就不能白嫖了，这也是上面的小剧场所说的出卖节操的原因，一旦公开权限，你的仓库 任何人都能访问，你的仓库设置成 Public，相当于你光着屁股暴露在 Github 几百万基佬面前，知道啥意思了吧？ 创建好仓库后，可以看到如下的仓库信息： （xxoo 是随便取的名字，不要问 xxoo 是什么意思，问了也不会告诉你。） 在这里把 SSH 后面的仓库地址复制下来，后面会用到。 接着返回到你博客的目录下，执行命令安装 git 插件： 1cnpm install --save hexo-deployer-git 安装完成后，编辑根目录下的 _config.yml，拉到最底部，deploy 后面添加如下内容： 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;huoshaotuzi&#x2F;xxoo.git（填你自己的） branch: master 这里的 repo 填入上面说的仓库地址： 保存配置文件后，输入命令： 1hexo d 执行命令后开始自动编译并且上传到 GitHub 仓库，然后会提示要输入 Github 的账号跟密码。 为了避免每次上传都要重复输入账号密码，你可以输入下面的命令记住密码： 1git config --global credential.helper store 上传成功后，返回仓库就能看到上传好的代码。 然后就可以通过仓库名称访问到你的博客了！ 我的仓库名称是：huoshaotuzi.github.io 在浏览器输入：huoshaotuzi.github.io 刚刚部署上去的时候，需要等几分钟才能看到博客，不然会出现 404 或者其他问题。 白嫖党只能使用 GitHub 提供的域名，接下来给大家介绍如何指定域名进行访问。 比如我的网站是：blog.huotuyouxi.com 这是怎么实现的呢? 指定域名！首先，你得有一个域名。 万网阿里云、百度云、腾讯云、京东云、华为云、国外的 GoDaddy……诸如此类域名服务提供商，任选一家即可。 建议购买 .com 后缀的域名，域名的名称就按照你自己喜欢的挑选了。 比如张三：zhangsan.com 皮卡丘博客：pikachublog.com 简单好记的域名，这个没什么要求的，选你喜欢的就好。 域名买好之后，在仓库主页的菜单栏，选择 Settings： 拉到下面，直到看到 GitHub Pages，然后点击 Choose a theme 选择一个主题： 主题按照你喜欢的随便选一个就好： 比如选第一个，然后点击右下角 Select theme。 接着返回 Github Pages 配置域名： 在 Custom domain 栏处填写你购买的域名，然后点击 Save。 如果需要启用 https 域名，把 Enforce HTTPS 勾选即可，刚部署时需要等待几分钟 Enforce HTTPS 才会显示可选，并且勾选完成后也需要等待几分钟，Github 会为你免费提供 SSL 证书。 然后打开你购买域名的网站，例如阿里云，登录后打开右上角控制台-点击左上角展开菜单-选择域名： 在域名右侧选择解析： 点击“添加记录”，记录类型 CNAME，主机记录 @，记录值填你自己仓库的名字： 如果你希望可以用 www 访问，那就再添加一条记录，主机记录填 www，其他跟上面的一样： 完成这一步你就可以通过购买的域名访问到博客了！ 指定服务器！不想出卖节操，就买台服务器自己安装环境，这样可以保证代码不被其他基佬看到。 1、域名和服务器的选择选服务器可是很有讲究的，看你网站的受众，如果是面向海外用户，就选国外的服务器；如果面向国内用户，那就买国内的服务器。服务器放在哪很大程度上会影响你网站的打开速度。 再者，如果你选国内服务器，还需要注意域名备案的问题。 想要搭建博客，最好提前买个域名进行备案。 没有备案的域名只能选择国外主机。 只建议购买：com、cn、net 这三个老牌域名。 非主流域名即使能备案，搜索引擎也很难收录，所以不推荐。 有条件或者嫌备案麻烦的，可以购买香港或者台湾地区的服务器，靠近大陆，延迟相对低一点，域名即买即用。 2、服务器环境服务器推荐 Centos 系统，如果是小白也可以选 Windows Server。 要让网站解析到服务器，首先需要安装 Web 服务器，老牌的 Web 服务器软件有 Apache，Windows 的 IIS。 这两个本人几乎没用过，就不在这里介绍了。 推荐使用 Nginx。 以 Centos 为例，安装十分简单： 1yum install -y nginx 安装完成后，执行命令： 1vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;blog.conf 按下 i 键插入如下内容： 12345server &#123; server_name blog.huotuyouxi.com; root &#x2F;var&#x2F;www&#x2F;blog; index index.html;&#125; 然后按 Esc，输入 wq! 保存。 接着重启 Nginx： 1nginx -s reload 在这里，server_name 是你的域名。 root 是你的博客项目路径，可以下载 FileZilla 把博客上传到服务器，或者直接使用 git clone 下来。 12cd &#x2F;var&#x2F;wwwgit clone &lt;你的博客仓库地址&gt; 然后你在哪买的域名，就登录到控制台把域名解析到服务器的公网 IP。 解析的方法在上面已经有介绍了，这里不再重复。 3、更新博客内容 前面的文章介绍了如何编写和更新博客： 123hexo cleanhexo ghexo d 更新博客内容并且推送到 Github 上面，你就可以回到服务器上，然后执行 git pull 把最新的博客内容拉取下来，实现博客的更新。 其中，hexo g 和 hexo d 两个命令可以简写成： 1hexo d -g 有兴趣的可以去了解一下 Git 自动构建，延伸的内容太多了，本文写不下 4、博客代码备份使用 hexo d 上传到 Github 的只是编译后的静态文件，博客的代码并没有上传到仓库里。 这样一旦你的博客代码丢失，你就无法继续更新了。 为了避免这种情况，我们要把博客代码也上传到仓库里，最好是上传到同一个仓库。 回到本地的博客项目，执行如下命令： 12git checkout -b developgit push origin develop 这两个步骤，第一个是切换到新的分支 develop（名字可以随便取），然后把新的分支推送到远程仓库。 如此一来，你的博客代码也被保存至仓库里。 前往 Github 查看，点击 Branch 即可看到新的分支： 还记得最早我们在 _config.yml 设置的 Github 仓库地址吗？ 这里我们把静态文件的分支设置成 master，因此我们可以专注于在 develop 分支上写博文，然后用 hexo d -g 进行推送，不需要进行分支切换，十分方便！ 把博客代码上传到远程仓库，即使你在另一台电脑上面也可以把项目克隆下来，然后执行如下命令： 1git checkout develop 切换到 develop 分支上去写博文。 结语借助 hexo 可以快速搭建属于自己的博客，平时学习到新东西的时候就可以记录下来，养成良好的习惯有助于学习成果的积累。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.huotuyouxi.com/categories/Hexo/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://blog.huotuyouxi.com/tags/gitlab/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.huotuyouxi.com/tags/Hexo/"}]}]}
{"meta":{"title":"火兔博客","subtitle":"火兔兔的小窝","description":"这里是火兔博客，火兔兔的小窝。","author":"火烧兔子","url":"http://huotublog.com","root":"/"},"pages":[],"posts":[{"title":"记录一下最新学到的东西","slug":"2023-news-1","date":"2023-02-15T08:59:06.000Z","updated":"2023-02-16T13:24:55.151Z","comments":true,"path":"2023/02/15/2023-news-1/","link":"","permalink":"http://huotublog.com/2023/02/15/2023-news-1/","excerpt":"","text":"前言原本只打算用一年去做游戏，结果硬是拖了三年，现在总算做出来了，最后还是变成自己一个人在做，真是世事无常大肠包小肠，感兴趣的可以看看实机演示：https://www.bilibili.com/video/BV1XT411f7Pw/ 最近重拾了这个博客，升级了下 hexo 的版本，并且也更换了主题与游戏博客保持一致，又新购了一个域名 huotutu.com，准备搭起来做一个小窝，研究前沿技术的同时顺便可以加入付费功能嘿嘿嘿~ 好了，直接进入正题。 PHP 是最好的语言吗？因为使用 Unity 开发游戏，因此接触了 C#，结果现在重新撸 PHP，发现很不习惯了，比如 PHP 是弱类型语言，这样在编写代码的时候经常会很不规范，传来的值是什么，返回的值是什么都不清楚，就跟开盲盒一样……现在最新的 PHP 已经开始重视这点了，为了更加规范，PHP 也必须要注重变量类型和返回值的声明了。 第二点，PHP 的变量类型比较少，没有 Dictionary（字典），这个类型在开发游戏的时候非常好用，虽然 PHP 可以用关联数值实现相同的效果，但因为上面的第一点，会出现很复杂的情况，比如在 C# 可以用字典这么保存变量，声明一个敌人的模型数据： 1234567891011// 敌人模型数据public class Format_Enemy&#123; public string id; // 敌人的等级 public int level; // 敌人的模型 public string prefab;&#125; 接着，当游戏载入时，读取本地 json 文件，格式如下： 1234[ &#123;&quot;id&quot;: &quot;goblin&quot;, &quot;level&quot;: 1, &quot;prefab&quot;: &quot;Goblin&quot;&#125;, &#123;&quot;id&quot;: &quot;monkey&quot;, &quot;level&quot;: 3, &quot;prefab&quot;: &quot;Monkey&quot;&#125;] enemy.json 文件以数组形式保存 model 类型的变量，接着将敌人数据载入字典： 1234567891011121314151617// 声明一个字典用来存储敌人模型数据Dictionary&lt;string, Format_Enemy&gt; models = new Dictionary&lt;string, Format_Enemy&gt;();// 初始化public void InitLoad()&#123; // 这里是读取json文件的方法 var items = ModelUtil.GetInstance().Load&lt;List&lt;Format_Enemy&gt;&gt;(&quot;enemy&quot;); // 循环将敌人id作为键名保存到字典 foreach (var item in items) &#123; models.Add(item.id, item); &#125; Debug.Log(&quot;敌人模板数据载入完成&quot;);&#125; 调用的时候就非常简单了： 1234var monkey = $models[&quot;monkey&quot;];// 输出monkey敌人的等级Debug.Log(monkey.level); 因为字典是以 key-object 的形式保存数据，通过 model[id] 的形式获得的是一个 object 对象，因而可以直接调用对象的属性，可是 PHP 就不能这么做了，如下为 PHP 的写法： 1234567$enemies = [ &#x27;goblin&#x27; =&gt; [&#x27;id&#x27; =&gt; &#x27;goblin&#x27;, &#x27;level&#x27; =&gt; 1, &#x27;prefab&#x27; =&gt; &#x27;goblin&#x27;], &#x27;monkey&#x27; =&gt; [&#x27;id&#x27; =&gt; &#x27;money&#x27;, &#x27;level&#x27; =&gt; 1, &#x27;prefab&#x27; =&gt; &#x27;money&#x27;],];$monkey = $enemies[&#x27;monkey&#x27;];var_dump($monkey[&#x27;level&#x27;]); 调用方法如出一辙，可是区别在于，PHP 是弱类型的语言，这里的所有数据都是“凭空”输入的，因此在编译器上面无法判断是否出错，而在 C# 有类的约束，可以直接用 . 调出属性，如果有写错的地方，编译器第一时间就会报错。 PHP 的数组没有任何约数，甚至可以直接凭空捏造一个 key： 12$arr[&#x27;abc&#x27;] = 123;var_dump($arr); 上面是一段没有任何问题的 PHP 代码，输出结果是： 1234array(1) &#123; [&quot;abc&quot;]=&gt; int(123)&#125; 不需要任何声明可以凭空调用，这既是优点也是缺点，优点是写起来很方便，缺点是撸代码很不规范，如下所示： 123456789function updateGoods(array $goods)&#123; if ($goods[&#x27;status&#x27;] == true) &#123; // ... 处理逻辑 &#125; $price = $goods[&#x27;price&#x27;]; var_dump($price);&#125; 上面是一个简单的数组调用，通过传入商品数据，在方法内更新商品状态，因为传入的是一个数组（关联数值），数组的键名完全就是凭空写进去的，没有任何约数，不知道的人根本不懂得应该传入什么键名，这样的代码后期无法维护，而当一个方法所需要的参数较多时，应该封装成类作为参数传入： 123456789101112131415class GoodsData&#123; public bool $status; public int $price;&#125;function updateGoods(GoodsData $goods)&#123; if ($goods-&gt;status == true) &#123; // ... 处理逻辑 &#125; $price = $goods-&gt;price; var_dump($price);&#125; 这样才能起到约束作用，没有约束就没有规范，没有规范就难以维护，C# 虽然写起来更舒服一点，但是开发网站还是得 PHP 效率高，光是等编译就能节省一大堆的时间了。 注解注解是新时代编程的主流，PHP 8 也很快就跟上了，所谓的注解，其实就是通过「反射」获取到注释的内容，再通过解析获得想要的结果。先来说一下什么是反射，反射就是程序获取到自身属性的行为，这么说很难理解，看下面的一个例子： 123456789101112/** * 这是一个类 */class TestClass&#123; private string $name; public function test(string $a, int $b): void &#123; var_dump($a, $b); &#125;&#125; 这是 PHP 里面的一个类，有一个 string 类型的私有属性 name，还有一个简单的方法，那么问题来了，我们怎么获取到注释信息？你没看错，我们现在要获取这个类的注释……正常来说，哪有这么奇怪的需求啊？注释不是写给码农看的吗？我们要拿注释做什么呢？关于这个问题，下文会说明，但是先解决眼前的问题——我们到底该如何通过代码拿到注释信息呢？ 我们顶多也就知道如何拿到类的名称，比如 PHP 8 里面最新加入了一个获取类名称的方法： 12345$obj = new TestClass();var_dump(get_debug_type($obj));// 输出结果string(9) &quot;TestClass&quot; 可是老师从来没教过我们怎么获取注释……正确答案是：通过反射机制（Reflection）。反射就是程序获取自身属性的一种行为，不仅是注释，类有哪些属性，哪些方法等等都能给你查的明明白白，通过反射机制，类文件的任何标点符号都不会放过，一切尽收眼底~是不是很兴♂奋？ 首先是类的注释，也就是在类声明上方的注释部分，为了通过反射获取类的注释，需要实例化反射类 ReflectionClass（PHP 自带）： 1234$reflection = new ReflectionClass ( TestClass::class );$ref = $reflection-&gt;getDocComment();var_dump($ref); 输出结果： 123string(26) &quot;/** * 这是一个类 */&quot; 接下来，我们可以来点更“变态”的，我想要拿到类的方法，想知道它的参数名称！ 全部都要看光光！ 123456$reflection = new ReflectionClass (TestClass::class);$res = $reflection-&gt;getMethod(&#x27;test&#x27;);$params = $res-&gt;getParameters();foreach ($params as $param) &#123; var_dump($param-&gt;getType()-&gt;getName() . &#x27;_&#x27; . $param-&gt;getName());&#125; 输出结果： 12string(8) &quot;string_a&quot;string(5) &quot;int_b&quot; 不仅是变量类型，形参的名字都拿到了，这就是反射的神奇之处，它可以获取到自身的属性，同时还可以改变属性的值，例如上面的 name 属性是私有变量，按照我们的常规思想是无法通过调用属性来改变值的，但是通过反射却可以，为了方便演示，增加了一个 show 方法用来输出 name 的值： 123456789class TestClass&#123; private string $name; public function show(): void &#123; var_dump($this-&gt;name); &#125;&#125; 接着，通过反射来修改 name 的值并调用 show 方法查看结果： 1234567891011$obj = new TestClass();$reflection = new ReflectionClass ($obj);$res = $reflection-&gt;getProperty(&#x27;name&#x27;);$res-&gt;setAccessible(true);$res-&gt;setValue($obj, &#x27;abc&#x27;);$obj-&gt;show();// 输出结果string(3) &quot;abc&quot; 神奇吧！！！在无法访问私有变量的情况下，竟然可以通过反射修改私有变量的值。emmm……仔细一想，虽然反射很牛杯，但是我一个只会增删改查的咸鱼，在开发中有什么用呢？完全就是多此一举嘛~ 如果想要修改变量的值，为什么不能直接写个 get-set 方法呢？确实如此，反射在我们日常工作的用途并不大，也不会有多少人接触。反射机制可以获取变量类型、方法名称、参数、注释信息等等，这些在日常处理业务几乎没有作用。但是它在设计框架、构筑开发流程中非常重要！就好比我们日常基本接触不到设计模式，可设计模式却是框架的核心。而现代的主流框架已经开始利用反射机制实现独特的开发方式，现在很热门的“依赖注入”就是通过反射实现的，比如下面这段代码： 1234567891011121314151617class TestController&#123; private TestService $service; public function __construct() &#123; $this-&gt;service = new TestService(); &#125;&#125;class TestService&#123; public function show(): void &#123; var_dump(&#x27;hell world&#x27;); &#125;&#125; 现在有一个 TestService 类，我们想在 TestController 调用，需要手动 new 的方式在构造方法进行赋值，但是在 Laravel 框架里，却可以这样： 123456789class TestController&#123; private TestService $service; public function __construct(TestService $service) &#123; $this-&gt;service = $service; &#125;&#125; 看到了吗？现在不需要手动 new 创建对象了，因为当你在构造方法里设置了一个参数，在 Laravel 框架的作用下就会自动实例化这个对象进行赋值，这就叫做依赖注入，正如其名，你需要的“依赖”会被框架“注入”。 你可能会说，这不就是少写了一段代码吗？实际上，别看着小小的变化，却涉及到整个编程流程方式的改变。 一个基本控制器如下，内有一个 index 方法： 1234567891011121314class TestController&#123; private TestService $service; public function __construct(TestService $service) &#123; $this-&gt;service = $service; &#125; public function index(Request $request) &#123; $params = $request-&gt;all(); &#125;&#125; 这个方法通过依赖注入获取到了 Request 对象，而在 Laravel 中，这个对象保存了请求的信息，我们可以直接从这个对象获取到所有请求参数，是不是很方便？这样做既让编程更加“优雅”，同时也减少了系统之间的耦合度。 依赖注入是框架帮你实现的，上面我介绍了反射的原理，你完全可以自己写一个依赖注入来试试~ 框架并不是简单的函数封装，而是提供一个编程的环境。 依赖注入和控制反转，还有反射……一大堆新的名词，老实说我十分反感，如果不能把复杂的问题简单的讲述，那说明理解不到位，或者故意把简单的说成复杂的，搞得好像很高大上一样，说的就是金融行业……如果你是初次看到这些名词，不用担心，因为你现在已经学 废 会了。 我不推荐你去搜这些专有名词啥意思，因为看完你会更懵逼——by 傻瓜式编程指南（兔兔著） 现在你已经知道了，依赖注入就是框架帮你注♂入一些东西，比如你想要的类的对象，只要写在方法的形参上，框架就会帮你实例化，你直接调用就完事。请参考 N 年之前我写的火兔引擎（开发框架），我在设计框架的时候就已经明确了目标：编程的最高境界是“无码”。 换句话说，除非你是非常喜欢写代码的人（高情商），否则，框架会自动帮你处理很多琐碎的事情，因此你不需要写太多的代码。市面上的 PHP 框架多如牛毛，什么阿猫阿狗阿兔都想“自创框架”，比如大名鼎鼎的 Fire Rabbit Engine，就是阿兔本兔原创的框架。 学习一门新的框架要不少时间成本，要我说的话，对大部分人来说，框架只要选择开发起来“舒服”的就行了，大部分情况下都不需要注意性能问题，小公司注重的是开发效率，指不定过完年公司就倒闭了 233，我以前上班的时候就是一个“项目杀手”，做一个项目死一个，入职一年，弄死的项目少则三个，多则五个！ 其实是因为老板自己都不知道想干嘛就胡乱尝试，今天刚废了一个项目，第二天又看上新的东西，脑袋一热一拍屁股就决定要开发新项目了，很荣幸……当时的技术主管全丢给我了。最后，我离职了，原因是给的钱不多吗？不是，那个时候我才刚刚毕业，并不看重钱，而是每个项目都是我在负责，就好像辛辛苦苦养大的孩子突然夭折了……说多了都是泪。 所以，当一个项目立项的时候，如果负责人非得选用性能最好，开发舒适度最烂的时候，应该想想，这是不是一种傲慢，自信的认为这个项目一定能成功呢？小公司根本不在乎性能，只要快速构建项目，快速上线才是王道！尤其是老板催你进度的时候，那跟催命似的，到时候后悔就来不及了。 回归主题，接下来开始介绍什么是“注解”。注解其实就是注释的一种，原本注释是给人看的。现在，一些走在时尚前端的码农研究出了新的花活——让程序也能看注释。 例如 Java 里面有这种代码： 123@Override@Deprecated@SuppressWarnings 下面是我网上 copy 来的冒泡排序： 12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 直接在方法上方加了一个 @Override，这个就是注解，它的作用是检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 这股时尚的潮流也 内 卷到 PHP 那边去了，于是，主打注解开发为亮点的 PHP 框架陆续出现，前有 Swoft，后有 Hyperf，Hyperf 的作者好像之前就是 Swoft 里的，后来单飞了，当然也有很多吃瓜事件，咱也不了解，至于为什么选择 Hyperf 而不是 Swoft，主要还是因为我个人对 Laravel 的偏爱，Hyperf 的代码几乎跟 Laravel 完全相似，相当于 Swoole 版的 Laravel，关于吃瓜问题就不多展开，技术本身无好坏，唯有人。本人也不了解真相就不多说了，看下面的代码： 123456789101112131415161718192021&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\AutoController;/** * @AutoController() */class IndexController&#123; // Hyperf 会自动为此方法生成一个 /index/index 的路由，允许通过 GET 或 POST 方式请求 public function index(RequestInterface $request) &#123; // 从请求中获得 id 参数 $id = $request-&gt;input(&#x27;id&#x27;, 1); return (string)$id; &#125;&#125; 通过写注释的方式来定义路由，是不是很新鲜？除此之外，注解也可以实现上面提到的依赖注入，比如我们需要一个类的实例： 123456789101112131415161718/** * @AutoController() */class IndexController&#123; /** * @Inject() * @var UserService */ private $userService; // /index/info public function info(RequestInterface $request) &#123; $id = $request-&gt;input(&#x27;id&#x27;, 1); return $this-&gt;userService-&gt;getInfoById((int)$id); &#125;&#125; 现在只要加入一个 Inject 注解，并且用 var 来声明变量的类型，框架就会自动为你注♂入这个类的实例，在 PHP 8 以前，注解都是非官方的，只是民间通过反射机制实现了 JAVA 类似的注解，如下所示： 12345/** * @param Foo $argument * @see https:/xxxxxxxx/xxxx/xxx.html */ function dummy($Foo) &#123;&#125; 而且这种注解一般没有什么实际的意义，就是一种人为的规定，比如 @param 我们视为一个参数，当然你也可以写成 @canshu，这都是可以的，因为这就是一个注释而已，注释在程序中不会被认为是代码，你怎么写都可以。 然后自己再写一个解析注释的代码： 123$ref = new ReflectionFunction(&quot;dummy&quot;);$doc = $ref-&gt;getDocComment();$see = substr($doc, strpos($doc, &quot;@see&quot;) + strlen(&quot;@see &quot;)); 上面是 PHP 最早的民间注解实现原理，而第一次尝试用注解作为开发的 Hyperf 框架很快就流行起来，习惯了这种开发方式会变得很愉♂悦，直到 PHP 8 开始，官方实现了 PHP 的注解： 123#[Params(&quot;Foo&quot;, &quot;argument&quot;)]#[See(&quot;https://xxxxxxxx/xxxx/xxx.html&quot;)]function dummy($argument) &#123;&#125; 简单地说：注释（comment）是给人看的，程序看不懂；注解（annotation）既是给人看的，程序也看得懂。 我们可以通过注解实现依赖注入等许多功能，人有多大胆，地有多大产，Hyperf 的做法属实是一种大胆的尝试了，无论是路由、控制器、中间件等等，都可以用注解的方式书写。 以前我最喜欢的是 Laravel 框架，而现在 Hyperf 是基于 swoole 的框架，而且框架的设计者应该也是 Laravel 的重度爱好者，从 Laravel 转 Hyperf 几乎没有任何学习成本，最新的火兔小窝（huotutu.com）将使用 v3.0 版本开发~ 好了，以上就是关于注解的说明，注解（Annotation）并不属于程序的代码，而是一种开发方式，就是通过特殊的格式定义注释，好让系统看得懂，因为注解的存在，注释也变成了一种开发方式，经典例子就是 Hyperf 框架。 框架并不是简单的函数封装，选择什么框架开发项目就决定了你的开发方式，开发方式是由框架设计者决定的，Hyperf 框架也不过是 swoole 框架的一个可选方案，只是因为我喜欢 Laravel 的开发方式，所以选择它。 可以缩减写代码工作量的框架都是好框架，现在 ChatGPT 火爆，甚至还能帮你写代码，以后说不定还会被 AI 取代。 协程双叒叕是一个令人头痛的新名词！先让我们来看摊煎饼的数学问题，假设一个锅每次只能摊两个煎饼，煎饼要求两面摊到金黄，单面摊到金黄需要 1 分钟，现在有三张饼要摊，请问把三张饼摊到两面金黄需要多久？ 正常人的思维：先弄 A 和 B 两张饼，两面都金黄一共需要 2 分钟，接着再下 C，两面金黄又需要 2 分钟，总计需要 4 分钟。 机智的人可能发现问题了，A 和 B 在锅里的时候，C 是空闲的，当 A 和 B 摊熟了，C 一个饼占了整个锅（一个锅是可以放两张饼的），那是不是有点浪费资源了？于是，聪明的人就有了新的方法： 第一分钟，A 和 B 下锅，把一面摊到金黄，接着把 B 拿出来放到一旁，把 C 下锅；第二分钟，A 两面全熟拿起来放到盘子，再把 B 翻过来继续摊，接着把刚才摊了一面的 B 下锅；第三分钟，BC 两面全熟，收锅关火！ 同样的锅，同样是三张饼，用这种方法竟然节约了 1 分钟！这是因为锅一直都是保持两张饼，而第一种方法，锅会出现空闲状态，原本能同时摊两张饼，却只摊了一张，这就是浪费时间的因素。 所谓的协程就是这种原理，最大化的利用程序的效率，锅就是服务器，为了把服务器的性能榨干就不能让它闲着，要永远让它“干活”。要知道，程序的执行速度是不同的，有的程序执行起来很慢（如读取 Excel），有的很快（给变量赋值），我们都知道程序是从上至下执行的，前面的代码没执行完毕，后面的代码就会一直处于等待状态，这就是浪费“资源”，就像上面的锅一样，原本可以同时摊两张饼，可一张饼占了整个锅，效率自然就低了。 例如 PHP 代码： 12echo &#x27;hello&#x27;;echo &#x27;world&#x27;; 这段代码为什么永远都是按顺序输出 hello 和 world 呢？正是因为程序是自上而下执行的，而且这两段代码执行速度很快，所以瞬间就输出完毕了，接着我们再模拟一下，代码执行慢的情况： 12345678910111213function loadFile()&#123; echo &#x27;hello&#x27;; sleep(1);&#125;function sayWorld()&#123; echo &#x27;world&#x27;;&#125;loadFile();sayWorld(); 这段代码同样是输出两个单词，但是会发现因为 sleep 的存在，第一个 hello 输出完毕之后等了一秒才输出 world，两个单词的输出顺序依然没变，这是因为程序无论如何都是从上往下执行的，而这种「等待」完全就是不必要的，两个函数没有任何关联，为什么不能先让下面的代码进行输出呢？ 就好比医院挂号，按照 1、2、3、4、5 顺序排列，1 号第一个进入窗口办理，很快就办完了，接下来轮到 2 号，可他身份证忘记带了，就打电话叫家人送过来，那么此时问题来了……现在确实是轮到 2 号办理手续，但是等他家人送身份证过来要半小时，后面的 3~5 号以及办理挂号的工作人员就这么干等着吗？那是不是可以通融一下，在 2 号的身份证送来之前，先让后面的人办理？等身份证到了，再让 2 号继续办理也不迟呀！ 正常的程序可不会这么“通情达理”，程序是一定严格按照从上至下的顺序执行的，2 号蛮横的说：现在轮到我挂号，我没办完，凭什么让你们先办啊？所以此时必须等到 2 号身份证送来，后面的 3~5 号才能继续办理。 谁排到队谁就拥有“挂号权”，轮到 2 号挂号了，医院又没规定挂号的最大时间，那么自然 2 号有权等到自己身份证送来，后面的人就是得干等着没办法，虽然不通人情，但这也无可奈何，因为程序可不知道你下面的代码是不是跟上面的有关，万一执行顺序乱了就报错啦~ 协程就是这个问题的解决方案：让你决定程序的控制权。程序不知道该不该先让后面的代码执行，可是你知道呀！那交给你来控制不就完事了吗？ 先来说一个 PHP 的关键词 yield，这个关键词并不是协程，而是用来生成迭代器（又叫生成器）的，迭代器就是一个能够被循环的对象，如果理解不了就直接认为是一个数组就好，例如下面这样： 1234$items = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];foreach ($items as $item) &#123; var_dump($item);&#125; 不只是数组，只要实现了迭代器接口（Iterator）的类都可以被 foreach 循环，下面尝试自定义一个迭代器（注意，PHP 8.1 不支持）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Rabbit implements Iterator&#123; // 这里我定义了一个 int 类型的指数物，用来标记当前进度，类似数组的下标 private int $pos; public function __construct() &#123; $this-&gt;pos = 0; &#125; // 当前返回的值 public function current() &#123; return $this-&gt;pos; &#125; // 将指数物向下移动一位，在foreach中每次调用都会前进一次 public function next() &#123; $this-&gt;pos++; &#125; // 迭代器的key（类似关联数值的键名） public function key() &#123; return $this-&gt;pos; &#125; // 判断是否可以继续向下执行，如果数据已经没了，就返回false，这里小于10是随便写的，让它打印0~10个数 public function valid() &#123; return $this-&gt;pos &lt;= 10; &#125; // 重置指数物，该方法在迭代器执行一次就无法调用，否则报错 public function rewind() &#123; $this-&gt;pos = 0; &#125;&#125;$rabbit = new Rabbit();foreach ($rabbit as $item) &#123; var_dump($item);&#125; 上面我定义了一个迭代器 Rabbit，通过 foreach 循环依次输出 0~10。任何类只要实现了 Iterator 迭代器接口就可以被 foreach 循环输出，接着我们的主角 yield 关键词要出现了： 1234567891011function rabbit()&#123; for ($i = 0; $i &lt;= 10; $i++) &#123; yield $i; &#125;&#125;$items = rabbit();foreach ($items as $item) &#123; var_dump($item);&#125; 上面的结果也是依次输出 0~10，这就是 yield 关键词的作用，它看起来像是 return，但又不全是，因为 return 一旦返回函数就会结束，而 yield 返回了数字，但却没有退出函数，不仅如此，yield 的返回值是一个可以被循环体调用的迭代器。 接着再看有意思的一组数据，我们稍加修改代码： 12345678910111213function rabbit()&#123; for ($i = 0; $i &lt;= 10; $i++) &#123; var_dump(&#x27;a&#x27; . $i); yield $i; var_dump(&#x27;b&#x27; . $i); &#125;&#125;$items = rabbit();foreach ($items as $item) &#123; var_dump($item);&#125; 在 yield 关键词上面和下面分别进行输出，我们再运行一次查看结果： 123456789101112131415161718192021222324252627282930313233string(2) &quot;a0&quot;int(0)string(2) &quot;b0&quot;string(2) &quot;a1&quot;int(1)string(2) &quot;b1&quot;string(2) &quot;a2&quot;int(2)string(2) &quot;b2&quot;string(2) &quot;a3&quot;int(3)string(2) &quot;b3&quot;string(2) &quot;a4&quot;int(4)string(2) &quot;b4&quot;string(2) &quot;a5&quot;int(5)string(2) &quot;b5&quot;string(2) &quot;a6&quot;int(6)string(2) &quot;b6&quot;string(2) &quot;a7&quot;int(7)string(2) &quot;b7&quot;string(2) &quot;a8&quot;int(8)string(2) &quot;b8&quot;string(2) &quot;a9&quot;int(9)string(2) &quot;b9&quot;string(3) &quot;a10&quot;int(10)string(3) &quot;b10&quot; 这里发现了奇怪的地方： 123string(2) &quot;a0&quot;int(0)string(2) &quot;b0&quot; 我们的循环体是这样的： 12345for ($i = 0; $i &lt;= 10; $i++) &#123; var_dump(&#x27;a&#x27; . $i); yield $i; var_dump(&#x27;b&#x27; . $i);&#125; 如果按照程序从上往下执行的观点，难道不是应该输出： 123string(2) &quot;a0&quot;string(2) &quot;b0&quot;int(0) 这样才对吗？可为什么却先跳到： 1234$items = rabbit();foreach ($items as $item) &#123; var_dump($item); // 这个地方输出 int(0)&#125; 也就是说，程序是先返回了 0 这个数，接着再执行下面的 var_dump 输出 b，因为 yield 的存在导致程序的执行顺序发生了变化，接着继续演示 yield 是如何手动控制执行顺序的： 12345678910111213141516171819202122232425function action_1()&#123; var_dump(&#x27;action_1_1&#x27;); yield; var_dump(&#x27;action_1_2&#x27;);&#125;function action_2()&#123; var_dump(&#x27;action_2_1&#x27;); yield; var_dump(&#x27;action_2_2&#x27;);&#125;$action_1 = action_1();$action_2 = action_1();$action_1-&gt;current();$action_2-&gt;current();var_dump(&#x27;ok&#x27;);$action_1-&gt;next();$action_2-&gt;next(); 上面有两个函数 action_1 和 action_2，通常情况下，如果没有 yield 关键词： 12var_dump(&#x27;action_1_1&#x27;);var_dump(&#x27;action_1_2&#x27;); 这段代码会一股脑的全部输出，但是因为有了 yield 关键词，我们就可以手动调用 next 方法让它往下执行，如果你不调用 next，那它就会在 yield 处返回，不再往下执行。 结果输出： 12345string(10) &quot;action_1_1&quot;string(10) &quot;action_1_1&quot;string(2) &quot;ok&quot;string(10) &quot;action_1_2&quot;string(10) &quot;action_1_2&quot; 可以发现，因为 yield 返回的是一个生成器，倘若我们执行了 next 方法，它才会继续向下执行，否则，它就会“卡”在 yield 的地方，这就是我们可以手动调控程序执行顺序的原因了。 换句话说，yield 就跟断点一样，我们想让程序在哪停下，就在哪用 yield 返回就行了，但是与 return 不同的是 yield 返回的是控制权，并不是让程序中断，这是利用了 yield 返回的是一个迭代器的原理实现的。 协程与多线程很容易混淆，我们会误以为是不是用 yield 改变了控制权，程序就可以不会再阻塞执行了呢？如下所示： 1234567891011121314function test()&#123; var_dump(&#x27;1&#x27;); sleep(3); yield; var_dump(&#x27;2&#x27;); yield; var_dump(&#x27;3&#x27;);&#125;$test = test();$test-&gt;current();$test-&gt;next();$test-&gt;next(); 结果我们发现，在输出第一个“1”的时候，程序还是卡了 3 秒才继续输出，换句话说，这个代码依然是同步执行的，上面的代码如果不执行完毕，还是会卡在执行过程，那这个 yield 到底有什么用呢？它还不是卡住了吗？ 回到摊煎饼的问题，现在只有一口锅，一口锅最多每次只能摊两个煎饼，那么为了提高效率，可以按照上面三分钟的摊法，还有一种方法——再多加一口锅，两口锅就可以同时摊 4 个煎饼了！ 再加一口锅即代表多线程，「协程」不是多线程，这两者很容易混淆，多线程是再切出一条线程处理程序，而「协程」还是在那个线程，只是我们通过任务调度的方式提高执行效率，还是那条线程，还是原来的味道！ 多线程是利用 CPU 多线程处理任务的优势，而协程是将单个线程的性能压榨到极致。 那么这个 yield 到底哪里神奇了啊？它本身就是在一个线程里面执行的，它的作用只是对程序进行“调度”而已，并不能解决程序阻塞问题。 正如上面的例子，多线程是加了一口锅，而协程是合理的利用这口锅，使它保持着最高效率——同时摊两个饼！用多线程可以解决效率低下的问题，那为什么还要协程呢？ 线程本身就是一种资源，协程就是最大化利用这条线程的性能，一口锅明明可以同时摊两个煎饼，为什么非要再开一个新锅呢？诚然，摊一个煎饼两面金黄要 2 分钟，摊三个煎饼，只要你拿出三口锅，时间就缩短到了 2 分钟了，岂不是比 3 分钟还快？那你家里可能有矿才能这么霍霍…… 这就是痛点所在了：协程就是为了解决资源利不充分的问题。 利用协程的特性可以让锅一直都在摊饼，能同时摊两张，那就一定同时摊两张，一刻都不许闲着，像极了煤老板压榨矿工。为了实现这个“监工”需要一个名为“调度器”的东西，调度器的作用就是依次执行所有协程任务，直到所有协程任务结束了，调度器才结束： 123456789101112131415161718function create_task($max)&#123; for ($i = 0; $i &lt; $max; $i++) &#123; yield $i; &#125;&#125;$task1 = create_task(3);$task2 = create_task(5);do &#123; var_dump($task1-&gt;current()); var_dump($task2-&gt;current()); $task1-&gt;next(); $task2-&gt;next();&#125; while ($task1-&gt;valid() || $task2-&gt;valid()); 上面的例子中，create_task 创建了两个数值不等的任务，所谓调度器其实就是 do-while 循环体，valid 方法判断这个任务是否结束，如果两个任务全部结束才跳出这个循环（调度器），但是因为我们给这两个任务不同的最大值，导致两个任务执行的次数不一样，第一个任务只返回 3 个值，第二个任务却返回了 5 个值，最后输出结果如下： 12345678910int(0)int(0)int(1)int(1)int(2)int(2)NULLint(3)NULLint(4) 前面三个数字，两个任务输出一模一样的结果，但是第一个任务从第四个数字开始就返回 Null 了，这是因为这个任务已经结束了，所以不再有新的返回值。同理，如果再添加任务三、任务四……那么这个调度器依然是依次执行所有任务，直到任务全部结束才跳出循环。 这就是协程的全部概念了……也就是说，协程是通过调度器实现依次执行全部的任务，这些任务绝对是不能阻塞进程的！否则任务阻塞了，后面的也得等在那边，所以如果使用协程，一定不能使用阻塞的代码，否则跟没用一样，协程的作用就是：把所有的煎饼都摊在锅里，这个锅能同时摊多少个煎饼，它就往里面塞多少个煎饼，而且雨露均沾，每个煎饼都只摊 1 秒，然后以迅雷不及掩耳之势换下一个煎饼，就这样，每个煎饼每次只摊 1 秒，直到全部的煎饼两面金黄为止。 上面的 1 秒只是一个比喻，实际上程序的运行速度比这个快多了。 协程的作用是控制程序的执行权限，通过权限转移的方式结合死循环（调度器）让每个任务每次循环都运行一次，直到所有任务结束才退出循环。 上面的调度器也是举个栗子罢了，实际的调度器会优化性能，比方说上面 3 次循环结束了，后面全部都是 NULL，实际上应该把已经完成的任务从循环体去掉，避免重复执行节约性能，这里就不对调度器详细展开了。 关于协程，我也是搞得很懵逼，最开始以为它跟多线程异步处理一样，就是把一些费时的任务切出去，然后执行下一段代码，其实并不是，如果两者混淆就理解不了协程了，协程……并不是异步处理，它也不是什么程序代码，它只是一种控制权转移。 协程的调度器其实是利用协程的控制权转移让所有的代码放到一块轮番切换执行，直到全部的代码执行完成。它本身就是一段阻塞程序（用死循环来实现调度器，任务不全部结束就跳不出这个死循环），它只是在循环执行这些任务罢了。 协程本身并不是为你提供异步环境，它就是一个执行权限的转移而已，而它之所以能够异步执行……是因为你写的代码是异步的啊，不是协程的调度器是异步的，你写了异步代码，它就异步执行，你写的不是异步代码，它就会阻塞，只要把这个搞清楚就不会懵逼了。 就跟打扑克一样，发牌的人每次都给在座的各位发一张扑克，直到所有玩家手牌满了才会停下，这就是协程的调度器，每次都只执行一次任务，然后遇到 yield 就立即切换到下一个任务，直到所有任务全部完成，这里的 yield 实现协程是 PHP 系统自带的，如果想要通过第三方实现，可以安装 swoole 扩展。 AOP（面向切面编程）关于协程就抛到一边吧，因为理解起来很不容易，写完协程现在都凌晨一点半了，接下来看轻松一点的 AOP 编程，这也是现在很热门的编程思想，它就跟 OOP（面向对象编程）一样是现在广大码农喜欢的新理念。 切面（Aspect）是一个新的名词，理解起来非常简单，火腿肠吃过吧？现在我们有一根很♂粗的火腿肠，用刀从中间切开，然后塞一粒玉米进去，现在它就变成玉米热狗肠了！ 真特喵的黑心，一粒玉米也敢叫玉米肠？ 好了，结束，这就是面向切面编程。用刀切开火腿肠，一刀两断，火腿肠赤果果的肉体的展示在你的面前，形成了两个完美的 Aspect（切面）。面向切面编程，就是向这个切开的面塞入一粒玉米。 我们可以从任何地方切开火腿肠，在任何切面塞入玉米，甚至辣椒等等。面向切面编程可以理解成「嵌入式」代码，你写一段代码，然后嵌入到任何其他代码里面。 PHP 里面有一个 trait 可以复用代码，但这并不是切面，这只是复用代码，切面编程一定存在『拦截』。 其实你早就用过 AOP 编程了，举个栗子就是 Laravel 的中间件，中间件会「拦截」请求，满足条件才进入下一步操作，如果不满足条件，那就 403 Forbidden，或者其他什么，总之，你通过中间件拦截请求，判断是否满足条件的这种行为就已经是面向切面编程了。 第二个栗子，如果你是前端开发，那么应该用过 Vue 框架，生命周期函数应该知道，就是那个什么 beforeCreate、created 之类的东西，如果你是 Unity 开发，那么也知道 Monobehaviour 也有生命周期函数，如 Awake、Start 等等，生命周期函数就是 AOP 的理念。 AOP 编程的核心理念就是「拦截请求」，通俗的说就是 “当 xxx 时，做 xxx”，这就是 AOP 编程的核心思想了，如下面一个更新用户积分的例子： 123456789class UserController&#123; public function update() &#123; $params = request()-&gt;all(); $model = User::find($params[&#x27;id&#x27;]); $model-&gt;update([&#x27;score&#x27; =&gt; $params[&#x27;score&#x27;]]); &#125;&#125; 该控制器提供了一个更新用户积分的方法，只要传来 id 和 score 分数参数就能找到对应的用户并且更新积分，但这样有不少问题，首先没有任何权限验证，岂不是人人都可以利用这个接口来改自己的分数？第二个，积分流水没有任何记录，万一以后跟用户产生纠纷怎么办？为了解决这个问题（先别想中间件的事情），我们需要进行如下两项改动： 1、对权限进行验证，只有管理员才能更新用户数据2、对积分流水进行记录 首先假设有一个 checkAdmin 方法，用来判断是否是管理员，该方法只需要传入一个 jwt-token 参数，如果是管理员就返回 true，否则返回 false，还有一个方法 saveLog 用来保存积分流水： 123456789101112131415161718192021222324252627282930class UserController&#123; public function update() &#123; $params = request()-&gt;all(); if (!$this-&gt;checkAdmin($params[&#x27;token&#x27;])) &#123; return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;没有修改权限&#x27;]); &#125; $model = User::find($params[&#x27;id&#x27;]); $model-&gt;update([&#x27;score&#x27; =&gt; $params[&#x27;score&#x27;]]); saveLog($params[&#x27;id&#x27;], $model-&gt;score); return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;修改成功&#x27;]); &#125; function saveLog($userID, $score) &#123; ScoreLog::create([&#x27;user_id&#x27; =&gt; $userID, &#x27;score&#x27; =&gt; $score]); &#125; function checkAdmin($jwtToken) &#123; // ... 此处省略逻辑 return true; &#125;&#125; 现在看起来安全多了，接下来，如果有一个修改用户所属用户组的接口： 12345678910public function changeGroup()&#123; $params = request()-&gt;all(); if (!$this-&gt;checkAdmin($params[&#x27;token&#x27;])) &#123; return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;没有修改权限&#x27;]); &#125; // ...逻辑代码省略&#125; 又得判断一次权限……很是繁琐，现在毫无疑问你会说出用中间件消灭这些重复的代码。没错，中间件处理权限验证是非常方便的，所有需要验证权限的请求先经过中间件，通过中间件过滤不符合条件的请求。 中间件就是一个嵌入式的代码，当请求进来的时候，为什么不会直接进入到控制器呢？因为 Laravel 框架对请求进行了拦截，只有通过你设定的中间件请求才会进入 Controller，否则就过滤掉，如果用生命周期来形容，就是 before 阶段就进行了处理，请求还没进入 Controller 就先被过滤掉了！ Laravel 的中间件如何实现拦截请求可以看我开发 FireRabbitEngine 的相关文章 中间件拦截不符合要求的请求，这就是通过切面“嵌入”一段代码，只要封装一个拦截器就可以实现这个功能了，但实际上拦截请求有很多种方式，接下来以 Hyperf 为例，演示如何通过切面的方式执行设计好的代码，假设有一个控制器： 12345678#[AutoController(prefix: &#x27;/test&#x27;)]class TestController&#123; public function test() &#123; return &#x27;test&#x27;; &#125;&#125; 现在我们要在这个控制器中嵌入其他代码，只需要声明一个切面： 12345678910111213#[Aspect]class TestAspect extends AbstractAspect&#123; public array $classes = [ &#x27;App\\Controller\\Front\\TestController::test&#x27; ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; var_dump(&#x27;insert&#x27;); return $proceedingJoinPoint-&gt;process(); &#125;&#125; 在 classes 数组内加入想要插入的控制器方法，在 process 方法里面写入想要插入的代码，这段代码会在访问 /test 路由的时候一并被执行，注意，这里一定要返回： 1return $proceedingJoinPoint-&gt;process(); 这段代码是返回原控制器的处理结果，它跟 Laravel 的中间件几乎一模一样，如果你嵌入了多个切面，那么必须要全部返回，只要有一个没有返回程序就不会继续执行。 Hyperf 是以注解的方式开发的，我们还可以用注解的方式插入切面，声明一个注解，该注解还带有一个参数，参数在后面可以获取到： 12345678namespace App\\Annotation;use Hyperf\\Di\\Annotation\\AbstractAnnotation;#[\\Attribute] class TestAnnotation extends AbstractAnnotation&#123; public string $val;&#125; 接着修改切面，把 classes 注释掉，改用注解的方式： 12345678910111213141516171819class TestAspect extends AbstractAspect&#123; public array $classes = [// &#x27;App\\Controller\\Front\\TestController::test&#x27; ]; public array $annotations = [ TestAnnotation::class, ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; // 这里拿到注解传来的参数 $val = $proceedingJoinPoint-&gt;getAnnotationMetadata()-&gt;method[TestAnnotation::class]; var_dump($val-&gt;val); return $proceedingJoinPoint-&gt;process(); &#125;&#125; 接着返回控制器，在想要嵌入的地方插入注解即可： 12345678#[TestAnnotation(val: &#x27;kkk&#x27;)]public function test()&#123; $res = &#x27;test-value&#x27;; var_dump(&#x27;controller&#x27;); return $res;&#125; 这样就完成了，在切面里也可以拿到 val 的值。 关于切面有几个注意的地方，process 方法只会执行一次，所以不用担心如果有多个切面会重复执行的问题，放心大胆的 return 即可，第二点，classes 和注解的方式只要写一个即可，我个人比较偏向于用注解的方法，第三，被切入的地方，可以通过 ProceedingJoinPoint $proceedingJoinPoint 变量获取其他数据，比如方法的参数： 12$params = $proceedingJoinPoint-&gt;getArguments();var_dump($params); 那么 AOP 到底有什么用呢？它就是一种编程理念而已，正如最开始说的那样，这只是决定了你开发方式，AOP 可以帮你节省很多重复的劳动，节约时间就是节约生命~中间件就是最好的例子，除此之外，一些数据库的更新操作，记录日志操作也可以用面向切面编程实现，因为这些都是重复性的劳动，全部交给框架去办才是正解。 除此之外，上面的代码几乎没有任何耦合，从而变得十分简洁优雅~ 管道管道（Pipeline）就是因为像水管一样，从水管的这头输入一滴水，经过管道拐来拐去，最后流到你家里，这个过程呢，这滴水可能与其他管道流进来的水混合在一起，你最后得到的这滴水是混合了很多次的水。 去年冬奥会冰墩墩火到爆，如果你没看过冰墩墩的制作过程，那么我在这里科普一下，冰墩墩陶瓷版是全手工制作的，第一道工序就是烧陶瓷了，用模板烧出冰墩墩的模样，烧好的冰墩墩是就是个模具生产出来的粘土人而已，没有任何色彩，因此进入第二道工序，上色！冰墩墩的本体是熊猫，因此只要黑白两种颜色，用毛笔蘸一点颜料慢慢涂满整个冰墩墩，白色的身体，黑色的手手和眼睛鼻子，到这里第二道工序就完成了，涂了色的冰墩墩接下来要送到第三道工序——贴眼睛，眼睛是用贴片式的，把提前准备好的眼睛贴片沾到冰墩墩眼睛处即可，这样第三道工序也完成了，最后一道工序就是给冰墩墩套上宇航员外壳，ok，整个流程结束，冰墩墩制作完成。 现在让我们捋一捋，烧好的冰墩墩陶瓷是原始对象，送到 1~4 道工序加工后变成了一个成品的冰墩墩，用户拿到手的就是加工好的冰墩墩，这个制作流程就叫做「管道」，通过这个管道设计，输入一只无色陶瓷冰墩墩，经过管道出来的就是一只上好色的成品冰墩墩。 管道的理念是从 Unix 系统出来的，比如查看日志的命令： 1tail -n 300 text.log 上面的命令会查询最新的 300 行日志，但是日志记录的内容太多了，我们如果想要某些关键词，比如 rabbit，可以用： 1tail -n 300 text.log |grep rabbit 上述代码就会从日志最新的 300 行里过滤出包含 rabbit 关键词的行数，这其实就是一个链式调用，像 javascript 里面的 axios 可以通过如下调用方式： 123456789axios.get(&#x27;/user&#x27;, &#123;params: &#123; ID: 12345&#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 这段代码表示发起一个 ajax 请求，当返回响应的时候，执行 then 的代码，如果执行过程发生异常就执行 catch 的代码，那么为什么可以用链式调用呢？其实很简单，就是让方法的返回值返回自身即可，用 PHP 来实现： 1234567891011121314151617181920212223class TestClass&#123; private string $content; public function __construct(string $content) &#123; $this-&gt;content = $content; &#125; public function add(string $newStr): TestClass &#123; $this-&gt;content .= $newStr; return $this; &#125; public function show() &#123; var_dump($this-&gt;content); &#125;&#125;$test = new TestClass(&#x27;abc&#x27;);$test-&gt;add(&#x27;e&#x27;)-&gt;add(&#x27;f&#x27;)-&gt;add(&#x27;g&#x27;)-&gt;show(); 输出结果为： 1string(6) &quot;abcefg&quot; 上面演示了最简单的链式调用，当一个对象的方法返回值是自身时，那么是不是可以继续调用其他方法？这就是链式调用的原理。现代主流框架基本都是支持这种链式调用的，比如 Laravel 框架的 ORM： 1234$users = User::select([&#x27;id&#x27;])-&gt;where(&#x27;score&#x27;, &#x27;&gt;&#x27;, 100) -&gt;limit(5) -&gt;get() -&gt;toArray(); 上面的代表表示查询用户积分大于 100 的用户 id，并且限制只取出 5 个数据，最后再把结果转化成数组形式。 管道还可以设计的更加复杂，例如上一个类执行完的结果，再传递给下一个类当做参数……简单地说，管道就是「传递」的过程，就好比一滴水从源头流进水管，万一水管接到了下水道，那这滴水不是被污染了吗？最后再流进你家里，当然，它也可能流到一根生锈的水管，因此融进了一些铁屑等杂质……诸如此类，这滴水流过什么样的水管就沾染上什么样的颜色，你把自己当成马里奥就行了，你想让管道怎么接就怎么接。 管道有很多实现的方法，比如 Laravel 的中间件，没错，又是它！只要你去研究 Laravel 中间件是如何实现的，你一定会被惊叹到，像洋葱一样一层一层剥开你的皮进入你的心…… 总之，管道就是 输入-输出 的过程，如果说切面的核心是拦截，那么管道的核心就是「连接」与「传递」。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://huotublog.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"开发技术","slug":"开发技术","permalink":"http://huotublog.com/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}]},{"title":"网站性能优化之静态资源加速","slug":"web-optimize-1","date":"2021-03-24T14:04:35.000Z","updated":"2023-02-16T06:50:23.267Z","comments":true,"path":"2021/03/24/web-optimize-1/","link":"","permalink":"http://huotublog.com/2021/03/24/web-optimize-1/","excerpt":"","text":"前言图片、css、js 等等不会在用户访问时改变的资源统称静态资源。 网站的打开速度除了跟代码有关，静态资源也会拖后腿，优化静态资源加载速度比起优化代码更能显著提高访问速度。 WEB 服务器Apache 和 Nginx 是常用的 WEB 服务器。 Nginx 处理静态资源的速度比 Apache 更快，所以选择 Nginx 可以提高静态资源访问速度。 Nginx 可以配置静态资源缓存，参考资料：Nginx 静态资源缓存设置 CDN两台电脑的远近距离会影响到访问速度，例如在大陆地区访问国外的服务器就会延迟。 CDN 即内容分发网络，它会根据就近原则为你分配访问的节点。 比如在广州有一台服务器，上面保存着图片 A，在美国也有一台服务器，也保存着相同的图片 A，假设你的网站客户群体是全球范围，那么让国内用户访问广州的服务器上面的图片 A，美国用户访问美国服务器的图片 A，这样访问速度就是最快的。 更细分一点，在广州、上海、福州、香港……等等很多个地区都有一台服务器，这些服务器都保存着图片 A，这样广州的人访问广州的服务器，上海的人访问上海的服务器……这就是内容分发，就近原则访问资源。 我们个人是没办法做到那么多节点的，只有依靠服务商。 CDN 的原理就是负载均衡，根据 IP 来分配节点。 有很多免费的 CDN 服务商，推荐使用 jsdelivr + Github 来作为个人的 CDN。 Github：http://github.com/ 首先到 Github 创建一个账号，然后新建一个仓库，上传一张图片，比如图片名字为：avatar.png。 然后就可以直接用 jsdelivr 加载这张图片了。 格式：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 版本号不是必须的，但是加上去可以防止用户本地缓存了资源导致没有更新，你可以随意编写自己的版本号，如：@1.0，不过如果你要加上版本号的话，需要用 git 命令打一个版本的标签。 示例：https://github.com/laravel/laravel 这是 Laravel 框架的仓库地址，仓库根目录下有一个 webpack.mix.js 文件。 那么可以访问下面的地址： 12https://cdn.jsdelivr.net/gh/laravel/laravel/webpack.mix.jshttps://cdn.jsdelivr.net/gh/laravel/laravel@8.5.15/webpack.mix.js 这样就 OK 了！ 上面的 @8.5.15 是 Laravel 框架已经打好的版本标签。 在仓库的 tags 页面可以查看所有标签 ：https://github.com/laravel/laravel/tags 默认不写标签就是引用最新版。 前端用的最多的 js 即 JQeury 了，仓库地址：https://github.com/jquery/jquery 可以试着拿这个仓库练习一下，首先是确定自己要用的 JQuery 版本：https://github.com/jquery/jquery/tags 例如我要引用最新的 v3.6.0，然后发现 dist 里有不同类型的文件：https://github.com/jquery/jquery/tree/3.6.0/dist 带有 min 即压缩过的，一般我们都是引用这个。 可以用下面的链接： 1&lt;script src=&quot;https://cdn.jsdelivr.net/gh/jquery/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt; CDN 不止可以用 js、css 等，还可以把图片也上传到自己的 github 仓库，用相同的办法引入即可。 需要注意的是 jsdelivr 可能不太稳定，一旦它挂了你的网站资源就加载不出来了，这也是用 cdn 的风险 图片加载优化推荐两个免费图床： SM.MS：http://sm.ms/ 牛图网：http://niupic.com/ 把图片上传到这两个网站，它们自带 CDN。 上传图片之前，可以到 TinyPng：https://tinypng.com/ 将图片压缩一下，体积减小之后访问的速度也就 更快了。 需要注意的是压缩画质会受损，请根据实际需求选择是否压缩 除此之外，图片的 jpg 格式比起 png 更小，因为 jpg 是压缩的格式，而 png 可以保留透明背景，如果不需要透明背景可以将图片压缩为 jpg 格式。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://huotublog.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://huotublog.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"FireRabbit-Engine 实战 从零搭建个人博客（四）完结篇","slug":"firerabbit-engin-4","date":"2021-03-24T13:55:27.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2021/03/24/firerabbit-engin-4/","link":"","permalink":"http://huotublog.com/2021/03/24/firerabbit-engin-4/","excerpt":"","text":"总结一个多月没更新了，大致总结一下。 博客已经做完而且上线了，框架也在边写博客业务的时候边更新，具体过程略。 静态资源使用 CDN 可以实现秒开，AB 测试的结果差强人意，原本一个单纯的框架测试 hello world 时 RPS 可以达到 200-300，而博客上线后，测试 5000 篇文章使用 Redis 缓存的情况下，RPS 只剩下 20-30，太丢 swoole 的脸了…… 总的来说，通过自己写框架的过程还是学到蛮多知识的，尤其是在做自己的游戏的时候，思维方式发生了很大的改变。 平时写网站几乎用不到的「设计模式」，对写框架和游戏开发来说却是最根本的基础，现在我已经决定好好学一下各种设计模式了。不然以后做游戏开发的时候，代码肯定是乱糟糟的一团。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://huotublog.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"}]},{"title":"FireRabbit-Engine 实战 从零搭建个人博客（三）登录与注册","slug":"firerabbit-engin-3","date":"2021-02-19T15:16:35.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2021/02/19/firerabbit-engin-3/","link":"","permalink":"http://huotublog.com/2021/02/19/firerabbit-engin-3/","excerpt":"","text":"视图文件在 app 下新建一个文件夹 view 用来保存视图模板， 再创建一个 storage，并继续在 storage 下创建 view_cache 用来保存编译后的视图文件。 然后修改 app.php： 1234Constant::VIEW_CONFIG =&gt; [ &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;, &#x27;cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/view_cache&#x27;,], 此处的文件路径即上述创建的文件夹。 视图母版母版即所有页面共用的代码，比如每个页面都有顶部导航栏跟底部栏， 只是中间的部分不同，因此只要把内容单独提取出来，顶部和底部的结构可以复用。 在 view 下新建 layout 用来保存母版，同时创建 app.blade.php： 123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;火兔博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; @yield(&#x27;content&#x27;) &lt;hr/&gt; &lt;div&gt; &lt;p align=&quot;center&quot;&gt;火兔博客©2021&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 中间的 yield(&#39;content&#39;) 即抽取出来的内容页。 登录&#x2F;注册页面添加登录注册的路由： 12345678910111213141516&lt;?php$router = new \\FireRabbit\\Engine\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Http\\\\Controller\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;); $router-&gt;get(&#x27;/register&#x27;, &#x27;IndexController@register&#x27;)-&gt;name(&#x27;register&#x27;);&#125;);return $router; 接着修改控制器： 123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/19 * Time：12:39 **/namespace App\\Http\\Controller;use FireRabbit\\Engine\\Controller\\Controller;class IndexController extends Controller&#123; public function login() &#123; $this-&gt;show(&#x27;login&#x27;); &#125; public function register() &#123; $this-&gt;show(&#x27;register&#x27;); &#125;&#125; 接着创建对应的 blade 模板，login.blade.php： ……","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://huotublog.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"}]},{"title":"FireRabbit-Engine 实战 从零搭建个人博客（二）创建博客所需的表","slug":"firerabbit-engin-2","date":"2021-02-19T10:30:46.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2021/02/19/firerabbit-engin-2/","link":"","permalink":"http://huotublog.com/2021/02/19/firerabbit-engin-2/","excerpt":"","text":"Phinx官方网站：Phinx - 官方文档 phinx 是一个数据库迁移插件，它可以帮你实现不使用 sql 文件来创建表。 框架还没集成数据库迁移系统，因此就需要自己手动安装了。 安装执行命令：composer require robmorgan/phinx。 初始化第一次安装还需要进行初始化：vendor/bin/phinx init，不然 phinx 不知道你的数据库账号密码就无法连接了。 初始化完成后，在项目根目录会出现一个配置文件 phinx.php： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpreturn[ &#x27;paths&#x27; =&gt; [ &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;, &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27; ], &#x27;environments&#x27; =&gt; [ &#x27;default_migration_table&#x27; =&gt; &#x27;phinxlog&#x27;, &#x27;default_environment&#x27; =&gt; &#x27;development&#x27;, &#x27;production&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;production_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ], &#x27;development&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;development_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ], &#x27;testing&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;testing_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ] ], &#x27;version_order&#x27; =&gt; &#x27;creation&#x27;]; 默认是 development 环境，在这里修改自己的数据库配置。 虽然 phinx 是数据库迁移，但它本身创建不了数据库，需要手动创建。 修改完成后，再创建一个名词叫做 blog 的数据库即可。 迁移目录根据配置文件最上方的目录： 1234&#x27;paths&#x27; =&gt; [ &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;, &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;], 创建对应的文件夹。 创建表迁移命令：vendor/bin/phinx create xxxx。 xxx 是表名，使用大驼峰方式。 执行迁移命令：vendor/bin/phinx migrate。 项目所需表博客项目需要的表及对应的字段，表名默认为复数形式（即加一个 s）。 所有的表都有一个自增主键。 用户表：users name：昵称 email：注册邮箱 password：密码，采用明文方式存储（本项目只是测试而已~~~好孩子不要学） created：注册时间 执行命令：vendor/bin/phinx create User 在迁移目录 migrations 即可看到迁移文件，修改迁移文件内容： 1234567891011121314151617181920212223242526272829&lt;?phpdeclare(strict_types=1);use Phinx\\Migration\\AbstractMigration;final class User extends AbstractMigration&#123; /** * Change Method. * * Write your reversible migrations using this method. * * More information on writing migrations is available here: * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method * * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working * with the Table class. */ public function change(): void &#123; $table = $this-&gt;table(&#x27;users&#x27;, [&#x27;signed&#x27; =&gt; false]); $table-&gt;addColumn(&#x27;name&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 16]) -&gt;addColumn(&#x27;email&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64]) -&gt;addColumn(&#x27;password&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64]) -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;]) -&gt;addIndex([&#x27;email&#x27;, &#x27;password&#x27;]) -&gt;create(); &#125;&#125; 邮箱和密码设置为关联索引，这样用户在登录的时候可以直接从索引返回查询结果，查询速度非常快。 created 是时间戳，直接使用当前时间作为值。 文章表：articles user_id：作者 ID title：标题 classify：分类 cover：封面图 view_count：浏览次数 created：发布日期 执行命令：vendor/bin/phinx create ArticleContent 12345678910111213141516171819202122232425262728293031&lt;?phpdeclare(strict_types=1);use Phinx\\Migration\\AbstractMigration;final class Article extends AbstractMigration&#123; /** * Change Method. * * Write your reversible migrations using this method. * * More information on writing migrations is available here: * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method * * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working * with the Table class. */ public function change(): void &#123; $table = $this-&gt;table(&#x27;articles&#x27;, [&#x27;signed&#x27; =&gt; false]); $table-&gt;addColumn(&#x27;title&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32]) -&gt;addColumn(&#x27;classify&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32]) -&gt;addColumn(&#x27;cover&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 255]) -&gt;addColumn(&#x27;user_id&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false]) -&gt;addColumn(&#x27;view_count&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false]) -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;]) -&gt;addIndex([&#x27;user_id&#x27;]) -&gt;create(); &#125;&#125; 文章内容表：article_contents article_id：文章 ID content：内容 执行命令：vendor/bin/phinx create ArticleContent 123456789101112131415161718192021222324252627&lt;?phpdeclare(strict_types=1);use Phinx\\Migration\\AbstractMigration;final class ArticleContent extends AbstractMigration&#123; /** * Change Method. * * Write your reversible migrations using this method. * * More information on writing migrations is available here: * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method * * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working * with the Table class. */ public function change(): void &#123; $table = $this-&gt;table(&#x27;article_contents&#x27;, [&#x27;signed&#x27; =&gt; false]); $table-&gt;addColumn(&#x27;article_id&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false]) -&gt;addColumn(&#x27;content&#x27;, &#x27;text&#x27;) -&gt;addIndex([&#x27;article_id&#x27;]) -&gt;create(); &#125;&#125; email_codes：邮件验证码 email：邮箱 code：验证码 created：创建日期 执行命令：vendor/bin/phinx create EmailCode 12345678910111213141516171819202122232425262728&lt;?phpdeclare(strict_types=1);use Phinx\\Migration\\AbstractMigration;final class EmailCode extends AbstractMigration&#123; /** * Change Method. * * Write your reversible migrations using this method. * * More information on writing migrations is available here: * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method * * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working * with the Table class. */ public function change(): void &#123; $table = $this-&gt;table(&#x27;email_codes&#x27;, [&#x27;signed&#x27; =&gt; false]); $table-&gt;addColumn(&#x27;email&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64]) -&gt;addColumn(&#x27;code&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 8]) -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;]) -&gt;addIndex([&#x27;email&#x27;]) -&gt;create(); &#125;&#125; 生成表执行命令：vendor/bin/phinx migrate 然后打开数据库，可以看到： 生成了这些表之后，就可以直接用框架集成的 ORM 调用了。 ModelORM 默认使用的表名即复数形式，也可以指定一个表名，只需要修改 $table 变量即可。 创建一个用来保存模型文件的目录 app&#x2F;Http&#x2F;Model。 User12345678910111213141516171819&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/19 * Time：14:00 **/namespace App\\Http\\Model;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $guarded = []; public $timestamps = false;&#125; Article123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/19 * Time：19:43 **/namespace App\\Http\\Model;use Illuminate\\Database\\Eloquent\\Model;class Article extends Model&#123; protected $guarded = []; public $timestamps = false; public function content() &#123; return $this-&gt;hasOne(ArticleContent::class)-&gt;withDefault(); &#125;&#125; ArticleContent12345678910111213141516171819&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/19 * Time：19:43 **/namespace App\\Http\\Model;use Illuminate\\Database\\Eloquent\\Model;class ArticleContent extends Model&#123; protected $guarded = []; public $timestamps = false;&#125; EmailCode12345678910111213141516171819&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/19 * Time：19:44 **/namespace App\\Http\\Model;use Illuminate\\Database\\Eloquent\\Model;class EmailCode extends Model&#123; protected $guarded = []; public $timestamps = false;&#125; 结束语现在数据库和模型已经设定好了，接下来就可以直接开始业务处理了！","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://huotublog.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"}]},{"title":"FireRabbit-Engine 实战 从零搭建个人博客（一）项目规划","slug":"firerabbit-engin-1","date":"2021-02-19T08:56:21.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2021/02/19/firerabbit-engin-1/","link":"","permalink":"http://huotublog.com/2021/02/19/firerabbit-engin-1/","excerpt":"","text":"前言居然非常不要脸的在标题写上自己引擎的名字了！ FireRabbit-Engine（火兔引擎）是基于 swoole 的 Laravel 劣质山寨版！ 但是就性能而言，相比 Laravel 的提升非常巨大！ （这是 swoole 的功劳啊、喂！） 我要高呼框架的口号：有手就行，火兔引擎！ 项目规划为了测试框架的性能和发现框架的不足之处，因此我打算用一个博客系统来测试。 这个博客系统会包含博客应该具备的基本功能，但绝不是手把手每一步都写得清清楚楚。 而且我的前端技术也不咋样，于是这个博客系统干脆就不需要 css 代码…… 功能模块博客包含以下几个简单模块： 登录&#x2F;注册（注册需要验证邮箱，顺便测试异步任务） 文章的增删改查 数据库迁移 权限认证（中间件来实现） 缓存 制作周期这几个模块只要一晚上就能完成，但是昨天晚上睡眠不足， 现在头有点昏昏沉沉，如果今天晚上没做完，就留到明天继续。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://huotublog.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"}]},{"title":"从零开始搭建自己的Swoole框架（十九）封包，发到composer仓库！","slug":"my-swoole-framework-19","date":"2021-02-19T03:13:19.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/19/my-swoole-framework-19/","link":"","permalink":"http://huotublog.com/2021/02/19/my-swoole-framework-19/","excerpt":"","text":"前言过年的假期也结束了，大家都陆续上班了。 2020 年我辞职回家一年也没有实现游戏梦，2021 年还有最后一次为梦想拼搏的机会。 再加上今年还有买房的梦想，所以今年开始没有太多任性的时间了， 如果家里有矿的话，我也想要归隐山林，专心钻研技术，无奈。 今年是毕业第五年的开始，五年……足以让一个人发生巨大的改变， 而我却连毕业时当架构师的梦想都没有实现，于是退而求其次才想要自己写一个框架。 即使是现在雏形完成了，但是技术方面还是没有很大的提升。 原因我很清楚，因为急于求成，因为想要证明自己给某个人看…… 后悔的是大学没有好好学习，然悔之无用。 看过一部电视剧，里面有一句台词深深的触动了我：“当你觉得一切都晚了的时候，恰恰是最早的时机。” 在 30 岁之前幡然醒悟，也许是一种值得庆幸的事，如果再晚几年，恐怕翻身的机会只会愈加渺茫。 所以今年，2021 年，我要把握最后一年的机会，尽全力实现自己的游戏梦。 一边实现梦想，一边学好技术，打铁还需自身硬，只有自己变强了，才能掌控自己的生活。 封装扩展包关于 composer 如何发布自己的扩展包，我在去年的时候写过一篇比较详细的文章了。 传送链接：https://huotublog.com/composer-package/ 配置信息因为用到了变量类型声明和返回值声明： 123public function test(int num) : int &#123; return num;&#125; 这是 PHP7.4 新增的功能，所以要对 PHP 的版本进行限制。 修改框架下的 composer.json 文件： 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;firerabbit/engine&quot;, &quot;description&quot;: &quot;基于swoole的个人框架。&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;火烧兔子&quot;, &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot; &#125; ], &quot;require&quot;: &#123; &quot;php&quot;: &quot;^7.4&quot;, &quot;illuminate/database&quot;: &quot;^7.30&quot;, &quot;xiaoler/blade&quot;: &quot;^5.4&quot;, &quot;monolog/monolog&quot;: &quot;^2.2&quot;, &quot;firebase/php-jwt&quot;: &quot;^5.2&quot;, &quot;phpmailer/phpmailer&quot;: &quot;^6.2&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;FireRabbit\\\\Engine\\\\&quot;: &quot;src/&quot; &#125;, &quot;files&quot;: [ &quot;src/function.php&quot; ] &#125;&#125; 除了限制 PHP 版本之外，添加了作者和描述信息。 项目结构将框架的目录进行一番修改，大致如下： Github 仓库Github 上创建一个公开的仓库。 然后将框架的代码上传至仓库。 Packagist 仓库接着发布到 composer 仓库。 地址：https://packagist.org/ 点击上面的 Submit 按钮，然后把 Github 的仓库地址复制过来，然后提交，检测包名字，没问题就继续点下一步。 等待 composer 抓取 github 的信息，完成之后显示如下界面： 说明已经成功传到 composer 的仓库了，现在这个包可供所有人拉取，但包还未指定版本号，因此仍然无法安装成功。 版本号任何包都需要有一个版本号，第一个版本可以计作：v1.0.0 版本号是个人自定义的，我定义的版本号规则如下： 第一个 1，代表大版本，除非框架有翻天覆地的更新，否则这个版本不会改变，一旦大版本号改变就说明原来的代码已经无法保证正常使用了，不应该直接从旧版本升级到新版本，无法保证向下兼容 第二个 0，代表中版本号，此版本更新说明添加了一些新功能，但是兼容旧版，可以直接升级 第三个 0，代表小版本号，此版本更新说明一些微不足道的改变，例如优化代码或者结构，不影响正常使用，可以直接升级 composer 包的版本是通过 git 标签实现的。 执行命令： 12git tag -a v1.0.0 -m &quot;初始版本&quot;git push origin v1.0.0 发布一个标签之后，回到 Packagist 页面，看看右下角是否有更新， 如果没有更新，手动点击 Update 按钮，同步完成之后就可以看到右下角多出了一个 v1.0.0。 安装现在就可以从远程仓库直接安装框架包了。 在任意位置创建一个空文件夹，然后进入文件夹，执行命令：composer require firerabbit/engine 具体的使用方法可以参照框架的 readme 文件。 最后的话框架部分大致就到这结束了，后续我还会不断更新框架功能。 接下来就要开始使用这个框架雏形来开发一个博客系统了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十八）异步任务","slug":"my-swoole-framework-18","date":"2021-02-18T11:42:11.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/18/my-swoole-framework-18/","link":"","permalink":"http://huotublog.com/2021/02/18/my-swoole-framework-18/","excerpt":"","text":"前言框架现在拥有发送邮件的能力了，但是发送邮件是非常耗时的一件事， 因此需要用异步任务来解决这个问题。 异步任务swoole 内置了异步任务处理，参照文档：https://wiki.swoole.com/#/start/start_task 一个简单的异步任务示例： 12345678910111213141516171819202122232425262728293031323334353637$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;set([ &#x27;task_worker_num&#x27; =&gt; 1,]);$http-&gt;on(&#x27;Request&#x27;, function ($request, $response) use ($http) &#123; // 投递任务 $params = [&#x27;name&#x27; =&gt; &#x27;花花&#x27;]; $taskID = $http-&gt;task($params); var_dump(&#x27;投递了一个任务，ID：&#x27; . $taskID . &#x27;，参数：&#x27; . json_encode($params, JSON_UNESCAPED_UNICODE)); $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;); $response-&gt;end(&#x27;&lt;h1&gt;Hello Swoole. #&#x27; . rand(1000, 9999) . &#x27;&lt;/h1&gt;&#x27;);&#125;);//处理异步任务(此回调函数在task进程中执行)$http-&gt;on(&#x27;Task&#x27;, function ($serv, $task_id, $reactor_id, $data) &#123; var_dump(&#x27;收到任务，开始处理，任务ID：&#x27; . $task_id . &#x27;，参数：&#x27; . json_encode($data, JSON_UNESCAPED_UNICODE)); // 业务逻辑 $result = &#x27;那只猫的名字叫做&#x27; . $data[&#x27;name&#x27;]; //返回任务执行的结果 $serv-&gt;finish($result);&#125;);//处理异步任务的结果(此回调函数在worker进程中执行)$http-&gt;on(&#x27;Finish&#x27;, function ($serv, $task_id, $data) &#123; // 任务执行完成后的回调 var_dump(&#x27;【处理结果】任务ID：&#x27; . $task_id . &#x27;，返回结果：&#x27; . $data);&#125;);$http-&gt;start(); 要开启任务，必须设置 task_worker_num，此参数是处理任务的进程数。 要投递一个任务，只要调用 server 的 task 方法即可，task 方法接收一个参数，执行完成后返回任务 ID。 投递的任务会在 task 事件中执行，要监听事件只需要调用 on 方法。 task 事件处理完成后的结果可以通知给 finish 事件，也可以不通知。 上述代码输出结果： 123string(59) &quot;投递了一个任务，ID：0，参数：&#123;&quot;name&quot;:&quot;花花&quot;&#125;&quot;string(71) &quot;收到任务，开始处理，任务ID：0，参数：&#123;&quot;name&quot;:&quot;花花&quot;&#125;&quot;string(78) &quot;【处理结果】任务ID：0，返回结果：那只猫的名字叫做花花&quot; 如果多次执行，任务 ID 会从 0 开始不断加 1，第二个任务的 ID 为 1，第三个任务的 ID 为 2，以此类推。 如果关闭程序再重新启动，任务 ID 又会从 0 开始。 即使将 task_worker_num 改为 2 或者更大，ID 也是保持相同规则自增，因此可以判定 ID 是多个工作进程共享的，不会出现 ID 重复的情况。 执行逻辑swoole 的异步任务必须接受一个数组作为参数，而不能直接将对象作为参数传给任务： 12345# 错误的方法$server-&gt;task(new MyTask());# 正确的方法$server-&gt;task([&#x27;name&#x27; =&gt; &#x27;花花&#x27;]); 只要想起之前路由是怎么设计的，任务系统就很简单了。 既然只能传递数组作为参数，那只要传一个任务名称，再实际调用的时候实例化就可以了。 实现任务分发任务必须要在 Swoole\\Http\\Server，因此原来的代码就需要修改一遍了。 传参：server要调用任务的地方，目前只有 controller，因此 server 必须传给 controller。 只要修改路由模块传递参数即可： 1234567891011121314151617/** * 处理路由 * @param Server $server * @param $request * @param $response */public function handle(Server $server, $request, $response)&#123; $route = $this-&gt;findRoute($request); if ($route == null) &#123; (new NotFoundResponse)-&gt;response($request, $response, $route); return; &#125; $route-&gt;createResponse($server, $request, $response);&#125; handle 多接收一个 server 参数， 然后再在实例化路由配置的时候把 server 传给路由， 路由实例化控制器的时候，再把 server 传给控制器就行了，详细的代码就不贴出来了。 控制器现在已经可以拿到 server 了，但这是 swoole 的方法， TaskInterface：标准任务接口基于面向对象的思想，此处应该有封装。 在框架目录下新建 Task 目录，再创建 TaskInterface 接口： 12345678910111213141516171819202122232425262728&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：20:23 **/namespace FireRabbitEngine\\Module\\Task;interface TaskInterface&#123; /** * 处理逻辑 * @param $params * @return mixed */ public function handle($params); /** * 处理完成回调 * @param $params * @return mixed */ public function finish($result);&#125; 这个接口就是一个统一标准的 Task 类，以后用户想要创建一个任务，就实现这个接口。 handle 方法即 swoole 监听的 task 事件中处理任务逻辑的地方； finish 方法即 swoole 监听的 finish 事件处理完任务执行回调的地方。 Task：分发任务统一的标准任务类已经有了，但还需要一个任务处理类，在 Task 文件夹下创建 Task 类： 12345678910111213141516171819202122232425262728293031323334&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：20:29 **/namespace FireRabbitEngine\\Module\\Task;use Swoole\\Http\\Server;class Task&#123; /** * 分发一个任务 * @param Server $server * @param TaskInterface $task * @param array $data * @return int */ public static function dispatch(Server $server, string $task, array $data = []): int &#123; $params = [ &#x27;task&#x27; =&gt; $task, &#x27;data&#x27; =&gt; $data, ]; var_dump($task); return $server-&gt;task($params); &#125;&#125; 这个类只需要一个 dispatch 方法，接收任务类的名称以及附加参数。 然后再修改框架的 controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:16 PM **/namespace FireRabbitEngine\\Module\\Controller;use FireRabbitEngine\\Module\\Task\\Task;use FireRabbitEngine\\Module\\Http\\Kernel as HttpKernel;class Controller&#123; protected $httpKernel; public function __construct(HttpKernel $httpKernel) &#123; $this-&gt;httpKernel = $httpKernel; &#125; /** * 分发任务 * @param $task * @param $data * @return int */ public function dispatch($task, $data) &#123; $server = $this-&gt;httpKernel-&gt;getServer(); return Task::dispatch($server, $task, $data); &#125; public function showMessage($message) &#123; $this-&gt;httpKernel-&gt;getResponse()-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $this-&gt;httpKernel-&gt;getResponse()-&gt;end($message); &#125; public function getRequest() &#123; return $this-&gt;httpKernel-&gt;getRequest(); &#125; public function getResponse() &#123; return $this-&gt;httpKernel-&gt;getResponse(); &#125;&#125; server 是通过 httpKernel 在路由时传参得到的， 如果没有 server 就无法调用 swoole 的 task 方法。 controller 也声明了一个 dispatch 方法供用户直接调用。 执行任务执行任务是在 HttpServer 处通过监听 task 和 finish 两个事件。 修改 HttpServer： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/15 * Time：16:26 **/namespace FireRabbitEngine\\Module\\Http;use FireRabbitEngine\\Module\\Auth\\Auth;use FireRabbitEngine\\Module\\Cache\\Cache;use FireRabbitEngine\\Module\\Constant;use FireRabbitEngine\\Module\\Database\\Manager as DatabaseManager;use FireRabbitEngine\\Module\\Logger\\Log as Logger;use FireRabbitEngine\\Module\\Mail\\Mailer;use FireRabbitEngine\\Module\\Route\\Router;use FireRabbitEngine\\Module\\Task\\TaskInterface;use FireRabbitEngine\\Module\\View\\Blade;use Swoole\\Http\\Server;class HttpServer&#123; public $server; public $router; public function __construct($host, $port, $config = []) &#123; $this-&gt;server = new Server($host, $port); $this-&gt;server-&gt;set($config); &#125; public function loadRouter(Router $router) &#123; $this-&gt;router = $router; return $this; &#125; public function loadMiddleware($middleware) &#123; \\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig($middleware); return $this; &#125; public function bootstrap($config) &#123; // 视图 Blade::setConfig($config[Constant::VIEW_CONFIG]); // 数据库ORM DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]); // 日志 Logger::setConfig($config[Constant::LOGGER_CONFIG]); // 缓存 $cache = $config[Constant::CACHE_CONFIG]; Cache::setConfig($cache[&#x27;driver&#x27;], $cache[$cache[&#x27;driver&#x27;]]); // JWT Auth::setConfig($config[Constant::JWT_CONFIG]); // 邮件 Mailer::setConfig($config[Constant::MAIL_CONFIG]); return $this; &#125; public function request($request, $response) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $this-&gt;registerError($response); $this-&gt;router-&gt;handle($this-&gt;server, $request, $response); &#125; private function registerError($response) &#123; register_shutdown_function(function () use ($response) &#123; $error = error_get_last(); var_dump($error); switch ($error[&#x27;type&#x27;] ?? null) &#123; case E_ERROR : case E_PARSE : case E_CORE_ERROR : case E_COMPILE_ERROR : $response-&gt;status(500); $response-&gt;end($error[&#x27;message&#x27;]); break; &#125; &#125;); &#125; public function task() &#123; $this-&gt;server-&gt;on(&#x27;task&#x27;, function ($server, $taskID, $reactorID, $data) &#123; var_dump(&#x27;收到任务，开始处理，任务ID：&#x27; . $taskID . &#x27;，参数：&#x27; . json_encode($data)); if (isset($data[&#x27;task&#x27;]) &amp;&amp; class_exists($data[&#x27;task&#x27;])) &#123; $task = new $data[&#x27;task&#x27;]; if ($task instanceof TaskInterface) &#123; $resultData = $task-&gt;handle($data[&#x27;data&#x27;]); $result = [ &#x27;task&#x27; =&gt; $data[&#x27;task&#x27;], &#x27;result&#x27; =&gt; $resultData ?? null, ]; $server-&gt;finish($result); &#125; &#125; &#125;); &#125; public function finish() &#123; $this-&gt;server-&gt;on(&#x27;finish&#x27;, function ($server, $taskID, $data) &#123; var_dump(&#x27;任务处理完了，任务ID：&#x27; . $taskID); if (isset($data[&#x27;task&#x27;]) &amp;&amp; class_exists($data[&#x27;task&#x27;])) &#123; $task = new $data[&#x27;task&#x27;]; if ($task instanceof TaskInterface) &#123; $task-&gt;finish($data[&#x27;result&#x27;]); &#125; &#125; &#125;); &#125; public function start() &#123; $this-&gt;server-&gt;on(&#x27;request&#x27;, [$this, &#x27;request&#x27;]); $this-&gt;server-&gt;start(); &#125;&#125; 新增了两个方法：task 和 finish，只要调用此方法即可实现监听事件。 开启监听在启动程序 http_server.php 处新增监听事件： 123456789101112131415161718192021222324252627&lt;?phpuse FireRabbitEngine\\Module\\Http\\HttpServer;date_default_timezone_set(&quot;Asia/Shanghai&quot;);define(&#x27;ROOT_PATH&#x27;, __DIR__);require &#x27;./vendor/autoload.php&#x27;;require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;$config = require &#x27;./app/config/app.php&#x27;;$server = new HttpServer(&#x27;0.0.0.0&#x27;, 9527, [ &#x27;worker_num&#x27; =&gt; 4, &#x27;task_worker_num&#x27; =&gt; 1,]);$router = require &#x27;./app/route/web.php&#x27;;$middleware = require &#x27;./app/config/middleware.php&#x27;;$server-&gt;task();$server-&gt;finish();$server-&gt;bootstrap($config[&#x27;framework&#x27;]) -&gt;loadMiddleware($middleware) -&gt;loadRouter($router) -&gt;start(); task 和 finish 必须在 start 之前， 而且 swoole 的参数必须加上 task_worker_num，该值是处理事件的进程数量。 通俗的讲 task_worker_num 就是工具人的数量，工具人越多，堆积的任务处理速度越快，swoole 会轮询分发给工具人任务，工具人至少也要有 1 个，如果没有工具人谁来干活呢？ 由于我的博客系统只需要发送邮件这个简单的任务，并不会堆积很多，所以只需要 1 个进程用来处理任务就够了。 项目任务前面已经完成了邮件系统，现在可以把发送邮件当做异步任务来执行了。 在博客项目新建存放任务类的文件夹 app&#x2F;Http&#x2F;Task，再创建一个用来发送邮件的任务： 123456789101112131415161718192021222324252627282930313233&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：21:46 **/namespace App\\Http\\Task;use FireRabbitEngine\\Module\\Mail\\Mailer;use FireRabbitEngine\\Module\\Task\\TaskInterface;class MailTask implements TaskInterface&#123; public function handle($params) &#123; var_dump(&#x27;调用handle处理任务&#x27;); $mailer = new Mailer(); $mailer-&gt;subject(&#x27;测试异步任务发送邮件&#x27;) -&gt;body(&#x27;这是邮件内容&#x27;) -&gt;address($params[&#x27;email&#x27;]) -&gt;send(); return &#x27;发送成功&#x27;; &#125; public function finish($result) &#123; var_dump($result); &#125;&#125; 然后在 controller 添加测试代码： 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use App\\Http\\Task\\MailTask;use FireRabbitEngine\\Module\\Controller\\Controller;class IndexController extends Controller&#123; public function test() &#123; $this-&gt;dispatch(MailTask::class, [&#x27;email&#x27; =&gt; &#x27;874811226@qq.com&#x27;]); $this-&gt;showMessage(&#x27;ok&#x27;); &#125;&#125; 最终输出结果为： 12345string(17) &quot;请求URI：/test&quot;string(126) &quot;收到任务，开始处理，任务ID：0，参数：&#123;&quot;task&quot;:&quot;App\\\\Http\\\\Task\\\\MailTask&quot;,&quot;data&quot;:&#123;&quot;email&quot;:&quot;874811226@qq.com&quot;&#125;&#125;&quot;string(24) &quot;调用handle处理任务&quot;string(33) &quot;任务处理完了，任务ID：0&quot;string(12) &quot;发送成功&quot; 并且邮箱也能正常收到测试邮件。 如此一来，框架的异步任务也算完成了。 延迟任务swoole 提供了毫秒定时器，可以用来延迟分发任务。 而定时器又分为 after（一次性）与 tick（重复）两种类型。 一次性定时器执行完就会销毁，而重复定时器则会间隔执行，直到手动销毁为止。 Swoole 官方文档：swoole - 定时器 一次性任务调用 delay 即可实现延迟发布任务。 重复性任务例如每隔半小时就将缓存中的数据写入到数据库，或者是爬虫任务每小时执行一次，诸如此类。 具体实现修改 Task 类，添加对应的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：20:29 **/namespace FireRabbitEngine\\Module\\Task;use Swoole\\Http\\Server;use Swoole\\Timer;class Task&#123; /** * 分发一个任务 * @param Server $server * @param TaskInterface $task * @param array $data * @return int */ public static function dispatch(Server $server, string $task, array $data = []): int &#123; $params = [ &#x27;task&#x27; =&gt; $task, &#x27;data&#x27; =&gt; $data, ]; return $server-&gt;task($params); &#125; /** * 延迟分发任务 * @param Server $server * @param int $ms * @param string $task * @param array $data */ public static function delay(Server $server, int $ms, string $task, array $data = []): int &#123; $params = [ &#x27;task&#x27; =&gt; $task, &#x27;data&#x27; =&gt; $data, ]; return Timer::after($ms, function () use ($server, $params) &#123; $server-&gt;task($params); &#125;); &#125; public static function tick(Server $server, int $ms, string $task, array $data = []): int &#123; $params = [ &#x27;task&#x27; =&gt; $task, &#x27;data&#x27; =&gt; $data, ]; return Timer::tick(1000, function () use ($server, $params) &#123; $server-&gt;task($params); &#125;); &#125; public static function clear(int $timerID): bool &#123; return Timer::clear($timerID); &#125;&#125; 执行延迟任务时，可以返回一个 int 类型的时钟 ID，调用 clear 可以将定时器清除。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十七）发送邮件","slug":"my-swoole-framework-17","date":"2021-02-18T08:09:29.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/18/my-swoole-framework-17/","link":"","permalink":"http://huotublog.com/2021/02/18/my-swoole-framework-17/","excerpt":"","text":"前言个人站长一般很难支付起短信的费用，因此邮件认证比较适合个人站长。 准备工作发送邮件是完全免费的，只要搭建一台用于发送邮件的服务器即可， 但是搭建邮件服务器的成本太昂贵了，因此我选择使用第三方提供的邮箱服务。 市面上的各大邮箱基本都是免费注册的，比如 QQ 邮箱，163 邮箱等等。 每种邮箱配置大同小异，我选择网易的 163 邮箱作为演示。 网易邮箱：https://www.163.com/ 右上角即可免费注册，注册成功后，进入个人中心，点击上方的“设置”，然后可以看到 POP3&#x2F;SMTP&#x2F;IMAP。 下方有两个可以选择的： 12IMAP/SMTP服务已关闭 | 开启POP3/SMTP服务已关闭 | 开启 选择 POP3/SMTP 右边的“开启”按钮，网易会要求你发送短信进行认证，认证后就可以开通了。 然后会获得一段用于验证的“神秘代码”，要把这个代码存下来，一旦关闭页面就无法再次查看了（但是可以重新创建）。 这样就申请好一个可以发送邮件的邮箱了。 安装插件包PHP 内置的方法也可以发送邮件，但是我选择使用一个比较成熟的插件包：phpmailer/phpmailer。 在框架目录下执行：composer require phpmailer/phpmailer 即可完成安装。 Mailer插件安装完成后，需要封装成方便调用的形式。 在框架目录新建一个 Mail 文件夹用来保存邮件发送相关代码，并且创建 Mailer 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：14:29 **/namespace FireRabbitEngine\\Module\\Mail;use PHPMailer\\PHPMailer\\PHPMailer;class Mailer&#123; protected static $mail; protected static $config; /** * 轮询计数器 * @var int */ protected static $sort = 0; /** * 邮件节点 * @var array */ protected static $pool = []; protected $subject, $body, $altBody, $reciverMail; public static function setConfig($config) &#123; self::$config = $config; self::$pool = $config[&#x27;pool&#x27;]; self::$mail = new PHPMailer(); self::$mail-&gt;isSMTP(); self::$mail-&gt;SMTPAuth = true; self::$mail-&gt;SMTPDebug = $config[&#x27;debug&#x27;]; self::$mail-&gt;isHTML($config[&#x27;html&#x27;]); self::$mail-&gt;SMTPSecure = $config[&#x27;secure&#x27;]; &#125; public function subject($title) &#123; $this-&gt;subject = $title; return $this; &#125; public function body($html) &#123; $this-&gt;body = $html; return $this; &#125; public function altBody($text) &#123; $this-&gt;altBody = $text; return $this; &#125; public function address($mail) &#123; $this-&gt;reciverMail = $mail; return $this; &#125; public function send() &#123; $node = self::$pool[self::$sort]; self::$sort++; if (self::$sort &gt;= count(self::$pool)) &#123; self::$sort = 0; &#125; // 载入节点配置 self::$mail-&gt;Host = $node[&#x27;host&#x27;]; self::$mail-&gt;Port = $node[&#x27;port&#x27;]; self::$mail-&gt;Username = $node[&#x27;user&#x27;]; self::$mail-&gt;Password = $node[&#x27;password&#x27;]; self::$mail-&gt;setFrom($node[&#x27;user&#x27;], $node[&#x27;name&#x27;]); self::$mail-&gt;addReplyTo($node[&#x27;user&#x27;], $node[&#x27;name&#x27;]); // 生成邮件信息 self::$mail-&gt;addAddress($this-&gt;reciverMail); self::$mail-&gt;Subject = $this-&gt;subject; self::$mail-&gt;Body = $this-&gt;body; self::$mail-&gt;AltBody = $this-&gt;altBody ?? &#x27;&#x27;; self::$mail-&gt;send(); &#125;&#125; Mailer 类重新封装了插件包发送邮件的代码，外部调用起来方便多了。 加载配置一个 163 邮箱大约每天只能发送 500-1500 封邮件， 一旦超过这个数，网易就会限制该账户继续发送邮件。 为了避免被限制导致业务无法正常执行，通常我们需要申请很多个邮箱（毕竟注册免费）。 然后类似负载均衡一样轮询多个邮箱，所以在 Mailer 类有一个用来控制轮询的变量 $sort， 并且在 send 方法动态获取节点配置。 因此需要配置足够多的邮箱以供邮件系统调用，编辑 app.php，添加邮件相关配置： 1234567891011121314151617181920212223242526Constant::MAIL_CONFIG =&gt; [ &#x27;debug&#x27; =&gt; 1, &#x27;html&#x27; =&gt; true, &#x27;secure&#x27; =&gt; &#x27;ssl&#x27;, &#x27;pool&#x27; =&gt; [ [ &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;, &#x27;port&#x27; =&gt; 465, &#x27;user&#x27; =&gt; &#x27;huotu_001@163.com&#x27;, &#x27;name&#x27; =&gt; &#x27;火兔博客1号&#x27;, &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;, ],[ &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;, &#x27;port&#x27; =&gt; 465, &#x27;user&#x27; =&gt; &#x27;huotu_002@163.com&#x27;, &#x27;name&#x27; =&gt; &#x27;火兔博客2号&#x27;, &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;, ],[ &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;, &#x27;port&#x27; =&gt; 465, &#x27;user&#x27; =&gt; &#x27;huotu_003@163.com&#x27;, &#x27;name&#x27; =&gt; &#x27;火兔博客3号&#x27;, &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;, ], ],], 通过增加 pool 内邮箱的数量，即可实现一天发送成千上万封邮件。 而且邮箱的配置完全是独立的，不仅可以在这里配置 163 邮箱，QQ 邮箱同样可以。 只要注册多个平台的多个邮箱，这个邮件系统的稳定性就越强，一般而言，个人博客配置 2-5 个邮箱就差不多了。 具体数量根据博客的功能决定，如果发送邮件的场景只有注册和找回密码，那配置 2 个就差不多了； 如果你想要在发布新文章的时候，同时发送一封邮件通知博客的订阅者，那就要多准备一些了（反正申请邮箱不要钱）。 实战调用在需要发送邮件的场景，调用 Mailer 提供的方法： 123456789101112131415161718192021222324252627&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;use FireRabbitEngine\\Module\\Mail\\Mailer;class IndexController extends Controller&#123; public function test() &#123; $mail = new Mailer(); $mail-&gt;subject(&#x27;测测&#x27;) -&gt;body(&#x27;bbb&#x27;) -&gt;altBody(&#x27;xxxx&#x27;) -&gt;address(&#x27;874811226@qq.com&#x27;) -&gt;send(); $this-&gt;showMessage(&#x27;ok&#x27;); &#125;&#125; 经过测试，邮件确实可以正常发送。 值得一提的是，这里的 body 方法可以接收 HTMl 代码， 因此可以结合 blade 模板发出十分美观的邮件。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十六）JWT用户认证","slug":"my-swoole-framework-16","date":"2021-02-18T04:52:13.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/18/my-swoole-framework-16/","link":"","permalink":"http://huotublog.com/2021/02/18/my-swoole-framework-16/","excerpt":"","text":"前言用户认证模块也是网页中非常重要的一个环节， 比如接口无法使用 session，因此只能传一个特殊的参数 “token”， token 是一个加密的字符串，在服务端进行解密，如果没问题就代表认证成功。 由于自己写的加密系统不安全，所以直接使用比较成熟的加密系统——JWT。 安装jwt 模块集成在框架里，因此要进入框架目录进行安装，而不是直接安装在博客系统里面。 执行命令：composer requiire firebase/php-jwt。 Auth上一个步骤已经安装了 jwt 插件包，用户只需要关注加密和解密， 对 jwt 具体是怎么实现的，则不需要了解。 因此我封装了一个 Auth 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：12:19 **/namespace FireRabbitEngine\\Module\\Auth;use Firebase\\JWT\\JWT;class Auth&#123; protected static $config; public static function setConfig($config) &#123; self::$config = $config; &#125; public static function decode($token) &#123; try &#123; JWT::$leeway = self::$config[&#x27;leeway&#x27;]; $decoded = JWT::decode($token, self::$config[&#x27;key&#x27;], [self::$config[&#x27;alg&#x27;]]); $data = (array)$decoded; return $data[&#x27;data&#x27;] ?? null; &#125; catch (\\Exception $e) &#123; return null; &#125; &#125; public static function encode($data, $expired) &#123; $currentTimestamp = time(); $key = self::$config[&#x27;key&#x27;]; $token = [ &#x27;iat&#x27; =&gt; $currentTimestamp, &#x27;nbf&#x27; =&gt; $currentTimestamp, &#x27;exp&#x27; =&gt; $currentTimestamp + $expired, &#x27;data&#x27; =&gt; $data, ]; return JWT::encode($token, $key, self::$config[&#x27;alg&#x27;]); &#125;&#125; 用户只需要调用 Auth 暴露的加密和解密方法即可。 加载配置在 app.php 添加新的配置参数： 12345Constant::JWT_CONFIG =&gt; [ &#x27;key&#x27; =&gt; &#x27;password&#x27;, &#x27;alg&#x27; =&gt; &#x27;HS256&#x27;, &#x27;leeway&#x27; =&gt; 60,], 其中 key 是加密字符串，alg 是加密方法， leeway 是时间偏差值，意思是说这个 token 在这个偏差的时间内都可以算作认证成功(防止服务器时钟偏差)。 调用方法在 test 方法添加如下代码： 1234567891011121314151617181920212223242526272829&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use FireRabbitEngine\\Module\\Auth\\Auth;use FireRabbitEngine\\Module\\Controller\\Controller;class IndexController extends Controller&#123; public function test() &#123; $token = Auth::encode([ &#x27;test&#x27; =&gt; 123, ], 60); var_dump($token, base64_decode($token)); $value = Auth::decode($token); $this-&gt;showMessage(json_encode($value)); &#125;&#125; 这里的 encode 的参数是一个数组，即用户的信息，可以是用户的 ID， 但绝对不能是密码或者其他敏感信息，因为 jwt 最终生成的 token 使用的是 base64，可以轻松解密。 上述代码打印的结果为: 1234567string(17) &quot;请求URI：/test&quot;string(177) &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MTM2MjUwMTIsIm5iZiI6MTYxMzYyNTAxMiwiZXhwIjoxNjEzNjI1MDcyLCJkYXRhIjp7InRlc3QiOjEyM319.ygfIeSOkifgPqWyUyIb5rJFLnHlaYMvGTue0WEsTvP4&quot;string(131) &quot;&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;&#123;&quot;iat&quot;:1613625012,&quot;nbf&quot;:1613625012,&quot;exp&quot;:1613625072,&quot;data&quot;:&#123;&quot;test&quot;:123&#125;&#125;��y#����l�Ȇ���K�yZ`��N�XK��&quot;object(stdClass)#30 (1) &#123; [&quot;test&quot;]=&gt; int(123)&#125; 至此，JWT 加密模块就完成了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十五）缓存模块","slug":"my-swoole-framework-15","date":"2021-02-18T03:30:22.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/18/my-swoole-framework-15/","link":"","permalink":"http://huotublog.com/2021/02/18/my-swoole-framework-15/","excerpt":"","text":"前言缓存可以大幅提高程序的性能以及减轻数据库压力。 今天就来设计框架的缓存模块。 缓存可以用很多种方法实现，例如：redis、数据库或者文件。 从性能来看，redis 是最优的，因此本框架将会使用 redis 作为缓存系统。 驱动接口虽然现在使用 redis 作为缓存驱动，但是未来可能会添加其他的。 因此将缓存驱动声明为一个接口，以后就不需要修改业务代码了。 在框架目录下新建一个 Cache 文件夹用来存放缓存相关的代码。 接着声明一个接口： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：10:54 **/namespace FireRabbitEngine\\Module\\Cache;use Closure;interface DriverInterface&#123; /** * 载入参数 * @param $config * @return mixed */ public function load($config); /** * 含有过期时间的键值对 * @param string $key * @param int $ttl * @param Closure $initFun * @return string */ public function remember(string $key, int $ttl, Closure $initFun): string; /** * 没有过期时间的键值对 * @param string $key * @param Closure $initFun * @return string */ public function rememberForever(string $key, Closure $initFun): string;&#125; 这里暂且实现两个键值对缓存的方法， remember 记住一个键值对 ttl 秒； rememberForever 记住一个键值对，且不过期。 上述两个方法如果没有默认值，则从 $initFun 闭包函数中获取，同时将数据写入缓存。 除此之外，还有一个 load 方法用于获取缓存的配置信息。 RedisDriver接着在 Cache 下新建一个 Driver 文件夹，用来保存对应的驱动。 创建 RedisDriver，让它实现 DriverInterface： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：10:53 **/namespace FireRabbitEngine\\Module\\Cache\\Driver;use Closure;use FireRabbitEngine\\Module\\Cache\\DriverInterface;class RedisDriver implements DriverInterface&#123; protected $instance; public function load($config) &#123; $this-&gt;instance = new \\Redis(); $this-&gt;instance-&gt;connect($config[&#x27;host&#x27;], $config[&#x27;port&#x27;]); $this-&gt;instance-&gt;auth($config[&#x27;password&#x27;]); &#125; public function remember($key, int $ttl, Closure $initFun): string &#123; $value = $this-&gt;instance-&gt;get($key); if ($value !== false) &#123; var_dump(&#x27;从缓存获取&#x27;); return $value; &#125; var_dump(&#x27;从闭包获取&#x27;); $value = $initFun(); $this-&gt;instance-&gt;setEx($key, $ttl, $value); return $value; &#125; public function rememberForever($key, Closure $initFun): string &#123; $value = $this-&gt;instance-&gt;get($key); if ($value !== false) &#123; return $value; &#125; $value = $initFun(); $this-&gt;instance-&gt;set($key, $value); return $value; &#125;&#125; redis 驱动直接调用 PHP 的 redis 扩展提供的方法。 Cache现在有了缓存驱动，但是并不是直接在控制器或者其他地方实例化这个缓存驱动来调用。 而是创建一个通用的 Cache 类来让用户调用， 如果不这样做，项目的缓存系统就相当于写死了，以后如果要把 redis 换成数据库缓存就很麻烦。 因此我们提供一个 Cache 类，用户只要调用 Cache 暴露出来的方法即可。 在框架的 Cache 目录下新建： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/18 * Time：10:53 **/namespace FireRabbitEngine\\Module\\Cache;use FireRabbitEngine\\Module\\Cache\\Driver\\RedisDriver;class Cache&#123; protected static DriverInterface $driver; public static function setConfig($cache, $config) &#123; switch ($cache) &#123; case &#x27;redis&#x27;: self::redisDriver($config); break; &#125; &#125; protected static function redisDriver($config) &#123; self::$driver = new RedisDriver(); self::$driver-&gt;load($config); &#125; public static function driver(): DriverInterface &#123; return self::$driver; &#125;&#125; Cache 类对外提供了 driver 方法用于获取缓存驱动， 用户调用框架的缓存系统时，只需要从 driver 方法获得缓存驱动的实例， 然后再调用 DriverInterface 声明的标准方法即可。 加载配置缓存系统需要在启动程序的时候连接到 redis， 因此声明一个新的常量，然后在 app.php 添加框架配置： 12345678Constant::CACHE_CONFIG =&gt; [ &#x27;driver&#x27; =&gt; &#x27;redis&#x27;, &#x27;redis&#x27; =&gt; [ &#x27;host&#x27; =&gt; &#x27;redis&#x27;, &#x27;port&#x27; =&gt; &#x27;6379&#x27;, &#x27;password&#x27; =&gt; &#x27;123123&#x27;, ],], 接着，在封装好的启动程序 HttpServer 初始化时加入缓存系统的初始化代码： 123456789101112public function bootstrap($config)&#123; Blade::setConfig($config[Constant::VIEW_CONFIG]); DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]); Logger::setConfig($config[Constant::LOGGER_CONFIG]); // 新增代码 $cache = $config[Constant::CACHE_CONFIG]; Cache::setConfig($cache[&#x27;driver&#x27;], $cache[$cache[&#x27;driver&#x27;]]); return $this;&#125; 如此一来，缓存系统就算完成了。 使用缓存创建一个 test 路由，控制器的代码如下： 123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use FireRabbitEngine\\Module\\Cache\\Cache;use FireRabbitEngine\\Module\\Controller\\Controller;class IndexController extends Controller&#123; public function test() &#123; $value = Cache::driver()-&gt;remember(&#x27;test&#x27;, 5, function () &#123; return &#x27;aaa&#x27;; &#125;); $this-&gt;showMessage(json_encode($value)); &#125;&#125; 从缓存驱动中获取名称为 “test” 的键，如果不存在则执行闭包， 闭包里面是用户的业务逻辑，例如从数据库查询数据等等，最终将结果以字符串的形式返回， 缓存系统将闭包返回的值写入到缓存，最后再把该值返回。 通俗的讲，就是 从缓存获取该键的值，如果没有就执行闭包的函数进行初始化。 测试结果： 12345678910root@0a71c06b420b:/www/blog# php http_server.php string(17) &quot;请求URI：/test&quot;string(15) &quot;从闭包获取&quot;string(17) &quot;请求URI：/test&quot;string(15) &quot;从缓存获取&quot;# 间隔5秒后再访问string(17) &quot;请求URI：/test&quot;string(15) &quot;从闭包获取&quot; 可以发现，第一次因为缓存没有数据，因此执行了闭包的函数， 第二次缓存已经有数据了，所以直接返回缓存中的数据，证明了闭包成功将数据写入到缓存了。 然后 5 秒之后再访问，可以发现又调用了闭包，证明缓存在 5 秒的时候过期了。 优化方案键值对只是 redis 的基本类型，后续还会加入更多的操作方法。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十四）启动程序优化","slug":"my-swoole-framework-14","date":"2021-02-17T10:42:19.000Z","updated":"2023-02-16T06:50:23.262Z","comments":true,"path":"2021/02/17/my-swoole-framework-14/","link":"","permalink":"http://huotublog.com/2021/02/17/my-swoole-framework-14/","excerpt":"","text":"前言前面几篇文章临时修改程序的启动文件，结果变成如下这般惨不忍睹： 12345678910111213141516171819202122232425262728&lt;?phpdate_default_timezone_set(&quot;Asia/Shanghai&quot;);require &#x27;./vendor/autoload.php&#x27;;require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;require_once &#x27;./app/route/web.php&#x27;;require_once &#x27;./app/config/app.php&#x27;;\\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);\\FireRabbitEngine\\Module\\View\\Blade::setConfig($config[&#x27;view&#x27;][&#x27;view_path&#x27;], $config[&#x27;view&#x27;][&#x27;view_cache_path&#x27;]);\\FireRabbitEngine\\Module\\Database\\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);// 新增行\\FireRabbitEngine\\Module\\Logger\\Log::setConfig($config[&#x27;logger&#x27;]);$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 参数的加载方式也需要优化一下，接下来就开始整改。 参数文件统一除了路由配置和中间件映射关系配置，其他的都可以移动到 app.pho 统一管理。 比如数据库的配置、redis 的配置、模板文件的存放位置等，都属于项目的配置。 因此将原来几个单独的配置文件删掉，统一放到 app.php： 1234567891011121314151617181920212223242526272829&lt;?phpuse FireRabbitEngine\\Module\\Constant;return [ &#x27;framework&#x27; =&gt; [ Constant::DATABASE_CONFIG =&gt; [ &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;mysql&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;database&#x27; =&gt; &#x27;blog&#x27;, &#x27;username&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;123123&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, ], Constant::LOGGER_CONFIG =&gt; [ &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../storage/logs/log.log&#x27;, &#x27;level&#x27; =&gt; &#x27;info&#x27;, &#x27;channel&#x27; =&gt; &#x27;channel-name&#x27;, ], Constant::VIEW_CONFIG =&gt; [ &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;, &#x27;cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;, ], ],]; 这个 Constant 类是框架配置的常量，定义如下： 12345678910111213141516&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/16 * Time：10:08 **/namespace FireRabbitEngine\\Module;class Constant&#123; const DATABASE_CONFIG = &#x27;firerabbiit_database&#x27;; const LOGGER_CONFIG = &#x27;firerabbit_logger&#x27;; const VIEW_CONFIG = &#x27;firerabbit_view&#x27;;&#125; 它的作用是统一配置的键名。 Server框架现在是直接使用 swoole 的函数来启动程序， 基于面向对象的思想，现在把 server 也封装为一个类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/15 * Time：16:26 **/namespace FireRabbitEngine\\Module\\Http;use FireRabbitEngine\\Module\\Constant;use FireRabbitEngine\\Module\\Database\\Manager as DatabaseManager;use FireRabbitEngine\\Module\\Logger\\Log as Logger;use FireRabbitEngine\\Module\\Route\\Router;use FireRabbitEngine\\Module\\View\\Blade;use Swoole\\Http\\Server;class HttpServer&#123; public $server; public $router; public function __construct($host, $port, $config = []) &#123; $this-&gt;server = new Server($host, $port); $this-&gt;server-&gt;set($config); &#125; public function loadRouter(Router $router) &#123; $this-&gt;router = $router; return $this; &#125; public function loadMiddleware($middleware) &#123; \\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig($middleware); return $this; &#125; public function bootstrap($config) &#123; Blade::setConfig($config[Constant::VIEW_CONFIG]); DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]); Logger::setConfig($config[Constant::LOGGER_CONFIG]); return $this; &#125; public function request($request, $response) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $this-&gt;registerError($response); $this-&gt;router-&gt;handle($request, $response); &#125; private function registerError($response) &#123; register_shutdown_function(function () use ($response) &#123; $error = error_get_last(); var_dump($error); switch ($error[&#x27;type&#x27;] ?? null) &#123; case E_ERROR : case E_PARSE : case E_CORE_ERROR : case E_COMPILE_ERROR : $response-&gt;status(500); $response-&gt;end($error[&#x27;message&#x27;]); break; &#125; &#125;); &#125; public function start() &#123; $this-&gt;server-&gt;on(&#x27;request&#x27;, [$this, &#x27;request&#x27;]); $this-&gt;server-&gt;start(); &#125;&#125; 修改启动程序现在就可以用 server 类来启动程序了，修改 http_server.php： 123456789101112131415161718192021222324&lt;?phpuse FireRabbitEngine\\Module\\Http\\HttpServer;date_default_timezone_set(&quot;Asia/Shanghai&quot;);define(&#x27;ROOT_PATH&#x27;, __DIR__);require &#x27;./vendor/autoload.php&#x27;;require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;$config = require &#x27;./app/config/app.php&#x27;;$server = new HttpServer(&#x27;0.0.0.0&#x27;, 9527, [ &#x27;worker_num&#x27; =&gt; 4,]);$router = require &#x27;./app/route/web.php&#x27;;$middleware = require &#x27;./app/config/middleware.php&#x27;;$server-&gt;bootstrap($config[&#x27;framework&#x27;]) -&gt;loadMiddleware($middleware) -&gt;loadRouter($router) -&gt;start(); 这样就实现了用类来控制启动程序，启动程序的代码也变得整洁了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十三）框架性能小测","slug":"my-swoole-framework-13","date":"2021-02-14T12:42:02.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/14/my-swoole-framework-13/","link":"","permalink":"http://huotublog.com/2021/02/14/my-swoole-framework-13/","excerpt":"","text":"前言自从写完路由模块之后就各种偷懒了…… 如果所有功能都要自己写的话，工作量实在太大了。 而且我对于 swoole 也没有花时间来学习，现在写的框架也只不过是简单的封装而已。 swoole 的优势很难体现出来，但是相比于用 Laravel 这种重型框架来说， 自己写的框架虽然是“山寨”版 Laravel，但是性能应该比 Laravel 强不少。 于是忍不住就想用 ab 工具来测一下了。 压测结果如果是访问域名的话，其实是先经过 nginx，然后再通过反向代理转发给 swoole， 这种方法与直接访问 swoole 端口有区别，于是就分作两租测试。 Nginx 反向代理：ab -c 100 -n 10000 http://firerabbit-engine.ht/ 直接访问 Swoole 端口：ab -c 100 -n 10000 http://127.0.0.1：9527/ 两种情况分别测试三组数据，取平均值。 测试的路由配置： 123456789101112131415&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Http\\\\Controller\\\\Home\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;a&#x27;, &#x27;b&#x27;]);&#125;);return $router; 路由加入了两个中间件，中间件处理过程也是比较消耗性能的地方。 然后是测试的方法： 12345678910111213141516171819202122232425&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use App\\Http\\Model\\User;use FireRabbitEngine\\Module\\Controller\\Controller;use FireRabbitEngine\\Module\\Logger\\Log;use FireRabbitEngine\\Module\\View\\Blade;class IndexController extends Controller&#123; public function index() &#123; $user = User::find(1); $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]); $this-&gt;showMessage($html); &#125;&#125; 测试方法通过 ORM 查询 users 表的数据，然后传给视图，最后输出视图页面。 这样可以模拟普通的业务逻辑，看看这个框架写的 WEB 程序到底能跑多少分吧！ Nginx 反向代理第一组数据： 1234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.15.12Server Hostname: firerabbit-engine.htServer Port: 80Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 51.355 secondsComplete requests: 10000Failed requests: 0Total transferred: 5570000 bytesHTML transferred: 3980000 bytesRequests per second: 194.72 [#/sec] (mean)Time per request: 513.548 [ms] (mean)Time per request: 5.135 [ms] (mean, across all concurrent requests)Transfer rate: 105.92 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.8 0 51Processing: 42 511 35.3 512 629Waiting: 30 506 35.2 508 629Total: 42 511 35.0 512 629Percentage of the requests served within a certain time (ms) 50% 512 66% 523 75% 529 80% 533 90% 546 95% 557 98% 572 99% 581 100% 629 (longest request) 第二组数据： 1234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.15.12Server Hostname: firerabbit-engine.htServer Port: 80Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 54.842 secondsComplete requests: 10000Failed requests: 0Total transferred: 5570000 bytesHTML transferred: 3980000 bytesRequests per second: 182.34 [#/sec] (mean)Time per request: 548.422 [ms] (mean)Time per request: 5.484 [ms] (mean, across all concurrent requests)Transfer rate: 99.18 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.5 0 40Processing: 56 544 49.7 543 1046Waiting: 50 539 49.6 538 1043Total: 61 544 49.8 543 1050Percentage of the requests served within a certain time (ms) 50% 543 66% 557 75% 567 80% 573 90% 588 95% 602 98% 619 99% 633 100% 1050 (longest request) 第三组数据： 123456789101112131415161718192021222324252627282930313233343536Server Software: nginx/1.15.12Server Hostname: firerabbit-engine.htServer Port: 80Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 54.510 secondsComplete requests: 10000Failed requests: 0Total transferred: 5570000 bytesHTML transferred: 3980000 bytesRequests per second: 183.45 [#/sec] (mean)Time per request: 545.097 [ms] (mean)Time per request: 5.451 [ms] (mean, across all concurrent requests)Transfer rate: 99.79 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 3.1 0 196Processing: 28 542 112.1 527 1561Waiting: 9 538 111.6 522 1557Total: 28 543 111.9 527 1561Percentage of the requests served within a certain time (ms) 50% 527 66% 542 75% 554 80% 562 90% 589 95% 614 98% 745 99% 1471 100% 1561 (longest request) 直接访问 swoole 程序第一组： 1234567891011121314151617181920212223242526272829303132333435Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9527Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 41.408 secondsComplete requests: 10000Failed requests: 0Total transferred: 5620000 bytesHTML transferred: 3980000 bytesRequests per second: 241.50 [#/sec] (mean)Time per request: 414.077 [ms] (mean)Time per request: 4.141 [ms] (mean, across all concurrent requests)Transfer rate: 132.54 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 1.4 0 15Processing: 41 412 34.8 410 580Waiting: 26 411 34.8 410 580Total: 41 412 34.4 410 591Percentage of the requests served within a certain time (ms) 50% 410 66% 421 75% 428 80% 435 90% 454 95% 469 98% 489 99% 507 100% 591 (longest request) 第二组： 1234567891011121314151617181920212223242526272829303132333435Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9527Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 40.637 secondsComplete requests: 10000Failed requests: 0Total transferred: 5620000 bytesHTML transferred: 3980000 bytesRequests per second: 246.08 [#/sec] (mean)Time per request: 406.368 [ms] (mean)Time per request: 4.064 [ms] (mean, across all concurrent requests)Transfer rate: 135.06 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 1.4 0 20Processing: 38 404 38.0 404 594Waiting: 19 404 38.0 403 594Total: 39 404 37.3 404 594Percentage of the requests served within a certain time (ms) 50% 404 66% 415 75% 423 80% 428 90% 443 95% 461 98% 484 99% 497 100% 594 (longest request) 第三组： 1234567891011121314151617181920212223242526272829303132333435Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9527Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 41.103 secondsComplete requests: 10000Failed requests: 0Total transferred: 5620000 bytesHTML transferred: 3980000 bytesRequests per second: 243.29 [#/sec] (mean)Time per request: 411.031 [ms] (mean)Time per request: 4.110 [ms] (mean, across all concurrent requests)Transfer rate: 133.52 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 5Processing: 39 408 49.5 402 1022Waiting: 38 407 49.4 402 1022Total: 43 408 49.5 402 1024Percentage of the requests served within a certain time (ms) 50% 402 66% 413 75% 420 80% 426 90% 441 95% 463 98% 521 99% 628 100% 1024 (longest request) 对比结果主要对比 Requests per second 参数， RPS（也叫 QPS）即平均每秒完成的请求数，这个值越大代币能承受的并发量越高。 nginx 转发的三组分别为：194.72、182.34、182.45 直接访问 swoole 的三组分别为：241.50、246.08、243.29 取平均值即：nginx&#x3D;186.50，swoole&#x3D;243.62 也就是说，通过 nginx 反向代理会损失一部分的性能。 而且距离最开始想要实现在几十毫秒内返回也差了很多，即使是直接访问 swoole 最快的也需要 600ms。 而且通过 nginx 转发之后，QPS 只有不到 200，相比其他 swoole 框架，自己写的框架性能已经大幅下降了。 这中间应该是有一些非异步的请求，比如 MySQL 查询，只有完成查询后才会继续往下执行，导致程序阻塞了。 不过总体而言，使用了 swoole 自己写的框架性能比起普通的 php-fpm 框架要高得多， 如果再加上一些逻辑业务处理，QPS 应该也能维持在 100-200 之间，这样的结果还是比较满意的。 关于 swoole 的特性还是需要仔细学习一番，框架方面的代码也还有很大的优化空间。 如果后续不断更新的话，可支持的并发量应该也会不断变大吧！ 后记为了提高性能，我把 PHP 升级到 7.4，同时 swoole 扩展也升级到 4.6.3， 然后重新测试了一遍。 Nginx 反向代理测试数据： 1234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.15.12Server Hostname: firerabbit-engine.htServer Port: 80Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 55.727 secondsComplete requests: 10000Failed requests: 0Total transferred: 5570000 bytesHTML transferred: 3980000 bytesRequests per second: 179.45 [#/sec] (mean)Time per request: 557.265 [ms] (mean)Time per request: 5.573 [ms] (mean, across all concurrent requests)Transfer rate: 97.61 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.6 0 26Processing: 37 555 58.0 550 938Waiting: 24 550 57.8 545 938Total: 37 555 57.8 550 938Percentage of the requests served within a certain time (ms) 50% 550 66% 565 75% 576 80% 583 90% 604 95% 628 98% 676 99% 797 100% 938 (longest request) 直接访问 swoole 程序测试数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsFinished 10000 requestsServer Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9527Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 41.988 secondsComplete requests: 10000Failed requests: 0Total transferred: 5620000 bytesHTML transferred: 3980000 bytesRequests per second: 238.16 [#/sec] (mean)Time per request: 419.885 [ms] (mean)Time per request: 4.199 [ms] (mean, across all concurrent requests)Transfer rate: 130.71 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 5Processing: 44 416 50.0 411 1090Waiting: 44 416 50.0 410 1090Total: 47 416 50.1 411 1092Percentage of the requests served within a certain time (ms) 50% 411 66% 421 75% 428 80% 434 90% 448 95% 464 98% 520 99% 559 100% 1092 (longest request) 对比结果升级了 PHP 和 swoole 扩展的版本后， nginx&#x3D;179.45，swoole&#x3D;238.16 原本为：nginx&#x3D;186.50，swoole&#x3D;243.62 好像也没有肉眼可见的提升…… 然后又尝试优化 composer 生成的自动加载：composer dump-autoload -o 测试的结果也没有太大的变化。 看来，如果想进一步提升 QPS 的话，重点应该是解决阻塞的地方了。 工作进程数忽然想到提高工作进程数，按道理应该可以提高一定的性能， 编辑 http_server.php 为 swoole 的 http 设置参数： 123$http-&gt;set([ &#x27;worker_num&#x27; =&gt; 8,]); 我的电脑是 4 核 i5，把工作进程设置为核心数的两倍，然后继续测试 swoole 程序和 nginx 转发的结果。 nginx 转发的结果： 1234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.15.12Server Hostname: firerabbit-engine.htServer Port: 80Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 59.781 secondsComplete requests: 10000Failed requests: 0Total transferred: 5570000 bytesHTML transferred: 3980000 bytesRequests per second: 167.28 [#/sec] (mean)Time per request: 597.808 [ms] (mean)Time per request: 5.978 [ms] (mean, across all concurrent requests)Transfer rate: 90.99 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.8 0 38Processing: 46 595 84.2 591 1436Waiting: 39 590 84.2 585 1435Total: 46 595 84.7 591 1445Percentage of the requests served within a certain time (ms) 50% 591 66% 607 75% 618 80% 624 90% 647 95% 668 98% 697 99% 742 100% 1445 (longest request) 直接访问 swoole： 1234567891011121314151617181920212223242526272829303132333435Server Software: swoole-http-serverServer Hostname: 127.0.0.1Server Port: 9527Document Path: /Document Length: 398 bytesConcurrency Level: 100Time taken for tests: 39.114 secondsComplete requests: 10000Failed requests: 0Total transferred: 5620000 bytesHTML transferred: 3980000 bytesRequests per second: 255.66 [#/sec] (mean)Time per request: 391.139 [ms] (mean)Time per request: 3.911 [ms] (mean, across all concurrent requests)Transfer rate: 140.32 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.4 0 6Processing: 61 387 77.4 380 1409Waiting: 61 387 77.4 380 1409Total: 67 388 77.6 381 1413Percentage of the requests served within a certain time (ms) 50% 381 66% 395 75% 405 80% 413 90% 433 95% 452 98% 494 99% 543 100% 1413 (longest request) nginx&#x3D;167.28，swoole&#x3D;255.66 PHP 和 swoole 未升级前：nginx&#x3D;186.50，swoole&#x3D;243.62PHP 和 swoole 升级后：nginx&#x3D;179.45，swoole&#x3D;238.16 嗯？？？nginx 的反而下降了？swoole 的倒是有一定的提升。 也许是因为没有足够的业务，导致测试的结果准确性不高。 测试就到这里吧，博客系统也还没开始制作，框架也属于半成品，等到完成度比较高的时候再测测看。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十二）日志系统","slug":"my-swoole-framework-12","date":"2021-02-14T06:27:25.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/14/my-swoole-framework-12/","link":"","permalink":"http://huotublog.com/2021/02/14/my-swoole-framework-12/","excerpt":"","text":"安装日志系统日志习题属于框架的一部分，因此在框架目录下执行： 1composer require monolog/monolog Logger在框架 module 下新建 Logger 文件夹用来保存日志相关功能代码， 在 Logger 创建 Log 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/14 * Time：13:38 **/namespace FireRabbitEngine\\Module\\Logger;use Monolog\\Handler\\StreamHandler;use Monolog\\Logger;use Monolog\\Formatter\\JsonFormatter;class Log&#123; /** * 日志配置 * @var array */ protected static $config; /** * 日志对象实例 * @var Logger */ protected static $instance = null; public static function setConfig($config) &#123; self::$config = $config; &#125; public static function getLogger() &#123; if (self::$instance == null) &#123; self::$instance = new Logger(self::$config[&#x27;channel&#x27;]); if (!file_exists(self::$config[&#x27;path&#x27;])) &#123; $file = fopen(self::$config[&#x27;path&#x27;], &#x27;w&#x27;); fwrite($file, &#x27;&#x27;); fclose($file); &#125; $streamHandler = new StreamHandler(self::$config[&#x27;path&#x27;], self::$config[&#x27;level&#x27;]);// $streamHandler-&gt;setFormatter(new JsonFormatter()); self::$instance-&gt;pushHandler($streamHandler); &#125; return self::$instance; &#125;&#125; setConfig 加载配置参数，getLogger 判断是否存在日志文件，如果没有则创建，同时返回插件包的 Logger。 配置参数打开 app&#x2F;config&#x2F;app.php，添加日志配置： 123456789101112131415161718192021222324252627282930&lt;?php$config = [ &#x27;view&#x27; =&gt; [ &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;, &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;, ], &#x27;logger&#x27; =&gt; [ &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../storage/logs/log.log&#x27;, &#x27;level&#x27; =&gt; \\Monolog\\Logger::INFO, &#x27;channel&#x27; =&gt; &#x27;channel-name&#x27;, ], &#x27;database&#x27; =&gt; [ &#x27;mysql&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;mysql&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;database&#x27; =&gt; &#x27;blog&#x27;, &#x27;username&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;123123&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, ], ],];return $config; 这里的 view 也被我修改了下，这样看起来更整齐。 加载配置编辑 http_server.php 加载日志配置： 123456789101112131415161718192021222324252627&lt;?phpdate_default_timezone_set(&quot;Asia/Shanghai&quot;);require &#x27;./vendor/autoload.php&#x27;;require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;require_once &#x27;./app/route/web.php&#x27;;require_once &#x27;./app/config/app.php&#x27;;\\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);\\FireRabbitEngine\\Module\\View\\Blade::setConfig($config[&#x27;view&#x27;][&#x27;view_path&#x27;], $config[&#x27;view&#x27;][&#x27;view_cache_path&#x27;]);\\FireRabbitEngine\\Module\\Database\\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);// 新增行\\FireRabbitEngine\\Module\\Logger\\Log::setConfig($config[&#x27;logger&#x27;]);$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 调用日志在 IndexController 测试日志是否能正常写入，添加测试代码： 123456789101112131415161718192021222324252627&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use App\\Http\\Model\\User;use FireRabbitEngine\\Module\\Controller\\Controller;use FireRabbitEngine\\Module\\Logger\\Log;use FireRabbitEngine\\Module\\View\\Blade;class IndexController extends Controller&#123; public function index() &#123; $user = User::find(1); $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]); Log::getLogger()-&gt;error(&#x27;日志&#x27;); $this-&gt;showMessage($html); &#125;&#125; 然后访问首页，可以看到配置日志路径的文件夹下多了一个 log.log： 1[2021-02-14T14:26:29.828157+08:00] channel-name.ERROR: 日志 [] [] 这样日志系统也完成了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十一）数据库模型","slug":"my-swoole-framework-11","date":"2021-02-14T04:41:11.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/14/my-swoole-framework-11/","link":"","permalink":"http://huotublog.com/2021/02/14/my-swoole-framework-11/","excerpt":"","text":"前言数据库操作类自己写不安全，而且也有比较成熟的插件包了， 因此我打算直接引入 Laravel 相同的 ORM。 插件包安装数据库操作属于框架层面的，因此在框架的目录下执行： 1composer require illuminate/database 框架目录下也会自动创建一个 composer.json 文件，同时安装完成后会生成 vendor 文件夹。 在框架目录添加 .gitignore 忽略上传 vendor 文件夹。 Blade 包错误修正在前面完成 blade 模板时，blade 模板的包是在 app 目录下的， 这样就不是在框架里了，因此回到博客目录用 composer remove xiaoler/blade 命令移除 blade 包。 然后再进入框架目录重新安装 blade 即可，这样 blade 模块就属于框架内部了。 框架现在还不是一个 composer 包，因此框架的自动加载文件需要手动添加， 编辑 swoole 启动文件，http_server.php： 1234require &#x27;./vendor/autoload.php&#x27;;// 新增行require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;; 在引入自动加载文件的下一行添加框架的自动加载，这样就完成了。 数据库配置编辑 app&#x2F;config&#x2F;app.php，添加数据库配置： 123456789101112131415161718192021&lt;?php$config = [ &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;, &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;, &#x27;database&#x27; =&gt; [ &#x27;mysql&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;database&#x27; =&gt; &#x27;blog&#x27;, &#x27;username&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;123456&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, ], ],];return $config; ORM 模块加载在框架 module 新建文件夹 Database 用来存储数据库相关功能模块代码， 在 Database 文件夹下新建 Manager.php 用于加载数据库配置： 1234567891011121314151617181920212223242526272829&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/14 * Time：13:02 **/namespace FireRabbitEngine\\Module\\Database;class Manager&#123; protected static $config; public static function setConfig($config) &#123; $db = new \\Illuminate\\Database\\Capsule\\Manager(); $db-&gt;addConnection($config); $db-&gt;setAsGlobal(); $db-&gt;bootEloquent(); &#125; public static function getConfig() &#123; return self::$config; &#125;&#125; setConfig 方法加载一个数组参数的配置。 编辑 http_server.php 加入一行： 1234567891011121314151617181920212223&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;require_once &#x27;./app/route/web.php&#x27;;require_once &#x27;./app/config/app.php&#x27;;\\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);\\FireRabbitEngine\\Module\\View\\Blade::setConfig($config[&#x27;view_path&#x27;], $config[&#x27;view_cache_path&#x27;]);// 新增行\\FireRabbitEngine\\Module\\Database\\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 在 on 之前加载数据库配置。 现在这个启动文件已经不堪入目了，等以后再优化 创建 Model在 app&#x2F;Http 下新建 Model 文件夹用来保存模型文件。 在 Model 新建第一个模型文件 User： 12345678910111213141516171819&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/14 * Time：13:05 **/namespace App\\Http\\Model;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $guarded = []; public $timestamps = false;&#125; 只要让它继承 Illuminate\\Database\\Eloquent\\Model 即可。 添加数据打开数据库，在 users 表加入一行数据： 12name：花花 - 001password：123123 查询数据打开 IndexController，修改 index 方法： 123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:17 PM **/namespace App\\Http\\Controller\\Home;use App\\Http\\Model\\User;use FireRabbitEngine\\Module\\Controller\\Controller;use FireRabbitEngine\\Module\\View\\Blade;class IndexController extends Controller&#123; public function index() &#123; $user = User::find(1); $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]); $this-&gt;showMessage($html); &#125;&#125; 原来的代码是直接传入 name 字符串，现在改成从数据库查询数据然后传给模板。 然后测试，发现页面输出了名字：花花 - 001 如此一来，ORM 模块也完成了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（十）数据库迁移","slug":"my-swoole-framework-10","date":"2021-02-13T16:34:09.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/14/my-swoole-framework-10/","link":"","permalink":"http://huotublog.com/2021/02/14/my-swoole-framework-10/","excerpt":"","text":"前言通常情况下我们要创建 MySQL 数据库的表需要手动创建 SQL 语句。 然而这样一方面是很不方便，另一方面也不安全，如果修改表结构的时候不小心改错了，就会造成无法挽回的后果，而且最关键的是还不知道是谁干的！ 之前上班的时候同事就遇到这种情况，有一个同事不小心删了另一个同事要用的表，结果不言而喻…… Phinx官方网站：https://book.cakephp.org/phinx/0/en/install.html Phinx 是一个数据库迁移插件，使用它可以通过 PHP 代码来创建表或者修改表结构。 如此一来就不需要手动使用 SQL 语句去修改数据库了。 安装 Phinx使用命令：require robmorgan/phinx 完成安装后，再执行 vendor/bin/phinx init： 1234/www/blog# vendor/bin/phinx initPhinx by CakePHP - https://phinx.org.created /www/blog/phinx.php 可以发现它在项目根目录自动创建了一个文件。 配置 Phinx打开上一步得到的 phinx.php： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpreturn[ &#x27;paths&#x27; =&gt; [ &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;, &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27; ], &#x27;environments&#x27; =&gt; [ &#x27;default_migration_table&#x27; =&gt; &#x27;phinxlog&#x27;, &#x27;default_environment&#x27; =&gt; &#x27;development&#x27;, &#x27;production&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;production_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ], &#x27;development&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;development_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ], &#x27;testing&#x27; =&gt; [ &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;name&#x27; =&gt; &#x27;testing_db&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;pass&#x27; =&gt; &#x27;&#x27;, &#x27;port&#x27; =&gt; &#x27;3306&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, ] ], &#x27;version_order&#x27; =&gt; &#x27;creation&#x27;]; 这个就是数据库的配置表，在这里填上自己的数据库账户和密码。 这里有不同的开发环境配置：production（线上环境）、development（开发环境）、testing（测试环境）。 我们暂且只要配置：development 即可。 paths 字段是数据库迁移文件的存放位置，默认是在项目根目录下的 db 文件夹： 1234&#x27;paths&#x27; =&gt; [ &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;, &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;], 数据库迁移文件属于项目的一部分，因此我把它修改成了在 app 目录下： 1234&#x27;paths&#x27; =&gt; [ &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/app/database/migrations&#x27;, &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/app/database/seeds&#x27;], 然后创建对应的文件夹即可。 创建表配置好之后就可以使用命令来创建表了： 1vendor/bin/phinx create User 上述命令生成了 User 表的数据库迁移文件， 可以发现在 app&#x2F;database&#x2F;migrations 目录下多出了一个文件： 1234567891011121314151617181920212223&lt;?phpdeclare(strict_types=1);use Phinx\\Migration\\AbstractMigration;final class User extends AbstractMigration&#123; /** * Change Method. * * Write your reversible migrations using this method. * * More information on writing migrations is available here: * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method * * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working * with the Table class. */ public function change(): void &#123; &#125;&#125; 在 change 方法里添加代码： 123456789public function change()&#123; // create the table $table = $this-&gt;table(&#x27;users&#x27;); $table-&gt;addColumn(&#x27;name&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32]) -&gt;addColumn(&#x27;password&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64]) -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;]) -&gt;create();&#125; 上述代码创建了一张 users 表，包括名称、密码和注册日期。 然后打开 MySQL 数据库，创建一个名字叫做 blog 的数据库。 注意！这里的数据库名字要与 phinx.php 配置文件对应 创建表数据库迁移文件写好之后，就可以用命令执行数据库迁移了。 1vendor/bin/phinx migrate 执行完成之后再返回查看 blog 数据库，可以发现 users 表已经创建好了。 除了 users 表之外，还有一张 phinxlog 表，这是用来保存迁移记录的。 后言数据库迁移属于项目单独引用的，以后再考虑封装到框架里面。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（九）视图blade模板","slug":"my-swoole-framework-9","date":"2021-02-13T13:50:05.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2021/02/13/my-swoole-framework-9/","link":"","permalink":"http://huotublog.com/2021/02/13/my-swoole-framework-9/","excerpt":"","text":"前言路由模块终于告一段落了，虽然完成了但还没有经过严格测试， 因此可能会存在一些问题，具体问题就等接下来的开发过程发现就好了。 视图模块由于我的框架不是专门做 API 的，也不是微服务架构，而是单体应用， 也就是说会出现 HTML 代码跟 PHP 代码混合在一块的视图文件， 直接用原生的 PHP 来写 HTML 页面肯定不是好方法，而模板引擎比较好用的就是 blade 模板了。 安装 blade 模板模板引擎的开发成本太高了，因此我打算直接用别人写好的。 使用 composer 命令 composer require xiaoler/blade， 安装完成后 composer.json 的 require 字段即可看到刚才的安装包： 1234567891011121314151617181920&#123; &quot;require&quot;: &#123; &quot;xiaoler/blade&quot;: &quot;^5.4&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;FireRabbitEngine\\\\Module\\\\&quot;: &quot;firerabbit-engine/module/&quot; &#125;, &quot;files&quot;: [ &quot;firerabbit-engine/common/function.php&quot; ] &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125;&#125; 模板引擎的配置模板引擎在第一次运行时，会根据模板创建出编译后的 php 文件， 也就是说，它需要将模板语言转化成 PHP 语言，生成对应解析后的文件。 在 app 下创建 view 文件夹，用来存放视图模板文件。 在 app 下创建 storage 文件夹，用来保存上传的文件或者缓存文件。 在 storage 目录下继续创建 cache，在 cache 目录下创建 view_cache 用来保存视图缓存文件。 view_cache 要加入到 .gitignore 忽略的目录，缓存文件不需要同步上传 视图缓存文件即经过模板引擎编译后生成的 PHP 文件。 为了方便管理全局配置，在博客目录下创建 app&#x2F;config&#x2F;app.php： 1234567&lt;?php$config = [ &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;, &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;,];return $config; app.php 是博客系统全局的配置文件。 视图模块接下来在框架的 module 目录创建文件夹 View 用来保存视图相关的功能类。 创建 Blade 调用 composer 引入的 blade 模板引擎插件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2021/2/13 * Time：22:06 **/namespace FireRabbitEngine\\Module\\View;use Xiaoler\\Blade\\Compilers\\BladeCompiler;use Xiaoler\\Blade\\Engines\\CompilerEngine;use Xiaoler\\Blade\\Engines\\EngineResolver;use Xiaoler\\Blade\\Factory;use Xiaoler\\Blade\\Filesystem;use Xiaoler\\Blade\\FileViewFinder;class Blade&#123; protected static $viewPath, $cachePath; /** * 设置模板文件目录 * @param $viewPath * @param $cachePath */ public static function setConfig($viewPath, $cachePath) &#123; self::$viewPath = $viewPath; self::$cachePath = $cachePath; &#125; /** * 获取模板引擎返回的html代码 * @param $blade * @param $params * @return string */ public static function view($blade, $params) &#123; $file = new Filesystem; $compiler = new BladeCompiler($file, self::$cachePath); $resolver = new EngineResolver; $resolver-&gt;register(&#x27;blade&#x27;, function () use ($compiler) &#123; return new CompilerEngine($compiler); &#125;); $factory = new Factory($resolver, new FileViewFinder($file, [self::$viewPath])); try &#123; return $factory-&gt;make($blade, $params)-&gt;render(); &#125; catch (\\Throwable $e) &#123; return $e-&gt;getMessage(); &#125; &#125;&#125; setConfig 方法可以用来设置视图和缓存文件的目录。 修改 http_server.php，引入上面创建的 app.php 全局配置文件，同时视图模板加载对应的配置： 123456789101112131415161718&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;require_once &#x27;./app/route/web.php&#x27;;require_once &#x27;./app/config/app.php&#x27;;\\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);\\FireRabbitEngine\\Module\\View\\Blade::setConfig($config[&#x27;view_path&#x27;], $config[&#x27;view_cache_path&#x27;]);$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 现在这个启动文件看起来乱七八糟的，后面再慢慢优化吧。 通过上面的配置，已经可以调用 Blade 类来生成视图文件了。 视图文件在 app&#x2F;view 下创建 layout，layout 是视图共用的模板， 比如顶部导航栏，底部 footer 之类的，也就是说 HTML 的母版。 在 layout 目录下面创建 app.blade.php： 12345678910111213&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; @yield(&#x27;content&#x27;)&lt;/body&gt;&lt;/html&gt; blade 模板文件的命名规则是：视图名称.blade，当然也可以通过配置取消 blade 后缀 这是一个简单的 HTML 代码，@yield(&#39;content&#39;) 即子页需要编写的内容。 关于 blade 模板的使用方法可以网上自行了解 接着在 app&#x2F;view 目录下创建首页 index.php： 123456@extends(&#x27;layout.app&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;index 首页&lt;/h1&gt; &lt;p&gt;这是一个参数：&#123;&#123; $name &#125;&#125;&lt;/p&gt;@endsection index 继承了 layout&#x2F;app.blade.php，只需要编写 ‘content’ 部分即可， 这里输出了一个 $name 参数，用来测试模板传参。 调用 blade 模板编辑 IndexController 的 index 方法： 12345678910111213141516&lt;?phpnamespace App\\Controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;use FireRabbitEngine\\Module\\View\\Blade;class IndexController extends Controller&#123; public function index() &#123; $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; &#x27;花花&#x27;]); $this-&gt;showMessage($html); &#125;&#125; 调用视图的方法为：Blade::view(视图文件名, [参数]) 视图文件名即去掉 blade 的名字，如：index.blade.php，即 index。 showMessage 方法即调用 swoole 的 response 输出字符串： 12345public function showMessage($message)&#123; $this-&gt;httpKernel-&gt;getResponse()-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $this-&gt;httpKernel-&gt;getResponse()-&gt;end($message);&#125; 然后打开浏览器，访问首页，即可看到： 12index 首页这是一个参数：花花 这样，框架的视图模块就完成了！","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（八）路由中间件","slug":"my-swoole-framework-8","date":"2021-02-12T06:57:33.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2021/02/12/my-swoole-framework-8/","link":"","permalink":"http://huotublog.com/2021/02/12/my-swoole-framework-8/","excerpt":"","text":"中间件的概念中间件就是一种系统之间互相连接的“中间的一层”。 通俗的讲类似古代的关口，西游记里唐僧每到一个国家都要取得这个国家的“通关文凭”，如果没有通关文凭就无法离开国界。边关的守卫就可以理解为“中间件”，唐僧就是请求，如果没有通过文凭（即达不到某种要求）就会被拦截在关口。 也就是说，中间件的主要功能是“拦截不符合规范的请求”。 它就是一种 if-else 条件判断结构，如果……就…… 比如要设计一个活动页面，只有今天晚上 9：00 到 10：00 这个时间段才会进入活动页，如果还不到 9 点就打开这个页面就会显示“活动还未开始”，如果是 10 点之后打开这个页面，就会显示“活动已结束”。 要实现这种功能十分简单，直接用 if-else 结构就可以了。 但是这种思想属于面向过程，在框架里可以将判断条件封装为“中间件”实现自动化处理请求，满足要求的就放过，不满足要求的就拦截下来，返回失败的处理。 中间件的应用场景中间件即拦截不符合规范的请求，因此它能用的场景非常多。 例如规定了某个时间段开放、关闭的活动页面； 表单验证、用户登录状态验证等等。 总之，凡是能用“如果……就……”描述的，几乎都可以用中间件实现，因为它本身即是一种条件判断结构。 Laravel 中的中间件Laravel 中的中间件的使用非常优雅！ 创建一个中间件，用于验证用户是否登录： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AuthCheck&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; // 判断用户是否登录状态，如果已登录则进入下一步 if (auth()-&gt;check()) &#123; return $next($request); &#125; // 如果未登录则返回提示页面的视图 $message = &#x27;用户未登录，无法操作，&lt;a href=&quot;#&quot;&gt;前往登录&lt;/a&gt;。&#x27;; return $this-&gt;showErrorPage($message); &#125; public functio showErrorPage($message) &#123; // ... 返回自定义视图页面 &#125;&#125; 然后在 Kernel.php 中注册中间件，并且命名： 123protected $routeMiddleware = [ &#x27;auth.check&#x27; =&gt; AuthCheck::class,]; 最后只要在路由配置中为需要验证用户身份的路由加上中间件即可： 1$router-&gt;middleware(&#x27;auth.check&#x27;)-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;user.index&#x27;); 只需如此简单的配置即可实现路由拦截。 Laravel 中间件的原理一个路由可以有很多中间件，只有满足所有中间件才让请求继续下去，否则就终端请求返回错误的结果。 看起来只需要一个 foreach 循环就能实现中间件了，用伪代码实现思路如下： 12345678910111213141516$flag = true;$conditions = [条件1, 条件2, 条件3];foreach ($conditions as $condition) &#123; if($condition == false) &#123; $flag = false; break; &#125;&#125;if ($flag == true) &#123; // 成功，进入下一步&#125; else &#123; // 失败，返回失败页&#125; 好像确实可以，但我出于好奇研究了一下 Laravel 的源码。 Laravel 源码在定义 Middleware 类的时候，我发现 Middleware 不需要继承任何框架的基类： 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AuthCheck&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; // 判断用户是否登录状态，如果已登录则进入下一步 if (auth()-&gt;check()) &#123; return $next($request); &#125; // 如果未登录则返回提示页面的视图 $message = &#x27;用户未登录，无法操作，&lt;a href=&quot;#&quot;&gt;前往登录&lt;/a&gt;。&#x27;; return $this-&gt;showErrorPage($message); &#125; public functio showErrorPage($message) &#123; // ... 返回自定义视图页面 &#125;&#125; 只是定义一个 handle 方法，一共接收两个参数， 一个是 Laravel 的 $request，另一个是闭包类型 $next。 如果请求验证成功，则直接返回闭包执行结果 $next($request)， 如果请求不符合要求，就自定义一个响应返回。 看来，玄机并不在 Middleware 的定义里。 基于 php-fpm 的框架入口文件基本上都是 index.php， 因此找到 Laravel 的入口文件在 public 目录下面，index.php 的内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package Laravel * @author Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__.&#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());$response-&gt;send();$kernel-&gt;terminate($request, $response); 这里引入了一个文件，然后得到一个 $app 对象，接着调用 handle 方法执行响应事件， 然后就没有其他代码了，因此这个引入的 app.php 是关键所在： 1$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;; 找到 app.php 发现如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/*|--------------------------------------------------------------------------| Create The Application|--------------------------------------------------------------------------|| The first thing we will do is create a new Laravel application instance| which serves as the &quot;glue&quot; for all the components of Laravel, and is| the IoC container for the system binding all of the various parts.|*/$app = new Illuminate\\Foundation\\Application( $_ENV[&#x27;APP_BASE_PATH&#x27;] ?? dirname(__DIR__));/*|--------------------------------------------------------------------------| Bind Important Interfaces|--------------------------------------------------------------------------|| Next, we need to bind some important interfaces into the container so| we will be able to resolve them when needed. The kernels serve the| incoming requests to this application from both the web and CLI.|*/$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Debug\\ExceptionHandler::class, App\\Exceptions\\Handler::class);/*|--------------------------------------------------------------------------| Return The Application|--------------------------------------------------------------------------|| This script returns the application instance. The instance is given to| the calling script so we can separate the building of the instances| from the actual running of the application and sending responses.|*/return $app; 这里是注册服务容器的地方，服务容器 Laravel 实例化类的一种设计模式， 具体的原理我也没有搞懂，只要知道这是一个“注册和实例化类”的地方就可以了。 跟 HTTP 请求相关的部分： 1234$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class); 按住 Ctrl 点击 App\\Http\\Kernel::class 可以跳转到类定义的地方， 结果发现跳转到中间件配置的地方了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; /** * The application&#x27;s global HTTP middleware stack. * * These middleware are run during every request to your application. * * @var array */ protected $middleware = [ // \\App\\Http\\Middleware\\TrustHosts::class, \\App\\Http\\Middleware\\TrustProxies::class, \\Fruitcake\\Cors\\HandleCors::class, \\App\\Http\\Middleware\\CheckForMaintenanceMode::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class, \\App\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, ]; /** * The application&#x27;s route middleware groups. * * @var array */ protected $middlewareGroups = [ &#x27;web&#x27; =&gt; [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], &#x27;api&#x27; =&gt; [// &#x27;throttle:60,1&#x27;, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], ]; /** * The application&#x27;s route middleware. * * These middleware may be assigned to groups or used individually. * * @var array */ protected $routeMiddleware = [ &#x27;auth&#x27; =&gt; \\App\\Http\\Middleware\\Authenticate::class, &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, ];&#125; 看来离想要找到的结果不远了，这个配置也没什么奇怪的地方， 接着发现这个类继承了另一个类： 1use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; 于是我们继续前往这个类，发现这个类有很多方法， 我就直接截取关键部分了： 123456789101112131415161718192021222324/** * Handle an incoming HTTP request. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */public function handle($request)&#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app[&#x27;events&#x27;]-&gt;dispatch( new RequestHandled($request, $response) ); return $response;&#125; handle 方法？也就是说最开始入口文件执行的便是这个方法了。 根据注释：Handle an incoming HTTP request 可以知道这里确实是处理进来请求的地方。 第一行执行的方法：enableHttpMethodParameterOverride，即 Laravel 重写请求方法的地方， 在 Laravel 除了 GET 和 POST 之外，还定义了 PUT、DELETE 等方法， 这里就是判断 _method 变量生成特殊请求方法的地方。 接着查看 sendRequestThroughRouter： 12345678910111213141516171819/** * Send the given request through the middleware / router. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance(&#x27;request&#x27;, $request); Facade::clearResolvedInstance(&#x27;request&#x27;); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 这里的代码应该就是我想要找的了， 1234return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); send 方法非常简单： 123456789101112 /** * Set the object being sent through the pipeline. * * @param mixed $passable * @return $this */public function send($passable)&#123; $this-&gt;passable = $passable; return $this;&#125; 并不是处理中间件的逻辑，接着看 through： 123456789101112/** * Set the array of pipes. * * @param array|mixed $pipes * @return $this */public function through($pipes)&#123; $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args(); return $this;&#125; 也不是，最后的 then： 1234567891011121314/** * Run the pipeline with a final destination callback. * * @param \\Closure $destination * @return mixed */public function then(Closure $destination)&#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes()), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable);&#125; 也只有短短数行的代码，难道最后也没找到中间件的实现逻辑？ 而且……这个 array_reduce 是什么鬼？ 仔细的研究了一番，发现这里的代码虽然只有 4 行，可真的不简单！ 其中，最关键的部分是这个叫做 carry 的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get a Closure that represents a slice of the application onion. * * @return \\Closure */protected function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; try &#123; if (is_callable($pipe)) &#123; // If the pipe is a callable, then we will call it directly, but otherwise we // will resolve the pipes out of the dependency container and call it with // the appropriate method and arguments, returning the results back out. return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; [$name, $parameters] = $this-&gt;parsePipeString($pipe); // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; // If the pipe is already an object we&#x27;ll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we&#x27;re given was already a fully instantiated object. $parameters = [$passable, $stack]; &#125; $carry = method_exists($pipe, $this-&gt;method) ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters) : $pipe(...$parameters); return $this-&gt;handleCarry($carry); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125;; &#125;;&#125; array_reduce如果猜的没错，Laravel 应该就是使用 array_reduce 来实现中间件的。 查了一下 PHP 的官方文档，它对 array_reduce 的描述是： 1array_reduce — 用回调函数迭代地将数组简化为单一的值 嗯……不愧是官方文档，说了跟没讲一样。 还是通过实战来了解一下什么是 array_reduce： 12345678910$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];$result = array_reduce($params, function ($carry, $item) &#123; var_dump(&#x27;carry=&#x27; . $carry); var_dump(&#x27;item=&#x27; . $item); return $carry . $item;&#125;);var_dump($result); 声明一个数组 $params 且包含三个字符串， 然后通过 array_reduce 传入数组参数，同时还有一个闭包， 闭包接收两个参数 $carry, $item，然后试着打印这两个参数以及最终结果： 1234567string(6) &quot;carry=&quot;string(6) &quot;item=a&quot;string(7) &quot;carry=a&quot;string(6) &quot;item=b&quot;string(8) &quot;carry=ab&quot;string(6) &quot;item=c&quot;string(3) &quot;abc&quot; 也就是说，一开始 $carry 的值是空的（Null），然后随着循环， $carry 会逐渐合并数组的每一个元素。 array_reduce 可以说是如下代码构成的： 12345678$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];$result = null;foreach ($params as $param) &#123; $result .= $param;&#125;var_dump($result); 循环遍历数组的每一个元素，然后保持一个不变的值。 与官方文档的描述对应起来了！将数组简化为一个单一的值。 也就是说通过 array_reduce 最终会返回一个值作为处理的结果。 array_reduce 可以接收第三个参数，即初始值： 123456$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];$result = array_reduce($params, function ($carry, $item) &#123; return $carry . $item;&#125;, &#x27;init&#x27;);var_dump($result); 最终会输出：initabc 如果不设置第三个参数，那么初始值就会默认为 Null。 最开始，我以为会是返回 true 或者 false 来判定中间件的执行结果， 但是 Laravel 的设计却令人惊叹！ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get a Closure that represents a slice of the application onion. * * @return \\Closure */protected function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; try &#123; if (is_callable($pipe)) &#123; // If the pipe is a callable, then we will call it directly, but otherwise we // will resolve the pipes out of the dependency container and call it with // the appropriate method and arguments, returning the results back out. return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; [$name, $parameters] = $this-&gt;parsePipeString($pipe); // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; // If the pipe is already an object we&#x27;ll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we&#x27;re given was already a fully instantiated object. $parameters = [$passable, $stack]; &#125; $carry = method_exists($pipe, $this-&gt;method) ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters) : $pipe(...$parameters); return $this-&gt;handleCarry($carry); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125;; &#125;;&#125; 上面的代码十分生涩难懂，简直如同“天书”， 因此我自己尝试实现相同的逻辑并且让代码变成“说人话”。 对暗号游戏接下来我开始参考着 Laravel 中间件的代码实现一个“对暗号”的“游戏”， 比如在一个军营里，一共有 A、B、C 三个巡逻队， 为了避免整个暗号泄露出去，规定每一个巡逻队都只持有暗号的其中一句， 今晚的暗号是：“上山打老虎”， 那么三个巡逻队分别得到的暗号是： A：上山 B：打 C：老虎 而你半夜出去嘘嘘，刚好被巡逻队给碰上了…… 于是，你必须说出你的口令，否则就会被当做奸细就地正法…… 三只巡逻队可以抽象成“巡逻队”概念，即定义一个 Middleware 作为父类， 他们都有核对口号的方法 handle，以及自己的密令： 12345678910111213141516abstract class Middleware&#123; public $keyword; public function handle($value, Closure $closure) &#123; var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword); // 包含指定关键词的口令视为核对成功 if (strstr($value, $this-&gt;keyword) != false) &#123; return $closure($value); &#125; return &#x27;口令核对失败&#x27;; &#125;&#125; 接着创建三个巡逻队，继承基类并且拥有独立的口令： 123456789101112131415class Middleware_A extends Middleware&#123; public $keyword = &#x27;上山&#x27;;&#125;class Middleware_B extends Middleware&#123; public $keyword = &#x27;打&#x27;;&#125;class Middleware_C extends Middleware&#123; public $keyword = &#x27;老虎&#x27;;&#125; 接下来实现具体的逻辑，声明一个包含 N 只巡逻队的数组（可以是 0-3 个）： 1234567function middlewares()&#123; $params = [&#x27;Middleware_A&#x27;, &#x27;Middleware_B&#x27;, &#x27;Middleware_C&#x27;]; $params = array_reverse($params); return $params;&#125; 这里增加了一个 array_reverse 将数组反转的方法，下文会解释。 然后实现核对密令的逻辑，比如你遇到巡逻队 A，那就核对巡逻队 A 的密令， 如果同时遇到两只巡逻队，A+B 或者 A+C 或者 B+C，那就应该核对两个巡逻队的密令， 如果你非常不幸的同时遇到三只巡逻队，那就要核对 ABC 的密令： 1234567891011121314151617181920212223242526272829303132function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe; &#125; return $pipe-&gt;handle($passable, $stack); &#125;; &#125;;&#125;function init()&#123; return function ($destination) &#123; var_dump($destination); return &#x27;ok&#x27;; &#125;;&#125;$response = array_reduce(middlewares(), carry(), init());var_dump($response(&#x27;小鸡炖蘑菇&#x27;));var_dump($response(&#x27;上山打野鸡&#x27;));var_dump($response(&#x27;上山打老虎&#x27;)); 上面的代码虽然很短，但是要理解起来非常不易。 array_reduce 可以接收三个参数： 第一个参数是数组，即要遍历的数组； 第二个参数是一个方法&#x2F;闭包（匿名函数），即执行遍历的逻辑； 第三个参数是初始值。 初始值是最终想要实现的结果，当满足所有条件后，就会返回初始值函数里的代码。 而 middlewares 是最开始定义巡逻队的地方，很不幸你同时遇到三只巡逻队： 1234567function middlewares()&#123; $params = [&#x27;Middleware_A&#x27;, &#x27;Middleware_B&#x27;, &#x27;Middleware_C&#x27;]; $params = array_reverse($params); return $params;&#125; array_reverse 这里的反转数组与接下来的堆栈调用有关， 栈结构是先进后出，会导致乱序，我们希望的结果是按照 A、B、C 的顺序执行。 init 方法定义了最终希望输出的值，如果满足所有条件的话，就返回这个值。 123456789function init()&#123; return function ($destination) &#123; var_dump($destination); return &#x27;ok&#x27;; &#125;;&#125; carry 是整个逻辑最关键的部分： 123456789101112131415function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe; &#125; return $pipe-&gt;handle($passable, $stack); &#125;; &#125;;&#125; 这个方法涉及了闭包的递归调用，最终的返回结果依然是一个闭包。 carry 方法传入两个参数 $stack, $stack 即遍历过程中持续引用的值，而 $pipe 则是当前元素。 回忆一下上面的代码： 123456$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];$result = array_reduce($params, function ($carry, $item) &#123; return $carry . $item;&#125;, &#x27;init&#x27;);var_dump($result); 应该不难理解，这里就是循环遍历一个数组，依次取值进行计算，最终返回一个结果而已。 接下来分析代码： 123456789101112return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe; &#125; return $pipe-&gt;handle($passable, $stack); &#125;;&#125;; carry 返回一个闭包，同时它内层的代码也是返回一个闭包，并且接收一个 $passable 作为参数。 $passable 的作用就是递归函数中不断传给下一次调用的值 在最内层，是一个条件判断语句： 1234567if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe;&#125;return $pipe-&gt;handle($passable, $stack); 如果传来的值不是 Closure（闭包类型），则判断它是否是一个对象， 如果不是对象则根据这个元素的名字实例化出对象来： 123if (!is_object($pipe)) &#123; $pipe = new $pipe;&#125; 最终调用实例化对象的 handle 方法，并且把 $passable 和 持续保留的那个值 $stack 传给 handle。 再看一次执行的逻辑，并且模拟每一次执行的结果： 123456789101112return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe; &#125; return $pipe-&gt;handle($passable, $stack); &#125;;&#125;; 假设调用方法： 12345678// array_reduce 返回的是一个闭包，可以当做函数调用$response = array_reduce(middlewares(), carry(), init());// 传入一个用来验证的口令$result = $response(&#x27;上山打野鸡&#x27;);// 打印出验证结果var_dump($result); 第一次遍历： 通过 init 方法赋值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 第一步：$stack 赋值，init 方法也是一个闭包，接收一个 $destination 参数// $stack 的初始值即 init 方法返回的闭包，所以是：$stack = function ($destination) &#123; var_dump($destination); return &#x27;ok&#x27;; &#125;;// 接着，取出数组的第一个元素$pipe = &#x27;Middleware_A&#x27;;// 第二步，进入闭包：function ($passable) use ($stack, $pipe)// 这里的 $passable 就是上面调用时传入的值：“上山打野鸡”// 执行判断语句if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe;&#125;// 很明显 $pipe 此时只是一个字符串，因此不满足 $pipe instanceof Closure// 于是进入 else 条件 !is_object($pipe) 它并不是一个对象，因此满足此条件// 所以将 $pipe = new $pipe; 实例化成对象// 此处的代码即：$pipe = new Middleware_A();// 实例化出巡逻队A的对象，然后调用他的 handle 方法并返回return $pipe-&gt;handle($passable, $stack);// Middleware_A 继承了父类 Middleware，因此 handle 为：public function handle($value, Closure $closure)&#123; var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword); // 包含指定关键词的口令视为核对成功 if (strstr($value, $this-&gt;keyword) != false) &#123; return $closure($value); &#125; return &#x27;口令核对失败&#x27;;&#125;// 此时 value 的值为：上山打野鸡，巡逻队A的暗号是：上山// 因此巡逻队A验证成功，将这个值传给闭包然后返回return $closure($value);// 接收到参数的 $closure 就是 $stack，也就是我们最开始定义的 init 方法 第二次遍历： 1234567891011121314151617181920212223242526272829303132// 此时已经不会经过 init 初始化了，// $stack的值是第一步返回的 return $pipe-&gt;handle($passable, $stack);// 也就是说init方法// 第二次遍历$pipe就会取第二个巡逻队：Middleware_B// 继续进入 function ($passable) use ($stack, $pipe) 执行判断语句if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe;&#125;// 同样Middleware_B只是一个字符串，因此会被实例化成类// 然后与第一步一样，进行比对暗号，Middleware_B的暗号是：打// 因此：上山打野鸡包含了这个字符，就符合巡逻队B的暗号// 又经过父类的方法：public function handle($value, Closure $closure)&#123; var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword); // 包含指定关键词的口令视为核对成功 if (strstr($value, $this-&gt;keyword) != false) &#123; return $closure($value); &#125; return &#x27;口令核对失败&#x27;;&#125;// init 方法继续被传递给下一个执行的对象 第三步，也就是最后的一个巡逻队了，这里产生了一个分歧点，即最后一个暗号不符合要求： 123456789101112131415161718192021222324252627282930313233343536373839// 第三次遍历$pipe就会取第三个巡逻队：Middleware_C// 继续进入 function ($passable) use ($stack, $pipe) 执行判断语句if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe;&#125;// 一样是实例化的过程，然后分歧点出现了// 第三个巡逻队的暗号是：老虎，而此时给出的却是：上山打野鸡// 不包括“老虎”两个字public function handle($value, Closure $closure)&#123; var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword); // 包含指定关键词的口令视为核对成功 if (strstr($value, $this-&gt;keyword) != false) &#123; return $closure($value); &#125; return &#x27;口令核对失败&#x27;;&#125;// 不符合结果就直接返回了一个字符串“口令核对失败”// 这个返回的值会被当做$stack的值// 最后就跟递归函数一样层层返回，将“口令核对失败”作为array_reduce将数组简化的唯一值// 也就是说，$response(&#x27;上山打野鸡&#x27;) 最后返回的是“口令核对失败”// array_reduce 返回的是一个闭包，可以当做函数调用$response = array_reduce(middlewares(), carry(), init());// 传入一个用来验证的口令$result = $response(&#x27;上山打野鸡&#x27;);// 打印出验证结果var_dump($result); 如果是传入正确的口令：上山打老虎呢？ 123456789101112131415161718// 巡逻队C核对口令正确，就会继续把参数传给闭包public function handle($value, Closure $closure)&#123; var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword); // 包含指定关键词的口令视为核对成功 if (strstr($value, $this-&gt;keyword) != false) &#123; return $closure($value); &#125; return &#x27;口令核对失败&#x27;;&#125;// 此时三个巡逻队已经遍历完了，还记得一直传下来的$stack的值是什么吗？// 答案是：init// 你可以重新返回去查看第一步到第三步，只要是验证口令成功的时候，// init 方法都会被当做下一个闭包传递下去，init 闭包即 $stack 的值// 所以最终返回的 $stack 即 init 方法 注意！上面的 array_reduce 执行完毕后并不是真的执行了代码，而是返回一个层层嵌套的递归函数（闭包），只有在调用的时候才会一层一层的执行，因而最先调用的中间件反而会变成最后执行（栈结构先进后出），所以我们才会在最开始反转数组，以保证执行顺序。 至此，Laravel 中间件验证路由请求的原理也就搞清楚了。 捋顺之后只剩下久久的深思，一段简单的代码却蕴藏着如此精深的奥妙。 可是……写完了如此长篇的文章，我的框架的中间件却还没有开始着手…… 为框架添加中间件中间件原理中间件其实跟路由的原理类似，即创建一个专门保存命名和映射关系的配置文件： 12// 键值对数组的键即中间件名称，值即对应的中间件&#x27;auth&#x27; =&gt; &#x27;App\\\\Middleware\\\\AuthMiddleware&#x27; 只需要用一个简单的名称字符串即可映射到对应的中间件类。 由于一个路由可以有很多个中间件，所以路由配置里需要添加一个数组用来存储中间件的名称。 优化路由模块在之前的设计中，Router 的 $routes 设计为静态变量， 其实只要修改 http_server.php 修改引入方式即可： 1234567891011121314&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;require_once &#x27;./app/route/web.php&#x27;;$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 而路由配置文件 web.php 只要返回 $router 即可： 123456789101112131415&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;); &#125;);return $router; 这样 Router 的 $routes 就不再需要设置为静态变量了。 路由添加中间件在路由配置的时候，期望效果是可以通过如下两种方式配置中间件： 12345678910111213141516&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;, &#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;]])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;)-&gt;middleware([&#x27;auth&#x27;]); &#125;);return $router; 第一种是在分组的时候，配置全组共用的中间件， 第二种是在单个路由配置的时候，可以自定义该路由的中间件， 如果使用第二种方法，并且该路由在一个分组里，该路由不仅有分组的中间件，还有自己单独添加的中间件。 1234567891011121314151617181920&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;, &#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;]])-&gt;group(function () use ($router) &#123; // 这个路由的中间件为：[auth, other] $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;other&#x27;]); // 这个路由的中间件为：[auth] $router-&gt;get(&#x27;/admin&#x27;, &#x27;IndexController@index&#x27;); &#125;);return $router; 上面的 &#x2F;user 路由额外添加了一个中间件 other，而 &#x2F;admin 路由不会受到影响。 中间件的合并顺序为：分组&gt;自定义 即优先执行分组设置的全局中间件，然后再执行自定义中间件。 middleware 方法必须放在 get&#x2F;post&#x2F;any 方法之后。 修改 name 方法，让该方法也返回 $this，这样就可以链式调用了。 然后为 Router 添加 middleware 方法，该方法接收一个数组参数： 12345678910111213141516171819202122232425// 新增属性(全局中间件)protected $middlewares = [];/*** 路由添加中间件** @param array $middlewares* @return Router*/public function middleware(array $middlewares)&#123; if ($this-&gt;lastHandleRouteIndex === null) &#123; return $this; &#125; // 合并中间件，优先级为：分组&gt;单个路由自定义配置 $middlewares = array_merge($this-&gt;middlewares, $middlewares); // 去除重复中间件 $middlewares = array_unique($middlewares); // 找到最后一个添加的路由 $route = $this-&gt;routes[$this-&gt;lastHandleRouteIndex]; $route-&gt;middleware = $middlewares; $this-&gt;routes[$this-&gt;lastHandleRouteIndex] = $route;&#125; 然后是分组的配置： 12345678910111213141516/*** 设置参数* @param $key* @param $value*/protected function createConfig($key, $value)&#123; switch ($key) &#123; case &#x27;namespace&#x27;: $this-&gt;namespace = $value; break; case &#x27;middleware&#x27;: $this-&gt;middlewares = $value; break; &#125;&#125; 分组配置时将中间件加入全局的中间件数组。 在调用结束的时候，应该把这个数组清空： 123456789101112/*** 路由分组* @param $func*/public function group($func)&#123; $func(); // 执行完成后将参数初始化 $this-&gt;namespace = &#x27;&#x27;; $this-&gt;middlewares = [];&#125; 给路由增加中间件的功能就完成了。 现在 RouteParams 路由配置对象里已经可以取到 middleware 属性的值了。 封装请求与响应框架的请求和响应是 swoole 的对象，内置的方法无法满足框架的需求， 因此需要将请求和响应进行封装，在框架的 module 目录新建文件夹 Http， Http 模块用于实现 Http 请求相关的处理类，新建两个类：Request 和 Response 用于封装请求和响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# Request.php&lt;?phpnamespace FireRabbitEngine\\Module\\Http;use FireRabbitEngine\\Module\\Route\\RouteParams;class Request&#123; protected $request, $route; public function __construct($request, $route) &#123; $this-&gt;request = $request; $this-&gt;route = $route; &#125; public function getRequest() &#123; return $this-&gt;request; &#125; /** * 获取路由 * @return mixed */ public function getRoute(): RouteParams &#123; return $this-&gt;route; &#125; /** * 判断该请求是否ajax * @return bool */ public function isAjax() &#123; return &#x27;XMLHttpRequest&#x27; == $this-&gt;request-&gt;header[&#x27;x-requested-with&#x27;]; &#125; /** * 获取get参数 * @param null $key * @param null $default * @return mixed */ public function getQueryParams($key = null, $default = null) &#123; if ($key == null) &#123; return $this-&gt;request-&gt;get; &#125; return isset($this-&gt;request-&gt;get[$key]) ? $this-&gt;request-&gt;get[$key] : $default; &#125; /** * 获取post参数 * @param null $key * @param null $default * @return mixed */ public function getPostParams($key = null, $default = null) &#123; if ($key == null) &#123; return $this-&gt;request-&gt;post; &#125; return isset($this-&gt;request-&gt;post[$key]) ? $this-&gt;request-&gt;post[$key] : $default; &#125; /** * 获取请求方法 * @return string */ public function getRequestMethod() &#123; return $this-&gt;request-&gt;server[&#x27;request_method&#x27;]; &#125; /** * 获取请求IP地址 * @return string | null */ public function getRequestIP() &#123; return $this-&gt;request-&gt;header[&#x27;x-real-ip&#x27;] ?? null; &#125; /** * 获取请求头 * @param $key * @return string | null */ public function getHeaders($key = null) &#123; if ($key == null) &#123; return $this-&gt;request-&gt;header; &#125; return $this-&gt;request-&gt;header[$key] ?? null; &#125; /** * 获取cookie * @param $key * @return string | null */ public function getCookies($key = null) &#123; if ($key == null) &#123; return $this-&gt;request-&gt;cookie; &#125; return $this-&gt;request-&gt;cookie[$key] ?? null; &#125; /** * 获取请求URI * @return mixed */ public function getRequestURI() &#123; return rtrim($this-&gt;request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;); &#125;&#125; Request 请求类实现了一些简单方法的封装，后续如有需求还可以继续扩展。 接下来创建 Response 响应类： 1234567891011121314151617181920212223242526272829303132&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/12/21 * Time：11:31 AM **/namespace FireRabbitEngine\\Module\\Http;class Response&#123; protected $response; public function __construct($response) &#123; $this-&gt;response = $response; &#125; public function getResponse() &#123; return $this-&gt;response; &#125; public function showMessage($message) &#123; $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $this-&gt;response-&gt;end($message); &#125;&#125; 这个类实现了一个简单的输出消息的方法，后续将会增加输出 view 和 API 类型的响应。 现在 Request 和 Response 都有了，但是每次都要分别取这两个对象不太方便， 于是我又定义了一个 Kernel（Http 请求核心类）： 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace FireRabbitEngine\\Module\\Http;class Kernel&#123; protected $request, $response; public function __construct(Request $request, Response $response) &#123; $this-&gt;request = $request; $this-&gt;response = $response; &#125; public function getRequest() &#123; return $this-&gt;request-&gt;getRequest(); &#125; public function getResponse() &#123; return $this-&gt;response-&gt;getResponse(); &#125; public function getHttpRequest() &#123; return $this-&gt;request; &#125; public function getHttpResponse() &#123; return $this-&gt;response; &#125;&#125; 这个类可以取到 swoole 的请求和响应，也可以取到框架自定义的请求和响应。 这样就把请求和响应封装成一个 Http 核心类了。 中间件类Laravel 的中间件不需要继承任何类，完全由用户自定义， 为了统一规范，我定义了一个中间件的父类： 12345678910&lt;?phpnamespace FireRabbitEngine\\Module\\Http;use Closure;abstract class Middleware&#123; abstract public function handle(Kernel $kernel, Closure $next);&#125; 这里类只有一个抽象方法 handle，所有的中间件继承这个类实现统一的标准。 handle 第一个参数即上文封装的 kernel，在中间件里通过 kernel 来获取参数和返回响应。 再在博客项目的路径下，新建 app&#x2F;middleware 用来存放中间件 TestMiddlewareA 和 TestMiddlewareB： 12345678910111213141516171819202122&lt;?phpnamespace App\\Middleware;use Closure;use FireRabbitEngine\\Module\\Http\\Kernel;use FireRabbitEngine\\Module\\Http\\Middleware;class TestMiddlewareA extends Middleware&#123; public function handle(Kernel $kernel, Closure $next) &#123; $request = $kernel-&gt;getHttpRequest(); if ($request-&gt;getQueryParams(&#x27;a&#x27;) == 1) &#123; $kernel-&gt;getHttpResponse()-&gt;showMessage(&#x27;aa&#x27;); return null; &#125; return $next($kernel); &#125;&#125; TestMiddlewareB： 1234567891011121314151617181920212223&lt;?phpnamespace App\\Middleware;use Closure;use FireRabbitEngine\\Module\\Http\\Kernel;use FireRabbitEngine\\Module\\Http\\Middleware;class TestMiddlewareB extends Middleware&#123; public function handle(Kernel $kernel, Closure $next) &#123; $request = $kernel-&gt;getHttpRequest(); if ($request-&gt;getQueryParams(&#x27;b&#x27;) == 1) &#123; $kernel-&gt;getHttpResponse()-&gt;showMessage(&#x27;bb&#x27;); return null; &#125; return $next($kernel); &#125;&#125; 这两个中间件的逻辑非常简单，就是通过 get 参数来判断是否通过请求， 这样在测试的时候就很方便了，只要在路径上面修改参数即可看到中间件的效果。 中间件实际上可以不需要 return null，为了美观后面会对此处的代码进行优化。 中间件逻辑前文通过 array_reduce 来演示 Laravel 中间件的处理逻辑， 现在就要把这个逻辑在框架中进行实现，在 Http 文件夹下新建一个 PipeLine 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace FireRabbitEngine\\Module\\Http;use Closure;class Pipeline&#123; protected $pipes, $kernel; public function send(Kernel $kernel) &#123; $this-&gt;kernel = $kernel; return $this; &#125; public function through($pipes) &#123; $this-&gt;pipes = $pipes; return $this; &#125; public function then(Closure $destination) &#123; return array_reduce($this-&gt;pipes, $this-&gt;carry(), $this-&gt;dispatchRouter($destination)); &#125; function carry() &#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (!is_object($pipe)) &#123; $pipe = new $pipe; &#125; return $pipe-&gt;handle($passable, $stack); &#125;; &#125;; &#125; function dispatchRouter($destination) &#123; return function ($passable) use ($destination) &#123; $destination($passable); &#125;; &#125;&#125; 这个类就是用来处理中间件逻辑的地方，具体逻辑与前文“对口令游戏”一样。 这个类通过 send 方法接收上面封装好的 Http 核心类 Kernel， Kernel 类具有获取请求参数和返回响应的权限，它会被传到中间件里。 中间件要根据请求参数判断是否符合条件，在中间件还可以直接返回响应 中间件的逻辑类也完成了，接下来就要修改 RouteParams 解析路由实例化控制器的地方。 将原来创建控制器实例的方法抽取出来，封装为 routeResponse： 12345678910111213141516171819/*** 执行路由响应* @return \\Closure*/protected function routeResponse()&#123; return function ($kernel) &#123; // 实例化类 $controllerName = $this-&gt;getFullControllerName(); $controllerObject = new $controllerName($kernel); $this-&gt;uri = rtrim($this-&gt;request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;); $params = $this-&gt;getRouteParams(); // 执行方法时，路径参数作为方法的参数 call_user_func_array([$controllerObject, $this-&gt;action], $params); &#125;;&#125; 这个方法返回的是一个闭包，也就是说返回值是一个匿名函数。 接下来修改原来的 createResponse 方法，现在可以直接实例化 PipeLine 来调用中间件： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 执行路由 * @param $request * @param $response */public function createResponse($request, $response)&#123; // 判断请求方法是否正确 if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123; (new MethodErrorResponse())-&gt;response($request, $response, $this); return; &#125; // 判断方法是否存在 $controllerName = $this-&gt;getFullControllerName(); if (!class_exists($controllerName)) &#123; (new ClassNotFoundResponse())-&gt;response($request, $response, $this); &#125; $action = $this-&gt;action; // 不存在方法则返回404 if (!method_exists($controllerName, $action)) &#123; (new ActionNotFoundResponse())-&gt;response($request, $response, $this); return; &#125; $this-&gt;request = $request; $this-&gt;response = $response; // 测试用 $pipes = [&#x27;App\\\\middleware\\\\TestMiddlewareA&#x27;, &#x27;App\\\\middleware\\\\TestMiddlewareB&#x27;]; $pipeline = new Pipeline(); $kernel = new Kernel(new Request($request, $this), new Response($response)); $routeResponse = $pipeline-&gt;send($kernel) -&gt;through(array_reverse($pipes)) -&gt;then($this-&gt;routeResponse()); $routeResponse($kernel);&#125; 上述代码中使用： 1$pipes = [&#x27;App\\\\Middleware\\\\TestMiddlewareA&#x27;, &#x27;App\\\\middleware\\\\TestMiddlewareB&#x27;]; 手动声明了两个中间件，然后访问任意路由就可以看到中间件的效果了。 测试之后发现中间件正常运行。 添加映射关系框架现在没有中间件名称和类名的映射关系，所以才只能用上面的测试代码来调试。 接下来创建一个配置中间件映射关系的文件，在博客目录下创建 app&#x2F;Middleware&#x2F;Kernel.php： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Middleware;class Kernel&#123; /** * 实例化的中间件 * * @var [Middleware] */ protected static $instances; protected static $middlewares = [ &#x27;a&#x27; =&gt; TestMiddlewareA::class, &#x27;b&#x27; =&gt; TestMiddlewareB::class, ]; public static function getMiddlewareInstance($name) &#123; // 从已实例化的对象数组中取 if(isset(self::$instances[$name])) &#123; return self::$instances[$name]; &#125; // 未实例化的创建新对象 $middlewareName = self::$middlewares[$name] ?? null; if($middlewareName == null) &#123; self::$instances[$name] = null; &#125; else &#123; self::$instances[$name] = new $middlewareName; &#125; return self::$instances[$name]; &#125;&#125; 在这里我用一个静态变量来保存实例化的中间件，因为中间件的对象是固定的， 没必要每次调用的时候都重新创建一次，一旦实例化之后就直接放进内存，这样可以提高效率。 这样就完成整个中间件的功能了。 测试中间件编辑 web.php，添加两个测试路由： 1234567891011121314151617181920&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;, &#x27;middleware&#x27; =&gt; [&#x27;a&#x27;]])-&gt;group(function () use ($router) &#123; // 这个路由的中间件为：[auth, other] $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;b&#x27;]); // 这个路由的中间件为：[auth] $router-&gt;get(&#x27;/admin&#x27;, &#x27;IndexController@index&#x27;); &#125;);return $router; 通过访问上述定义的路由，然后修改 a 和 b 参数的值即可看到中间件的拦截功能。 修改记录中间件配置化修改时间：2020-02-13 22:47 突然发现 PipeLine 方法调用 Kernel 类十分不合理。 框架的代码不应该依赖项目的代码，因此需要优化。 在 app&#x2F;config 目录下创建 middleware.php 用来保存中间件的名称映射关系： 123456&lt;?phpreturn [ &#x27;a&#x27; =&gt; App\\Middleware\\TestMiddlewareA::class, &#x27;b&#x27; =&gt; App\\Middleware\\TestMiddlewareB::class,]; 接着将原本放在 app&#x2F;Middleware 下面的 Kernel 删掉， 并且在框架 module&#x2F;Http 目录新建一个 Middleware 目录，将 Middleware.php 移到这个目录下。 同时重新创建一个 Kernel 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace FireRabbitEngine\\Module\\Http\\Middleware;class Kernel&#123; /** * 实例化的中间件 * * @var [Middleware] */ protected static $instances; protected static $middlewares = []; /** * 读取配置文件 * @param $middlewares */ public static function setConfig($middlewares) &#123; self::$middlewares = $middlewares; &#125; public static function getMiddlewareInstance($name) &#123; // 从已实例化的对象数组中取 if (isset(self::$instances[$name])) &#123; return self::$instances[$name]; &#125; // 未实例化的创建新对象 $middlewareName = self::$middlewares[$name] ?? null; if ($middlewareName == null) &#123; self::$instances[$name] = null; &#125; else &#123; self::$instances[$name] = new $middlewareName; &#125; return self::$instances[$name]; &#125;&#125; 中间件的配置不再直接写在这个类里，而是通过 setConfig 读取配置参数。 接着在修改文件 http_server.php，加入一行代码： 1\\FireRabbitEngine\\Module\\Http\\Middleware\\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;); 这样框架和项目之间就不再有直接的依赖关系了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（七）路由动态注入参数","slug":"my-swoole-framework-7","date":"2021-02-11T14:33:44.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/11/my-swoole-framework-7/","link":"","permalink":"http://huotublog.com/2021/02/11/my-swoole-framework-7/","excerpt":"","text":"前言已经写到第七章了，竟然还是在写路由 &#x3D; &#x3D; 今天就来实现路由给方法动态传参的功能。 动态传参就是说路由定义的规则：/article/&#123;id&#125;，会自动注入到 ArticleController 的 show 方法。 示例： 123456789101112131415161718192021// 定义一个路由$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);// 有了上面的路由，用户访问地址：/article/1 就会自动调用ArticleController的show方法// 在前面Controller定义了一个setRouteParams方法把路由参数传给控制器// 控制器内部就存储了一个一维数组：[1]// 但是这样调用起来很麻烦，尤其是参数比较多的时候容易造成混乱// 最优雅的方式就是Laravel的路由参数自动注入// 只要在ArticleController定义一个show方法，接收一个id参数，而路由参数会自动注入到这个方法public function show($id) &#123; var_dump($id);&#125;// 如果是多个参数的呢？也是一样的。$router-&gt;get(&#x27;/article/&#123;id&#125;/edit/&#123;classify&#125;&#x27;, &#x27;ArticleController@test&#x27;)-&gt;name(&#x27;article.test&#x27;);public function test($id, $classify) &#123; var_dump($id, $classify);&#125; 原理解析这里涉及到一个函数动态传参的问题， “如何将数组元素的值，依次作为参数传给函数？” 可变参数PHP 支持函数不定参数，就是用三个点加上参数名即视为可变参数： 123456789// 支持可变参数的函数function test(...$args) &#123; var_dump($args);&#125;// 测试传入不同的参数test(&#x27;a&#x27;);test(&#x27;a&#x27;, &#x27;b&#x27;);test(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); 输出结果： 123456789101112131415161718array(1) &#123; [0]=&gt; string(1) &quot;a&quot;&#125;array(2) &#123; [0]=&gt; string(1) &quot;a&quot; [1]=&gt; string(1) &quot;b&quot;&#125;array(3) &#123; [0]=&gt; string(1) &quot;a&quot; [1]=&gt; string(1) &quot;b&quot; [2]=&gt; string(1) &quot;c&quot;&#125; 也就是说，在函数中可以将可变参数当成数组来使用， 那是不是说明我们传一个数组进去，就会被当成多个参数了呢？ 123456789// 支持可变参数的函数function test(...$args) &#123; var_dump($args);&#125;// 测试传入不同的参数$params = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;];test($params); 上面的代码，我们传入一个数组，按照设想的情况， 数组中的三个值应该会作为三个参数传入 test 方法， 假设的情况是这样： 1234$params = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;];// 想象中的样子test($params); =&gt; test(&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;); 但实际的打印结果却是： 1234567891011array(1) &#123; [0]=&gt; array(3) &#123; [0]=&gt; string(2) &quot;aa&quot; [1]=&gt; string(2) &quot;bb&quot; [2]=&gt; string(2) &quot;cc&quot; &#125;&#125; 也就是说，数组只是被当成了一个参数传给 test 方法， 其实不难想像，如果数组会被解析成多个参数， 那可变参数不是不能传入数组作为参数了吗？ 函数的动态调用通常情况下，没办法实现将数组依次当做函数的参数。 而要用到 PHP 内置的一个方法：call_user_func_array 注意！有一个类似的方法：call_user_func，不要输错！ 这个方法可以动态调用函数，它可以接收两个数组作为参数： 1call_user_func_array([调用对象，方法名称]，[参数1，参数2，参数3...]); 第一个数组，第一个元素是调用的对象，即类的实例化，第二个参数是一个字符串即要调用对象的方法名称。 第二个数组即是要依次传入方法的参数。 示例代码： 12345678910111213141516171819class Test&#123; public function show($name) &#123; var_dump($name); &#125; public function playGame($name, $game) &#123; $text = $name . &#x27;在玩&#x27; . $game; var_dump($text); &#125;&#125;$test = new Test();call_user_func_array([$test, &#x27;show&#x27;], [&#x27;小白&#x27;]);call_user_func_array([$test, &#x27;playGame&#x27;], [&#x27;小白&#x27;, &#x27;俄罗斯方块&#x27;]); 输出结果： 12string(6) &quot;小白&quot;string(27) &quot;小白在玩俄罗斯方块&quot; RouteParams：动态传参动态传参的原理已经弄明白了，接下来只要改造原来的解析方法就可以： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 执行路由 * @param $request * @param $response */public function createResponse($request, $response)&#123; // 判断请求方法是否正确 if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123; (new MethodErrorResponse())-&gt;response($request, $response, $this); return; &#125; // 判断方法是否存在 $controllerName = $this-&gt;getFullControllerName(); if (!class_exists($controllerName)) &#123; (new ClassNotFoundResponse())-&gt;response($request, $response, $this); &#125; $action = $this-&gt;action; // 不存在方法则返回404 if (!method_exists($controllerName, $action)) &#123; (new ActionNotFoundResponse())-&gt;response($request, $response, $this); return; &#125; // 实例化类 $controllerObject = new $controllerName($request, $response, $this-&gt;name); $this-&gt;uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;); $params = $this-&gt;getRouteParams(); // ... 以后的中间件写在这里 // 执行方法时，路径参数作为方法的参数 call_user_func_array([$controllerObject, $action], $params);&#125;/** * 获取路由参数 * @return array */public function getRouteParams()&#123; if ($this-&gt;uri == &#x27;&#x27;) &#123; return []; &#125; preg_match_all($this-&gt;pattern, $this-&gt;uri, $result); if (count($result[0]) == 0) &#123; return []; &#125; $params = []; for ($i = 1; $i &lt; count($result); $i++) &#123; $params[] = $result[$i][0]; &#125; return $params;&#125; RouteParams 将获取路由参数的方法抽离出来， 并且移除了 Controller 的 setRouteParams 方法，改用动态注入参数。 这样路由的参数注入也完成了！ 测试结果编辑 web.php 添加路由： 12$router-&gt;get(&#x27;/article/&#123;id&#125;/edit/&#123;classify&#125;&#x27;, &#x27;ArticleController@test&#x27;)-&gt;name(&#x27;article.test&#x27;);$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;); 编辑 ArticleController 添加方法： 123456789101112131415161718192021&lt;?phpnamespace App\\controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;class ArticleController extends Controller&#123; public function show($id) &#123; var_dump($id); $this-&gt;showMessage(&#x27;ok&#x27;); &#125; public function test($id, $classify) &#123; var_dump($id,$classify); $this-&gt;showMessage(&#x27;ok&#x27;); &#125;&#125; 测试结果均能正确打印出注入的参数。 另外，发现到一个新问题就是路由的顺序，由于是使用正则匹配的，只要修改声明路由的顺序： 12/article/&#123;id&#125;/article/&#123;id&#125;/edit/&#123;classify&#125; 结果访问：http://firerabbit-engine.ht/article/1/edit/aa 就会优先匹配到上面的正则，而 id 参数则是：1&#x2F;edit&#x2F;aa 只能人为避免因为书写顺序而产生奇奇怪怪的问题了，在编辑路由的时候优先将匹配规则较多的写在上面就不会弄错了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（六）为路由模块添加命名功能","slug":"my-swoole-framework-6","date":"2021-02-10T03:08:08.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/10/my-swoole-framework-6/","link":"","permalink":"http://huotublog.com/2021/02/10/my-swoole-framework-6/","excerpt":"","text":"前言参考 Laravel 的路由，希望我的框架可以跟 Laravel 一样给路由命名， 1$router-&gt;get(&#x27;/home&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;); 然后提供一个全局函数 route 生成链接。 比如定义一个路由名 index，路由规则是：“&#x2F;home”， 然后通过 route(&#39;index&#39;) 会生成 “&#x2F;home” 链接。 其实就是从路由配置表里找到对应名字的路由然后取出路由规则而已。 对于需要解析路由参数的就不能只是简单的返回字符串了， 比如显示文章详情：路由命名为：article.show，对应的路由规则：/article/&#123;id&#125;， 通过全局函数生成文章详情的链接 route(&#39;article.show&#39;, [&#39;id&#39;=&gt;1]) 返回：“&#x2F;article&#x2F;1”。 原理与解析路由参数一样，即正则匹配进行替换。 链式调用只要方法返回类本身就可以实现链式调用了。 12345678910111213141516171819202122&lt;?phpclass Test&#123; protected $word = &#x27;&#x27;; public function say($word) &#123; $this-&gt;word .= $word . PHP_EOL; return $this; &#125; public function showResult() &#123; echo $this-&gt;word; &#125;&#125;$test = new Test();$test-&gt;say(&#x27;hello&#x27;)-&gt;say(&#x27;world&#x27;)-&gt;showResult(); Router：添加命名功能其实这个地方我有点疑惑，为什么 name 方法是写在最后面， get 方法已经将路由参数写入到配置里面了，写在链式调用最后的方法如何修改前面设定的值？ 1$router-&gt;get(&#x27;/home&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;); 结果灵鸡一动！突然想到一种奇妙的方法来实现“后调改前值”， 就是加入一个 lastIndex，在插入路由配置的时候，计算这个插入值所在数组的索引并保存下来。 如果要修改最后一个调用的配置，就可以从 lastIndex 获取到了。 修改 Router 原来生成路由配置的方法， 为了链式调用必须返回类本身，同时加入 lastIndex 变量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 保存最后一个操作的路由对象索引 * @var null */private $lastHandleRouteIndex = null;/** * 定义一个 GET 请求路由 * @param $route * @param $controller * @return Router * @throws RouteParamException */public function get($route, $controller)&#123; return $this-&gt;addRoute(RequestMethod::GET, $route, $controller);&#125;/** * 定义一个 POST 请求路由 * @param $route * @param $controller * @return Router * @throws RouteParamException */public function post($route, $controller)&#123; return $this-&gt;addRoute(RequestMethod::POST, $route, $controller);&#125;/** * 定义一个任意请求皆可的路由 * @param $route * @param $controller * @return Router * @throws RouteParamException */public function any($route, $controller)&#123; return $this-&gt;addRoute(RequestMethod::ANY, $route, $controller);&#125;/** * 将路由加入配置数组 * @param $method * @param $route * @param $controller * @return Router * @throws RouteParamException */protected function addRoute($method, $route, $controller)&#123; $param = new RouteParams(); $param-&gt;method = $method; $param-&gt;route = $route; // 格式为：控制器@方法名 $actions = explode(&#x27;@&#x27;, $controller); // 如果不按照规则设置控制器和方法名则抛出异常 if (count($actions) != 2) &#123; throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;); &#125; $param-&gt;controller = $actions[0]; $param-&gt;action = $actions[1]; $param-&gt;namespace = $this-&gt;namespace; $param-&gt;pattern = $this-&gt;getPattern($route); self::$routes[] = $param; // 新加入行 $this-&gt;lastHandleRouteIndex = count(self::$routes) - 1; return $this;&#125; 索引一开始是空的，所以赋值为 null，在插入路由配置的时候， 通过 count(self::$routes) - 1 计算当前新插入值的索引。 接下来新增一个 name 方法，路由名相当于唯一的 ID，因此不允许重复： 1234567891011121314151617181920212223/** * 给路由命名 * @param $routeName * @throws RouteParamException */public function name($routeName)&#123; if ($this-&gt;lastHandleRouteIndex === null) &#123; return; &#125; // 判断路由是否存在同名 foreach (self::$routes as $route) &#123; if ($route-&gt;name == $routeName) &#123; throw new RouteParamException(&#x27;路由名称重复[&#x27; . $routeName . &#x27;]&#x27;); &#125; &#125; $route = self::$routes[$this-&gt;lastHandleRouteIndex]; $route-&gt;name = $routeName; self::$routes[$this-&gt;lastHandleRouteIndex] = $route;&#125; 通过 lastIndex 找到最后一个修改的路由配置，然后给它赋值 name 属性。 避坑指南：诡异的 null 值 这里有个神坑！ PHP 对 null 值的判定很诡异。 在 PHP 中，0 == null 的结果为 true。 因此必须使用三等号：=== 来判定包括类型也必须完全一致。 123if ($this-&gt;lastHandleRouteIndex === null) &#123; return;&#125; 上面的 if 本来是为了判定是否有路由配置，如果还没配置路由就调用 name 就直接跳过， 第一次操作时，lastIndex 的索引是 0，如果不使用三等号第一个配置的路由就会被跳过了。 在使用判空操作，如：empty、isset 时必须注意 0、null、false 这几个值 再来个有趣的小测试： 123var_dump(0 == false);var_dump(0 == null);var_dump(0 == &#x27;&#x27;); 以上三个，全部输出：bool(true)，是不是惊到了！ 在某些场合双等号判定会造成失误，应该改用三等号。 测试路由名称编辑 web.php 修改路由配置： 1234567891011121314151617&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;); $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;); $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;user.index&#x27;); $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;)-&gt;name(&#x27;login.submit&#x27;); $router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);&#125;); 然后在 Router 执行 var_dump(self::$routes) 即可看到所有路由，name 字段已经变成设置的值了。 RouteParams：生成链接RouteParams 保存了路由的所有配置，接下来要让它能根据路由规则生成对应的链接。 PHP 提供了一个正则替换函数： 123456789&lt;?php$uri = &#x27;/article/&#123;id&#125;/classify/&#123;classify&#125;&#x27;;$pattern = &#x27;/&#123;id&#125;/&#x27;;$res = preg_replace($pattern, &#x27;123&#x27;, $uri);var_dump($res); 上面的示例代码通过正则替换将自定义规则的 id 替换成数字 123。 接着，继续看： 12345678910&lt;?php$uri = &#x27;/article/&#123;id&#125;/classify/&#123;classify&#125;&#x27;;$patterns = [&#x27;/&#123;id&#125;/&#x27;, &#x27;/&#123;classify&#125;/&#x27;, ];$replacements = [123, 456];$res = preg_replace($patterns, $replacements, $uri);var_dump($res); 输出结果： 1string(25) &quot;/article/123/classify/456&quot; 通过传入数组参数即可实现批量替换，输出的字符串即链接地址。 原理已经搞清楚了，开始实际上手，修改 RouteParams，创建一个空方法： 1234public function createLink($params)&#123;&#125; 接着创建一个用来生成 query 参数的私有方法： 1234567891011121314 /** * 构建query参数的地址 * @param $route * @param $query * @return string */private function buildQuery($route, $query)&#123; if (empty($query)) &#123; return $route; &#125; return $route . &#x27;?&#x27; . http_build_query($query);&#125; 如果没有参数就直接返回，不然就返回包含 query 参数的路由地址。 现在可以开始编写 createLink 的方法体了， 因为斜杠是正则符号，所以首页的路由“&#x2F;”要单独返回： 123456public function createLink($params)&#123; if ($this-&gt;route == &#x27;/&#x27;) &#123; return $this-&gt;buildQuery($this-&gt;route, $params); &#125;&#125; 接着判断是否包含路由参数，没有参数的也直接返回： 123456789101112131415public function createLink($params)&#123; if ($this-&gt;route == &#x27;/&#x27;) &#123; return $this-&gt;buildQuery($this-&gt;route, $params); &#125; // 取出自定义规则 $pattern = &#x27;/.*?\\/(\\&#123;.*?\\&#125;)/&#x27;; preg_match_all($pattern, $this-&gt;route, $result); // 如果匹配不到自定义参数则直接返回路由规则 if (count($result[0]) == 0) &#123; return $this-&gt;buildQuery($this-&gt;route, $params); &#125;&#125; 我希望实现全局函数 route 传入指定的参数就可以替换掉路由自定义的参数，生成替换了值的地址： 12345// 通过调用全局函数生成路由route(&#x27;article.show&#x27;, [&#x27;id&#x27; =&gt; 1]) =&gt; 返回结果：/article/1// 也就是说，路由规则需要实现如下变换效果/article/&#123;id&#125; =&gt; 从 route 函数传入的数组中取出 id 变量，然后再替换掉 &#123;id&#125; 这一步比较复杂，要先获取到匹配的规则：&#123;id&#125;，以及花括号里面的参数名 id： 1234567891011121314151617181920// 获取自定义匹配规则$patterns = [];$paramNames = [];for ($i = 1, $count = count($result[1]); $i &lt;= $count; $i++) &#123; // 此处得到自定义规则的参数，如：&#123;id&#125; $rule = $result[1][$i - 1]; /** * 花括号是正则表达式的符号，必须加上反斜杠转转义 * 最后，在前后加上斜杠才是一个完整的正则表达式 */ $patterns[] = &#x27;/&#x27; . str_replace([&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;\\&#123;&#x27;, &#x27;\\&#125;&#x27;], $rule) . &#x27;/&#x27;; /** * 截取中间的变量名 */ $paramNames[] = substr($rule, 1, strlen($rule) - 2);&#125; 一共得到了两个数组，$patterns 是正则替换表达式，而 $paramNames 是自定义路由参数的名字。 接下来把自定义路由中的 &#123;id&#125; 替换成 $params 传入的变量值， 因为传入的 $params 是一个关联数组，而 PHP 的正则替换函数是一维数组， 所以要把 $params 中对应的参数提取出来， 从 $paramNames 获取到的路径参名称作为键，取 $params 传进来的值： 1234567891011121314151617/** * 生成要替换的数组结构，根据规则与传入的参数一一对应 * 假设路由规则是 /article/&#123;id&#125; * 那么$params传入的参数就应该是：[&#x27;id&#x27;=&gt;1] */$replacements = [];foreach ($paramNames as $key) &#123; if (!isset($params[$key])) &#123; throw new RouteParamException(&#x27;路由缺失参数[&#x27; . $key . &#x27;]&#x27;); &#125; $replacements[] = $params[$key]; // 移除路径参数 unset($params[$key]);&#125; 如果传入的数组不符合规则就抛出一个 RouteParamException 异常（这个异常是之前定义的）。 生成替换的值后，就可以把这个键从 $params 里面移除了，因为最后我们要生成 query 参数， 而路径参数已经被使用了，如果不去掉，最后就会变成这样： 1/article/1?id=1 所以这一步顺便使用 unset 方法把已经用过的数组元素去掉。 接下来就可以使用正则替换将规则中的 &#123;id&#125; 替换成对应的值了： 12// 然后将替换值根据规则进行置换$res = preg_replace($patterns, $replacements, $this-&gt;route); 最后再构建 query 参数就大功告成，完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 生成链接 * @param $params * @return string * @throws RouteParamException */public function createLink($params)&#123; if ($this-&gt;route == &#x27;/&#x27;) &#123; return $this-&gt;buildQuery($this-&gt;route, $params); &#125; // 取出自定义规则 $pattern = &#x27;/.*?\\/(\\&#123;.*?\\&#125;)/&#x27;; preg_match_all($pattern, $this-&gt;route, $result); // 如果匹配不到自定义参数则直接返回路由规则 if (count($result) == 0) &#123; return $this-&gt;buildQuery($this-&gt;route, $params); &#125; // 获取自定义匹配规则 $patterns = []; $paramNames = []; for ($i = 1, $count = count($result[1]); $i &lt;= $count; $i++) &#123; // 此处得到自定义规则的参数，如：&#123;id&#125; $rule = $result[1][$i - 1]; /** * 花括号是正则表达式的符号，必须加上反斜杠转转义 * 最后，在前后加上斜杠才是一个完整的正则表达式 */ $patterns[] = &#x27;/&#x27; . str_replace([&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;\\&#123;&#x27;, &#x27;\\&#125;&#x27;], $rule) . &#x27;/&#x27;; /** * 截取中间的变量名 */ $paramNames[] = substr($rule, 1, strlen($rule) - 2); &#125; /** * 生成要替换的数组结构，根据规则与传入的参数一一对应 * 假设路由规则是 /article/&#123;id&#125; * 那么$params传入的参数就应该是：[&#x27;id&#x27;=&gt;1] */ $replacements = []; foreach ($paramNames as $key) &#123; if (!isset($params[$key])) &#123; throw new RouteParamException(&#x27;路由缺失参数[&#x27; . $key . &#x27;]&#x27;); &#125; $replacements[] = $params[$key]; // 移除路径参数 unset($params[$key]); &#125; // 然后将替换值根据规则进行置换 $res = preg_replace($patterns, $replacements, $this-&gt;route); return $this-&gt;buildQuery($res, $params);&#125;/** * 构建query参数的地址 * @param $route * @param $query * @return string */private function buildQuery($route, $query)&#123; if (empty($query)) &#123; return $route; &#125; return $route . &#x27;?&#x27; . http_build_query($query);&#125; Router：查找路由名路由的名称是唯一的，每一个名称对应一个路由，相当于路由的唯一 ID。 只要根据这个 ID 就可以找到对应的路由。 Router 方法应该暴露一个可供外部调用的查找路由名方法，修改 Router 添加如下内容： 123456789101112131415/** * 根据路由名称寻找路由 * @param $routeName * @return mixed|null */public function findRouteFromName($routeName)&#123; foreach (self::$routes as $route) &#123; if ($route-&gt;name == $routeName) &#123; return $route; &#125; &#125; return null;&#125; 方法倒是很简单，只要循环找到对应名字的路由配置就行了。 查找数组效率最高的方法不是遍历而是通过数组的下标，我考虑过将路由分为已命名路由和未命名路由，未命名路由就是一个普通的索引数组，而已命名路由则是关联数组，键即路由的名字，这样查找路由时优先从已命名路由通过下标查询，如果没有再去遍历未命名路由，但是如果改成这样，Router 匹配路由规则时就要再进行一次数组合并，反而会降低路由解析的性能，因此舍弃了这种想法 route：全局函数只要 new 一个 Router 对象就可以调用 findRouteFromName 找到对应的路由， 然后再调用路由的 createLink 生成路由链接。 现在缺少一个全局函数：route。 同样借助 composer 的自动加载功能，修改 composer.jsp，添加加载规则： 123456789101112131415161718&#123; &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;FireRabbitEngine\\\\Module\\\\&quot;: &quot;firerabbit-engine/module/&quot; &#125;, &quot;files&quot;: [ &quot;firerabbit-engine/common/function.php&quot; ] &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125;&#125; 在 psr-4 下面增加了一个字段 files，而这个文件即框架的通用函数库。 创建 firerabbit-engine/common/function.php 文件： 1234567891011121314151617181920&lt;?php/** * 根据路由名称生成对应路由 * @param $routeName * @param array $params * @return mixed|null * @throws \\FireRabbitEngine\\Module\\Route\\Exception\\RouteNotFoundException */function route($routeName, $params = [])&#123; $router = new \\FireRabbitEngine\\Module\\Route\\Router(); $route = $router-&gt;findRouteFromName($routeName); if ($route == null) &#123; throw new \\FireRabbitEngine\\Module\\Route\\Exception\\RouteNotFoundException(&#x27;不存在路由[&#x27; . $routeName . &#x27;]&#x27;); &#125; return $route-&gt;createLink($params);&#125; 这里我不使用 function_exists 来判断方法是否存在，即使真的冲突了就直接报错， 实际上使用了这个方法来判断也没任何意义，重名了就不定义这个函数？ 那连错在哪都不知道，为何要屏蔽可能报错的信息？我是百思不得其解。 如果遇到重名的函数，在我们执行 php http_server.php 启动程序的时候就会报错了，完全不用担心。 如果我们引入了第三方的包，其他人也定义了 route 函数那样才会产生麻烦。 一般的第三方包也不会去定义全局函数，而是封装成类进行调用， 函数是面向过程开发，也不符合开发包的理念，所以这一点完全不用担心。 因为我开发的是框架，只有框架才会定义全局函数，我的框架里也不可能引入其他框架。 测试结果三种不同类型的路由： 123$router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;);$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);$router-&gt;get(&#x27;/test/&#123;id&#125;/user/&#123;name&#125;/goods/&#123;qq&#125;&#x27;, &#x27;TestController@test&#x27;)-&gt;name(&#x27;test&#x27;); 测试代码： 12345$link = route(&#x27;test&#x27;, [&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;哈哈怪&#x27;, &#x27;qq&#x27; =&gt; &#x27;okok&#x27;]);$link2 = route(&#x27;article.show&#x27;, [&#x27;id&#x27; =&gt; 123]);$link3 = route(&#x27;login&#x27;);var_dump($link, $link2, $link3); 输出结果： 123string(33) &quot;/test/1/user/哈哈怪/goods/okok&quot;string(12) &quot;/article/123&quot;string(6) &quot;/login&quot; 看上去没有问题了！","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（五）为路由模块添加解析路径参数功能","slug":"my-swoole-framework-5","date":"2021-02-09T10:46:43.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/09/my-swoole-framework-5/","link":"","permalink":"http://huotublog.com/2021/02/09/my-swoole-framework-5/","excerpt":"","text":"前言上文已经实现简单路由，但还没办法解析路由参数。 例如： 1http://www.huotublog.com/article/1 包含了路径参数，即 article 后面的 1。 本章将为路由模块添加解析路径参数的功能。 另外，Query 参数不叫路由参数，例如： 1http://www.huotublog.com/article/1?a=222 这里的 a 是 query 参数，不是路径参数。 匹配原理假设路径参数可以有无限多个，在这样无法确定数量情况， 无法使用一般的 if-else 来获取。 这个时候就需要用到正则表达式了。 正则表达式可以按照某种规则来匹配特殊的字符串，包括替换字符串。 1234567&lt;?php$url = &#x27;/article/123&#x27;;$pattern = &#x27;/article\\/(\\d+)/&#x27;;preg_match_all($pattern, $url, $res);var_dump($res); 以上示例输出结果：123 正则表达式不仅可以匹配特定的规则，而且只要加上括号就可以把匹配规则视为一个变量单独取出来。 如果不了解正则表达式可以自行搜索，这里不扩展。 因为我的路由配置参考 Laravel，所以要实现 Laravel 一样的效果： 12/article/&#123;id&#125;/article/&#123;id&#125;/edit 用花括号包起来的部分视为变量，即有如下匹配规则： 12/article/&#123;id&#125; =&gt; /article/1/article/&#123;id&#125;/edit =&gt; /article/1/edit 还要获取路径上面的变量，也就是说 &#123;id&#125; 部分视为一个路径参数。 既要匹配路由规则，又要获得路径参数，一共需要两步才能实现这样的效果。 第一步是把 /article/&#123;id&#125; 转化为一个正则表达式， 第二步是拿上一步得到的正则表达式去匹配 URI。 路径参数不只是数字，也有可能是别的什么，甚至是中文都可以当做路径参数。 12# 这是一个正确的 URIhttp://www.huotublog.com/article/我的swoole框架 只不过你在浏览器输入上面的地址，然后再复制下来，会被 urlencode。 结果就会变成这样： 1https://huotublog.com/article/%E6%88%91%E7%9A%84swoole%E6%A1%86%E6%9E%B6 所以如果我们只匹配数字是不行的，而是要用全匹配 .。 .（点）在正则表达式里是匹配除了换行之外所有字符串 例如有一个包括两个路径参数的路由： 12345678$url = &#x27;/article/&#123;id&#125;/show/&#123;classify&#125;&#x27;;$pattern = &#x27;/.*?\\/(\\&#123;.*?\\&#125;)/&#x27;;preg_match_all($pattern, $url, $result);$transform = str_replace($result[1], &#x27;(.*?)&#x27;, $url);var_dump($transform); 这里的规则 .*? 是三个正则表达式符号，意思是说尽可能多的匹配字符串。 加上括号就可以取出匹配的字符串了，匹配到的结果存入 $result 变量， 也就是说一共会得到两个值：&#123;id&#125;、&#123;classify&#125; 然后用 PHP 的 str_replace 函数进行简单的替换： 1string(25) &quot;/article/(.*?)/show/(.*?)&quot; 如果不懂正则表达式，直接套用 (.*?) 即可，既简单又粗暴 替换后的字符串还不是表达式，只是加入了正则表达式符号而已。 就跟 json 字符串不是 json 对象一个道理，还需要转换一下才能变成表达式 斜杠是正则表达式里比较敏感的字符，过滤掉干扰字符串，修改为完整的正则表达式： 1234$transform = &#x27;/article/(.*?)/show/(.*?)&#x27;$pattern = &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\\/&#x27;, $transform) . &#x27;$/&#x27;;var_dump($pattern); rtrim 去掉右侧的斜杠，防止匹配不到 输出结果： 1string(32) &quot;/\\/article\\/(.*?)\\/show\\/(.*?)$/&quot; 转换得到的正则表达式，用它就可以匹配出路由规则中的变量： 12345678// 用户请求的 URI$requestUri = &#x27;/article/123/show/abc&#x27;;// 通过匹配得到参数preg_match_all(&#x27;/\\/article\\/(.*?)\\/show\\/(.*?)$/&#x27;, $requestUri, $params);var_dump($params); 输出结果： 1234567891011121314151617array(3) &#123; [0]=&gt; array(1) &#123; [0]=&gt; string(21) &quot;/article/123/show/abc&quot; &#125; [1]=&gt; array(1) &#123; [0]=&gt; string(3) &quot;123&quot; &#125; [2]=&gt; array(1) &#123; [0]=&gt; string(3) &quot;abc&quot; &#125;&#125; 路由参数解析原理已经搞清楚了，接下来就在路由解释器里实现这个功能。 实现解析路由功能有一个特殊的路由，即 /（首页的地址）， 所有的路由都带有 /，导致无法正确匹配，因此这个路由需要单独判断。 RouteParams：解析参数传给控制器RouteParams 增加一个新的变量用来保存替换后的正则表达式： 12345/** * 正则表达式匹配规则 * @var string */public $pattern; 修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public function createResponse($request, $response)&#123; // 判断请求方法是否正确 if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123; (new MethodErrorResponse())-&gt;response($request, $response, $this); return; &#125; // 判断方法是否存在 $controllerName = $this-&gt;getFullControllerName(); if (!class_exists($controllerName)) &#123; (new ClassNotFoundResponse())-&gt;response($request, $response, $this); &#125; $action = $this-&gt;action; // 不存在方法则返回404 if (!method_exists($controllerName, $action)) &#123; (new ActionNotFoundResponse())-&gt;response($request, $response, $this); return; &#125; // 实例化类 $controllerObject = new $controllerName($request, $response, $this-&gt;name); $uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;); if ($uri != &#x27;&#x27;) &#123; // 匹配路径参数 preg_match_all($this-&gt;pattern, $uri, $result); if (count($result[0]) != 0) &#123; $params = []; for ($i = 1; $i &lt; count($result); $i++) &#123; $params[] = $result[$i][0]; &#125; $controllerObject-&gt;setRouteParams($params); &#125; &#125; // ... 以后的中间件写在这里 // 执行方法 $controllerObject-&gt;$action();&#125; 在 RouteParams 创建出控制器对象的时候解析出路径参数，把路径参数传给控制器。 Controller：接收路径参数控制器还没有 setRouteParams 方法，修改控制器的基类： 1234567891011121314151617181920212223242526&lt;?phpnamespace FireRabbitEngine\\Module\\Controller;class Controller&#123; protected $request, $response, $route, $routeParams; public function __construct($request, $response, $route) &#123; $this-&gt;request = $request; $this-&gt;response = $response; $this-&gt;route = $route; &#125; public function showMessage($message) &#123; $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $this-&gt;response-&gt;end($message); &#125; public function setRouteParams($params) &#123; $this-&gt;routeParams = $params; &#125;&#125; 如此一来控制器也能够获取到路径参数了。 Router：赋值匹配规则Router 在生成配置的时候，可以同时生成路由的正则匹配规则。 修改生成路由配置的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 将路由加入配置数组 * @param $method * @param $route * @param $controller * @throws RouteParamException */protected function addRoute($method, $route, $controller)&#123; $param = new RouteParams(); $param-&gt;method = $method; $param-&gt;route = $route; // 格式为：控制器@方法名 $actions = explode(&#x27;@&#x27;, $controller); // 如果不按照规则设置控制器和方法名则抛出异常 if (count($actions) != 2) &#123; throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;); &#125; $param-&gt;controller = $actions[0]; $param-&gt;action = $actions[1]; $param-&gt;namespace = $this-&gt;namespace; $param-&gt;pattern = $this-&gt;getPattern($route); self::$routes[] = $param;&#125;protected function getPattern($route)&#123; if ($route == &#x27;/&#x27;) &#123; return &#x27;&#x27;; &#125; $pattern = &#x27;/.*?\\/(\\&#123;.*?\\&#125;)/&#x27;; preg_match_all($pattern, $route, $result); // 如果第一个数组的个数为0，表示没有匹配到路径参数 if (count($result[0]) == 0) &#123; return &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\\/&#x27;, $route) . &#x27;/&#x27;; &#125; $transform = str_replace($result[1], &#x27;(.*?)&#x27;, $route); $transform = &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\\/&#x27;, $transform) . &#x27;$/&#x27;; return $transform;&#125; getPattern 方法将路由中自定义的规则解析成对应的正则表达式， 然后赋值给 RouteParams 对象。 Router：修改匹配规则现在已经可以获取到正则表达式了，接下来修改路由匹配规则。 将之前 Router 直接匹配的方法改成正则匹配， PHP 有一个用来测试正则匹配结果的函数：preg_match。 没有匹配到正则表达式的字符，这个函数会返回 0，以此来判断是否符合路由规则。 修改 findRoute 方法： 123456789101112131415161718192021222324252627 /** * 寻找路由 * @param $request * @return mixed|null */public function findRoute($request)&#123; $uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;); foreach (self::$routes as $route) &#123; if (empty($uri)) &#123; if ($route-&gt;route != &#x27;/&#x27;) &#123; continue; &#125; return $route; &#125; else if ($route-&gt;pattern != &#x27;&#x27; &amp;&amp; preg_match($route-&gt;pattern, $uri) != 0) &#123; return $route; &#125; &#125; return null;&#125; 路由解释器的解析功能也改完了，接下来创建一个新的控制器来测试是否能获取到参数。 测试结果在 app&#x2F;controller&#x2F;Home 创建 ArticleController： 12345678910111213&lt;?phpnamespace App\\controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;class ArticleController extends Controller&#123; public function show() &#123; $this-&gt;showMessage(json_encode($this-&gt;routeParams)); &#125;&#125; 然后编辑 web.php 添加一条路由配置： 1$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;); 然后访问地址：http://firerabbit-engine.ht/article/1 可以看到输出了一个数组，且只有一个值：1。 防止路由冲突由于匹配规则具有先后级，就是书写的顺序。 定义具有歧义的路由时要注意先后顺序： 12$router-&gt;get(&#x27;/user/&#123;id&#125;&#x27;, &#x27;UserController@test&#x27;);$router-&gt;get(&#x27;/user/home&#x27;, &#x27;UserController@home&#x27;); 上面将 / 后面的参数视为 id 变量， 所以会匹配到第一个路由，第二个路由就被忽略了。 在配置路由的时候要注意先后顺序，最好不要定义具有歧义的路由。 防止路由重名在 Laravel 里面可以有相同匹配规则但是请求方法不同的路由， 例如： 12$router-&gt;get(&#x27;/user/home&#x27;, &#x27;UserController@homeGet&#x27;);$router-&gt;post(&#x27;/user/home&#x27;, &#x27;UserController@homePost&#x27;); 我设计的路由模块不支持这个功能，不能定义同名路由。 可能存在的问题路由解析是框架里面最核心且使用频率最高的一个部分， 正则表达式的性能可能会比较低。 有一个优化的方法就是增加路由缓存，将匹配成功的路由记录下来， 下次访问先检测这条记录是不是在缓存里，如果是的话就不去正则匹配而是直接从缓存取出记录过的路由对象。 现在还不需要考虑到性能优化，如果到时候真的有问题了再优化也不迟。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（四）路由模块","slug":"my-swoole-framework-4","date":"2021-02-09T03:25:34.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/09/my-swoole-framework-4/","link":"","permalink":"http://huotublog.com/2021/02/09/my-swoole-framework-4/","excerpt":"","text":"前言路由是一个框架最基本的功能， 虽然没研究过框架的路由是怎么加载的， 这里就凭直觉和使用 Laravel 的经验来自己写一个。 REQUEST_URI用户请求网页输入的网址叫做 URL，URL 在网上已经被统称为 URI 了，下文也采用 URI 的说法。 （注意区分：一个是i，一个是l） 其实 URL 跟 URI 有区别，如果你有兴趣可以了解一下这个小知识：URL 是 URI 的子集，URI 是一种抽象的概念，只要是任何可以可以找到某个资源的方法就叫做 URI，它还包括：URN，就是通过资源名字+身份证的方式找资源，但是 URN 几乎没人用，导致 URI 几乎全部是 URL，所以现在把 URL 当做 URI 也没什么问题，实际上它们算是抽象父类和子类的关系 swoole 可以通过 $request-&gt;server[&#39;request_uri&#39;] 获取到请求的资源路径。 路由模块原理用户访问网站的本质就是请求服务器上面的一个文件。 比如请求一张图片： 12# 名称为 1.jpg 的文件http://www.huotublog.com/img/1.jpg 不仅是图片，js、css 都是文件，包括 php 也是一种文件。 我们在 nginx 的配置： 123456789101112131415161718server &#123; listen 80; server_name firerabbit-engine.ht; location ~* \\.(gif|jpg|jpeg|png|css|js|ico|ttf|woff|woff2|svg|map)$ &#123; root /www/firerabbit-engine/public; &#125; location / &#123; proxy_http_version 1.1; proxy_set_header Connection &quot;keep-alive&quot;; proxy_set_header X-Real-IP $remote_addr; if (!-e $request_filename)&#123; proxy_pass http://php-fpm72:9527; # 注意 &#125; &#125;&#125; 这里把图片等静态文件全部指向 &#x2F;www&#x2F;firerabbit-engine&#x2F;public 目录。 如果没有找到文件，就转发给 http://php-fpm72:9527 来处理。 而监听这个端口的，就是 swoole 程序。 例如用户访问网页地址为：http://www.huotublog.com/article/1 这个地址的后缀不符合 nginx 配置的设定，属于“找不到文件”的情况， 因此 nginx 就会把请求转发给我们设置的 swoole 监听的端口， nginx 在转发时会将请求的参数、cookie 等也一并转发 swoole 接收到的 URI 即：&#x2F;article&#x2F;1 “&#x2F;article&#x2F;1” 只是一个字符串， 究竟是怎么变成 Controller 里的方法被执行的？ 这就是路由解释器的作用了：将字符串解析成对应的控制器和方法。 PHP 实例化方法在 PHP 中实例化对象是通过：new 类名 的方法，但是我们这里只能拿到字符串。 那应该怎么实例化出对象呢？ 下面这样明显是错的： 123456789101112&lt;?phpclass IndexController&#123; public function sayHello() &#123; echo &#x27;hello&#x27;; &#125;&#125;// 想要实例化一个字符串的错误方法$obj = new &#x27;IndexController&#x27;; 这里就要用到 PHP 中的一个概念：可变变量。 这里的“可变”不是指变量的类型，而是变量本身就是可变的。 直接看示例代码： 12345678910111213// 定义两个变量$dog = &#x27;狗狗&#x27;;$cat = &#x27;猫猫&#x27;;// 再定义一个变量，取名为 $dog 变量的名字 $test = &#x27;dog&#x27;;// 会输出什么？echo $$test;// 接着，改变 $test 的值为 $cat 变量的名字$test = &#x27;cat&#x27;;// 会输出什么？echo $$test; 结果是：狗狗猫猫 可变变量也就是可以“改变”的变量，我们利用这个特性就可以实例化对象和调用方法： 1234567891011121314&lt;?phpclass IndexController&#123; public function sayHello() &#123; echo &#x27;hello&#x27;; &#125;&#125;$controller = &#x27;IndexController&#x27;;$obj = new $controller;$obj-&gt;sayHello(); 可变变量是实现路由的基础。 匹配规则最后只需要将 URI 解析成对应的控制器和方法的字符串就可以了， 至少有三种方法可以实现。 方法一：Query 参数简单的粗暴的 query 参数。 query 参数就是 GET 方法的查询参数： 12# a 就是 query 参数http://www.huotublog.com?a=1 我们可以直接指定请求的控制器和方法： 12# c 是控制器名称，a 是方法，其他的是参数http://www.huotublog.com?c=article&amp;a=show&amp;id=1 上面的例子即请求 ArticleController 的 Show 方法，显示 ID&#x3D;1 的文章。 这种方法简单粗暴，并且十分无脑，最大的问题是太丑了，所以直接舍弃这个方案。 好看的路由应该是这样的： 12345678# 显示文章详情http://www.huotublog.com/article/1# 编辑文章页面http://www.huotublog.com/article/edit# 文章列表 ，可适当加入 query 参数http://www.huotublog.com/article_list?classify=1 方法二：文件映射建立文件映射关系，即路由映射到指定目录下的文件。 比如有一个路由： 1http://www.huotublog.com/article/show/1 我们拿到 “&#x2F;article&#x2F;show&#x2F;1” 这个字符串，以 “&#x2F;“ 为分割符，可以得到对应的值。 123$uri = &#x27;/article/show/1&#x27;;$route = explode(&#x27;/&#x27;, $uri); 然后将 $route[0] 作为控制器的名字， $route[1] 作为方法的名字， 如果有 $route[2] 则视为路由参数。 遇到特殊的情况： 12345# 网站首页http://www.huotublog.com# 列表页http://www.huotublog.com/article_list 则进行特殊处理，当访问首页时，接收到的字符串是 “&#x2F;”, 即 $route[0] 为空，这种情况就默认请求 IndexController， 如果 $route[1] 是空的（即方法名为空）， 则默认请求 index 这个方法。 实现如下： 1234567891011121314151617181920$uri = &#x27;/&#x27;;$route = array_filter(explode(&#x27;/&#x27;, $uri));// 控制器名称$controllerName = &#x27;Index&#x27;;if(isset($route[0])) &#123; $controllerName = ucfirst(strtolower($route[0]));&#125;// 方法名称$method = &#x27;index&#x27;;if(isset($route[1])) &#123; $method = $route[1];&#125;// 路由参数$param = isset($route[2]) ?? null; 这样就解决了特殊路由无法匹配的问题， 这种方法的好处是直接将请求的路由解析成对应的控制器和方法名称， 但是局限性也比较大，所有的路由都是相同规格的，而且不支持路由命名。 如果你要生成一个链接就只能写硬编码了。 最好的方法是给路由命名，然后通过一个函数来生成对应的路由。 方法三：映射关系表配置映射关系表关联数组)， 键名即路由的名字，值保存了路由的配置， 这样我们就可以实现路由命名的功能了： 1234567891011121314$routes = [ &#x27;home&#x27; =&gt; [ &#x27;route&#x27; =&gt; &#x27;/&#x27;, &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\&#x27;, &#x27;controller&#x27; =&gt; &#x27;IndexController&#x27;, &#x27;method&#x27; =&gt; &#x27;index&#x27;, ], &#x27;user.home&#x27; =&gt; [ &#x27;route&#x27; =&gt; &#x27;/user&#x27;, &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\&#x27;, &#x27;controller&#x27; =&gt; &#x27;UserController&#x27;, &#x27;method&#x27; =&gt; &#x27;index&#x27;, ],]; 其中路由配置里包含了 namespace（命名空间），controller（对应控制器的名称）， method（控制器方法名称），route 是匹配的路由规则。 如果我们要引用一个路由地址，例如首页：$routes[&#39;home&#39;][&#39;route&#39;]。 如果要匹配一个路由，例如请求为：“&#x2F;”，则可以遍历 $routes，然后匹配 route 字段是否符合要求。 到这里，思路已经很清晰了，我们现在就可以创建一个 routes.php 路由配置表， 但是这样属于硬编码，我们不应该直接用一个数组文件来配置路由， （这样是面向编程开发了，而框架应该是面向对象开发。） 接下来开始封装类，通过类来执行路由的初始化。 路由对象在框架 module 目录下，创建 Route 文件夹，作为路由模块相关代码存放点。 Router：路由解释器接着创建类文件 Router，如下： 123456789|-- app| `-- public|-- composer.json|-- firerabbit-engine| `-- module| `-- Route| `-- Router.php|-- http_server.php`-- vendor 给 Router 加上命名空间： 12345678&lt;?phpnamespace FireRabbitEngine\\Module\\Route;class Router&#123; &#125; Laravel 的路由配置是比较优雅的， 我打算直接参考 Laravel 路由的调用方法再自己实现一个。 Laravel 的路由配置示例： 1Route::get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;); 简单地说就是在 Route 类里面以数组存储路由配置，也就是上面的数组格式， 然后通过调用方法将路由规则写入到数组里面。 RequestMethod：请求方法常量我们知道请求方法主要有 GET、POST， 请求方法也是路由的一部分，可以通过限制请求方法来阻止一些不符合规范的请求。 创建一个专门用来保存常量的类 /module/Route/RequestMethod.php： 12345678910&lt;?phpnamespace FireRabbitEngine\\Module\\Route;class RequestMethod&#123; const GET = &#x27;GET&#x27;; const POST = &#x27;POST&#x27;; const ANY = &#x27;ANY&#x27;;&#125; 其中，any 意思是两种方法都允许。 RouteParams：路由对象每个路由配置都当成一个对象来处理，因此同样封装一个类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：12:48 PM **/namespace FireRabbitEngine\\Module\\Route;class RouteParams&#123; /** * 路由名称 * @var string */ public $name; /** * 路由匹配规则 * @var string */ public $route; /** * 命名空间 * @var string */ public $namespace; /** * 控制器名称 * @var string */ public $controller; /** * 调用的控制器方法名称 * @var string */ public $action; /** * 请求方法 * @var string */ public $method; public function createResponse($request, $response) &#123; // 待实现 &#125; public function getFullControllerName() &#123; return $this-&gt;namespace . $this-&gt;controller; &#125;&#125; 这个类里的 createResponse 方法暂时放空，待会实现。 Controller：控制器现在还没有控制器，因此在 module 文件夹里面创建一个 Controller， 并创建一个 Controller 基类： 12345678910111213141516171819202122232425262728293031&lt;?php/** * Created by PhpStorm * Author：FireRabbit * Date：2/9/21 * Time：1:16 PM **/namespace FireRabbitEngine\\Module\\Controller;class Controller&#123; protected $request, $response; protected $route; public function __construct($request, $response, $route) &#123; $this-&gt;request = $request; $this-&gt;response = $response; $this-&gt;route = $route; &#125; public function showMessage($message) &#123; $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $this-&gt;response-&gt;end($message); &#125;&#125; 以后博客的控制器全部继承框架的基类，目前里面只有一个简单的显示消息的方法。 然后为了测试路由，在 app&#x2F;controller 下面创建两个控制器：IndexController 和 UserController： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;class IndexController extends Controller&#123; public function index() &#123; $this-&gt;showMessage(&#x27;网站首页&#x27;); &#125; public function login() &#123; $this-&gt;showMessage(&#x27;登录页面&#x27;); &#125;&#125;&lt;?phpnamespace App\\controller\\Home;use FireRabbitEngine\\Module\\Controller\\Controller;class UserController extends Controller&#123; public function index() &#123; $this-&gt;showMessage(&#x27;用户中心&#x27;); &#125; public function loginSubmit() &#123; $this-&gt;showMessage(&#x27;注册成功！&#x27;); &#125;&#125; 目前的文件结构如下： 123456789101112131415|-- app| |-- controller| `-- Home| |--- IndexController.php| `--- UserController.php|-- composer.json|-- firerabbit-engine| `-- module| |-- Controller| | `-- Controller.php| `-- Route| |-- RouteParams.php| `-- Router.php`-- http_server.php Router：生成路由配置接下来实现路由解释器的配置功能，编辑 Router.php，添加方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 保存路由配置的数组protected static $routes = [];/** * 定义一个 GET 请求路由 * @param $route * @param $controller * @throws RouteParamException */public function get($route, $controller)&#123; $this-&gt;addRoute(RequestMethod::GET, $route, $controller);&#125;/** * 定义一个 POST 请求路由 * @param $route * @param $controller * @throws RouteParamException */public function post($route, $controller)&#123; $this-&gt;addRoute(RequestMethod::POST, $route, $controller);&#125;/** * 定义一个任意请求皆可的路由 * @param $route * @param $controller * @throws RouteParamException */public function any($route, $controller)&#123; $this-&gt;addRoute(RequestMethod::ANY, $route, $controller);&#125;/** * 将路由加入配置数组 * @param $method * @param $route * @param $controller * @throws RouteParamException */protected function addRoute($method, $route, $controller)&#123; $param = new RouteParams(); $param-&gt;method = $method; $param-&gt;route = $route; // 格式为：控制器@方法名 $actions = explode(&#x27;@&#x27;, $controller); // 如果不按照规则设置控制器和方法名则抛出异常 if (count($actions) != 2) &#123; throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;); &#125; $param-&gt;controller = $actions[0]; $param-&gt;action = $actions[1]; self::$routes[] = $param;&#125; 自定义了 get、post、any 方法实现路由配置， 控制器和方法的格式就模仿 Laravel，如：IndexController@index， 就是请求 IndexController 控制器的 index 方法。 RouteParamException：自定义异常这里我还抛出了一个自定义异常，因此需要在 module&#x2F;Route 下再创建一个 Exception 文件夹用来保存自定义异常类： 12345678910&lt;?phpnamespace FireRabbitEngine\\Module\\Route\\Exception;use Exception;class RouteParamException extends Exception&#123;&#125; 异常类只要有一个壳就好了。 web.php：路由配置文件现在路由添加参数的功能也做好了，接下来就要一个用来配置路由的文件。 在 app 目录下新建一个 route 文件夹，再创建一个 web.php 用来保存页面路由。 以后还可以创建 api.php 用来实现接口路由 web.php 内容如下： 12$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;get(&#x27;/&#x27;, &#x27;App\\\\Controller\\\\Home\\\\IndexController@index&#x27;); 这样显然很不美观，命名空间应该被提取出来。 Router：增加分组功能重新编辑 Router.php，添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 分组命名空间protected $namespace = &#x27;&#x27;;/** * 设置配置参数外部调用方法 * @param $configs * @return $this */public function setConfig($configs)&#123; foreach ($configs as $key =&gt; $value) &#123; $this-&gt;createConfig($key, $value); &#125; return $this;&#125;/** * 设置参数 * @param $key * @param $value */protected function createConfig($key, $value)&#123; switch ($key) &#123; case &#x27;namespace&#x27;: $this-&gt;namespace = $value; break; &#125;&#125;/** * 路由分组 * @param $func */public function group($func)&#123; $func(); // 执行完成后将参数初始化 $this-&gt;namespace = &#x27;&#x27;;&#125;/** * 将路由加入配置数组 * @param $method * @param $route * @param $controller * @throws RouteParamException */protected function addRoute($method, $route, $controller)&#123; $param = new RouteParams(); $param-&gt;method = $method; $param-&gt;route = $route; // 格式为：控制器@方法名 $actions = explode(&#x27;@&#x27;, $controller); // 如果不按照规则设置控制器和方法名则抛出异常 if (count($actions) != 2) &#123; throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;); &#125; $param-&gt;controller = $actions[0]; $param-&gt;action = $actions[1]; $param-&gt;namespace = $this-&gt;namespace; // 将命名空间赋值给路由对象 self::$routes[] = $param;&#125; 增加了一个 group 分组方法，现在就可以把路由按照分组进行配置了， createConfig 方法以后可以支持更多的分组配置参数。 重新编辑 web.php： 123456789101112131415&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;); $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;); $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;); $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;);&#125;); 看起来好多了，配置文件也弄好了。 RouteParams：执行路由Router 里只负责解析路由和生成路由配置，执行路由不应该在 Router， 上面定义了 RouteParams 类（路由对象），这个类才是实际的执行者： 1234567891011121314151617181920212223242526272829public function createResponse($request, $response)&#123; // 判断请求方法是否正确 if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123; (new MethodErrorResponse())-&gt;response($request, $response, $this); return; &#125; // 判断方法是否存在 $controllerName = $this-&gt;getFullControllerName(); if (!class_exists($controllerName)) &#123; (new ClassNotFoundResponse())-&gt;response($request, $response, $this); &#125; $action = $this-&gt;action; // 不存在方法则返回404 if (!method_exists($controllerName, $action)) &#123; (new ActionNotFoundResponse())-&gt;response($request, $response, $this); return; &#125; // 实例化类 $controllerObject = new $controllerName($request, $response, $this-&gt;name); // ... 以后的中间件写在这里 // 执行方法 $controllerObject-&gt;$action();&#125; 按照面向对象的编程思想，RouteParams 类即一个实际的路由，这个类暴露 createResponse （创建响应）方法供外部调用。 RouteResponse：路由响应这个类里还有一些返回响应的方法，比如找不到方法或者类文件， 因此需要创建一个 module&#x2F;Route&#x2F;Response 文件夹用来保存响应相关的类。 创建一个响应类的基类： 123456789&lt;?phpnamespace FireRabbitEngine\\Module\\Route\\Response;abstract class RouteResponse&#123; public abstract function response($request, $response, $route);&#125; 然后再创建几个继承该类的响应，例如 NotFoundResponse 响应： 12345678910111213&lt;?phpnamespace FireRabbitEngine\\Module\\Route\\Response;class NotFoundResponse extends RouteResponse&#123; public function response($request, $response, $route) &#123; $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&#x27;不存在页面，404&#x27;); &#125;&#125; 其他的响应类都一样，这里是临时用的，以后要让用户可以自定义错误页面。 Router：解析路由路由的执行方法也弄好了，但是现在还没办法匹配路由， Router 做的事情是匹配用户的请求，判断是否在 $routes 的配置里， 如果找到对应的配置就去执行路由，现在还缺少匹配路由的方法。 回到 Router.php 新增一个解析路由的方法： 123456789101112131415161718192021222324252627282930313233343536/** * 处理路由 * @param $request * @param $response */public function handle($request, $response)&#123; $uri = $request-&gt;server[&#x27;request_uri&#x27;]; $route = $this-&gt;findRoute($uri); if ($route == null) &#123; (new NotFoundResponse)-&gt;response($request, $response, $route); return; &#125; $route-&gt;createResponse($request, $response);&#125;/** * 寻找路由 * @param $uri * @return mixed|null */public function findRoute($request)&#123; $uri = $request-&gt;server[&#x27;request_uri&#x27;]; // 查找规则和方法都匹配的路由 foreach (self::$routes as $route) &#123; if ($route-&gt;route == $uri) &#123; return $route; &#125; &#125; return null;&#125; 这里的 findRoute 即路由解释器的核心功能，通过循环逐一与配置文件进行匹配， 如果符合要求就返回路由对象，然后执行路由。 现在先简单的实现，如果一个请求路径完全匹配 route 字段即认为匹配。 引入路由配置路由解析功能也完成了，但是路由配置文件 web.php 还没引入， 配置文件应该是在程序启动时就加载到内存中的，直接用 require 引入就可以了， 我把 $routes 定义成静态变量了，它的作用范围是全局的。 编辑根目录下面的 http_server.php，修改如下： 1234567891011121314151617&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;require &#x27;./app/route/web.php&#x27;;$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$router = new \\FireRabbitEngine\\Module\\Route\\Router();$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123; var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]); $router-&gt;handle($request, $response);&#125;);$http-&gt;start(); 加入 var_dump 方便调试，每次刷新网页的时候都可以在终端看到输出结果， 实际上线的时候要删掉这一句。 这里通过 require 引入 web.php，然后在 $http-&gt;on 里调用解释器解析路由。 路由模块仅仅只是暴露一个简单的 handle 方法：$router-&gt;handle($request, $response) 代码十分整洁干净，符合自己的预期要求。 到这一步已经完成了，但还有一个地方要做！ 类的自动加载最开始创建的 Controller 并没有被加入 psr-4 自动加载配置里， 编辑根目录下面的 composer.json，修改如下： 123456789101112131415&#123; &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;FireRabbitEngine\\\\Module\\\\&quot;: &quot;firerabbit-engine/module/&quot; &#125; &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125;&#125; 新增 App 自动加载路径，这样以后我们创建的控制器或者模型都会被自动加载了。 由于修改了配置，因此需要执行 composer dump-autoload 重新生成自动加载文件。 每次新创建用来保存类的文件夹时都要重新加载一下 然后就可以打开浏览器，测试路由功能了！ 最终文件目录结构： 123456789101112131415161718192021222324252627282930313233343536373839|-- app| |-- config| |-- controller| | `-- Home| | |-- IndexController.php| | `-- UserController.php| |-- public| `-- route| `-- web.php|-- composer.json|-- firerabbit-engine| `-- module| |-- Controller| | `-- Controller.php| `-- Route| |-- Exception| | `-- RouteParamException.php| |-- RequestMethod.php| |-- Response| | |-- ActionNotFoundResponse.php| | |-- ClassNotFoundResponse.php| | |-- MethodErrorResponse.php| | |-- NotFoundResponse.php| | `-- RouteResponse.php| |-- RouteParams.php| `-- Router.php|-- http_server.php|-- test.php`-- vendor |-- autoload.php `-- composer |-- ClassLoader.php |-- LICENSE |-- autoload_classmap.php |-- autoload_namespaces.php |-- autoload_psr4.php |-- autoload_real.php |-- autoload_static.php `-- installed.json 简单的路由功能这样就算完成了，但是现在还没办法实现路径参数，下文再补充。 每次修改代码都记得要 Ctrl+C 结束 swoole 进程再重新启动，不然修改不会生效。 总结最后是贴上完整的代码： Router.php 文件是作为“解析&#x2F;分发”和“配置”路由的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?phpnamespace FireRabbitEngine\\Module\\Route;use FireRabbitEngine\\Module\\Route\\Exception\\RouteParamException;use FireRabbitEngine\\Module\\Route\\Response\\NotFoundResponse;class Router&#123; protected static $routes = []; protected $namespace = &#x27;&#x27;; /** * 处理路由 * @param $request * @param $response */ public function handle($request, $response) &#123; $uri = $request-&gt;server[&#x27;request_uri&#x27;]; $route = $this-&gt;findRoute($uri); if ($route == null) &#123; (new NotFoundResponse)-&gt;response($request, $response, $route); return; &#125; $route-&gt;createResponse($request, $response); &#125; /** * 寻找路由 * @param $uri * @return mixed|null */ public function findRoute($request) &#123; $uri = $request-&gt;server[&#x27;request_uri&#x27;]; // 查找规则和方法都匹配的路由 foreach (self::$routes as $route) &#123; if ($route-&gt;route == $uri) &#123; return $route; &#125; &#125; return null; &#125; /** * 定义一个 GET 请求路由 * @param $route * @param $controller * @throws RouteParamException */ public function get($route, $controller) &#123; $this-&gt;addRoute(RequestMethod::GET, $route, $controller); &#125; /** * 定义一个 POST 请求路由 * @param $route * @param $controller * @throws RouteParamException */ public function post($route, $controller) &#123; $this-&gt;addRoute(RequestMethod::POST, $route, $controller); &#125; /** * 定义一个任意请求皆可的路由 * @param $route * @param $controller * @throws RouteParamException */ public function any($route, $controller) &#123; $this-&gt;addRoute(RequestMethod::ANY, $route, $controller); &#125; /** * 设置配置参数外部调用方法 * @param $configs * @return $this */ public function setConfig($configs) &#123; foreach ($configs as $key =&gt; $value) &#123; $this-&gt;createConfig($key, $value); &#125; return $this; &#125; /** * 设置参数 * @param $key * @param $value */ protected function createConfig($key, $value) &#123; switch ($key) &#123; case &#x27;namespace&#x27;: $this-&gt;namespace = $value; break; &#125; &#125; /** * 路由分组 * @param $func */ public function group($func) &#123; $func(); // 执行完成后将参数初始化 $this-&gt;namespace = &#x27;&#x27;; &#125; /** * 将路由加入配置数组 * @param $method * @param $route * @param $controller * @throws RouteParamException */ protected function addRoute($method, $route, $controller) &#123; $param = new RouteParams(); $param-&gt;method = $method; $param-&gt;route = $route; // 格式为：控制器@方法名 $actions = explode(&#x27;@&#x27;, $controller); // 如果不按照规则设置控制器和方法名则抛出异常 if (count($actions) != 2) &#123; throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;); &#125; $param-&gt;controller = $actions[0]; $param-&gt;action = $actions[1]; $param-&gt;namespace = $this-&gt;namespace; self::$routes[] = $param; &#125;&#125; RouteParam.php 是作为路由对象，在这里实例化控制器并且执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpnamespace FireRabbitEngine\\Module\\Route;use FireRabbitEngine\\Module\\Route\\Response\\ActionNotFoundResponse;use FireRabbitEngine\\Module\\Route\\Response\\MethodErrorResponse;use FireRabbitEngine\\Module\\Route\\Response\\ClassNotFoundResponse;class RouteParams&#123; /** * 路由名称 * @var string */ public $name; /** * 路由匹配规则 * @var string */ public $route; /** * 命名空间 * @var string */ public $namespace; /** * 控制器名称 * @var string */ public $controller; /** * 调用的控制器方法名称 * @var string */ public $action; /** * 请求方法 * @var string */ public $method; public function createResponse($request, $response) &#123; // 判断请求方法是否正确 if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123; (new MethodErrorResponse())-&gt;response($request, $response, $this); return; &#125; // 判断方法是否存在 $controllerName = $this-&gt;getFullControllerName(); if (!class_exists($controllerName)) &#123; (new ClassNotFoundResponse())-&gt;response($request, $response, $this); &#125; $action = $this-&gt;action; // 不存在方法则返回404 if (!method_exists($controllerName, $action)) &#123; (new ActionNotFoundResponse())-&gt;response($request, $response, $this); return; &#125; // 实例化类 $controllerObject = new $controllerName($request, $response, $this-&gt;name); // ... 以后的中间件写在这里 // 执行方法 $controllerObject-&gt;$action(); &#125; public function getFullControllerName() &#123; return $this-&gt;namespace . $this-&gt;controller; &#125;&#125; 而 web.php 则是全局的路由配置文件，实现了用类配置路由，而不是用纯数组： 123456789101112131415&lt;?php$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;setConfig([ &#x27;namespace&#x27; =&gt; &#x27;App\\\\Controller\\\\Home\\\\&#x27;,])-&gt;group(function () use ($router) &#123; $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;); $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;); $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;); $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;);&#125;); 以上，简单路由就完成了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（三）类的自动加载","slug":"my-swoole-framework-3","date":"2021-02-06T10:49:48.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/06/my-swoole-framework-3/","link":"","permalink":"http://huotublog.com/2021/02/06/my-swoole-framework-3/","excerpt":"","text":"准备工作创建文件目录如下： 123456blog|-- app| `-- public|-- firerabbit-engine| `-- module`-- http_server.php 其中，根目录 blog 为项目根目录，app 文件夹是项目所在目录， public 用来存放 web 的静态资源如图片、js 文件等。 firerabbit-engine 是框架目录，module 存放模块代码， 目前框架代码跟是项目代码放在一起的， 为了以后方便分离，所以把项目的代码放在 app 里面处理。 文件夹的大小写规范自己定义即可 psr-4 自动加载在根目录创建文件 composer.json，并输入如下内容： 1234567891011121314&#123; &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;FireRabbitEngine\\\\Module\\\\&quot;: &quot;firerabbit-engine/module/&quot; &#125; &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125;&#125; 这里我们指定了框架的命名空间以及将镜像源修改为阿里云。 接着使用命令 composer install 执行安装， 完成后出现 vendor 文件夹： 1234567891011121314151617|-- app| `-- public|-- composer.json|-- firerabbit-engine| `-- module|-- http_server.php`-- vendor |-- autoload.php `-- composer |-- ClassLoader.php |-- LICENSE |-- autoload_classmap.php |-- autoload_namespaces.php |-- autoload_psr4.php |-- autoload_real.php |-- autoload_static.php `-- installed.json 我们第一步要实现路由功能，路由是一个模块， 因此在 modlue 下新建文件夹 Route， 接着在该目录新建文件 Router.php： 1234567891011&lt;?phpnamespace FireRabbitEngine\\Module\\Route;class Router&#123; public function test() &#123; var_dump(&#x27;ok&#x27;); &#125;&#125; FireRabbitEngine 即框架的命名空间 接着编辑 http_server.php，引入 composer 加载文件： 123456789101112131415&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);// 测试$router = new \\FireRabbitEngine\\Module\\Route\\Router();$router-&gt;test();$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123; $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start(); 在终端输入 php http_server.php，看到打印出 ok 就说明自动加载没问题了。 每次修改代码都要 Ctrl+C 关掉再重新启动，不然修改了代码也不会生效，因为 swoole 是常驻内存的，只在启动时加载一次 完整的项目目录如下： 12345678910111213141516171819|-- app| `-- public|-- composer.json|-- firerabbit-engine| `-- module| `-- Route| `-- Router.php|-- http_server.php`-- vendor |-- autoload.php `-- composer |-- ClassLoader.php |-- LICENSE |-- autoload_classmap.php |-- autoload_namespaces.php |-- autoload_psr4.php |-- autoload_real.php |-- autoload_static.php `-- installed.json 我们需要同步到 Git 防止丢失代码， 因此需要设置 .gitignore 文件来忽略不需要上传的文件或者目录。 在终端或者直接右键创建文件都可以，.gitignore 内容如下： 12vendor.idea 我用的是 PhpStorm 会产生 .idea 文件夹，但这个是不需要上传的，如果你用的是 vscode，要把 .vscode 文件夹也加进去 然后就可以把项目同步到 Git 上面了。 如此一来类的自动加载就实现了， 下一步我们就可以开始编写路由模块了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（二）项目的规划和设计草案","slug":"my-swoole-framework-2","date":"2021-02-06T06:05:50.000Z","updated":"2023-02-16T06:50:23.263Z","comments":true,"path":"2021/02/06/my-swoole-framework-2/","link":"","permalink":"http://huotublog.com/2021/02/06/my-swoole-framework-2/","excerpt":"","text":"项目的规划和设计草案前言在第（一）章中我们已经实现了 hellow world！ 但是现在不用急着撸代码， 而是要把我们设计这款框架的想法捋顺。 期望效果按照重要性给各项指标进行打分，其中星星越多代表重要性越高。 开发舒适度：★★★★★这是最关键的一条！ 使用了我们的框架， 开发者撸代码会变成愉♂悦的过程！ 我给它起个口号： 享受令人愉♂悦的开发过程。 — by FireRabbit-Engine 火兔引擎 但是怎么个舒适法得有一个定义，不然就太宽泛了。 能够帮助开发者快速排查错误以及调试的能力 在框架层面自动帮用户解决掉麻烦问题，比如 SQL 注入、用户权限、跨域问题、表单校验等等 指令式开发，开发者可以在控制台输入指令自动生成对应的文件，比如输入 make:model 就会生成一个数据库查询模型 高性能：★★★★★我们既然选择了 swoole 扩展， 自然要体现出它应该具有的高性能特点， 高性能的指标是响应速度，期望效果是 1-30 ms。 （以接口的响应速度为判定指标） 它要非常的快！不快怎么装 X 呢！ 高并发：★★★★★同样是 swoole 的特色， 我们的框架也应该支持强大的并发连接。 框架完成后我们会用 ab 测试来查看高并发情况下的性能。 扩展性：★★★★★人没梦想跟咸鱼有什么区别！ 万一框架火了呢！？ 我们这套框架应该是能让开发者 DIY 的。 框架的扩展性要非常的强， 各个模块之间尽可能的解耦。 安全性：★★★★★手撸框架要十分注意的地方！ 市面的框架基本上已经把安全隐患在框架层面解决了， 以至于我们完全忽视了本应该注意的漏洞。 就比如 SQL 注入，你用的框架封装好的 ORM 自动帮你处理了。 但是我们自己从零开始撸框架就不一样了， 我们要让这个框架使用起来非常安全。 代码规范：★★★为了后期可维护，代码规范也是十分必要的， 毕竟老夫也不是什么大神，只能说在认知的范围内尽量吧…… 如果后期觉得设计不合理，会推翻重做。 小白化：★★★让一个没学过 swoole 的人也能上手。 （其实我自己就是现学现卖） 我们再给它起个口号： 有手就能撸。 — by FireRabbit-Engine 火兔引擎 “会增删改查吗？” “明天可以来上班了。” —— 根据本人亲身经历改编。 半自动化：★★★谁说做开发就一定要手撸代码的？ 要我说的话， 开发的最高境界是“无码” 其实是我开发游戏的时候得到的灵感， 比如关卡的设计，每个场景都要单独写一个吗？ 那如果是几千个关卡的游戏呢？ 只要一个配置文件就能搞定！ 而我们只需要写一个关卡解释器， 将配置的参数实例化为游戏的场景。 所以我有一个预感，以后的开发者不需要写太多的代码， 只要配置文件就可以解决大部分的问题。 在开发这个框架的时候，我会把这个思想融入到设计层面。 亲，我们这个框架高清无码。— by FireRabbit-Engine 火兔引擎 模块设计框架是由模块构成的， 我们要把每个模块都拆分成独立的，以后还能拆分成单独的包。 入口文件swoole 已经是单一入口了， 所以直接用就行了。 配置文件有一个专门用来读取配置文件的模块， 除了框架的配置还支持用户自定义配置。 不同的模块有不同的配置文件，全部单独区分： 12345# 文件目录 config/database.php // 数据库配置cache.php // 缓存配置sms.php // 短信配置…… // 诸如此类 自动加载直接使用 composer 实现自动加载即可。 遵循 psr-4 加载规范。 路由模块需要一个路由解析器来处理 swoole 收到的请求路径， 将请求分发到控制器和对应的方法，还有处理路径上的参数。 12345678910111213141516171819# 用户浏览一篇博客文章http://127.0.0.1/article/1# swoole 收到 nginx 转发的请求是这样的/article/1# 这个时候我们就需要定义一个解释器解析路由/article/1 是一个字符串，要将字符串按照某种规则匹配# 最终解析的结果为：/article/1 =&gt; 控制器是 article，方法是 show，参数是 1 # 实例化控制器$name = &#x27;ArticleController&#x27;; // 解析后得到的控制器名字$controller = new $name;# 执行对应的方法$method = &#x27;show&#x27;;$controller-&gt;$show; 以上就是路由解析器的大概原理。 真正要实现是很复杂的，因为路由是各种各样奇奇怪怪的： 1234567891011# 文章详情http://127.0.0.1/article/1# 编辑文章http://127.0.0.1/article/1/edit# 很长很长，看得出来哪些是路径参数吗？http://127.0.0.1/article/classify_1/list/12345/show# 注意！下面这种是 query 参数，要获取这种参数很简单http://127.0.0.1/article?id=1 如果我们的网站不打算使用路径参数， 那就简单得多了，但是用 query 参数很不美观。 比如 TP 框架的这种路径： 12345# c 代表控制器，a 代表方法，id 是查询参数http://127.0.0.1?c=article&amp;a=show&amp;id=1# 美化后的路由（这才是我们想要的）http://127.0.0.1/article/1 请求和响应这个就是面试的时候经常考的问题了， 就不再详细介绍了， 简单地说就是用户访问我们的网站， 我们要给它输出什么样的结果。 请求要经过过滤器（中间件、数据&#x2F;权限验证） 响应返回的格式（content-type） 表单验证对用户提交的表单字段验证。 如果每个表单都要这样： 12345678# 用户注册if(isset($_GET[&#x27;name&#x27;] &amp;&amp; strlen($_GET[&#x27;name&#x27;]) &lt; 4 || strlen($_GET[&#x27;name&#x27;]) &gt; 10) &#123; echo &#x27;用户名不能为空，且长度为4~10&#x27;;&#125;# 下面还有重名判断、邮箱、手机号码、密码长度……# 接着，用户修改密码，找回密码，更新账户资料# 以上，请再来一遍…… 一个框架没有表单处理模块，你离升仙也就不远了。 中间件通俗的将就是请求拦截器。 表单验证也是拦截请求， 但是在拦截的层面上不一样， 表单验证一般是在控制器里面拦截的， 而中间件是在还没进入到控制器的时候就开始拦截。 比如一个抢购活动在晚上 9 点开始： 12345678$startTime = date(&#x27;Y-m-d 21:00:00&#x27;)$currentTime = date(&#x27;Y-m-d H:i:s&#x27;);if($currentTime &gt;= $startTime ) &#123; # 显示活动页&#125; else &#123; # 显示活动还没开始&#125; 你可以在控制器里面写上这样的代码来判断活动是否开始， 但是这种硬编码绝对会让你原地爆炸， 即使你自己觉得没啥，你同事绝对会想在月黑风高的时候把你弄死…… 我们为什么不这样做呢？ 12345678910111213141516171819202122232425# 定义一个“规则”，把它命名为：2021_12_12_active规则 2021_12_12_active : 如果当前时间大于等于 2021-12-12 21:00:00 则返回 true，否则返回 false# 然后再修改路由解析器：用户访问：http://127.0.0.1/goods/1路由解析器解析出：控制器：goods，方法：show，参数：1它正准备实例化对象呢！这个时候，中间件站了出来，说：路由老哥，等一哈！路由老哥愣住了，停下来听中间件想说什么。中间件不慌不忙的解释道：这个路径被加上了“规则”，要验证之后才可以。而这个规则叫做：2021_12_12_active根据《小学生手册》里规定：第 2021_12_12_active 条：好孩子在 2021-12-12 这一天必须在晚上九点以后上传睡觉。在九点之前睡觉的都不是好孩子！不能让它们通过！这件事交给我来处理，你可以退下了。于是路由解释器就把执行权限交给了中间件。中间件就会查询时间是否符合要求，如果符合要求就让请求正常进行下去，不符合要求就返回异常的结果。 中间件就是一套“规则”，你可能会问那跟表单验证有什么不同？ 其实表单验证就是中间件的子集，除了表单验证之外，还有权限验证。 比如你可以规定一个请求不带 token 就不让它通过。 表单验证和权限验证虽然都属于中间件， 但我们还是会单独拆分出来， 因为他们在细节还是有些不同的， 而且我们还可以通过封装实现更加简单的操作。 表单验证和权限验证均可以在控制器里面处理，如果是在控制器层面处理的话就不叫做中间件的，为了实现复用性，我们会把表单验证跟用户验证以中间件的形式实现 日志不论是本地调试还是线上查询问题所在， 日志都是非常重要的，日志系统可以支持数据库和文件。 我们暂时只支持文件日志。 常量需要一个专门的类来保存框架使用的各种常量。 比如返回的错误码之类的，redis 的键等等。 如果不统一管理常量的话，后期会变得非常麻烦。 缓存将缓存的调用封装起来， 我们自定义一个 Cache 类， 外部只要调用暴露出来的接口即可。 而 Cache 内部则可以支持不同的缓存数据库， 包括 Redis 集群的调用等等。 目前仅考虑：Redis 数据库（Model）同缓存系统， 数据库模型直接暴露一个供外部调用的接口， 然后通过配置文件来自定义包括集群甚至是数据库类型等等配置。 数据库类型目前仅考虑：MySQL 模型文件主要是定义字段以及处理一些关联关系。 不将复杂的代码放到这里。 比较复杂的数据库逻辑可以再定义一个 Action 层来处理。 模板引擎（View）为了支持搜索引擎的 SEO， 我们不采用前后端分离的设计， 当然也不能直接写 phtml（即 php 和 html 混合的代码） 第一次学 PHP 的时候，我们都接触过这样的： 123456789101112131415# index.php&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;?php echo &#x27;hello world&#x27;;&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; phtml 文件把 php 的逻辑代码与 html 代码混合在一起， 如果是循环或者增加条件判断，简直不忍直视…… 而使用模板引擎的情况下，我们只要传入参数， 然后模板渲染结果就可以了， 模板引擎当然也可以改成可配置的。 目前仅考虑：blade 控制器（Controller）在我设计的这个框架里， 控制器不是用来处理业务逻辑的， 而是验证+分发请求+返回响应。 不过，验证可以完全交给中间件来处理， 这样控制器的代码就可以更加简洁。 期望效果： 12345678public function index() &#123; // 获取参数 $params = $this-&gt;getParams(); // 将参数传递给 service，处理查询逻辑 $items = ArticleService::getInstance()-&gt;getList($params); // 返回视图响应，并将参数传给视图渲染页面 $this-&gt;view(&#x27;home.index&#x27;, [&#x27;items&#x27; =&gt; $items]);&#125; 所有控制器的方法内的代码不超过 10 行。 逻辑处理（Service）处理逻辑代码的地方，本质是一个类。 队列按照原生开发的话，应该会使用 redis + 死循环来实现队列， 但是考虑到 swoole 自带了任务处理机制， 等我学习之后再具体考虑怎么实现。 单元测试没有。 总结大致就想到这么多，后期如果有需要再进行补充。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（一）框架概述","slug":"my-swoole-framework-1","date":"2021-02-04T11:10:12.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/04/my-swoole-framework-1/","link":"","permalink":"http://huotublog.com/2021/02/04/my-swoole-framework-1/","excerpt":"","text":"从入口文件开始说起框架概述简单地说框架就是封装好各种便利功能的工具， 同时还会“自动化”的处理复杂的事情， 通俗的说就是让程序员开开心心码代码的结构。 我们现在要撸的这套框架，应该满足以下需求： 可以缩短开发时间 支持后期扩展 不是仅仅封装一下类和方法就叫框架了， 它整体的结构应该让程序员使用起来非常舒服！ 环境PHP 版本：7.2.31Swoole 版本：4.5.2PHP Redis 版本：5.1.1 这里我用的 redis 是 PHP 的扩展， 如果你不安装 redis 扩展也可以用 composer 引入。 框架起名第一步是给框架起个好名字， 我把这个框架叫做“火兔引擎”， 创建目录：/firerabbit-engine。 这个目录名称和位置你可以随意设置， 之后用 nginx 指定就行了，最简单的就是放到 www 目录下。 虚拟域名平时我们可能都是用 127.0.0.1， 但是本地的项目多了的话，就不能用单一的地址了。 我们可以设置一个虚拟域名，即修改本地的主机解析记录。 windows 系统和 mac os 都是修改 hosts 文件， 以 mac os 为例： 1sudo vim /etc/hosts 在最底下插入一行： 1127.0.0.1 firerabbit-engine.ht firerabbit-engine.ht 是你设置的虚拟域名， 可以任意设置，但是最好不要是跟真正域名冲突的， 比如你设置了 baidu.com， 那你访问百度就会变成解析到自己本机了， 这个 .ht 后缀也是我虚构的。 测试的时候就可以在浏览器输入 firerabbit-engine.ht 访问博客地址。 Hello World！现在项目是空的，一个文件也没有， 首先在项目目录下新建一个 http_server.php。 然后查看 Swoole 官方文档：Http 服务器 直接把示例代码抠下来复制到 http_server.php： 123456789$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 9527);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123; var_dump($request-&gt;server); $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start(); 注意我这里把默认端口改成 9527 了。 之后可以用 127.0.0.1:9527 进行访问。 如果你跟我一样是用 docker 的话， 记得要设置端口映射：-p 9527:9527，不然宿主机是访问不到的。 接着在项目的目录下，在控制台输出命令启动程序：php http_server.php 你会看到光标卡住了，这说明程序已经运行了。 swoole 本身就自带了 http 服务器的功能，因此不需要借助 nginx 12cd /www/firerabbit-engine/php http_server.php 做完这一步就可以用 IP 地址+端口号的方式访问了， 打开浏览器，输入地址：127.0.0.1:9527 可以看到： 1Hello Swoole. #7090 后面的是随机数字所以每次刷新都不一样。 控制台也打印出了请求详情， 这样，第一步就成功了。 Nginx 转发虽然 swoole 自带了 http 服务器， 但是 swoole 处理 css、js 等静态文件却没有什么好的方法， 而 nginx 的强项就是处理静态文件，一拍即合，各展所长！ 所以这里我们结合 nginx 处理静态文件， 静态文件 nginx 处理，动态文件 swoole 处理； 同时还可以利用上面的虚拟域名来访问网站。 nginx 增加一个配置文件 firerabbit.conf： 123456789101112131415161718server &#123; listen 80; server_name firerabbit-engine.ht; location ~* \\.(gif|jpg|jpeg|png|css|js|ico|ttf|woff|woff2|svg|map)$ &#123; root /www/firerabbit-engine/public; &#125; location / &#123; proxy_http_version 1.1; proxy_set_header Connection &quot;keep-alive&quot;; proxy_set_header X-Real-IP $remote_addr; if (!-e $request_filename)&#123; proxy_pass http://php-fpm72:9527; # 注意 &#125; &#125;&#125; 因为我是用 docker 搭建的 nginx 和 php 环境， 容器之间不能直接通过 IP 访问，而是要用容器名。 如果你不是用 docker 环境，php-fpm72 要改成 127.0.0.1： 1proxy_pass http://127.0.0.1:9527; 然后执行命令：nginx -s reload 来平滑重启 nginx。 接着在浏览器输入上面设置的虚拟域名：http://firerabbit-engine.ht/ 可以看到同样的 hello world 页面。 通过 nginx 的转发， 所有静态文件如图片、css 文件等都会被转发到请求 public 这个目录， 不会发送到 swoole 那边，只有找不到文件才会转发给 swoole。 捋一捋程序的处理流程： 在浏览器输入域名的时候，用户的请求先经过 nginx 的正则判断， 如果是 jpg 之类的结尾，就去 public 这个目录下面找， 如果找不到文件了，再转发给 http://php-fpm72:9527。 这样 nginx 的配置也弄好了。 项目结构基本结构一个典型的框架，包含以下几个特征： 单一入口 MVC 结构（模型、视图、控制器分离） 自动加载（composer） 单一入口这个很好理解， swoole 默认即单一入口， 也就是全部请求都转发给 http_server.php 文件处理。 MVC 就是分离代码，让每个类的功能更加单一， 简单的说就是 PHP 写接口，前端人员写前端页面， 但是我们并不会真正的完全分离，因为博客是要做 SEO 的， 如果全部都用接口，搜索引擎就不会收录了。 我们的 MVC 结构会用模板引擎来实现代码解耦。 自动加载是我们这个框架的核心部分， 因为我们会依赖其他组件，同时我们自己的类也需要加上命名空间。 现代 PHP composer 自动加载几乎是必备的。 执行流程捋一捋框架的整体运行流程： swoole 收到 nginx 转发来的请求， 通过“解析器”将请求 uri 解析成对应的控制器和方法， （解析器就是路由功能，解析器是一个类文件，自己要写的） 以及获取各种参数、cookie 等等， 将这些参数传递给 controller， controller 负责处理业务逻辑。 虽然 MVC 框架已经很流行了， 但是我们这里不推荐在 controller 处理逻辑， 在这里写业务，后面这个文件就会变成几千行，不方便维护。 我们再增加一个 Service 层，将业务逻辑的代码移到 Service 去处理。 这样整个框架的流程大致可以捋顺了，如下图： swoole 收到 nginx 转发的请求， 通过解析器（一个类文件）， 将请求的 uri 解析成对应的路由和参数， 实例化路由的类并且调用对应的方法，并将参数传递给类的实例化对象， 类的实例化对象（controller）再调用 service 来处理逻辑。 （controller 的作用 与 nginx 类似，也是分发请求，但是它还有一个返回响应的功能） controller 得到参数和 cookie 等，交给 service 处理， service 再调用 model 或者其他的类库，返回处理结果，将值返回给 controller， 最后一步，controoler 收到返回的值，再返回对应类型的响应。 （响应的种类有很多，例如 json、html 等等，如：content-type: text/html; charset=UTF-8） 原本 controller 是处理逻辑代码的地方， 在这里我们把它变成分发请求了， 这是防止以后 controller 变得臃肿， 但实际上， 逻辑代码转移到 service 会让 service 变得臃肿…… （目前没有更好的方法了） 控制器的处理流程可以看图： 我个人比较喜欢这种方式， 最终我们写的控制器会是这样的： 12345678910class IndexController &#123; public function index() &#123; // 查询列表数据，为了方便调用，service全部做成单例的 $articles = ArticleService::getInstance()-&gt;getList(); // ... 这里返回视图 $this-&gt;view(&#x27;index&#x27;, [&#x27;articles&#x27; =&gt; $articles]); &#125;&#125; 控制器的代码会变得十分简洁。 控制器还有一个作用就是验证数据， 比如用户提交的表单， 如果输入的邮箱格式不正确就直接返回错误的响应， 数据验证就全部在 controller 处理了，而不是传到 service。 我把控制器的功能限制为：① 验证数据 ② 转发给 service 处理 ③ 返回结果 而 service 则处理数据库操作之类的业务逻辑。 controller 和 service 的功能变得十分单一，从而降低耦合性。 问题就是，控制器干净了，service 却脏了…… service 不仅要处理数据库，还要更新缓存之类的，想想就可怕。 后面我们可以考虑把数据库处理的逻辑转移到 model， 这样可以减少 service 臃肿度。 第一阶段目标现在思路已经很明确了， 但是很多细节部分我们还没有设计， 比如日志系统、缓存系统、数据库系统、配置参数文件、中间件…… 下期统一进行规划，本篇文章就到这了。","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"从零开始搭建自己的Swoole框架（序章）","slug":"my-swoole-framework-0","date":"2021-02-04T09:22:12.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/02/04/my-swoole-framework-0/","link":"","permalink":"http://huotublog.com/2021/02/04/my-swoole-framework-0/","excerpt":"","text":"开发目标及准备说明这一篇不包含任何技术代码，如需要直接开始请阅读第（一）章。 前言毕业三年，成为架构师！ 这是我毕业时的梦想，结果没有实现。 现在重拾初心，从零设计一个属于自己的框架！ 目标按照目前市面上的发展来看， swoole 毫无疑问是目前 PHP 的天花板， 而自己在工作的时候做的都是流水线，几乎没机会接触到 swoole。 于是趁这个机会也学习一下。 这次设计的框架以开发博客系统作为案例， 我们不考虑它的适用性，正如标题所写的一样， 这是属于自己的框架， 而不是 Laravel 那样可以单独发布的 composer 包。 所以最终我们会完成一个单体博客应用， 如果你要把自己的框架做成发布到全网让别人使用你的框架， 可以了解一下 composer 的扩展包是怎么制作的。 只要这套框架做完了， 你自己改造成可以用 composer require xxx/xxx 那样引入的也完全没问题。 准备工作PHP 环境本人使用的是 docker 环境， window 系统也可以用 wamp、xampp 等等， 只要搭好 PHP 环境并且安装了 swoole 扩展就行了。 windows 系统安装 swoole 扩展比较麻烦， 如果你不会安装，可以在 windows 系统安装 docker， 然后再在 docker 里面安装 php 环境。 Swoole 扩展Swoole 官方网站：swoole.com swoole 其实是一个 php 扩展并不是框架，它跟 yaf 一样是基于内存常驻的。 swoole 依然还在保持着更新，yaf 却 N 年没更新了。 所以如果要学的话，强烈推荐 swoole 而不是 yaf。 Nginx因为我们要做的是一个博客系统的单体应用。 Swoole 对静态文件的处理能力比较弱， 所以我们的目标是 swoole 做服务器， 静态文件交给 nginx 处理， php 请求转发给 swoole。 单体应用是相对于微服务来说的，通俗的讲即整个项目就只有一个文件夹，而微服务则是把各个模块拆出来，比如用户模块、订单模块诸如此类，还可以把全站的 api 接口拆分出来当成一个项目（前后端分离） MySQL免费的数据库，除了这个还有 Mango， 但是我没用过，根据你个人兴趣选择即可。 Redis免费的高性能包括键值对、哈希、集合列表等等处理器。 用来做缓存和队列任务，文章排行榜等等。 Composerphp 的包管理工具，现在的项目还是纯手撸那也太 lower 了。 我们在开发框架的时候，会像 Laravel 那样依赖一些第三方的包。 感觉好像有点作弊？ 用 composer 就跟直接拿别人开发好的一样， 不是说好手撸框架么？ 不用担心，开发框架最核心的是编程思想， 具体怎么实现，我相信大家看着源码也能模仿出来。 如果你愿意从写 MySQL 数据连接开始，那也没问题! 如果你要从最底层的代码开始写， 那么我建议你将数据库处理、上传组件、缓存处理、队列任务等等， 把这些都做成单独的 composer 包， 然后再在框架里引入自己写的 composer 组件包， 像拼积木一样，看起来很酷对吧！ 这样一个高度定制化的框架就实现了。 我还真的试过这么做，但是做一个 composer 包就放弃了…… 因为……工作量增加了好几倍。 很不现实，你做的越细，工作量就越大， 而我们自己一个人维护不过来， 所以不推荐一开始就有那么大的野心， 本篇文章要完成的目标仅仅只是一个单体博客应用而已， 甚至都不会把框架单独拆分出来（业务逻辑代码也混合在框架里）。 核心内容是开发框架的编程思想，而不是具体的实现。 IDE用 PHPStorm 即可，当然也可以用微软的 VScode。 最终目标在我们学习 PHP 的时候， 第一个开发的项目是什么？ 我猜大部分人都是博客系统！ 那么，三年前的我和三年后的我， 制作相同的一套系统会有什么差别呢？ 用毕生（三年）的功力，来开发这套博客系统吧！","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"}]},{"title":"MAC 系统打开网页速度缓慢问题的解决方法","slug":"mac-os-internet-slowly-resolved","date":"2021-01-16T04:12:32.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2021/01/16/mac-os-internet-slowly-resolved/","link":"","permalink":"http://huotublog.com/2021/01/16/mac-os-internet-slowly-resolved/","excerpt":"","text":"问题描述MAC系统的浏览器打开某些网站特别慢，有的甚至打不开。比如百度云网盘链接打开很快，但是点击输入提取码却要卡半天；百度图片甚至直接打不开了；还有B站打开也要半天，严重浪费时间和影响效率。 解决方法改变位置其实不是家里网络的问题，而是苹果系统迷之BUG！ 首先点击左上角的苹果图标，然后选择“系统偏好设置”，接着选择“网络”。 （小技巧：按Command+空格键可以打开聚焦搜索，然后直接输入“网络”两个字，MAC系统就会显示出系统偏好设置里的网络了） 左侧默认有： Wi-Fi（已连接） 蓝牙 PAN 雷雳网桥 这里我们不用修改。 看中间部分，默认值是“自动”，点击下拉框，然后选择“编辑位置”。 然后点击“+”号，输入新的位置：“家”，再点击完成。 接着我们可以发现，左侧的 Wi-Fi 的 IP 地址已经没了，并且提示你无法连接到网络。 只要你点击下方的“应用”，就会重新寻找 IP 地址。 现在已经大功告成了！再打开那些网页，你可以发现速度起飞了！ 改变 DNS如果上述方法依然无法提高访问速度，那就有可能是 DNS 地址在作怪。 我们知道，域名只是一个指向服务器 IP 地址的代号，把域名解析为 IP 地址需要 DNS 服务商为我们提供服务，因此 DNS 服务器也会影响打开网页的速度。 依然是系统偏好设置里的网络，点击左侧的 Wi-Fi，然后右下角的“高级”。 在顶部选项卡选择“DNS”，然后点击左下角的“+”号，添加如下地址： 8.8.8.8 8.8.4.4 以上任意一个即可，这两个是谷歌的 DNS 服务器。 当然我们国内的还有臭名昭著的 114： 114.114.114.114 你也可以修改为 114，但是并不推荐这么做。 因为它经常会在你打开的网页里加入一些奇奇怪怪的广告，最常见的就是手机访问网页时，右侧经常会出现一个红包领取的图标（并不是网站有这种东西，而是使用了 114 服务器解析后，它给这个网站加上的） 以前刚毕业的时候，曾经被这个奇怪的问题困扰了半天，还以为自己的网站是被被人黑了呢！ 还有，当你访问的网站 404 时，114 会把网页改成它们的广告页，要知道互联网上 404 的页面有很多，光是广告费的收入就可想而知了。 虽说 114 又不是在做公益，没道理不牟利。 404 页面修改成广告倒是情有可原，但拦截别人的网站并在里面加入领取红包的广告，这样做就很不厚道了。 关闭蓝牙据说苹果的蓝牙也会影响 Wi-Fi，你可以尝试关闭蓝牙，如果能提高网页访问速度，那说明蓝牙也会影响。 但是苹果系统又没有耳机接口，这样蓝牙耳机就用不了了…… 代理设置如果你用了代理，那访问国内网站的速度肯定会变慢。 最好的方法就是改成 PAC 自动模式，这样软件就会自动判断是否需要开启代理了。","categories":[],"tags":[{"name":"MAC OS","slug":"MAC-OS","permalink":"http://huotublog.com/tags/MAC-OS/"},{"name":"解决方案","slug":"解决方案","permalink":"http://huotublog.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"MySQL为什么不使用 SELECT *(星号)查询？","slug":"mysql-why-not-use-select-star","date":"2020-06-25T00:03:20.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2020/06/25/mysql-why-not-use-select-star/","link":"","permalink":"http://huotublog.com/2020/06/25/mysql-why-not-use-select-star/","excerpt":"","text":"前言不论书上还是网上的技术论坛分享的 MySQL 查询优化方面的文章都不推荐使用 SELECT *，但是他们从未说过为什么不能这样用或者仅仅只是浅显的描述原因，但并不能让人觉得心服口服，那么——到底在 MySQL 为什么不用 SELECT * 来查询呢？ 老娘很好奇！——「千反田」 使用场景实际上我标题党了！标题其实是一个伪命题。 抛开使用场景就提出命题全部都是无稽之谈！ 比如一个 MySQL 的表 users 如下： name 类型 备注 id int 自增主键 name varchar 用户昵称 email varchar 注册邮箱 现在需求是：产品需要查询全部的用户资料然后导出 Excel。 当然，我们肯定直接用 SELECT * FROM users 查询了。 你也可以用下面的方法： 1SELECT id,name,email FROM users; 这两种方法是等价的，*（星号）的本质就是查询所有字段，并不是说使用星号就跟列出所有字段有什么不同的地方。 上述场景，两种方法的结果和过程完全一致。 SELECT * 的优点看到这里是不是颠覆常规的认知了？ 众所周知，不论书上还是网上一致抵制 SELECT 星号查询。 为什么还能有优点呢？ 抛开使用场景不谈而直接讨论命题的做法显然不可取。 以技术的角度来讨论这个问题，把不需要的字段查出来确实不好，为什么不好我们下文再介绍。 如果以项目经理的角度来说，SELECT 星号查询能大幅提升开发效率和减轻后续维护的时间。 这就涉及到「性能和开发效率的抉择」两者无法兼得。 为了提高查询效率，我们使用了 SELECT 字段1,字段2,字段3 进行查询，但如果后期我们修改表结构，表中新增了一个字段 4，那开发人员就得找到查询语句再补充一个字段 4，如果数据库模型使用了诸如 Laravel 的 fillable （可填充字段），你不仅要修改查询语句，还得修改模型。 示例： 1234567891011121314&lt;?phpnamespace App\\Model;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; // 原本数据库只有两个字段 name 和 email protected $fillable = [&quot;name&quot;, &quot;email&quot;];&#125;// 某个业务逻辑$users = User::select([&quot;name&quot;, &quot;email&quot;])-&gt;get(); 虽然这个 fillable 跟查询没有关系，但是不设置 fillable 在插入数据字段就会屏蔽 业务更新后，users 表新增了一个 address （住址）字段，业务需求不仅要显示出 name 和 email 现在还要把住址也显示出来。 于是，代码修改： 1234567891011121314&lt;?phpnamespace App\\Model;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; // 添加新的字段 address protected $fillable = [&quot;name&quot;, &quot;email&quot;, &quot;address&quot;];&#125;// 查询字段新增 address$users = User::select([&quot;name&quot;, &quot;email&quot;, &quot;address&quot;])-&gt;get(); 是不是很麻烦？因为添加一个新字段要修改两个地方的代码，开发效率大大降低了。 相反，如果直接使用星号查询呢？ Laravel 的 Model 中，与 fillable 相反的是 guarded（不可填充字段），将 guarded 的值设置为空数组代表所有字段（*）都可以填充（fillable）。 代码修改如下： 1234567891011121314&lt;?phpnamespace App\\Model;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; // 所有字段都可以填充 protected $guarded = [];&#125;// 不使用 select 方法查询即返回全部字段，也就是 SELECT * 查询$users = User::get(); guarded 也跟查询没有关系，它指代的是需要屏蔽哪些字段，与 fillable 相反 现在即使添加了新的 address 字段，我们也不需要回去修改代码了。 所以，SELECT 星号的优点就是可以提高开发效率，而且这种开发效率的提升是极为显著的，试想一下如果一张表后期改了很多字段，不仅有新增字段还有删除的字段，如果使用 SELECT 字段1,字段2 的方法来查询，每次表结构更改就得重新审核一遍所有该表的查询语句，因为一旦忘记修改某处那就会报字段不存在的错误。 事情往往都有两面性，尽管 SELECT 星号查询会在一定程度上降低性能，但它却能提升开发效率，我们应该根据使用场景来决定具体用哪种方法，在需要高度优化的场景，我们自然不会使用低性能的 SELECT 星号，规则是死的，人是活的，场景不断变化，我们的查询语句也要跟随变化。 缺点上文提到使用 SELECT 星号查询会影响性能，这其实是一句很含糊的话，到底是什么性能？性能只是一种笼统的概念，网上大都没有深究具体哪些地方会受到影响，无非都是说查询的字段越多查询速度越慢，诸如此类。 老娘很好奇！！——「千反田」 接下来就来详细的探讨 SELECT 星号影响的到底是哪些性能。 磁盘 IO我们知道 MySQL 的本质是存储在磁盘上的文件，因此查询操作就是一种读取文件的行为。 （当然还有一种是不需要读取文件的，后文介绍） 如果查询的字段越多，说明要读取的内容也就越多，因此会增大磁盘 IO 开销。 在对于 TEXT、MEDIUMTEXT 等更大长度的字段时，效果尤为明显。 内存后端代码查询 MySQL 后将查询结果保存在变量中，变量会占用内存资源，字段越多变量占用的内存就越高，看下面的例子，展示了两种不同查询占用的内存情况。 123456789101112131415161718# 查询语句select * from `users` limit 5000# PHP Laravel 框架测试内存使用情况// 获取查询前内存使用$startMemory = memory_get_usage();// 查询$users = User::limit(5000)-&gt;get();// 获取查询后内存使用$endMemory = memory_get_usage();echo &#x27;查询前：&#x27; . $startMemory . PHP_EOL;echo &#x27;查询后：&#x27; . $endMemory . PHP_EOL;## 输出结果查询前：15362584查询后：27977144 如果只查询部分字段： 123456789101112131415161718# 查询语句select id from `users` limit 5000# PHP Laravel 框架测试内存使用情况// 获取查询前内存使用$startMemory = memory_get_usage();// 查询$users = User::select([&#x27;id&#x27;])-&gt;limit(5000)-&gt;get();// 获取查询后内存使用$endMemory = memory_get_usage();echo &#x27;查询前：&#x27; . $startMemory . PHP_EOL;echo &#x27;查询后：&#x27; . $endMemory . PHP_EOL;# 输出结果查询前：15363056查询后：21672336 只查一个字段和查出全部字段内存占用差距非常大，尤其是在有 text 或者较大长度字段时，千万不要使用 SELECT 星号把无关的字段也包含到查询语句中，因为查找这些字段不仅没有意义还会徒增内存消耗。 网络传输 &#x2F; 带宽我们知道 MySQL 可以部署在与项目相同的服务器，也可以不在同一台服务器，当项目与 MySQL 不在同一台服务器时这种情况就会更加严重。 同理，如果使用了 TEXT 等大字段，要传输的内容也会变得更多。 从另一台部署了 MySQL 的服务器进行查询时，另一台服务器需要把数据传输给当前服务器，这中间是通过网络进行通信的，查询的数据越多返回的数据量也就越大。 数据传输量越大占用的网络资源就越多，这也是为什么前端要把 js 文件压缩成 min 减小体积的原因，只要传输的文件内容体积变小，传输花费的时间就越少，而大文件直到传输完成前网络连接不会断开，如果连接数一直增加最终可能超过服务器的承受能力导致后续连接直接未响应。 如果 MySQL 服务器是单独的，那么前面提到的缺点还会成倍的增加。 试想一下，MySQL 服务器中读取了多余字段（磁盘 IO &#x2F; 网络等性能消耗），然后再把数据传给项目所在服务器（多余字段导致内存增加），也就是说两台服务器都徒增压力。 无法高效利用索引在本博客前一篇文章中提到对 MySQL 占用内存过高的优化技巧。 因为 MySQL 为了查询优化占缓存了许多数据到内存中，而如果我们能利用内存的数据，查询效率能得到质的飞跃。 其中之一就是索引。 MySQL 中存在一种概念叫做「覆盖查询」，当查询的字段全部都是索引时，这时 MySQL 可以直接从索引中返回数据而不需要再次去查询表。 示例，orders 表中存在索引字段：user_id 和 goods_id，直接查询这两个字段时，通过 explain 分析可以发现： 1explain select user_id,goods_id from orders where user_id = 1 limit 10; Extra 字段返回的结果是：Using index 这里说明查询结果用到了索引，「覆盖查询」的原理就是在 MySQL 创建表数据的时候，会对索引的数据创建单独的结构（注意：索引里面就包含了数据），因此查询索引字段直接从这个单独的结构里面就能拿到数据了，就不需要通过索引去定位行再从行中取记录。 如果我们把上述的查询语句修改一下，加入一个非索引字段 price： 1explain select user_id,goods_id,price from orders where user_id = 1 limit 10; 可以发现，Extra 原本的 Using index 已经变成 NULL 了。 这是因为 price 不是索引字段，因此 MySQL 无法直接得到数据，必须定位到行才能拿到 price 字段，这种通过索引定位行再回到表中查询的过程叫做「回表查询」。 「覆盖查询」是从索引直接拿到数据，不需要「回表查询」，因而查询速度更快。 通过上面的分析，我们知道要实现「覆盖查询」的条件必须是：查询的字段全部都是索引。 显然我们不可能给每一张表的所有字段都加上索引，因此使用 SELECT 星号在字段比较多的表中无法实现「覆盖查询」。 尾语保持一颗「千反田的好奇心」，相信技术一定会有很大突破。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/tags/MySQL/"}]},{"title":"MySQL新增用户、修改密码、设置权限","slug":"mysql-init-action","date":"2020-06-21T09:42:53.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2020/06/21/mysql-init-action/","link":"","permalink":"http://huotublog.com/2020/06/21/mysql-init-action/","excerpt":"","text":"前言每次部署新项目都要重新设置 MySQL 的用户及权限，但这些基础命令又不经常用到，每次都要重新查找，于是整合了一下发成博文以便后续直接 复制粘贴。 网上搜索的大都是低版本 MySQL 或者根本就是错误的代码，不知道他们这样直接复制粘贴别人的代码但又没试过的是什么心态，简直浪费别人的时间。（尤其点明某 CSDN） 错误的范例： 1grant all privileges *.* to &#x27;要创建的用户&#x27;@&#x27;localhost&#x27; identified by &#x27;自定义密码&#x27;; 上述代码在 MySQL 8 直接报错 本文记录的命令以最新版的 MySQL 8 为基准。 用户介绍这一段科普 MySQL 用户知识，如需直接得到问题的解决答案可直接跳过。 MySQL 的所有用户均在 mysql 这个数据库里面保存。 1234567891011121314151617mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select user,host from users;ERROR 1146 (42S02): Table &#x27;mysql.users&#x27; doesn&#x27;t existmysql&gt; select user,host from user;+------------------+-----------+| user | host |+------------------+-----------+| mysql.infoschema | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+-----------+4 rows in set (0.00 sec) 其中，authentication_string 为加密后的密码。 123456789101112mysql&gt; select user,host,authentication_string from user;+------------------+-----------+------------------------------------------------------------------------+| user | host | authentication_string |+------------------+-----------+------------------------------------------------------------------------+| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || mysql.session | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || mysql.sys | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || root | localhost | |+------------------+-----------+------------------------------------------------------------------------+5 rows in set (0.00 sec) 当然，即使是 MySQL 系统创建的数据库同样适用 SQL 语句，你可以直接通过 update 命令修改字段： 123456mysql&gt; update user set host=&quot;%&quot; where user=&quot;root&quot;;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec) 上述命令是有效的，它的作用是把 root 用户的权限修改为 %（通配符），即除了 localhost（本地连接）之外，任何主机都可以通过该用户访问 MySQL。 当然这是不安全的，因为我们现在还没有给 root 用户设置密码，也就是说任何人都可以无密码访问到 MySQL。 虽然我们可以通过 update 直接修改 authentication_string 字段，但是这个字段是要经过加密的，不能直接修改成某个密码的值。 具体操作方法见下面的介绍。 新增用户非本地连接时，最好不要使用 root 登录，而是创建一个新用户并且指定权限。 MySQL 创建新用户命令： 1create user &#x27;用户名&#x27;@&#x27;权限&#x27; identified by &#x27;密码&#x27;; 其中，需要设置三个字段的值： 用户名：即登录的用户名，如：root2 权限：可选值为 % 或者 localhost 或指定具体 IP，如果要通过第三方软件（如 Navicat）必须将这个值设置为 % 或者某个主机 IP，推荐使用 %，表示所有 IP，如果设置为 localhost（本地）表示只有这台服务器才能访问。 密码：设置登录的密码 示例： 1create user &#x27;huotu&#x27;@&#x27;%&#x27; identified by &#x27;huotublog&#x27;; 上述代码表示创建一个具有远程登录权限的用户 huotu 且密码为 huotublog。 刷新权限命令：flush privileges; 修改密码如果需要修改用户的密码可以使用如下命令，不能直接使用 update 更新： 1Alter user &#x27;huotu&#x27;@&#x27;%&#x27; identified by &#x27;新密码&#x27;; 修改完成后需要刷新权限： 1flush privileges; 设置权限如果不设置权限，那么新增的用户就无法操作表。 在 MySQL 中所有用户都拥有某些数据库和表的某些权限，比如 root 用户具有最高权限，拥有操作所有数据库和表的能力。 一个用户的权限可以是一整个数据库，也可以对应许多个数据库，也可以是一个数据库中的某个表。 命令如下： 1grant all privileges on *.* to &#x27;huotu&#x27;@&#x27;%&#x27; with grant option; 上述命令赋予 huotu 用户所有数据库的表所有操作（增删改查）。 with gran option 表示该用户可给其它用户赋予权限，但不可能超过该用户已有的权限。 all privileges 对应具体的权限，可换成 select,update,insert,delete,drop,create 等操作。 示例： 1grant select,insert,update on *.* to &#x27;huotu&#x27;@&#x27;%&#x27;; 表示 huotu 只有对数据库中的表查询、插入和修改的权限，因此他无法进行删除操作。 *.* 这里的 * 指的是通配符，第一个 * 的位置指定数据库，设置为 * 表示所有数据库，也可以指定某个数据库，比如：myblog.*。（myblog 是一个数据库，表示拥有 myblog 数据库对所有表的操作权限） 第二个 * 指的是数据库中的某个表，设置为 * 表示对数据库所有表都有权限，也可以指定具体的表：myblog.articles。 查看授权信息查询某个用户的操作权限。 1show grants for &#x27;root&#x27;@&#x27;localhost&#x27;; 撤销权限删除某个用户的全部权限。 1revoke all privileges on *.* from &#x27;huotu&#x27;@&#x27;%&#x27;; 删除用户将用户数据删除。 1drop user &#x27;huotu&#x27;@&#x27;%&#x27;; 疑点解析上述所有命令基本都是 &#39;huotu&#39;@&#39;%&#39;，在看到这些命令的时候我在想后面的权限是有必要的吗？ 因为已经有用户名了，附带权限不是多此一举？ 其实只要测试一下就知道了，我们可以通过 create 命令创建一个 user 字段相同的用户，比如 root，但是权限不同，即 %，此时查询出来这两个同名的用户是并存的。 1234567891011121314mysql&gt; create user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; select user,host,authentication_string from user;+------------------+-----------+------------------------------------------------------------------------+| user | host | authentication_string |+------------------+-----------+------------------------------------------------------------------------+| root | % | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 || mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || mysql.session | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || mysql.sys | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || root | localhost | *05F9DE4C759F49574C4400083F80107567B47C2E |+------------------+-----------+------------------------------------------------------------------------+ 如果不添加权限那这两个同名用户就无法区分了，也就是说 user 字段加上 host 字段组成唯一键，而不是 user 字段唯一。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/tags/MySQL/"}]},{"title":"拆分你的代码","slug":"split-your-code-file","date":"2020-05-26T11:37:21.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/05/26/split-your-code-file/","link":"","permalink":"http://huotublog.com/2020/05/26/split-your-code-file/","excerpt":"","text":"前文概要本文讲述的是如何把一个大文件拆分成许许多多小文件的方法。 所谓大文件其实没有一个明确定义，暂且规定一个文件如果超过 1000 行就算大文件吧！ 当然也不用死脑筋，一看到代码行数多就得拆分，这完全要看情况，就好比玩游戏辅助的位置就一定得跟射手？如果脑袋不会转弯，对以后学习都很不利。死脑筋在一定程度上等同于“杠精”，本文介绍的是拆分文件的方法，而如何使用取决于一个聪明的孩子。 拆分文件的目的是解决混乱的逻辑，因为一个文件只要很大，极有可能是混杂了本来不应该出现的东西。拆分之后的小文件可能只有 100-200 行，相比一个 1000 多行的文件，哪个更容易让人看懂？ （题外话：在我看来辅助是决定游戏成败的关键因素，它的位置与打野一样重，出了辅助装的辅助不会抢经济，也就意味着这个位置可以支援任何一路，帮助中路快速清兵 Gank 上路，或者开局配合队友入侵对面野区，或者在上单被单杀后去守塔并且吃掉本来会被浪费的兵线，或者在打野队友被对面反蓝的时候去支援等等，辅助是很灵活的位置，但是一个死脑筋的人理解范畴就是辅助只有跟了射手才是辅助。） 架构演变技术的演变过程都是朝着分离代码发展。 最早的 PHP 文件前后端代码混合在一起，相信大家最开始学 PHP 的时候都接触过这种代码： 123456// index.php 文件&lt;html&gt;// ...此处省略998行&lt;h1&gt;&lt;?php echo &quot;hello world!&quot; ?&gt;&lt;/h1&gt;&lt;/html&gt; 这种文件又被归为：.phtml 格式，意思是 PHP 代码与 HTML 混合的文件。 因为 PHP 代码可以嵌入在 HTML 文件中，所以 PHP 又被叫做嵌入式语言。 可以嵌入其他语言感觉很 Cool，但其实这种做法是非常不可取的，试想一下公司忽然来了一个不懂 HTML 的 PHP 实习生，看着混合着 HTML 和 PHP 代码的文件肯定一脸懵逼。 为了维护混合代码的项目需要掌握前端知识，后端开发无形中增加了学习成本。 重点知识：HTML 代码与 PHP 代码混合在一起 也就是上面提到的“出现不应该出现的东西”，HTML 代码应该只包含 HTML、JS、CSS 之类的前端方面文件，而用来处理业务逻辑的 PHP 文件里也不应该出现前端的东西。只要出现了本来不应该出现的东西就会导致维护成本增加。 传统 MVC 模式首先介绍一下传统 MVC 模式， 这是早期用来处理代码文件膨胀的解决方案： 将代码文件分成： Model（模型）处理数据库操作 View（视图）渲染 HTML 文件 Controller（控制器）处理请求和响应 在一定程度上满足了早期的需求，模型文件专门处理数据库的增删改查，而控制器只要实例化模型对象就可以直接调用数据库操作方法，然后把数据传递给视图进行渲染。 每一步都变得更加专业化了。 模板视图：包括 PHP 代码与 HTML 代码的特殊文件 但 MVC 结构依然没有摆脱代码混合的问题，而是使用了稍微好一些的模板视图（例如：smart 模板、blade 模板）。 模板视图就是用来处理前端和 PHP 代码，用来最终渲染出 HTML 页面的文件。 以 Laravel 使用的 blade 模板为例： 1234567891011121314151617// IndexController.phpclass IndexController &#123; public function index() &#123; // 查询数据库，取 ID=1 的 goods $goods = Goods::where(&#x27;id&#x27;, 1)-&gt;first(); return view(&#x27;index&#x27;, compact(&#x27;goods&#x27;)); &#125;&#125;// index.blade.php&lt;html&gt;// ... 省略998行&#123;&#123; $goods-&gt;name &#125;&#125;&lt;/html&gt; 通过模板引擎编译后生成如下文件： 1234&lt;html&gt;// ... 省略998行&lt;?php echo $goods-&gt;name; ?&gt;&lt;/html&gt; 也就是说我们现在不需要直接在 HTML 上面写代码，而是在模板文件（index.blade.php）上面写代码。 但这种方法治标不治本，虽然模板文件是 PHP 文件，但还是夹杂着 HTML。 前后端分离为了分离出 HTML 和 PHP 代码，人们研究出了通过接口调用实现前后端分离的方法。 这种技术叫做 Ajax，前端通过 JavaScript 发起 HTTP 请求，服务器返回查询的数据，前端再渲染数据。 整个过程实现了前后端代码的完全分离。 现在我们后端开发人员已经从前端地狱中解放出来了！！ Service 模式因为前后端分离，MVC 模式的 View（视图）已经不需要了， 取而代之的是新出现的 Service（服务）。 MVC 模式下，所有的业务逻辑都写在 Controller（控制器）上。 示例代码： 12345678910111213141516171819class GoodsController&#123; public function index() &#123; // 按发布时间倒序获取20条商品数据 $goods = Goods::orderByDesc(&#x27;created_at&#x27;)-&gt;limit(20)-&gt;get(); // 拼装接口返回数据 $items = []; foreach($goods as $item) &#123; $items[&#x27;data&#x27;][] = [ &#x27;id&#x27; =&gt; $item-&gt;id, &#x27;title&#x27; =&gt; $item-&gt;title, &#x27;time&#x27; =&gt; $item-&gt;created_at ]; &#125; // 返回接口响应 return api_response($items); &#125;&#125; 把所有业务逻辑代码都写在控制器上会导致控制器文件逐渐膨胀。 控制器的作用是处理请求和响应，我们可以让它更加专业化一点，让它只负责处理请求然后给出响应。 至于逻辑处理，可以交给第三方：Service（服务）来处理。 所谓 Service 层只不过是再额外增加一个文件。 示例： 123456789101112131415161718class GoodsService &#123; // 按发布时间倒序获取20条商品数据 public function getGoodsItems() &#123; $goods = Goods::orderByDesc(&#x27;created_at&#x27;)-&gt;limit(20)-&gt;get(); // 拼装接口返回数据 $items = []; foreach($goods as $item) &#123; $items[&#x27;data&#x27;][] = [ &#x27;id&#x27; =&gt; $item-&gt;id, &#x27;title&#x27; =&gt; $item-&gt;title, &#x27;time&#x27; =&gt; $item-&gt;created_at ]; &#125; return $goods; &#125;&#125; 然后在控制器里只需要实例化出一个 GoodsService 对象，调用方法即可： 12345678910class GoodsController&#123; public function index() &#123; $service = new GoodsService(); $items = $service-&gt;getGoodsItems(); // 返回接口响应 return api_response($items); &#125;&#125; 控制器里面只负责处理请求和给出响应，把逻辑处理交给 Service 处理，这样 Controller 的代码几乎已经没有多少了，以后某个接口出问题可以立即找到对应的控制器方法，大大减少排查问题的时间。 （把业务逻辑写在控制器里是一个非常让人吐血的事情，作为接盘了不少项目的我深有体会） 更多的划分方法机智的你一定发现，即使增加了 Service 层，业务逻辑代码还是很多啊，把本来囤积在 Controller 的代码移到 Service 有什么意义？ 意义之一就是让每个结构更加专业化，Controller 只处理请求和响应，因为 Controller 如果有太多代码的话，如果一个接口出问题了，你要在 IDE 上面拖动滚轮才能定位到你想要的那个方法上面，然后直接在 Controller 层排查问题。而且 Controller 层如果囤积了太多业务代码，还有其他小伙伴也在修改这个控制器就很容易发生代码冲突造成不必要的麻烦。 Goods（商品）的相关业务逻辑就交给 GoodsService 处理；User（用户）的业务逻辑就交给 UserService 处理，这样你要修改哪个模块的业务逻辑也很方便不是吗？ 但还是没有解决 Service 层代码囤积问题。 这里凭经验之谈，其中一个方法就是数据库操作的逻辑移动到 Model 层里面去处理，示例： 12345678910111213141516171819class UserModel extends Model &#123; // 添加一名新用户 public function addUser($username) &#123; // user 表增加一条新用户记录 $user = $this-&gt;create([ &#x27;username&#x27; =&gt; $username, ]); // 为用户开通支付账户 UserAccountModel::create([ &#x27;user_id&#x27; =&gt; $user-&gt;id ]); // ... 其他数据库相关操作 // 返回新创建的 user 对象 return $user; &#125;&#125; 然后 UserService 直接调用 Model 的方法： 1234$data = request()-&gt;all();$model = new UserModel();$user = $model-&gt;addUser($data);// ... 处理其他逻辑 这样 Service 层的代码一部分就转移到了 Model 层里去了！ 把所有数据库增删改查的逻辑全部转移到 Model 层， 而 Service 只要实例化对应的 Model，调用方法（负责处理整体的逻辑）。 这样 Service 层也可以变得更加专业化。 Model：喵喵喵？把锅甩给我！？ 新的问题又来了，Model 层膨胀了！ OK，用同样的逻辑，我们再分出一个 Action（操作）层。 新建 Action 类，每一个操作对应一个类文件： 12345678910111213141516171819202122232425class UserAddAction &#123; // 创建新用户 public function add($data) &#123; $model = new UserModel(); $user = $model-&gt;create($data); return $user; &#125;&#125;class UserAccountAddAction &#123; // 开通用户支付账户 public function add(UserModel $user) &#123; $model = new UserAccountModel(); $data = [ &#x27;user_id&#x27; =&gt; $user-&gt;id, // ... 省略其他数据 ]; $account = $model-&gt;create($data); return $account; &#125;&#125; 接下来在 Model 里面只要实例化 Action，然后调用方法就可以了： 12345678910111213141516171819202122232425class UserModel extends Model &#123; // 添加一名新用户 public function addUser($username) &#123; // user 表增加一条新用户记录 $userAddAction = new UserAddAction(); $data = [ &#x27;username&#x27; =&gt; $username, // .. 其他数据 ]; $user = $userAddAction-&gt;add($data); // 为用户开通支付账户 $userAccountAddAction = new UserAccountAddAction(); $data = [ &#x27;user_id&#x27; =&gt; $user-&gt;id, // .. 其他数据 ]; $account = $userAccountAddAction-&gt;add($data); // ... 其他数据库相关操作 // 返回新创建的 user 对象 return $user; &#125;&#125; 每一个 Action 只对应一个方法，这样 Action 就不会膨胀了。 业务调用关系如下： Controller -&gt; Service -&gt; Model -&gt; Action 但代码拆分的缺点就是会让文件变得越来越多，每一个数据库操作就要写一个 Action，以后可能会出现上千个文件，而我们知道 PHP 程序运行时需要加载全部的文件，无疑会降低性能。 代码变得更好维护的成本是降低性能，代价未免太大了。 所以优化也要适度，回到标题，如何选择是要看情况进行灵活变通的。 微服务架构微服务架构同样是为了拆分代码， 把一套系统的各个功能模块拆分成独立的模块， 每一个小模块都是一个新的项目。 例如一套系统有用户模块、商品模块、订单模块， 主项目负责处理请求，然后调用相应的模块，再将数据返回。 主服务器的作用类似于 Controller 层， 只负责处理请求和响应，但具体的实现都交给 Service（子模块）去处理。 把每一个功能都单独立项可以使项目更加专一化，原本一个项目包括了所有模块。 “单体应用”模式 单体应用只需要部署一套项目，项目里就已经包含了完整的模块。 所有开发人员都在一个项目上进行开发工作。 单体应用的缺点是随着业务增加会越来越难以维护（因为所有的代码都集中在一个地方）。 而所有人都在共同维护一套代码，每个人习惯不同，技术水平也不同， 代码质量参差不齐，新加入的小伙伴也不敢轻易修改老员工的代码。 （有时候虽然知道老员工写了一个可以直接调用的方法，但新员工依然会产生不信任感，总归不是自己写的代码，万一被原主人改了怎么办？完全不能放心调用。） 单体应用排查 BUG 困难 有时候新来的小伙伴为了找一个 BUG 可能要遍历用户模块、订单模块、商品模块…… 几乎把所有的逻辑代码查了个遍。如果把每个模块都单独拆成小项目交给一个小团队去维护，大家各扫门前雪，用户模块出问题了就让负责用户模块的人去处理，这样大家互不影响，不会出现你删了别人代码，导致别人一脸懵逼的排查了一整天都没找到原因。 项目拆分成小项目，每个项目的运行速度就会变得更快，大大提高了系统性能。 理想很美好！现实很残酷…… 到公司你还是要当打杂的角色，不可能让一个人只负责一个项目， 往往就是用了微服务架构，你一个人要负责全部的项目（工作量反而增加了）。 不是技术负责人要压榨劳动力……而是他要为项目负责任。 如果他招来的人跑路了，那负责这个模块的功能就没人维护了，所以当你加入微服务架构里，每个团队成员至少也要负责 2 个以上的项目，万一其中一个人跑路还有另一个可以顶替。 项目变多，单个项目维护成本降低， 但总体维护成本也会提高，尤其是架构师跑路，谁来接盘就是一个严重问题。 回到最开始的地方，我们最终还是没能解决接盘侠的问题…… 总之，接盘侠是无可避免的要痛苦的。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"MySQL占用内存过高优化记录","slug":"mysql-memory-optimize","date":"2020-04-09T12:57:07.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2020/04/09/mysql-memory-optimize/","link":"","permalink":"http://huotublog.com/2020/04/09/mysql-memory-optimize/","excerpt":"","text":"前言在腾讯云购买的 1 核 1G 主机，使用 Docker 搭建的 MySQL 内存占用竟然高达 34%！再加上 Docker 其他容器运行起来和系统本身程序占用的内存，总内存高达 80+%，由于其他程序使用了 Redis 作为缓存，1G 内存就剩下 10%+ 可用内存（100MB+），一不小心可能就会让服务器卡成渣甚至直接 GG。 由于服务器一天的访问量并不多，并发访问也不高，并不需要把 MySQL 优化的多好，只要能正常运行就够了，加上有 Redis 缓存这一层，几乎很少会跑到 MySQL 查询。 所以综合起来，MySQL 压根不用担心它会挂掉，可以把默认的优化方案修改一下，以便把占用的内存释放出来。 优化后的结果如下图： 查询内存占用使用 top 命令查询当前程序的内存占用情况。 我们需要关注的部分如下： 123456 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1751 root 20 0 740212 11140 1476 S 1.2 1.1 106:46.57 barad_agent 1750 root 20 0 164512 8648 1312 S 0.6 0.9 20:52.41 barad_agent 29245 root 20 0 155148 2380 660 S 0.6 0.2 0:24.18 sshd 31044 root 20 0 135552 6028 1468 S 0.6 0.6 0:11.02 YDService 1 root 20 0 43656 2764 1364 S 0.0 0.3 2:19.11 systemd PID：进程 ID %CPU：CPU 占用百分比 %MEM：内存占用百分比 COMMAND：程序命令名称 如果发现某个不需要的进程占用了过高的内存或 CPU，可以直接使用 kill &lt;PID&gt; 杀掉进程。 进程杀掉程序就停了，我们不能直接杀掉 MySQL，具体解决思路见下一个步骤。 解决思路MySQL 在启动的时候，会占用一部分的内存来作为缓冲区，这样做的原因是可以优化查询速度，我们可以发现只要查询过一次 MySQL，然后用相同的语句再次查询，第二次查询会比第一次更快，这其中就用到了 MySQL 自身的缓存系统。 MySQL 的缓存机制是当某一个连接访问某张表时，MySQL 会先检查访问的表是否在缓存区中，如果这张表已经在缓存区中打开，那就会直接访问缓存区从而加快查询速度，如果这张表不在缓存区，那就会从实际的数据库文件进行查询，然后再把这张表加入缓存区，以便后续查询加快速度。 由于这个机制我们的 MySQL 在运行过程占用的内存会逐渐增加，1G 的内存不适合用来做 MySQL 的优化，我们要做的就是去掉 MySQL 用来加快查询的各种机制。 解决方案修改 MySQL 配置文件 my.cnf，找到 [mysqld] 下添加如下内容： 123456[mysqld]// 此处省略其他配置，添加如下内容table_open_cache=200table_definition_cache=400performance_schema_max_table_instances=400performance_schema=off 保存然后重启 MySQL，OK！内存已经降到 10%+ 了。 各个配置项的具体用途： 字段 用途 table_open_cache 高速缓存的大小，每当访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，下次查询该表时首先从高速缓存区查询，如果表在缓存中则直接从缓存查询，从而大幅提高查询速度。 table_definition_cache 定义了内存中可打开的表结构数量。 performance_schema_max_table_instances 检测的表对象的最大数目。 performance_schema 主要用来收集 MySQL 性能参数，启用 performance_schema 之后，server 会持续不间断地监测。【罪魁祸首】 通过调整前面 3 个配置项的值，占用内存均有 1~3% 程度的降低，罪魁祸首便是 performance_schema，将其设置为 off 之后，内存直接降低了 20%！ 其详细介绍可参考 MySQL 官方文档：MySQL Performance Schema 当然除了上面几个配置项之外，MySQL 仍有许多可以优化的配置项，但是现在既然已经实现了自己的目的，就暂时不进行扩展阅读了，以后如果需要更深入的优化，到时候再学也不迟（日均 IP 100+ 根本不用考虑什么优化嘛~）。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/categories/MySQL/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/tags/MySQL/"}]},{"title":"游戏菜单系统开发之栈的妙用","slug":"game-developer-stack","date":"2020-04-02T03:43:09.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2020/04/02/game-developer-stack/","link":"","permalink":"http://huotublog.com/2020/04/02/game-developer-stack/","excerpt":"","text":"菜单系统菜单是所有游戏必不可少的一个系统。 在游戏场景中，按 X 键可以呼出菜单，在菜单中按上下键可以切换菜单选项，再按 Z 键可以选中菜单，然后进入子页面的操作，子页面的菜单中也有子菜单，子菜单的操作与父级菜单一致。当打开菜单的状态，再按 X 键会返回上一级的菜单，直到主菜单返回游戏场景。 演示效果如下： 实现思路要实现菜单系统，最关键的地方在于防止按键冲突。 主菜单有按键事件，子菜单中也有按键事件，因此在主菜单中选中了子菜单，就要解除主菜单的监听事件而绑定子菜单的监听事件，多级菜单同理，可以归纳为：打开菜单——解除上一级的监听事件——绑定当前菜单的监听事件。 游戏的例子可能让从未接触过游戏的开发者难以理解，那么再看下一个例子。 上图为某电商首页的 UI，假如产品经理提出一个需求，在这个网页上按 X 键可以展开商品分类的菜单，然后通过键盘的按键可以选择二级菜单，选中一个分类再按 Z 键展开三级菜单，在展开菜单的情况下按 X 键会返回上一级菜单，你应该如何实现此功能？ 如果使用正常的方法，用变量来判断打开了哪些菜单，然后再绑定对应的事件，你会发现很难实现无限级的菜单系统，而且业务代码会变得乱糟糟的。 比如情报页面有线索二级菜单，线索菜单又可以进入到线索列表三级菜单，而角色状态可能只有一个显示角色信息的 UI，只有切换角色的按钮，没有三级菜单。 每个主菜单的选项都可能是不同的，它们没有共同点，因此你无法使用继承的关系把相同的操作提取出来，每一个菜单都要单独判断，简直是 if-else 地狱，不难想象代码会乱成什么样子。 在这里我们可以用“栈”的特性来优雅的实现菜单系统。 栈：一种先进后出的数据结构 栈是一种先进先出的结构，与队列正好相反，而我们打开菜单，按 X 键也正好是逐级向上返回，符合了栈的特性——先打开的菜单最后关闭。 在这里核心点是 监听事件与解除监听，无需关心具体的业务逻辑。 示例语言为 TypeScript，cocos creator 游戏引擎开发 首先我们定义一个父类 StackComponent 这个父类是需要调用栈的组件必须继承的类： 1234567891011121314151617181920212223// 文件名 Scene_StackComponent.tsconst &#123; ccclass, property &#125; = cc._decorator;@ccclassexport default abstract class NewClass extends cc.Component &#123; /** 添加监听按键 */ addListener() &#123; cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this); cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this); &#125; /** 移除监听按键 */ removeListener() &#123; cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this); cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this); &#125; abstract onKeyDown(event: cc.Event.EventKeyboard): void; abstract onKeyUp(event: cc.Event.EventKeyboard): void;&#125; addListener 方法添加按键监听，而 removeListener 方法则移除监听的事件，具体的按键事件进行了抽象，由子类来实现。 onKeyDown：键盘按下的时候触发 onKeyUp：键盘弹起的时候触发 接着定义一个栈结构，栈非常简单就可以实现，用一个数组来保存数据，用 pop 方法即可弹出最后一个元素： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 文件名 System_StackComponent.tsconst &#123; ccclass, property &#125; = cc._decorator;import System_StackComponent from &quot;./Scene_StackComponent&quot;;@ccclassexport default class NewClass extends cc.Component &#123; private _componentStacks: System_StackComponent[] = []; /** * 清空栈 */ flushStack() &#123; this._componentStacks = []; &#125; /** * 从栈取出最后一个元素 */ popStack() &#123; var len = this._componentStacks.length; if (len == 0) &#123; cc.error(&#x27;栈已空，调用失败&#x27;); return; &#125; // 弹出当前窗口 let pop = this._componentStacks.pop(); pop.removeListener(); // 最后一个元素添加监听 if (this._componentStacks.length != 0) &#123; let last = this._componentStacks[this._componentStacks.length - 1]; last.addListener(); cc.log(&#x27;窗口出栈,剩余：&#x27; + this._componentStacks.length); &#125; &#125; /** * 菜单组件入栈 * @param component */ pushStack(component: System_StackComponent) &#123; if (!component) &#123; cc.error(&#x27;这是一个空的元素&#x27;); return; &#125; // 原来最后一个元素移除监听 let len = this._componentStacks.length; if (len != 0) &#123; let last = this._componentStacks[len - 1]; last.removeListener(); &#125; // 当前元素添加监听 component.addListener(); this._componentStacks.push(component); cc.log(&quot;入栈：&quot;, this._componentStacks) &#125;&#125; popStack 方法弹出栈最顶层的元素，并且移除监听事件，同时监听新的顶层元素事件。 pushStack 方法将新的菜单入栈，监听当前菜单事件并且移除原来菜单的事件。 栈中所有的元素都继承 System_StackComponent 栈组件，因此它们都具有 addListener 方法和 removeListener 方法。 接下来为了方便，我们把对象保存在 JavaScript 的系统对象 window 中： 1window[&quot;__game&quot;][&quot;stack&quot;] = new System_Stack; 这样我们就可以通过 __game.stack 来调用栈的方法了。 主菜单脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041const &#123; ccclass, property &#125; = cc._decorator;import Scene_Menu_Item from &quot;./Scene_Menu_Item&quot;;import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;@ccclassexport default class Scene_Menu extends Scene_StackComponent &#123; /** 关闭菜单 */ closeMenu() &#123; // 弹出当前菜单事件 __game.stack.popStack(); // 销毁菜单节点（让菜单消失） this.node.destroy(); &#125; /** 显示情报面板 */ showInformationPanel() &#123; // 读取情报面板的预制资源 cc.loader.loadRes(&quot;/prefab/SceneInformation&quot;, (err, res) =&gt; &#123; let clueNode = cc.instantiate(res); let clue = clueNode.getComponent(&quot;Scene_Information&quot;); // 把菜单脚本压入栈 __game.stack.pushStack(clue); // 调用菜单脚本的初始化方法 clue.init(); // 把菜单节点添加到场景（显示菜单 UI） cc.find(&quot;Scene&quot;).addChild(clueNode); &#125;) &#125; // 具体的监听事件 onKeyDown(event: cc.Event.EventKeyboard) &#123; // 判断当前选项在“情报”菜单，如果此时按 Z 键则调用 showInformationPanel 方法显示情报页 // 判断按 X 键调用 closeMenu 方法关闭菜单 &#125; onKeyUp(event: cc.Event.EventKeyboard) &#123; // 业务逻辑忽略 &#125;&#125; closeMenu 方法关闭当前菜单，并且弹出栈，在所有菜单关闭的时候都调用这个方法。 onKeyUp 是键盘弹起事件，暂时不用理会。 在游戏场景加载中，为了能随时随地呼出菜单，我们再定义一个新的类： 1234567891011121314151617181920212223242526272829303132333435363738394041// System_Menu.tsconst &#123; ccclass, property &#125; = cc._decorator;import Scene_Menu from &quot;./Scene_Menu&quot;;import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;@ccclassexport default class System_Menu extends Scene_StackComponent &#123; private _menuNode: cc.Node = null; init() &#123; __game.stack.pushStack(this); &#125; // 监听 X 键 onKeyDown(event: cc.Event.EventKeyboard) &#123; switch (event.keyCode) &#123; case cc.macro.KEY.x: this.show(); break; &#125; &#125; onKeyUp(event: cc.Event.EventKeyboard) &#123; &#125; /** 显示菜单 */ show() &#123; // 加载菜单预制资源并添加到场景 cc.loader.loadRes(&quot;/prefab/Menu&quot;, (err, res) =&gt; &#123; let node = cc.instantiate(res); let menu: Scene_Menu = node.getComponent(&quot;Scene_Menu&quot;); // 将主菜单入栈 __game.stack.pushStack(menu); this._menuNode = node; // 添加到场景 cc.find(&quot;Scene&quot;).addChild(node); &#125;); &#125;&#125; 再将这个类添加到 window 系统对象： 1234// 添加到 window 对象window[&quot;__game&quot;][&quot;menu&quot;] = new System_Menu;// 执行初始化操作（入栈）__game.menu.init(); 如此一来，我们就可以随时随地通过全局的方法 __game.menu.show() 调出菜单了！ 注意！System_Menu 脚本并没有出栈的操作，因为如果这个脚本出栈了，那就不能监听 X 呼出菜单的事件，保留最底层的监听以便随时呼出菜单。 知识总结由于菜单是一级一级往上打开，而关闭的时候是一级一级向下关闭，因此它符合栈的结构，当一个菜单节点入栈时，我们为它绑定监听事件，同时解除上一级菜单的监听事件；当一个菜单出栈时，我们就解除这个菜单的监听事件，然后再给栈新的顶层节点绑定监听事件，无论有多少级的菜单都能够用这种结构来实现，只要让它们继承 StackComponent 类即可实现栈的调用控制事件的监听与解除，比起用变量来判断打开了哪些菜单，是不是优雅得多呢？","categories":[{"name":"通用技术","slug":"通用技术","permalink":"http://huotublog.com/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://huotublog.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"技术","slug":"技术","permalink":"http://huotublog.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Javascript使用对象必须知道的一件事","slug":"javascript-object-issue","date":"2020-04-01T08:32:49.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2020/04/01/javascript-object-issue/","link":"","permalink":"http://huotublog.com/2020/04/01/javascript-object-issue/","excerpt":"","text":"JavaScript 的对象JavaScript 中，对象即引用。 我们知道引用的特性： 将对象赋值给另一个变量，另一个变量的值如果改变，原对象的值也会改变。 引用即是内存地址的指向，将对象赋值给另一个变量，相当于另一个变量也指向了同一块内存地址，因此改变值时，原对象的值也会跟着变。通过下面的例子来了解一下引用的特性。 示例： 12345678910// 声明一个json对象let json = &#123; &quot;aa&quot;: &quot;Im aa&quot;, &quot;bb&quot;: &quot;Im bb&quot;&#125;;// 将json对象赋值给另一个变量let data = json;data.aa = &quot;no ok!&quot;;// 输出两个对象console.log(json, data); 在控制面板上的输出结果： 1&gt; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; 在这个示例中，我们原本是希望把 json 变量的值赋值给另一个变量 data，本意是不希望修改 json 的值，但由于 JavaScript 中对象即引用的特性会导致原来的值发生改变。 解决方法可以使用 Object.assign(target, source) 方法将 source 对象复制一份给 target 变量，类似 PHP 中的 clone，复制出来的变量会独立占据一片内存空间，而不是原对象的引用。 示例： 123456789101112// 声明一个json对象let json = &#123; &quot;aa&quot;: &quot;Im aa&quot;, &quot;bb&quot;: &quot;Im bb&quot;&#125;;// 复制对象到datalet data = &#123;&#125;;Obejct.assign(data, json);// 修改aa的值data.aa = &quot;no ok!&quot;;// 输出两个对象console.log(json, data); 输出结果： 1&gt; Object &#123; aa: &quot;Im aa&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; 可以看到，原来的 json 对象的值没有改变。 在 TypeScript 中，不能直接使用 Object.assign 方法，而是要使用 (&lt;any&gt;Object).assign。 示例： 12345678// 声明一个json对象let json = &#123; &quot;aa&quot;: &quot;Im aa&quot;, &quot;bb&quot;: &quot;Im bb&quot;&#125;;// 复制对象到datalet data = &#123;&#125;;(&lt;any&gt;Object).assign(data, json); 完结感言由于 cocos creator 使用的是 JavaScript 和 TypeScript 开发，今天在制作游戏的事件系统，遇到一个神秘的 BUG，排查了好久一直没找到原因，突然想起来以前也遇到过同样的问题，为了涨点记性，特此记录。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://huotublog.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://huotublog.com/tags/JavaScript/"}]},{"title":"Linux自定义别名——大幅提高工作效率！","slug":"linux-alias","date":"2020-03-30T17:29:34.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2020/03/31/linux-alias/","link":"","permalink":"http://huotublog.com/2020/03/31/linux-alias/","excerpt":"","text":"Linux 系统命令在 Linux 系统中，诸如 ls、top、ps 此类为 Linux 系统内置的命令，我们希望通过自定义命令来作为某些复杂命令的组合，如自定义 ll 为 ls -alF 的简写，通过简写可以大幅缩短输入命令的时间，\b还可以避免输错命令，何乐而不为呢？ 自定义 Linux 命令 &#x2F; 添加别名 Alias自定义命令其实就是添加一个别名，执行如下命令创建别名： 12cd ~vim .bash_profile 在这个文件里输入需要创建的别名，例如 ll： 1alias ll=&#x27;ls -alF&#x27; 然后保存，再执行： 1source .bash_profile 现在，使用 ll 等价于输入 ls -alF。 可以将常用的命令组合简写，例如我们常用来查看进程的命令： 1alias psp=&#x27;ps -ef|grep&#x27; 以后只需要输入： 1234567# 查看 PHP 进程psp php# 输出结果FireRabbitdeMacBook-Pro:~ firerabbit$ psp php 501 89356 1 0 二07下午 ?? 29:02.94 /Applications/PhpStorm.app/Contents/MacOS/phpstorm 501 99412 99183 0 9:20下午 ttys005 0:00.00 grep php 对于记不住命令的小金鱼们来说，利用好别名可以事半功倍哟！ 注意事项！别名的使用只有定义者自己知道，因此不适合多人协作的工作。在日常的开发中（如在个人的 Mac），可以自定义一些常用的别名来提高自己工作的效率。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/tags/Linux/"}]},{"title":"Redis添加密码验证","slug":"redis-add-permission","date":"2020-03-30T17:24:22.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/31/redis-add-permission/","link":"","permalink":"http://huotublog.com/2020/03/31/redis-add-permission/","excerpt":"","text":"为什么要为 Redis 添加密码验证？默认情况下，redis 不需要使用密码即可连接，而由于默认开放端口为 6379（用户一般不会去修改这个端口），导致基本信息完全暴露给试图攻击服务器者。 IDCE.COM 建站之初未设置 redis 密码，结果被注入了挖矿病毒 %&gt;_&lt;% 没有任何密码验证，意味着任何人都能访问到服务器的 Redis 服务，可能造成重要的信息泄露或者被访问者恶意删除造成严重后果！ 总而言之，如果要使用 Redis 服务，那么最好为 redis 加上密码验证可以增加系统的安全性。 开启 redis 密码验证以 Linux 系统为例，首先找到 redis.conf 配置文件，如果不知道文件在哪可以使用命令 find / -name redis.conf 找到。 添加 requirepass 字段，后面即你需要设置的密码，建议生成一个足够长的随机字符串来作为密码。 完成后保存，重启 redis 即可！ Redis-cli 验证密码在 cli 模式下，如果设置了密码需要验证之后才能执行 redis 操作，进入 redis 服务，然后执行 auth 密码 即可。 PHP 验证 Redis 密码123456$redis = new Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); //连接Redis$redis-&gt;auth(&#x27;123456&#x27;); //密码验证$redis-&gt;select(2);//选择数据库2$redis-&gt;set( &quot;testKey&quot; , &quot;Hello Redis&quot;); //设置测试keyecho $redis-&gt;get(&quot;testKey&quot;);//输出value","categories":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/tags/Redis/"}]},{"title":"Docker更换镜像源","slug":"docker-change-mirrors","date":"2020-03-30T17:21:03.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/31/docker-change-mirrors/","link":"","permalink":"http://huotublog.com/2020/03/31/docker-change-mirrors/","excerpt":"","text":"国内镜像源Docker 官方镜像中国区https://registry.docker-cn.com 网易http://hub-mirror.c.163.com 中科大https://docker.mirrors.ustc.edu.cn 阿里云阿里的镜像异常麻烦，本着求真的角度，还是把这一部分补充了 %&gt;_&lt;%。 首先需要注册成为阿里开发者，前往：阿里云开发者中心。 注册并登陆后，点击右上角的控制台： 想吐槽阿里云的界面设计，阿里云是一个超级聚合体……里面的服务实在太多，如果不写这样一个图文教程很难找到自己想要的功能，操作步骤如下图所示： 进入容器镜像服务，点击左侧菜单的镜像中心-镜像加速器： 根据阿里的提示操作即可： 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://93m46zjd.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 这里的 https://93m46zjd.mirror.aliyuncs.com 是我的个人镜像源加速地址，建议自己申请一个。 更换 Docker 镜像源Linux 系统Docker 使用 daemon.json 作为配置文件，如果没有的话则创建，编辑 daemon.json： 1vim /etc/docker/daemon.json 添加仓库地址（以中科大镜像源为例）： 123&#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 完成并保存，重启 docker： 1service docker restart 作为一个学府，中科大还十分贴心的写了帮助文档：Docker 镜像使用帮助 Windows 系统Docker for Window 可以直接通过右键右下角小鲸鱼，选择 Settings，选择 Daemon 选项卡，在右下角的 Registry mirrors 添加对应的镜像源地址即可。 Mac 系统如果你是下载了 Docker 桌面版的 Mac 系统用户，启动 Docker，选择右上角的小鲸鱼图标，选择菜单中的 Preferences： 在选项卡中选择 Daemon，点击 Registry mirrors 下方的加号，输入需要添加的国内镜像源地址，完成后点击底部的 Apply &amp; Restart 应用配置并重启 Docker：","categories":[{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/tags/Docker/"}]},{"title":"Mac系统安装Pecl","slug":"mac-install-pecl","date":"2020-03-30T17:15:19.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2020/03/31/mac-install-pecl/","link":"","permalink":"http://huotublog.com/2020/03/31/mac-install-pecl/","excerpt":"","text":"PECL 简介PECL（The PHP Extension Community Library）是 PHP 扩展的存储库，为 PHP 所有的扩展提供提供托管和下载服务。 一些常用及优秀的 PHP 扩展均被收录在 PECL 中，如：yaf、swoole 等等，我们可以方便的使用 pecl 命令来安装这些扩展。 PECL 支持的扩展：PECL All Packages 在 Mac 系统或 Linux 系统中可能没有默认安装 pear，因此无法使用 pecl 命令，本文将介绍如何安装 pear。 PEAR 安装方法官方文档：Getting and installing the PEAR package manager 1、下载 PEAR使用 curl 命令下载即可： 1curl -O https://pear.php.net/go-pear.phar 2、 安装 PEAR下载完成后，执行下面命令进行安装： 1sudo php -d detect_unicode=0 go-pear.phar 3、配置安装过程需要配置参数： 12345678910111213141516171819Below is a suggested file layout for your new PEAR installation. Tochange individual locations, type the number in front of thedirectory. Type &#x27;all&#x27; to change all of them or simply press Enter toaccept these locations. 1. Installation base ($prefix) : /usr 2. Temporary directory for processing : /tmp/pear/install 3. Temporary directory for downloads : /tmp/pear/install 4. Binaries directory : /usr/bin 5. PHP code directory ($php_dir) : /usr/share/pear 6. Documentation directory : /usr/docs 7. Data directory : /usr/data 8. User-modifiable configuration files directory : /usr/cfg 9. Public Web Files directory : /usr/www10. System manual pages directory : /usr/man11. Tests directory : /usr/tests12. Name of configuration file : /private/etc/pear.conf1-12, &#x27;all&#x27; or Enter to continue: 修改安装时的根目录，输入 1，再输入 /usr/local/pear，回车； 修改命令的安装目录，输入 4，再输入 /usr/local/bin，回车； 其它选项使用默认即可，一路回车。 4、测试是否安装成功输入命令 pear version，如果成功安装将会看到类似如下信息： 1234PEAR Version: 1.10.9PHP Version: 7.1.23Zend Engine Version: 3.1.0Running on: Darwin hongjiahuangdeMac-mini.local 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2/RELEASE_X86_64 x86_64 接下来就可以使用 pecl install &lt;扩展名称:版本号&gt; 安装各种被 PECL 收录的扩展了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"}]},{"title":"Redis淘汰机制","slug":"redis-delete-policy","date":"2020-03-30T17:11:39.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/31/redis-delete-policy/","link":"","permalink":"http://huotublog.com/2020/03/31/redis-delete-policy/","excerpt":"","text":"配置文件redis 的配置文件为 redis.conf，当 redis 占用的内存达到配置的最大内存时，再使用 redis 增加新的值时会触发淘汰机制将占用的内存释放出来，以创建新的键值。 redis 允许占用的最大内存，约在 567 行： 1# maxmemory &lt;bytes&gt; 找到 maxmemory 去掉前面的 # 井号， 将 &lt;bytes&gt;（单位：字节） 改为需要设置的最大内存值，一般而言，建议设置为服务器总内存的 50%~75%（需根据服务器情况确定），如果服务器其他进程占用较多内存的话，可以减少这个值。 当 redis 内存占用达到设置的最大值，触发的淘汰策略，约在 598 行： 1# maxmemory-policy noeviction 去掉前面的 # 井号，后面即为淘汰的策略，淘汰策略有许多种，下面进行介绍。不过在此之前，我们可以理解一下 redis 如何淘汰掉键值。 我们通过给一个键值设置过期时间，来让它“自动过期”，但实际上，即使到了过期时间，这个键其实并没有立即被删除，而是当下次取这个键值的时候进行判断，如果这个键设置了过期时间，同时已经过了过期时间再进行删除，这是一种惰性的删除策略。 此外，除了这种被动删除的策略之外还有主动删除策略，例如定期扫描过期的键值，扫描也不可能将全部的键都扫秒一遍，而是通过某种随机算法获取某些键，判断键是否过期再决定是否删除。 为什么键设定了过期时间不能在到期后立即删除呢？因为从技术的角度上来考虑这是一件十分困难的事，如果要追踪一个键值的过期时间，可能需要启动一个进程来追踪并且在过期时“杀掉”这个键，这样使用 redis 的优势就全部没有了，反而要消耗更多的系统资源。 redis 过期的键太多而没有删除，会造成内存资源的浪费，反之，如果过于频繁的去检查过期的键，希望在第一时间释放出内存资源，频繁的检查也是十分耗费资源的事，因此两者之间必须存在一个平衡，这就需要依靠 redis 的淘汰策略。 内存淘汰机制redis 有如下淘汰策略： noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适） volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除","categories":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/tags/Redis/"}]},{"title":"Redis基础","slug":"redis-base","date":"2020-03-30T17:06:41.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/31/redis-base/","link":"","permalink":"http://huotublog.com/2020/03/31/redis-base/","excerpt":"","text":"Redis 简介Redis 是由 ANSI C（标准C语言）写的键值对存储系统，由于是存储在内存中的，所以性能极高，但我们知道存储在内存中一旦电脑关闭就会丢失数据，Redis 还提供了数据持久化的功能，也就是说，Redis 的数据也可以保存在本地硬盘中。 原子操作所谓原子操作指的是不可再分割的操作，要么都成功，要么都失败。 Redis 的操作结果一定是确定的，例如将商品库存存储在 Redis 中，此时由于高并发场景有 1000 个请求进入，判断减少库存，总库存为 999 个，那么第 1000 个请求会因为高并发的场景而判断失误吗？答案是不会。 同理，一些抽奖活动将奖品数量存储在 Redis 进行操作，不会出现奖品被人领光还能领到奖品的情况，当有面试官问你就这么告诉他。 以抽奖场景示例： 1234567// 读取数据库奖品余额$count = PrizeModel::getCount();// 判断是否还有可以领取的奖品if($count &gt; 0) &#123; // 处理领奖逻辑，并且减少奖品数量&#125; 在这个场景中，涉及到读后写的问题，在读取奖品余额后更新奖品数量，由于读写操作是分开的，可能因为请求的先后而产生不同结果；比如 A 进来领取奖品，奖品的库存是 1，此时 B 也进来领取奖品，这个时候他也判断了奖品库存是 1，这个时候奖品的数量只剩 1 个，却有两个人被判断为可以领取奖品，就出现奖品库存变为负数的情况。 导致问题的根本原因在于读操作与写操作是分离的，中间如果有其他的请求进来，那么读操作的结果就是不准确的，可以使用 Redis 的 decr（自减）来操作商品库存： 12345$redis = new Redis();$count = $redis-&gt;decr(&#x27;prize&#x27;);if($count &gt; 0) &#123; // 处理领奖逻辑&#125; Redis 的 decr 命令将值减 1，并且返回了计算后的结果，实现了读写同步的操作，因此不会产生因为高并发场景读取了错误数据的情况。 这些都是依赖 Redis 的原子操作，之所以能够实现原子操作，是因为 Redis 是单线程。 假如对方问你，为什么单线程就是原子操作？ 扩展阅读：什么是线程 操作系统调度任务以线程为基本单位，Redis 所有的指令都在一个线程中进行，不会扩展出额外的线程；多线程，比如 MySQL 启动的时候是一个进程，而执行增删改查操作就是一个新的线程。多线程指的是可以同时干很多件事，而单线程只能一件事一件事的干，做完一件事才做下一件事，从效率上来说多线程远远超出单线程，但单线程的优势是每一步的执行结果都是确定的，要么都成功，要么都失败。 实际上，Redis 虽然是单线程但效率也是非常高的，因为它完全基于内存操作。 键Redis 使用键值对的形式存储数据，键类似于变量名字，键是一个字符串，最大长度 512MB，与开发语言不同的是 Redis 中的键可以使用一些开发语言中不能作为命名的符合，如：冒号、横杠。 键名称太长，会占用更多的内存空间，此外，太长的键名也会多查找造成影响；名称太短，又会造成语义不清，所以在取键名的时候需要有规范。 键的名称区分大小写，不建议大小写混用，要么全部大写，要么全部小写，取名“见名知意”为佳。 可以参考如下规则： 第一段为项目名称或者缩写形式（非必需），如：project 或 pro第二段为表的名字，如：user第三段为区分键的字段，如：MySQL 主键的列名，属性名第四段为键的特征字段，可以作为查询依据，如：MySQL 中主键 ID 的值 键的各个字段通常用冒号隔开。 示例： 12345# 根据 IDidce:users:id:1# 根据属性名 nameidce:users:name 前缀增加项目名称的用途是：当一个 Redis 服务器部署了多个项目可以进行区分，如果是单个项目，则可以去掉项目名称。 1234users:id:1# 根据属性名 nameusers:name 在项目中，最好有一个统一管理键名称的地方，否则后期无法进行维护。 数据类型Redis 支持如下数据结构： String：字符串 Hash：哈希 List：列表 Set：集合 Sorted Set：有序集合 PHP 使用 RedisPHP 想要使用 Redis 需要安装 redis 相关的扩展：PECL - REDIS 扩展下载。 也可以不使用扩展，直接下载 predis：Github - Predis 下载 将下载的包使用 require 命令引入： 1require &quot;./lib/predis-1.1/autoload.php&quot;; Redis 应用场景缓存由于其高性能的特性可以作为数据缓存，对于频繁查询但是不经常更新的数据可以将其缓存到 Redis 中，从而减少数据库查询压力，例如商品的库存、金额，需要注意的是当这些数据更新的时候也必须同步更新缓存数据。 此外，对于像微博的阅读量此类频繁更新的数据，也可以用缓存处理。方法是获取一条微博详情的时候，先判断是否有缓存，有的话先从缓存读取阅读量的数据，没有的话就从数据库读取，然后保存在 Redis 中；当用户访问时，直接在 Redis 操作访问量的增加，然后设置一个定时器程序，定期将缓存中的阅读量写入数据库，不过，这种类型的数据一般是比较不重要的，因为有可能会发生意外服务器重启导致数据丢失而没有正常写入数据库。 当某种数据需要频繁的查询或更新时可以使用 Redis 作为缓存。 排行榜我们经常会收到亲朋好友要求帮忙给他们家的小盆友投票（一般是才艺表演之类的），根据点赞数进行排行，排在前几名的会有奖励之类的。排行榜的数据变化十分频繁，这个时候就可以使用 Redis 的有序集合结构来存储排行数据。 分布式锁、本地锁Redis 中有一种命令 setnx 意为 set if not exists，即当不存在时设置数据，否则不进行操作，利用这种特性可以实现分布式锁。当成功设置的时候就执行后面的逻辑，如果未能成功设置代表之前已经执行过了，就不再走后面的逻辑。 锁的作用是防止重复动作，比如用户在点击领取奖励的时候，发现没有响应（网络延迟导致），结果用户以为自己没点下去就多点了几次，如果不做防止重复提交的处理，很有可能会造成领取到多次奖励的 BUG。 分布式就是多台机子间，而本地锁指的是本机，其原理类似，比如设置一个带有过期时间的 String 类型的缓存，如果这个键不为空则代表加过锁了。 消息队列Redis 中的列表结构由于读取头尾的速度非常快，因此适合作为消息队列的容器，将任务队列存储在 Redis 中可以大大提高程序的执行效率（与传统的数据库存储相比）。 Redis 安全隐患其中一个是未设置密码问题：Redis 未设置密码导致服务器被安装挖矿病毒 此外，Redis 即使正常使用也可能存在安全隐患。 缓存分为过期缓存和不过期缓存，不过期缓存过多可能造成内存溢出，而过期缓存又可能带来新的问题。 缓存穿透缓存穿透指的是查询一个缓存中不存在的数据，比如我们设置了一个根据用户 ID 来获取用户信息的缓存，此时如果我们输入 -1 或者其他不存在的 ID，那么系统将会判断缓存不存在，接着就去数据库查询。 这种“绕过”缓存查询数据库的行为类似于直接穿透了 Redis。 如果有人利用了这一点编写程序大量查询不存在的用户 ID 就很可能造成数据库崩溃。 解决方法是即使不存在的用户 ID 也设置一个空的缓存的键值，不过此类键值需要设置一个较短的过期时间，否则也可能会被恶意查询造成内存溢出。 缓存雪崩雪崩指的是一种短期内产生的爆发性冲击，在 Redis 中，如果有许多缓存在同一时刻过期，就会造成大量的数据需要从数据库查询，面对冲击性涌入的查询，数据库很可能造成崩溃。 解决方法是尽可能的让缓存的过期时间不一样，热门数据的缓存时间更长一些，对于同类型的数据可以设置一个额外的随机时间来让同类型的数据也会在不同时刻过期。 除此之外，还可以设计多级缓存结构来防止缓存雪崩。 当第一层的缓存过期了，不从数据库读取，而是判断第二层缓存是否存在，如果有就直接取数据，如果没有再判断下一层缓存……以此类推。这样的结构称为多级缓存，多级缓存结构比较复杂，其中第一层缓存叫做一级缓存，第二层叫做二级缓存……多级缓存结构可以防止突发性的冲击造成数据库崩溃，不过这样系统的复杂性会变高，多级缓存需要有一个程序来定期维护下级缓存，一般由架构师进行设计。 缓存击穿缓存击穿与缓存雪崩有些类似，不过不同的是缓存击穿指的是某个单一的键值过期，但是此时却有大量的流量涌入，造成所有的请求都直接到数据库那边，相当于在某个点凿出了一个洞，因此叫做“击穿”。 防止缓存击穿的方法： 方法（一）：后台增加一个定期任务刷新缓存的过期时间。 方法（二）：将缓存的过期时间也保存在值里面，当获取这个缓存数据的时候判断过期时间，在超过设置的阀值时更新这个缓存的过期时间。 方法（三）：可以使用缓存雪崩所说的多级缓存方法。 方法（四）：增加锁机制，当缓存过期查询数据库时，判断锁，只允许一个请求进来，其他请求都进入等待状态，进入的请求在查好数据后更新缓存，此时等待中的请求就可以获取到数据了。 总结Redis 还有许多应用，持续保持学习中……","categories":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/tags/Redis/"}]},{"title":"Window环境下安装Docker的坑","slug":"window-install-docker-issue","date":"2020-03-30T17:03:50.000Z","updated":"2023-02-16T06:50:23.267Z","comments":true,"path":"2020/03/31/window-install-docker-issue/","link":"","permalink":"http://huotublog.com/2020/03/31/window-install-docker-issue/","excerpt":"","text":"前言最近下载了 Docker for Window 搭建 Win10 系统的 PHP 环境，结果遇到了一大堆问题，网络上搜索答案极少，而且也很难找到能解决问题的方法，通过不断尝试和推测，踩了很多坑，也找到了填坑的办法，在此记录下来。 Docker for Window 下载地址：Docker 官方网站下载 Docker Hub 登录问题需要注册一个 Docker Hub 来进行登录，登录的帐号只能是 Docker ID，也就是注册时的用户名，而不是邮箱，此处需要注意，在使用 docker login 命令时经常会犯错而无法成功登录。 Hyper-V 缺失问题Docker for Window 依赖 Hyper-V（微软的虚拟机系统），只有 Window 专业版才有这个功能，家庭版如果需要开启此功能就需要升级到专业版。 查看电脑系统的方法：右键我的电脑，选择属性即可看到 Window 版本信息。 家庭版也可以不升级，安装另一个 Docker 的产品——Docker Tool。 Docker Tool 不依赖 Hyper-V，而是 VirtualBox（也是一种虚拟机软件），如果安装了 Docker Tool，则会自动安装 VirtualBox。Docker Tool 的操作方法与 Docker for Window 不太一样，更复杂一些，虽然本人也尝试下载过，但是感觉十分不便，因此最后卸载了。（由于安装了 Docker Tool，这里又挖了一个新坑，后面进行介绍） 本人用的是 Win10 专业版系统，却发现没有 Hyper-V 这个选项，原来是因为下载了精简版的 ISO 作为装机镜像，一些装机系统那边下载的软件都是经过二次封装的，削减了一部分的功能，因此推荐用那些精简过的系统。 找了许多装机的 ISO 镜像，最后决定下载微软官方原版的 ISO 镜像（十分干净，不带第三方软件），然后重新安装了 Win10 专业版。 Window MSDN 镜像下载：MSDN 我告诉你 选择左侧的系统，根据个人需求安装即可，不过据说对 Window 版本有一定的要求，太早的版本可能还是没有这个功能，建议至少 Win 8 以上(专业版)。 查看 Hyper-V 的方法是打开 控制面板，然后选择 程序，再选择 启用或关闭 Windows 功能。 重装后的系统已经可以看到 Hyper-V 这个选项了，如下图所示： 勾选后选择确定，重新启动电脑。 开启 Hyper-V 导致无法开机问题在开启 Hyper-V 的过程中，又遇到新的问题，如果将 Hyper-V 勾选起来点击确定，系统会安装软件然后提示重新启动，此时重新启动会导致电脑无法开机，一直在开始界面，并且提示“系统正在自动修复”。 只有进入到安全模式，将 Hyper-V 取消掉才能正常开机；又或者多次重启失败，系统自动恢复最后一次正确的配置。网上查了很多资料都没有找到解决方法，于是推测是因为相关的虚拟机服务没有启动导致的。 解决方法是进入服务管理，将 Hyper-V 的相关服务调整为“自动启动”，点击开始，选择运行（或者直接按 Win+R 快捷键），然后输入 services.msc 进入服务管理。 然后打开 Hyper-V，再重启就可以了。 Docker 命令被占用在安装好了 Docker for Window 后，打开命令行使用 docker 命令，却提示如下的错误信息： 1unable to resolve docker endpoint: open C:\\Users\\Administrator\\.docker\\machi.... 大致意思是找不到某个文件，而 docker-machine 是 Docker Tool 用到的东西，在翻找了许多资料后才发现原来是卸载时残留的环境变量导致的问题，Docker Tool 虽然卸载了，但是环境变量还在，这就导致了使用 docker 命令用的环境变量路径还是 Docker Tool 设置的路径，由于软件被卸载了，路径自然就找不到了。 解决方法是删掉残留的环境变量。 右键我的电脑，高级系统设置，环境变量。 然后在用户变量与系统变量中，找到 Docker 相关的变量全部删除，然后卸载掉 Docker for Window，重装一遍，即可解决（建议重启一次电脑）。 磁盘共享Docker 恢复正常以后，本人使用的是自己封装的一套 docker-compose 系统，由于里面用到了容器卷，在 Window 系统中还存在磁盘共享问题。 在使用 docker-compose up -d 的时候遇到如下错误： 1Cannot create container for service redis: b&#x27;Drive sharing failed for an unk... 大致意思是说磁盘共享失败。 解决方法是打开 Docker for Window 的 Settings，右键右下角的小鲸鱼图标进入设置界面，在设置界面中选择 Shared Drives 选项卡，将需要共享的磁盘勾选起来，然后点击 Apply（应用）保存设置，这个过程可能需要输入 Window 系统的用户名和密码，如果没有设置密码则需要设置一个。 Docker-Compose 路径问题接着又遇到新的问题，执行 docker-compose up -d 弹出如下错误： 1ERROR: for workspace_redis_1 Cannot start service redis: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;process_linux.go:430: container init caused \\&quot;rootfs_linux.go:58: mounting \\\\\\&quot;/etc/localtime\\\\\\&quot; to rootfs \\\\\\&quot;/var/lib/docker/overlay2/c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27/merged\\\\\\&quot; at \\\\\\&quot;/var/lib/docker/overlay2/c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27/merged/usr/share/zonStarting workspace_mysql_1 ... error 这是由于我在 docker-compose.yml 文件中写了一个错误的路径，/etc/localtime 是 Linux 系统里面的路径，将它去掉就可以了。 1234567891011redis: build: redis/ restart: always volumes: - ./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./var/logs/redis.log:/var/log/redis.log - /etc/localtime:/etc/localtime ports: - &quot;6379:6379&quot; networks: - default 去掉后就可以正常运行了。 Vmware、Hyper-V 不兼容问题第一次因为 Hyper-V 缺失而无法安装时，曾经尝试过使用 Vmware 来安装虚拟机，想要在虚拟机里面装一个 MacOS 系统，结果也是一个大坑，默认情况下的 Vmware 不支持 MacOS，而需要安装一个补丁，结果折腾了半天也没搞定，MacOS 的镜像高达 7 个 G，还因为百度网盘暂停会导致重新开始……折腾得心累，于是放弃了。 Hyper-V 与 Vmware 是不兼容的，一山不容二虎，如果要使用其中的一种，需要卸载掉另外一种。否则可能会因为服务的问题导致软件不能正常启动。 完结感言在中途曾经放弃过安装 Docker 的念头，而是手动安装了 PHP、MySQL、Redis、Nginx 等环境，但是后面又发现许多 PHP 扩展在 Window 系统的安装都十分麻烦，比如 swoole 扩展还需要安装 cygwin，折腾的心累于是放弃了。 真是艰辛的过程~~~","categories":[{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/tags/Docker/"}]},{"title":"MySQL主键详解","slug":"mysql-primary-key","date":"2020-03-30T17:01:50.000Z","updated":"2023-02-16T06:50:23.264Z","comments":true,"path":"2020/03/31/mysql-primary-key/","link":"","permalink":"http://huotublog.com/2020/03/31/mysql-primary-key/","excerpt":"","text":"前言从书本上学到的 MySQL 主键知识十分有限，我们只是知道基础的理论。 在一次面试中，面试官提问：主键索引与普通索引有什么区别？ 当场懵逼。 为了深入学习 MySQL 记录下此文。 MySQL 主键（Primary Key）MySQL 中的键即某种约束，键具有索引的作用，通过约束条件可以使得数据更快的被查到。 主键 是基本每张表都会用到的，一般类型为整型（integer、bigInteger）或者无符号整型（unsigned integer)并按照自然数的顺序自增。 主键是唯一的。 主键是一种索引，可以加快查询效率。 这是我们通常理解的主键，那么主键作为索引，又与普通索引有什么不同？为什么表需要主键？ 主键的分类主键的字段名称一般设置为 ID，当这个 ID 与业务无关时，称为逻辑主键（即 ID 没有实际的意义），如果将用户名（name） 字段设置为主键，该字段是业务中会用到的字段，称为业务主键。 由于主键是业务中经常会用到的键，而业务又经常变更，因此不适合将业务字段作为主键，而是设置一个与业务毫无关系的（ID）字段作为主键。 如果将业务字段用来做主键，例如上面的例子中的 name，系统后台需要修改某个用户的 name 字段，意味着主键也跟着变更了。 如果存在以下场景： 用户个人空间的地址为：http://domain.com/:name，:name 是用户名（即数据库中的 name 字段）。 主键一旦变更，某些页面如个人空间也会跟着变更，假如我收藏了某个用户的空间到浏览器：http://domain.com/user/xiaoming，结果因为用户改名为：xiaohong，这个用户的空间地址就变成了：http://domain.com/user/xiaohong，那我收藏的地址就 404 了，除了这方面的原因，由于可以随意修改主键，也就导致你改了主键的值，其他人又改成之前用过的主键，会产生许多问题，如果某个人又将 xiaogang 的名字改成 xiaoming，那我收藏的地址就会变成原名为 xiaogang 的个人空间，业务变得十分混乱。 主键通常是不能变更的值，因此建议设置一个与业务毫无关系的字段作为主键的值，之所以要用整型是因为查询效率比字符串更高、所需空间更小，可以使用自增自动生成唯一的值。 其他类型如字符串作为主键，由于在插入数据时需要生成唯一字符串，同时还需要判断是否已存在该值，故在插入数据的时候效率也会降低。 除了将单个字段设置为主键，也可以将多个字段绑定在一起作为联合主键（也称复合主键）。 主键设计原则： 主键的值 应该 无法被修改 主键的值 不应该 与业务有关 主键的值 建议 使用系统自动生成（如自增整型） 建议 使用单个字段作为主键 每张表都 建议 设置主键 为什么表需要主键想一下如果没有主键，需要删改查除某条数据的时候会有多麻烦：“帮我删掉 name 为 xiaohong 的那条数据”，而 name 属性又没有设置唯一键，存在很多条同名数据，到底是删除哪条？ 而当我们设置了 ID 作为主键，那我们就可以说：“删除 ID 为 6 的数据”、“帮我把 ID 为 6 的 name 字段改成 xiaohong”。 主键的其中一个作用即指向该行的数据，键具有约束作用，主键约束可以令数据具有唯一性，设置身份证为主键，那么这个主键就决定了一个人的个人资料，从千千万万个人当中，可以用身份证来指代唯一的一个人。 此外，主键索引可以提升查询效率，将一个字段设置为主键时，便会创建主键索引。 （下文介绍主键索引与普通索引区别） MySQL 主键与唯一键（Unique Key）的区别主键字段的值是唯一的，唯一键也要求字段值唯一，这两者的区别在于唯一键的值可以为 NULL，并且可以存在重复的 NULL 数据。 梳理如下： 唯一键的值 可以为空，且不能存在除空值以外重复的值。 主键的值必须 不为空 且不存在重复。 每张表中 只能 存在一个主键，可以存在 多个 唯一键。 从存在意义上来说，主键的作用是指代这一行的数据（如身份证代表一个人），而唯一键只是一种约束作用，用来约束这个字段在这张表不能存在相同值（如限制用户手机号码只能注册一个账号）。 主键索引与普通索引（Normal Index）的区别 扩展阅读：MySQL索引背后的数据结构及算法原理 普通索引的作用只是加快查询效率，并且可以存在重复的值，而主键索引的值是唯一的，它也可以提高查询效率，普通索引的值可以为 NULL，查询一个存在 NULL 的普通索引会导致查询效率提升的作用失效，当一个列设置了索引，同时也应当将其设置为 NOT NULL。 主键索引与普通索引的结构也不同。 聚簇索引和非聚簇索引（二级索引） 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行 Innodb 存储引擎中，数据表 table 由 table.frm、table.idb 组成。table.frm 保存表结构的定义，table.idb 保存的是数据和索引，这样的结构称为聚簇索引。 Myisam 存储引擎中，数据表 table 由 table.frm、table.myi、table.myd 组成。table.frm 保存表结构的定义，table.myi 保存索引，table.myd 保存数据。在用到索引时，先到 table.myi(索引树)中进行查找，取到数据所在 table.myd 的行位置，拿到数据。所以 Myisam 引擎的索引文件和数据文件是独立分开的，称之为非聚簇索引。 聚簇索引是按照数据存放的物理位置为顺序的，聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索更快。 在 Innodb 中，主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。 在表结构中只存在一个聚簇索引（主键索引），除此之外都是非聚簇索引（普通索引）。 覆盖索引一种特殊情况可以不通过聚簇索引查询数据，那就是通过创建联合索引（多个字段作为索引），如果查询的数据在索引中可以直接获取到，那就不需要再到数据行进行查询了。 例如创建索引：idx_name_email name 字段 和 email 字段是联合索引，当我们使用如下语句查询时： 1select name where email = &quot;xxx@idce.com&quot; 通过 email 来查询 name，由于它们是一组联合索引，因此可以直接从索引中拿到对应的数据。 覆盖索引查询数据只需要从索引中获得，而不需要到数据表中获取，因此可以极大的提高查询效率。 之所以能够从索引中得到数据，是因为索引的结构中保存了对应字段的值。 容易混淆的一个地方：上面介绍的聚簇索引才能保存数据，那为什么普通索引也能保存数据？ 其实这里指的是表的数据，通过聚簇索引找到的数据是直接找到表对应行的一整行数据，而索引保存的数据是这个字段的值，因此可以通过索引得到对应字段的值。 面试官曾经问我的问题：索引会保存字段的值吗？ 当时觉得不会，应该是保存对应行的所在地址才对。但其实是会保存的，因为只有保存了这个数据，查询索引字段才能快速进行数据对比从而筛选数据，如果能不回到表查询，则不回到表查询，回到表查询的效率比直接从索引拿数据低得多。 索引的结构，一侧是字段的值，另一侧是下一个数据的地址：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/tags/MySQL/"}]},{"title":"Nginx SSL证书配置问题","slug":"nginx-ssl-issue","date":"2020-03-30T16:57:16.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/31/nginx-ssl-issue/","link":"","permalink":"http://huotublog.com/2020/03/31/nginx-ssl-issue/","excerpt":"","text":"SSL 问题Nginx 重启时，报错信息： 1nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in /etc/nginx/conf.d/xxx.conf:57 通常我们会在 server 有如下 Nginx 配置： 1234567ssl on;ssl_certificate /etc/nginx/ssl/xxx.com.pem;ssl_certificate_key /etc/nginx/ssl/xxx.com.key;ssl_session_timeout 5m;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on; 访问网页提示错误代码 ERR_SSL_PROTOCOL_ERROR。 原因在于 Nginx 升级到 1.15 版之后，SSL 的配置不再使用 ssl on，把这一句去掉就可以。 这时再执行：nginx -s reload 平滑重启 Nginx 就不会报错了。 CURL 无法正常访问按照上面的步骤重启 Nginx 后，使用 curl 尝试连接到网站，结果依然报错： 1curl: (35) SSL received a record that exceeded the maximum permissible length. 这其实也是升级后配置发生了变化，第一个步骤的提示信息已经给与了提示：use the &quot;listen ... ssl&quot;，再次编辑 xxx.conf，将 listen 443 修改为：listen 443 ssl： 12345server &#123; listen 443 ssl; server_name idce.com; // ...此处省略&#125; 保存，然后再执行重启，OK！","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/tags/Nginx/"}]},{"title":"PHPStorm逼死强迫症患者解决方法","slug":"phpstorm-no-ext-tip-issue","date":"2020-03-30T16:40:47.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/31/phpstorm-no-ext-tip-issue/","link":"","permalink":"http://huotublog.com/2020/03/31/phpstorm-no-ext-tip-issue/","excerpt":"","text":"PHPStorm在使用 JSON 函数的时候，会报如下提示： 1ext-json missing in composer.json 花花绿绿看得猛男落泪，简直要逼死强迫症啊！ 原因可能是因为使用了 Docker 或者其他的环境，由于扩展是安装在虚拟机上就导致本机无法正确识别 PHP 的扩展，并不是本机上没有安装这个扩展，代码没有问题也不会报错，就是看得难受。 解决方案所幸，这里提供了两种方法可以根治此问题。 方案一针对缺失的扩展，在 composer.json 文件的 require 字段进行添加。 例如：&quot;ext-json&quot;: &quot;*&quot;： 如果没有 composer.json 文件，在项目根目录下自行创建一个即可。 这种方法针对特定的扩展，除了 JSON 扩展，常见的还有 CURL 扩展也无法正常识别，用相同的方法即可解决，扩展不多的时候可以用这种方法，要是使用了诸多第三方扩展而 PHPStorm 无法识别，可以参考下面的方案二一次性解决问题。 方案二关闭 PHPStorm 缺失扩展提示。 打开左上角 File-&gt;Settings 搜 PHP，然后找到下方一行的 Inspections，在右侧搜索 extension，找到 Extension is mission in composer.json 取消勾选保存即可，见下图： 以上方法任选一种即可。 猛的一顿操作之后——舒服多了！！","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"}]},{"title":"PHP-CLI 常用命令参数","slug":"php-cli-arguments","date":"2020-03-15T04:15:44.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/15/php-cli-arguments/","link":"","permalink":"http://huotublog.com/2020/03/15/php-cli-arguments/","excerpt":"","text":"运行 PHP 文件可以直接使用 php &lt;文件路径&gt; 执行 PHP 文件。 1php /var/www/html/project/index.php; 进入命令行模式使用命令 php -a 可以进入命令行模式，在这里可以直接运行 PHP 代码： 12345root@0139eebfa774:/var/www/html# php -aInteractive shellphp &gt; echo &quot;hello world&quot;;hello world 加载指定配置文件使用 php -c 可以加载指定的配置文件 php.ini: 1php -c /test/my_php.ini 显示当前配置文件路径使用命令 php --ini 查看当前加载的配置文件路径。 1234567891011121314root@0139eebfa774:/var/www/html# php --iniConfiguration File (php.ini) Path: /usr/local/etc/phpLoaded Configuration File: /usr/local/etc/php/php.iniScan for additional .ini files in: /usr/local/etc/php/conf.dAdditional .ini files parsed: /usr/local/etc/php/conf.d/docker-php-ext-bcmath.ini,/usr/local/etc/php/conf.d/docker-php-ext-gd.ini,/usr/local/etc/php/conf.d/docker-php-ext-gmp.ini,/usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini,/usr/local/etc/php/conf.d/docker-php-ext-opcache.ini,/usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini,/usr/local/etc/php/conf.d/docker-php-ext-redis.ini,/usr/local/etc/php/conf.d/docker-php-ext-sockets.ini,/usr/local/etc/php/conf.d/docker-php-ext-sodium.ini,/usr/local/etc/php/conf.d/docker-php-ext-swoole.ini 启动一个 WebServerWeb Server（网页服务）一般是由 Apache、Nginx 或是 Windows 系统的 IIS 提供。 从 PHP 5.4.0 起，也可以使用 cli 模式来启动 PHP 内置的 Web Server。 这个内置的 Web 服务器主要用于本地开发使用，不可用于线上产品环境。 使用命令 php -S localhost:&lt;端口号&gt; [文件路径] 来启动一个 WebServer： 12root@0139eebfa774:/var/www/html# php -S localhost:999[Sun Mar 15 04:25:52 2020] PHP 7.4.1 Development Server (http://localhost:999) started localhost 等价于 127.0.0.1 启动 PHP WebServer 时可以指定一个文件作为启动脚本（如框架的入口文件），在该文件注册所需要的插件及分发路由等等。 1php -S 127.0.0.1:666 test.php 命令添加 -t 参数，将会以目录作为 WebServer 的启动目录。 1php -S 127.0.0.1:666 -t public/ 关掉命令行窗口或者按 Ctrl + C 即可退出 PHP WebServer。 PHP 版本号使用 php -v 命令可以查看 PHP 版本信息。 12345root@0139eebfa774:/var/www/html# php -vPHP 7.4.1 (cli) (built: Dec 28 2019 20:56:41) ( NTS )Copyright (c) The PHP GroupZend Engine v3.4.0, Copyright (c) Zend Technologies with Zend OPcache v7.4.1, Copyright (c), by Zend Technologies PHP 扩展使用 php -m 命令可以查看 PHP 安装的扩展。 123456789101112root@0139eebfa774:/var/www/html# php -m[PHP Modules]bcmathCorectypecurldatedomfileinfofilterftpgd PHP 参数使用 php -i 命令可以查看 PHP &#x2F; 扩展的配置参数，等价于 phpinfo。 语法查错可以用 php -l &lt;文件路径&gt; 来检测该 php 文件是否有语法错误： 12root@0139eebfa774:/var/www/html# php -l index.phpNo syntax errors detected in index.php 执行一段代码使用 php -r &quot;代码&quot; 来执行一段 PHP 代码： 12root@0139eebfa774:/var/www/html# php -r &quot;echo &#x27;ok&#x27;;&quot;ok 查看扩展详情使用命令 php --ri &lt;扩展名称&gt; 获取扩展配置详情： 12345678910111213141516171819202122232425262728293031root@0139eebfa774:/var/www/html# php --ri swooleswooleSwoole =&gt; enabledAuthor =&gt; Swoole Team &lt;team@swoole.com&gt;Version =&gt; 4.4.14Built =&gt; Jan 6 2020 07:22:54coroutine =&gt; enabledepoll =&gt; enabledeventfd =&gt; enabledsignalfd =&gt; enabledcpu_affinity =&gt; enabledspinlock =&gt; enabledrwlock =&gt; enabledopenssl =&gt; OpenSSL 1.1.1d 10 Sep 2019http2 =&gt; enabledzlib =&gt; 1.2.11mutex_timedlock =&gt; enabledpthread_barrier =&gt; enabledfutex =&gt; enabledmysqlnd =&gt; enabledasync_redis =&gt; enabledDirective =&gt; Local Value =&gt; Master Valueswoole.enable_coroutine =&gt; On =&gt; Onswoole.enable_library =&gt; On =&gt; Onswoole.enable_preemptive_scheduler =&gt; Off =&gt; Offswoole.display_errors =&gt; On =&gt; Onswoole.use_shortname =&gt; On =&gt; Onswoole.unixsock_buffer_size =&gt; 8388608 =&gt; 8388608 查看扩展提供的方法使用命令 php --re &lt;扩展名称&gt; 获取扩展的所有方法： 1php --re swoole 获取函数详情使用命令 php --rf &lt;函数名称&gt; 获取函数详情，可以用来检测函数是否存在： 1234567891011root@0139eebfa774:/var/www/html# php --rf array_columnsException: Function array_columns() does not existroot@0139eebfa774:/var/www/html# php --rf array_columnFunction [ &lt;internal:standard&gt; function array_column ] &#123; - Parameters [3] &#123; Parameter #0 [ &lt;required&gt; $arg ] Parameter #1 [ &lt;required&gt; $column_key ] Parameter #2 [ &lt;optional&gt; $index_key ] &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"}]},{"title":"Trait - 优雅的复用方法","slug":"trait","date":"2020-03-14T16:40:51.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/15/trait/","link":"","permalink":"http://huotublog.com/2020/03/15/trait/","excerpt":"","text":"Trait为了解决单继承问题，从 PHP 5.4 开始新增了 trait 关键字来实现代码的复用。trait 定义的代码块在类的内部引入，类就能获得由 trait 定义的属性及方法。 通过定义一个 SingletonTrait，来实现单例模式的类共用代码块： 1234567891011trait SingletonTrait&#123; protected static $instance = null; public static function getInstance() &#123; if (null === self::$instance) &#123; self::$instance = new static(); &#125; return self::$instance; &#125;&#125; 要引用 Trait 十分简单，只要在类的内部使用 use 关键字即可： 123456789101112class SomeService&#123; use SingletonTrait; public function test() &#123; echo &#x27;ok!&#x27;; &#125;&#125;$service = SomeService::getInstance();$service-&gt;test(); 通过引用 SingletonTrait 代码块 SomeService 直接获得了 trait 定义的方法及属性，通过 trait 引用实现复用单例模式方法，而不是直接复制粘贴同样的代码到每个单例的类中，让代码变得更加优雅！ Trait 的实现原理是简单的把代码块拷贝到类 访问修饰符在类的继承关系中，如果父类的属性或方法使用了 private 声明，子类是无法调用的，但是在 Trait 中不同，因为 Trait 相当于把代码引入到类里面，也就是变成了类的一部分，因此当 Trait 声明了私有属性或方法，在类的内部是可以直接使用的。 Trait 定义的代码块同样可以使用 static、abstract 等修饰符。 多个 Trait一个类可以引用多个 Trait，中间使用逗号隔开。 当引入的多个 Trait 里面存在同名方法时，需要通过两种方式来解决冲突，否则会报出致命异常： 1PHP Fatal error: Trait method xxx has not been applied, because there are collisions with other trait methods on Test in xxx insteadof使用 insteadof 关键字来让其中一个 Trait 的方法覆盖另一个。 123456789101112131415161718192021222324252627282930313233343536373839trait A&#123; public function hello() &#123; echo &#x27;A:hello&#x27; . PHP_EOL; &#125; public function world() &#123; echo &#x27;A:world&#x27; . PHP_EOL; &#125;&#125;trait B&#123; public function hello() &#123; echo &#x27;B:hello&#x27; . PHP_EOL; &#125; public function world() &#123; echo &#x27;B:world&#x27; . PHP_EOL; &#125;&#125;class Test&#123; use A,B &#123; // 使用 A trait 中的 hello 覆盖 B 的 hello A:: hello insteadof B; // 使用 B trait 中的 world 覆盖 A 的 world B:: world insteadof A; &#125;&#125;$test = new Test();$test-&gt;hello();$test-&gt;world(); 输出结果： 12A:helloB:world as 方法重命名如果需要保留两者的方法，可以使用 as 重命名，然后再用另一个的方法进行覆盖： 12345678910111213141516171819202122232425262728293031323334353637383940414243trait A&#123; public function hello() &#123; echo &#x27;A:hello&#x27; . PHP_EOL; &#125; public function world() &#123; echo &#x27;A:world&#x27; . PHP_EOL; &#125;&#125;trait B&#123; public function hello() &#123; echo &#x27;B:hello&#x27; . PHP_EOL; &#125; public function world() &#123; echo &#x27;B:world&#x27; . PHP_EOL; &#125;&#125;class Test&#123; use A, B &#123; // 将 A trait 中的方法重命名 A::hello as ahello; A::world as aworld; // 再使用 insteadof 关键字覆盖冲突的方法 B:: hello insteadof A; B:: world insteadof A; &#125;&#125;$test = new Test();$test-&gt;hello();$test-&gt;world();$test-&gt;ahello();$test-&gt;aworld(); 注意，即使重命名了也需要使用 insteadof 覆盖原来的代码，不然同样会产生致命报错。 Trait 嵌套Trait 里面也可以引用其他 Trait。 优先级当 Trait 中定义的方法或属性与类或其父类相同时，其优先级如下： 1子类 &gt; trait &gt; 父类 Trait 的意义Trait 能实现代码块的复用，但是继承（extends）、实现（implements）同样可以复用父类的方法或实现接口的方法，它们之间有什么区别呢？ 我们知道面向对象编程里代码的关联性十分重要，例如继承关系即把子类的属性和方法进行了抽象，接口同样是把相同的东西抽象出来，然后在子类进行实现，这样有时候我们遇到像“水陆两栖动物”这种特殊的类型，既要让它继承水生动物的特性，又要让它继承陆生动物的特性，而 PHP 不支持多继承，要实现这种效果会变得十分麻烦。 而 Trait 定义的代码块，并没有严格意义上的关联性，仅仅只是为了复用代码块而被设计。Trait 的作用更像是一个功能块，不论是谁，只要让其他的类“嵌入”这个功能块就能让它具有对应的效果。 就好比 LOL 里的提莫，你可以出帽子、法穿棒等纯粹的 AP 装让它变成 AP 提莫，也可以出纳什之牙、飓风让提莫变成一个普攻型的 APC（远程输出单位），Trait 的作用类似于装备效果，任何人都可以出这件装备，只要装备了就能得到对应的能力。 在 Laravel 框架里，要实现“软删除”功能十分简单，只需要在数据库迁移中添加字段： 12345Schema::create(&#x27;orders&#x27;, function (Blueprint $table) &#123; $table-&gt;bigIncrements(&#x27;id&#x27;); // .. 省略其他字段 $table-&gt;softDeletes(); &#125;); 然后在 Model 里直接引入 Trait： 123456789namespace App\\Model;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\SoftDeletes;class Order extends Model&#123; use SoftDeletes;&#125; 即可让一个模型具有软删除的功能。 Laravel 还有许多地方存在此类的应用，通过这样的设计让代码更加优雅！ 结尾凡是在开发过程中，只要意识到自己通过 Ctrl+C、Ctrl+V 复制了同一份的代码，就表明这个地方写的不够好，一定存在优化的空间。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"}]},{"title":"微服务","slug":"mini-server","date":"2020-03-14T12:57:38.000Z","updated":"2023-02-16T06:50:23.261Z","comments":true,"path":"2020/03/14/mini-server/","link":"","permalink":"http://huotublog.com/2020/03/14/mini-server/","excerpt":"","text":"前言微服务是一种服务架构模式，目标是架构师的话，当然不能放过这个知识点。 架构模式一般的项目架构有两种形式：单体应用和微服务。 单体应用单体应用就是用一套代码实现全部功能。 微服务微服务就是把单体应用的代码按照功能拆分出来，形成多套独立的代码，通过某种方式让它们连接在一起，实现完整功能。 单体应用好比早期的网站开发，用 PHP 搭建的网站： 123456&lt;html&gt;... &lt;body&gt; &lt;?php echo &quot;hello world!&quot; ?&gt; &lt;/body&gt;&lt;/html&gt; HTML 代码与 PHP 代码混合在一起。 而随着技术的发展，又推出了 MVC 模式，实现模型、视图、控制器的分离。 然而问题的本质依然没有改变，还不是要一个人去完成同样的工作？ 技术从未停下发展的脚本，职业的分工越来越明确，开始出现专门写 HTML 和 JavaScript 的前端人员和专门写 PHP 代码的后端人员，前端人员通过一项技术“Ajax”调用后端人员写的接口，使他们看似分离但却紧紧的联系到一起，共同实现一个完整的项目。 这样的分工方式就叫做微服务。 微服务架构比如有一套系统，包括如下业务： 把这些业务拆分出来，单独做成一套系统，然后以某种方式让独立的项目之前能够进行通信，这就完成了一套微服务架构。 微服务通信模式HTTP 通信RPC 通信消息队列微服务的优缺点优点 大型项目解耦，提高整体性能 每个服务都很小，开发人员可以聚焦自己负责的功能模块。 只需要极少的人来维护一套代码 可以用不同的语言开发 缺点 架构需要花费一定的精力，如果架构得不好，后期反而会变成麻烦 由于服务分散成很多个，因此难以快速定位错误 管理成本提高","categories":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://huotublog.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"PHP-FPM","slug":"php-fpm","date":"2020-03-14T12:24:27.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/14/php-fpm/","link":"","permalink":"http://huotublog.com/2020/03/14/php-fpm/","excerpt":"","text":"前言在学 PHP 的时候，搜索网上教程一顿操作配置了 LNMP（Linux + Nginx + MySQL + PHP）环境，在配置 Nginx 的时候听说了 PHP-FPM，然而却没有进行深究，只知道让 Nginx 转发就完事了。 为了进一步的学习 PHP，需要了解 PHP-FPM 是什么。 CGI 通用网关接口通用网关接口（Common Gateway Interface，CGI）是一个为用户和 WEB 服务（如 Nginx）与其他应用（如 PHP）提供交互的程序。 早期的 WEB 应用只处理静态的页面，用户访问站点只要请求指定的 .htm 或 .html 文件，静态文件可以直接输出给浏览器，所以 Nginx 不需要做额外的处理。 随着互联网的发展，只有静态的页面已经不能满足人们的需求了。 Nginx 本身不处理文件，只是分发请求，比如用户请求 /index.html，它会去服务器寻找这个文件，找到了就输出给浏览器，没找到就返回 404。这里分发的是静态数据，但如果用户请求的是 /index.php，这是一个 PHP 文件，不能像 .html 文件一样直接返回给浏览器。 这个时候就犯难了，Nginx 应该如何处理非静态的文件呢？ 为了解决如何处理非静态文件的问题，CGI 诞生了。 CGI 做的事情就是解析用户的请求，然后将请求的结果解析成 HTML 返回给浏览器，开发者可以使用任何语言处理 Web Server 发来的请求，生成动态的内容。 上面的例子，用户访问 /index.php 文件，由于 Nginx 无法处理这种格式的文件，于是将请求（包括参数等等）转发给 CGI 程序（可理解为语言解释器）进行处理，这里的 CGI 就是 PHP-CGI，PHP-CGI 可以解析 PHP 文件，index.php 文件在 PHP-CGI 程序进行解析和处理后才会输出给浏览器。 index.php 文件就交给 PHP 程序去处理，.jsp 文件就让 Java 去处理，每种动态语言都有对应的 CGI，Nginx 只需要将请求转发给 CGI 就可以了，再通过 CGI 输出数据给浏览器。 FastCGI 快速网关接口CGI 在高并发时存在性能问题，作为改进版的 FastCGI 便出现了。 快速网关接口（Fast Common Gateway Interface，FastCGI）是 CGI 的增强版。 CGI 原理在接收到请求时，先 fork 出 CGI 进程，然后处理请求，处理完后结束这个进程，这就是 fork-and-execute 模式。 所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 进程，每个进程都会加载解析配置文件，初始化执行环境，那么当高并发请求时，会大量挤占系统的资源如内存，CPU 等，造成效能低下。 FastCGI 原理FastCGI 进程管理器启动时会创建一个主（Master）进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接。 Web 服务器接收 HTTP 请求后，将 CGI 报文通过 UNIX 或 TCP Socket 进行通信，将环境变量和请求数据写入标准输入，转发到 CGI 解释器进程。 CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器。 CGI 解释器进程变为空闲状态，等待下一个 HTTP 请求的到来。 由于 FastCGI 模式在启动时便创建了很多个子进程，这些子进程常驻内存中，一旦接收到请求就可以立即进入工作状态，而传统的 CGI 模式，只有在接收到请求的时候才会去创建进程，重新读取配置文件等一系列初始化操作，毫无疑问性能会相差很多。 PHP-FPM FastCGI 进程管理器PHP 的 FastCGI进程管理器（FastCGI Process Manager，PHP-FPM），PHP-FPM 即 FastCGI 的具体实现。 PHP 的解释器是 PHP-CGI，它本身只会解析请求返回结果，不能进行进程的调度，而 PHP-FPM（进程管理器）所做的事情便是管理进程。 PHP-FPM 包含了一个 master 进程和许多个 worker 进程，worker 进程的数量是可以动态调节的，创建和销毁全部由 master 进程来控制。 其中，master 进程负责分发请求，首先 master 进程检测是否有可用的 worker 进程，如果没有则返回错误（502），然后将请求分发给空闲的 worker 进程处理，然后接取下一个请求，再将请求分发给空闲的 worker，如果 worker 进程处理请求超时则返回错误（504）。 这样的协作方式大大的提高了程序处理并发请求的性能，worker 进程的数量可以通过 php.ini 文件进行配置。 理论上进程越多，可以处理的请求也越多，但空闲的进程太多反而会造成内存的浪费。 Nginx 与 PHP-FPM 通信Nginx 与 PHP-FPM 的通信方式有两种：TCP SOCKET 和 Unix SOCKET。 TCP socket 的优点是可以跨服务器，Nginx 服务器不需要与 PHP-FPM 在同一台服务器上，由于跨服务器的特性，还可以实现分布式部署。 Unix socket 用于实现同一主机上的进程间通信，相较于 TCP socket，Unix socket 跳过了许多验证的步骤，因此 Unix socket 的效率比 TCP socket 要高，但是不稳定。 TCP socket一个基于 TCP socket 的 PHP 站点 Nginx 配置： 123456789101112131415161718server &#123; listen 80; server_name localhost; root /www/web; index index.html index.php; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; &#125;&#125; 为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。 Nginx 的 FastCGI 模块提供了 fastcgi_param 来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量，fastcgi_param 是一个文件，包含了 Nginx 中的变量映射关系： 123456789101112131415161718192021fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length;fastcgi_param SCRIPT_NAME $fastcgi_script_name;fastcgi_param REQUEST_URI $request_uri;fastcgi_param DOCUMENT_URI $document_uri;fastcgi_param DOCUMENT_ROOT $document_root;fastcgi_param SERVER_PROTOCOL $server_protocol;fastcgi_param REQUEST_SCHEME $scheme;fastcgi_param HTTPS $https if_not_empty;fastcgi_param GATEWAY_INTERFACE CGI/1.1;fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;fastcgi_param REMOTE_ADDR $remote_addr;fastcgi_param REMOTE_PORT $remote_port;fastcgi_param SERVER_ADDR $server_addr;fastcgi_param SERVER_PORT $server_port;fastcgi_param SERVER_NAME $server_name; 除此之外，还有一个重要的指令 fastcgi_pass，这个指令用于指定 FPM 进程监听的地址，Nginx 会把所有的 PHP 请求翻译成 FastCGI 请求之后再发送到这个地址。 上面的 Nginx 配置文件中，我们配置了 fastcgi_pass 127.0.0.1:9000;，其含义是将请求转发到本机 9000 端口（PHP-FPM 进程）处理，这样的方式叫做 TCP socket。 TCP socket 的好处是可以将 Nginx 服务器与 FPM 服务器进行分离，因此可以实现分布式 PHP-FPM 架构： 配置 upstream 来指定 PHP-FPM 服务器： 1234567891011121314151617181920212223upstream php-fpm &#123; server 127.0.0.1:9000; server 127.0.0.2:9000;&#125;server &#123; listen 80; server_name localhost; root /www/web; index index.html index.php; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_index index.php; fastcgi_pass php-fpm; &#125;&#125; Unix socket基于 Unix socket 的 Nginx 配置： 1fasrcgi_pass /usr/run/php-fpm.sock PHP-FPM 配置： 123listen = 127.0.0.1:9000# 或者listen = /var/run/php-fpm.sock socket 的本质是一个文件，因此还存在权限问题，所以需要注意 Nginx 所在的用户组是否有该文件的操作权限。 Unix socket 通信方式需要在本机生成 sock 文件，因此 Nginx 服务器与 PHP-FPM 必须在同一台机子。 关于两者的取舍，当并发量较小时（比如几百），可以选择 Unix socket 以提高处理效率，在并发量较大时，可以选择 TCP socket 以保持连接的稳定性。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"}]},{"title":"一文读懂Nginx","slug":"nginx-introduction","date":"2020-03-10T14:20:15.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/10/nginx-introduction/","link":"","permalink":"http://huotublog.com/2020/03/10/nginx-introduction/","excerpt":"","text":"Nginx 是什么？Nginx 是高性能 HTTP 和反向代理 WEB 服务器，还提供了邮件代理服务。 简而言之即分发服务器请求的软件。 访问一个网站的本质： 在浏览器输入网址 DNS 服务商将网址解析成服务器 IP 地址 访问此 IP 的服务器 服务器收到请求，建立连接 服务器上的 Nginx 解析请求并转发给对应程序处理 程序处理请求 程序返回请求的结果（响应） 在此过程，Nginx 负责分发请求给指定的程序处理。 Nginx 在分发请求的时候，会携带请求参数和请求头等其他信息，Nginx 自身无法处理请求，它只是将请求转发给对应程序处理，如果是 PHP 搭建的网站，则转发给 PHP-CGI，由 PHP-CGI 返回结果给客户端。 PHP-CGI 是处理 PHP 文件的程序 Nginx 起源Nginx 是伊戈尔·赛索耶夫为俄罗斯访问量第二的 rambler.ru 站点设计开发的。 第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。 从发布至今，凭借开源的力量，已经接近成熟与完善。 中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 URI 是什么？在了解 Nginx 是如何分发请求之前需要先了解什么是 URI。 URI 统一资源标识符(Uniform Resource Identifier， URI)，它由三个部分组成： 协议 主机 资源路径 示例： 1https://blog.huotuyouxi.com/img/1.jpg https：协议 blog.huotuyouxi.com：主机 &#x2F;img&#x2F;1.jpg：资源路径 上面也提到了，访问网址的本质是访问服务器上某个文件，示例的网址访问 blog.huotuyouxi.com 所在服务器上的 1.jpg 这个文件。 如果这样理解不能，换句话说： 1F:\\games\\Lol\\Lol.exe 访问服务器上的文件与访问本地 F 盘并无太大的差别，区别在于访问网址相当于访问远程服务器上的文件。 通俗的讲 URI 就是远程服务器文件的路径。 至于协议部分，协议即一种人为约定的规则，除了 http、https 协议，还有 ftp、sftp 等等各种协议，请求协议跟后文没有多大关系，有兴趣可以自行查阅当做扩展阅读。 Nginx 如何分发请求？客户端请求 URI 对应的文件，Nginx 是如何处理的呢？ 在分发请求之前，Nginx 首先需要解析请求。 假如我们把域名：blog.huotuyouxi.com 解析到 IP 为 xxx.xxx.xxx.xxx 的服务器上。 然后在该服务器上安装 Nginx，并且添加如下配置文件： 1234567891011121314151617181920212223242526272829303132server &#123; # 监听 80 端口 listen 80; # 对应的域名 server_name blog.huotuyouxi.com; # 项目根目录 root /www/blog/public; # 访问日志存储位置 access_log /var/log/nginx/blog_access.log; # 错误日志存储位置 error_log /var/log/nginx/blog_error.log; # 字符集 charset utf-8; # 匹配 URI 以 / 开头（因为所有的 URI 都是以 / 开头，所以会匹配到所有请求） location / &#123; # 尝试获取这几种文件 try_files $uri $uri/ /index.php?$query_string; &#125; # 匹配后缀为 .php 的请求 location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass 127.0.0.1:9000; &#125; 小知识：80 是 http 默认端口，443 是 https 默认端口，访问域名时无需指定端口即可访问，使用其他端口时，就需要在域名后面加上 :端口号才能访问，例如：http://blog.huotuyouxi.com:81 location 是 Nginx 主要的模块之一，用来匹配 URI，满足条件时进入到模块内执行，我们在这个配置文件里设置了两个 location 模块匹配资源文件。 第一个 location 定制了规则 /，匹配以 / 开头的所有 URI，由于所有的 URI 都是以 &#x2F; 开头，所以会匹配到所有请求。 123location / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; try_files 按顺序检查文件是否存在，返回第一个找到的文件，至少需要两个参数，当前面的文件都找不到时，会内部重定向到最后一个参数： $uri $uri&#x2F; &#x2F;index.php?$query_string $uri 指的是完全匹配的文件，$uri/ 指的是文件夹，当前面两个都没有时，会访问 /index.php，而后面的 ?$query_string 指的是携带请求参数，如果不携带参数，使用 $_GET 会获取不到任何参数。 访问目录是以配置的项目相对路径： 1root /www/blog/public; 最后的值访问 index.php 即访问 /www/blog/public/index.php。 接着第二个 location，~ 是一种标识符，用于正则匹配 URI，区分大小写，正则匹配规则为：.php$ 也就是以 .php 结尾的文件，当满足条件时进入此模块。 123456location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass 127.0.0.1:9000;&#125; 注意！反斜杠 \\ 一定要存在，因为 .（点）也是正则表达式，需要加上反斜杠转义才能匹配 .php 后缀 location 在配置文件里的前后顺序并不是匹配的顺序，location 匹配的规则及顺序后文介绍，在这个例子中 / 的匹配优先级低于 ~，也就是先匹配 .php 后缀的文件，如果匹配不到再匹配 / 规则。 假如某个用户访问：blog.huotuyouxi.com&#x2F;php-fpm 此时，在 Nginx 中的处理流程是： 首先匹配到了 server_name：blog.huotuyouxi.com，进入当前配置文件进行处理。 接着解析 $uri（文件路径）即 server_name 后面的部分 /php-fpm，然后优先匹配规则 ~ .php，发现它并没有 .php 结尾，接着往下级匹配 /，满足条件，进入到该模块： 1234location / &#123; # 尝试获取这几种文件 try_files $uri $uri/ /index.php?$query_string;&#125; try_files 会尝试获取 /www/blog/public/php-fpm 文件，发现没有，继续匹配第二个参数；$uri/ 比之前的参数多加了一个 / 结尾，指的是文件夹，发现也没有 /www/blog/public/php-fpm 这个目录，前面两个参数都匹配完了，因此请求会变为内部重定向到最后一个参数 index.php 这个文件，然后重新开始匹配，此时正好匹配了规则 .php 结尾，进入 location ~ .php 模块： 123456location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass 127.0.0.1:9000;&#125; 进入到这个模块后，实际上是将请求转发给了 PHP-CGI 进行处理，前面几个字段暂时不用理会，只需要知道请求被转发给了 fastcgi_pass 这个字段，也就是 127.0.0.1:9000（PHP-FPM 本机端口），CGI 处理完请求后将结果返回给客户端。 以上就是 Nginx 解析和分发请求的过程。 Nginx 匹配规则及优先级Nginx 配置文件中的 location 即匹配规则，匹配规则可以有任意个，按照优先级逐个匹配，匹配成功时停止往下匹配。 匹配规则Nginx 的 location 模块包含 4 种匹配标识符： 12345标识符 描述= 精确匹配：当 $uri 完全匹配。~ 正则匹配：正则表达式匹配 $uri，区分大小写。~* 正则匹配：正则表达式匹配 $uri，不区分大小写。^~ 非正则匹配：匹配到前缀最多的 $uri 后就结束，该模式匹配成功后，不会使用正则匹配。 标识符置于 location 语句后面，标识符后面为匹配规则。 示例： 1234location [标识符] &lt;匹配规则&gt; &#123; # 匹配成功时执行的代码块 return 200;&#125; 除了标识符之外，可以不使用标识符进行前缀匹配（最长字符匹配）。 匹配优先级 location 的匹配优先级与 location 在配置文件的书写顺序无关 Nginx location 匹配优先级为： (location &#x3D;) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) &gt; (location &#x2F;) 换而言之，即： （精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location 通配） “&#x3D;”精准匹配使用精准匹配时，URI 必须完全相同才能匹配成功。 如下面的匹配规则，只有 URI 等于 /php-fpm 时才会触发成功，模块里的 return 403; 将会返回一个 403 Forbidden 提示信息，模拟我们不希望用户能直接访问的目录或文件。 123location = /php-fpm &#123; return 403;&#125; 然后把 server_name 字段修改为 localhost 方便本地调试。 修改 Nginx 配置需要重启或平滑重启使配置生效，平滑重启命令：nginx -s reload 请求 URI：127.0.0.1/php-fpm 可以使用 curl 命令来测试，即 curl 127.0.0.1/php-fpm，也可以直接打开浏览器输入这个地址查看结果。 返回结果：403 请求 URI：127.0.0.1/php-fpm/1.jpg 匹配失败，= 号必须完全匹配。 “~”正则匹配，区分大小写location 后跟波浪线标识符 ~，可以实现按照正则表达式规则进行匹配，~ 波浪线标识符正则匹配时会区分大小写，下面的规则表示不希望用户访问所有后缀为 .php 的文件。 123location ~ \\.php$ &#123; return 403;&#125; 请求 URI：127.0.0.1/php-fpm.php 结果：403 请求 URI：127.0.0.1/php-fpm.phP 第二个请求里，最后一个字母 P 为大写，因此匹配失败。 在波浪线前面加上感叹号，形成 !~ 标识符，表示不匹配正则表达式（区分大小写）的规则，也就是跟 ~ 的作用相反。 “~*”正则匹配，不区分大小写波浪线后加上星号 ~* 标识符将不区分大小写进行正则匹配。 123location ~* .php&#123; return 403;&#125; 请求 URI：127.0.0.1/php-fpm.php 结果：403 请求 URI：127.0.0.1/php-fpm.phP 结果：403 由于使用了不区分大小写的规则，因此最后一个 P 改成大写也能匹配成功。 在波浪线前面加上感叹号，形成 !~* 标识符，表示不匹配正则表达式（不区分大小写）的规则，也就是跟 ~* 的作用相反。 “^~”非正则匹配前缀“^~” 非正则匹配，后面的参数为匹配的路径，只要 URI 满足了这个前缀就匹配成功。 123location ^~ /encrpyt/ &#123; return 403;&#125; 请求 URI：127.0.0.1/encrpyt/ 结果：403 请求 URI：127.0.0.1/encrpyt 匹配失败，/encrpyt 没有满足 /encrpyt/，缺少了后面的 /。 请求 URI：127.0.0.1/encrpyt/1.jpg 结果：403 请求 URI：127.0.0.1/encrpyt/images/1.jpg 结果：403 也就是说，只要前缀满足了这个条件就匹配成功，上面的匹配规则含义是 encrypt 目录下所有的文件都禁止访问。 不使用标识符不使用标识符即按照最长字符串匹配，优先匹配最长的字符串，只要完全匹配就停止继续往下匹配。 1234567location /files/encrypt/ &#123; return 403;&#125;location /post.php &#123; return 403;&#125; 请求 URI：127.0.0.1/post.php 首先会查找最长的字符串规则：/files/encrypt/ 发现不匹配，接着匹配第二长的规则：/post.php，匹配成功，返回 403。 请求 URI：127.0.0.1/files/encrypt/post.php 首先查找最长字符串规则：/files/encrypt/ 前缀满足条件，匹配成功，停止往下匹配。 注意！测试匹配规则时，如果你拷贝了上面完整的 Nginx 配置文件，.php 结尾是有 location ~ .php$ 规则的，记得删掉，否则会优先匹配到正则规则，建议测试时删除多余的所有规则，避免干扰结果，只建立一个对照组进行测试 Nginx 配置文件Nginx 包括主配置文件与子配置文件，默认路径为： &#x2F;etc&#x2F;nginx&#x2F;nginx.conf（主配置） &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;（子配置目录） Nginx 提供了官方的中文文档可供查阅：Nginx - 官方中文文档 主配置文件主配置文件可以让所有子配置文件共享通用的配置，可以定义 Nginx 基本参数等。 编辑主配置文件 /etc/nginx/nginx.conf，对应参数及作用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Nginx 运行时的用户和用户组user nginx;# Nginx 工作进程数，推荐设置为 CPU 核心数worker_processes 1;# 全局错误日志存储路径及类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/nginx_error.log warn;# 进程 PID 文件路径pid /var/run/nginx.pid;# 事件模块events &#123; # 每个工作进程的最大连接数 worker_connections 1024;&#125;# HTTP 服务http &#123; # 文件扩展名与文件类型映射表 include /etc/nginx/mime.types; # 默认文件类型 default_type application/octet-stream; # 日志格式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; # 全局访问日志目录 access_log /var/log/nginx/nginx_access.log main; # 是否调用 sendfile 函数输出文件 sendfile on; # 此选项仅在使用 sendfile 的时候使用 #tcp_nopush on; # http 层面的连接超时时长（单位：秒），如一个网页打开 65 秒后服务器还没给出响应，则显示超时 keepalive_timeout 65; # 是否开启 gzip 压缩，开启时可以压缩文件体积减少网络传输，使得网页打开更快，但是会消耗 CPU 资源 #gzip on; # 读取子配置文件 include /etc/nginx/conf.d/*.conf;&#125; events 模块包含了 Nginx 处理连接的设置，常见的配置如下： 12345678910events&#123; # 设置网路连接序列化，防止惊群现象发生，默认为 on accept_mutex on; # 设置一个进程是否同时接受多个网络连接，默认为 off multi_accept on; # 事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport use epoll; # 最大连接数 worker_connections 1024;&#125; Events 模块的更多配置项：Nginx - 指令 log_format 字段可以定义日志的输出格式，具体可设置的参数格式及说明如下： 参数 说明 示例 $remote_addr 客户端地址 219.227.111.255 $remote_user 客户端用户名称 — $time_local 访问时间和时区 18&#x2F;Jul&#x2F;2014:17:00:01 +0800 $request 请求的URI和HTTP协议 “GET &#x2F;article-10000.html HTTP&#x2F;1.1” $http_host 请求地址，即浏览器中你输入的地址（IP或域名） www.blog.huotuyouxi.com 198.98.120.87 $status HTTP请求状态 200 $upstream_status upstream状态 200 $body_bytes_sent 发送给客户端文件内容大小 1547 $http_referer url跳转来源 https://www.google.com/ $http_user_agent 用户终端浏览器等信息 “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.0C; $ssl_protocol SSL协议版本 TLSv1 $ssl_cipher 交换数据中的算法 RC4-SHA $upstream_addr 后台upstream的地址，即真正提供服务的主机地址 10.36.10.80:80 $request_time 整个请求的总时间 0.165 $upstream_response_time 请求过程中，upstream响应时间 0.002 server 模块用于配置站点，可以在主配置文件添加，但是后期不方便维护，我们可以单独为每个站点编辑一份配置文件。 子配置文件子配置文件是一个包含 server 模块的配置文件，由自己来创建，推荐为每个站点单独创建一个配置文件。 命名规则一般是根据站点名称，如：blog.huotuyouxi.com.conf。 当然这个没有严格要求，也可以写成：blog.conf。 当子配置文件多的时候方便区分即可。 使用命令 vim/etc/nginx/conf.d/blog.conf 来创建博客的配置文件： 12345678910111213141516171819202122232425262728server &#123; listen 80; server_name blog.huotuyouxi.com; return 301 https://blog.huotuyouxi.com$request_uri;&#125;server &#123; # https listen 443 ssl; server_name blog.huotuyouxi.com; root /www/blog; index index.html; # 访问日志存储位置 access_log /var/log/nginx/blog_access.log; # 错误日志存储位置 error_log /var/log/nginx/blog_error.log; # 以下为 SSL 相关配置 ssl_certificate /etc/nginx/ssl/3527929_blog.huotuyouxi.com.pem; ssl_certificate_key /etc/nginx/ssl/3527929_blog.huotuyouxi.com.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on;&#125; 上述配置文件将默认的 http 80 端口重定向到了 https 的链接上。 编辑完成后运行：nginx -s reload 平滑重启即可使配置生效。 在子配置里可以单独设置访问日志和错误日志，让每个站点都有独立的日志记录文件： 12345# 访问日志存储位置access_log /var/log/nginx/blog_access.log;# 错误日志存储位置error_log /var/log/nginx/blog_error.log; access_log：访问日志主要记录客户端的请求。客户端向 Nginx 服务器发起的每一次请求都记录在这里。客户端 IP，浏览器信息，referer，请求处理时间，请求 URL 等都可以在访问日志中得到。当然具体要记录哪些信息，你可以通过 log_format 指令定义。 12access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; # 设置访问日志access_log off; # 关闭访问日志 path 指定日志的存放位置。 format 指定日志的格式。默认使用预定义的 combined。 buffer 用来指定日志写入时的缓存大小。默认是 64k。 gzip 日志写入前先进行压缩。压缩率可以指定，从 1 到 9 数值越大压缩比越高，同时压缩的速度也越慢。默认是 1。 flush 设置缓存的有效时间。如果超过 flush 指定的时间，缓存中的内容将被清空。 if 条件判断。如果指定的条件计算为 0 或空字符串，那么该请求不会写入日志。 error_log：记录服务器和请求处理过程中的错误信息。 1error_log path [level]; path：指定错误日志的存储位置 level：指定要记录的错误级别，只有发生错误的级别大于等于 level 的时候才会记录错误，可取值为：debug, info, notice, warn, error, crit, alert,emerg，默认值为 error。 如果没有配置单独的日志文件，则会记录在全局日志里。 代理服务代理指的是中介服务。 分为正向代理与反向代理。 正向代理正向代理可以理解成代购模式，例如你的朋友要去国外旅游，于是你拜托他帮忙购买你需要的商品，他从国外买好回来再交给你。 在这里你就是客户端，而你的朋友就是代理服务器。 这样直接由代理服务器去完成某件事的过程，叫做正向代理。 正向代理的应用例子——VPN： 由于国内无法访问到国外的某些网站，比如谷歌；但不是所有的国外服务器都被墙了，因此你可以买一台没有被墙的国外服务器，当你需要访问国外网站的时候，就让服务器去访问，然后再让服务器把结果转发给你。 正向代理的特征是你知道自己委托了谁去干这件事。 反向代理反向代理与正向代理不同的地方在于：客户委托中介完成一件事，结果中介私底下把需求转交给了别人去干，客户不知道究竟是谁帮自己做完了需求，但是得到了自己想要的结果就够了。 好比游戏里面的公会，村民可以把自己的委托贴在公会告示板上，然后公会的看板娘会把委托的需求分配给适合的冒险者来完成。 反向代理的应用例子——负载均衡： “负载”可以理解成负荷，用户访问一个非静态网站，程序需要读取数据库、渲染 HTML 页面、维持 TCP 连接等操作需要消耗 CPU、内存资源，会给服务器带来一定的负荷。 假如服务器可以承受的压力为 100N（物理学单位） 在某个瞬间，每有一名用户访问这个网站，会给服务器带来 5N 的压力，那么这个瞬间最大承载量就是 20 名用户，当服务器压力超过 100N 时就会崩溃。 要解决这个问题，可以进行硬件提升或者优化项目代码。 硬件提升可以提升服务器最大承受压力值，比如双核的服务器升级到 4 核，使服务器的最大承受压力从 100N 提升到 200N。 软件优化可以减少每个访客造成的压力，比如某些数据库 N+1 的问题严重影响了数据库的性能，造成数据库卡顿，优化了这个问题后，访客造成的压力值从 5N 降低到了 4N。 但是这两种方法提升都有一个临界点，比如硬件优化继续往上提升，服务器的价格就越来越贵，也不可能存在无限核心数的服务器；软件优化到一定程度后已经很难再找到优化的空间。 达到临界值后就无法再继续优化了，单机的性能已经达到了极致。 此时，如果能再买一台同样的服务器并且部署同一套项目，是不是可以使最大承载访客数翻倍呢？ 确实可以，只要有两台服务器，那么它们的处理能力就会翻倍！ 只要把一半的请求转发给另一台相同的服务器，平均分担压力。 但是应该怎么让请求分别进入到不同的服务器呢？ 答案是通过 Nginx，利用上文介绍的反向代理功能。 这个过程称为“均衡”，负责维持均衡的那台服务器只负责分发请求，把请求转发给其他能完成功能的服务器处理，由其他服务器返回结果。 负责分发请求的服务器称为“均衡调度器”，Nginx 配置： 1234567891011121314upstream huotu-server &#123; server 192.168.0.14; server 192.168.0.15; server 192.168.0.16;&#125;server &#123; listen 80; server_name blog.huotuyouxi.com; location / &#123; proxy_pass http://huotu-server; &#125;&#125; upstream 字段定义了代理服务器的 IP 地址，当访客进来的时候，Nginx 会按照某种规则将请求分发给其中一个服务器处理。 server 模块里通过 proxy_pass http://huotu-server; 将匹配到规则的请求转发给代理服务器来处理。 当用户访问：blog.huotuyouxi.com Nginx 会把请求转发给某台服务器处理，因此每次访问网站看到的返回 IP 可能都会不同。 Nginx 模块Nginx 发展迅速的原因除了开源之外，还可以使用官方提供的模块或用户自定义开发的模块，由于模块化使得 Nginx 的定制能力很强，可以使用第三方扩展模块让 Nginx 适应各种场景，有能力的大神也可以分享自己写好的模块让其他人直接使用，像这样可以自由 DIY 的软件，有谁会不喜欢呢？ 例如，由淘宝的工程师清无（王晓哲）和春来（章亦春）所开发的 nginx_lua_module 可以将 Lua 语言嵌入到 Nginx 配置中，从而利用 Lua 极大增强了 Nginx 本身的编程能力，甚至可以不用配合其它脚本语言（如 PHP 或 Python 等），只靠 Nginx 本身就可以实现复杂业务的处理。 Nginx 本身支持多种模块，如 HTTP 模块、EVENT 模块和 MAIL 模块等。 前文提到，在 HTTP 请求中，Nginx 的工作仅仅只是分析请求然后转发给匹配规则的 location 去处理，location 模块中的内容才是真正干活的人。 1234567server &#123; # 匹配规则 location / &#123; # 实际的工作者 return 403; &#125;&#125; 已安装模块可以用命令：nginx -V 查看，输出结果类似如下： 1234built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) built with OpenSSL 1.1.0j 20 Nov 2018TLS SNI support enabledconfigure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&#x27;-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.15.12/debian/debuild-base/nginx-1.15.12=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#x27; 安装模块Nginx 有许多可以自定义安装的模块，下面以 echo 为例。 echo 仓库地址：Github - echo-nginx-module 安装 echo 模块 echo-nginx-module 可以使 Nginx 具有输出字符串的能力，这个功能可以用来简单的调试，如输出参数等。 1234567location /hello &#123; return 200 &#x27;hello!&#x27;;&#125;location /hello_echo &#123; echo &quot;hello, echo!&quot;;&#125; 官方模块官方模块是 Nginx 官方提供的可扩展模块。 例如 Nginx 预制的模块 stub_status 可以用来查看 Nginx 的运行状态： 123location /test &#123; stub_status;&#125; 访问后的输出页面： 1234Active connections: 2 server accepts handled requests 3 3 2 Reading: 0 Writing: 1 Waiting: 1 更多 Nginx 官方模块以使用方法：http://nginx.org/en/docs/ 如上面的 stub_status，可以通过查询手册：ngx_http_stub_status_module 来获取如何使用。 第三方模块可以通过搜索 Github 寻找来自全世界开发者分享的模块：Github - Nginx 扩展模块 具体的使用方法可以参照作者写的 README 文档。 Nginx 应用场景最后再来总结一下，Nginx 具体的应用场景。 HTTP 服务Nginx 可以为站点提供 HTTP 服务。 利用 location 模块匹配 URI 规则，再将其分发到对应的程序进行处理。 负载均衡Nginx 的反向代理服务，可以实现分发请求的功能。 具体方法是配置 upstream 字段： 12345678910111213141516http &#123; upstream myproject &#123; server 127.0.0.1:8000 weight=3; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003; &#125;server &#123; listen 80; server_name www.domain.com; location / &#123; proxy_pass http://myproject; &#125; &#125;&#125; 负载均衡有以下几种模式： 模式 说明 轮询模式 Nginx 默认配置，当客户端访问服务的时候，请求按时间顺序逐一分配到不同的后端服务器，如果有某台服务器挂了，Nginx 会自动剔除 权重模式 可以为每个服务器配置不同的权重，权重值越高的越容易被分发到请求，当多台服务器性能存在差异时，可以让配置高的服务器分配更高的权重 IP 哈希 如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。解决 Session 丢失的问题，保证每个用户访问到同一台服务器。 第三方插件 可以通过安装第三方插件实现更多的模式 防盗链当自己网站的图片、视频等静态资源被其他人引用时，其他人访问了别人的网站，就会请求到我们服务器上的资源，给我们的服务器带来压力。 Nginx 可以验证来源网站 referers 来判断请求是否是本站点，如果是其他的站点则不让它们获取到图片资源： 1234567location ~* \\.(gif|jpg|png|swf|flv)$ &#123; root html valid_referers none blocked *.huotuyouxi.com; if ($invalid_referer) &#123; return 404; &#125;&#125; CDN 服务器可以用 Nginx 搭建 CDN 服务器。 限流Nginx 的 ngx_http_limit_req_module 模块可以限制访问频率和并发连接数。 HttpLimit zone：HttpLimit zone HttpLimitReqest：HttpLimitReqest 黑&#x2F;白名单可以禁止某些 IP 访问，或允许指定 IP 访问。 1234location / &#123; deny 8.8.8.8; allow 9.9.9.9;&#125; 解决跨域问题以 Ajax 方式访问非本站点的链接时，浏览器出于安全考虑会禁止访问，也就是跨域问题（HTTP 访问限制，CORS）。 在 Nginx 中只需要配置允许访问的来源类型即可解决跨域问题： 123456# 允许访问的来源，* 指的是全部，可以是 IP 地址或者域名add_header Access-Control-Allow-Origin *;# 允许请求的类型add_header Access-Control-Allow-Headers X-Requested-With;# 允许请求的方法add_header Access-Control-Allow-Methods GET,POST,OPTIONS; 邮件服务Nginx 提供了邮件代理服务，具体参照官方文档：Nginx - MailCore","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/categories/Nginx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/tags/Nginx/"}]},{"title":"PHP中的反射","slug":"php-reflex","date":"2020-03-10T09:55:28.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/10/php-reflex/","link":"","permalink":"http://huotublog.com/2020/03/10/php-reflex/","excerpt":"","text":"反射是什么？反射原本指的是一种光学现象，光在传播时照射在物体上会产生返回原物体的现象。在 PHP 中，反射的作用类似光的传播，PHP 可以通过反射机制拿到代码本身，也就是通过代码得到代码，反射一词十分形象。 通过反射机制可以获取类中的变量、方法名称甚至是注释等等，在正常的开发环境中几乎不会用到，一般都是在框架设计时使用，目的是增加框架的扩展性。 Laravel、Swoft 框架都用到了反射机制，Swoft 注解的实现原理就是使用反射机制来实现的。 一些 API 文档插件可以通过注释来编译生成 API 文档，其原理同样是使用了 PHP 的反射机制。 示例定义一个类，类里面有常量、私有属性（private 声明的变量）、类的注释和方法的注释等等。 思考下面几个业务中几乎不会用到的问题： 如果我们要获取类里面的所有常量，应该怎么做？ 如果我们要获取方法的注释，或者类的注释，应该怎么做？ 如果我们要获得类的命名空间，又该怎么做？ 此时习惯了做业务的我们肯定一脸懵逼，PHP 中的反射就是为了解决这一类的问题，通过反射提供的 API 可以拿到一个类的所有信息。 通过下面的代码举例，你马上就会弄懂什么是反射了！ 1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * 类的注释 */class User&#123; const BOY = 1; const GIRL = 2; private $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; /** * 我是方法注释 */ public function sayHello() &#123; echo &#x27;hello!&#x27;; &#125;&#125;$class = new ReflectionClass(&#x27;User&#x27;); // 将类名User作为参数，即可建立User类的反射类$properties = $class-&gt;getProperties(); // 获取User类的所有属性，返回ReflectionProperty的数组$property = $class-&gt;getProperty(&#x27;name&#x27;); // 获取User类的属性ReflectionProperty$methods = $class-&gt;getMethods(); // 获取User类的所有方法，返回ReflectionMethod数组$method = $class-&gt;getMethod(&#x27;sayHello&#x27;); // 获取User类的方法的ReflectionMethod$constants = $class-&gt;getConstants(); // 获取所有常量，返回常量定义数组$constant = $class-&gt;getConstant(&#x27;BOY&#x27;); // 获取常量$namespace = $class-&gt;getNamespaceName(); // 获取类的命名空间$comment_class = $class-&gt;getDocComment(); // 获取User类的注释文档，即定义在类之前的注释$comment_method = $class-&gt;getMethod(&#x27;sayHello&#x27;)-&gt;getDocComment(); // 获取User类中方法的注释文档var_dump($comment_method); 上面的代码会输出： 123string(39) &quot;/** * 我是方法注释 */&quot; 反射 APIPHP 官方手册：https://www.php.net/reflection 应用场景反射机制会打破类的封装性，日常业务也不需要获取代码的注释。 因此在日常开发中几乎不会直接用到，但是在框架或者插件的设计上却能发挥很大的作用。 生成 API 文档由于反射可以拿到类的属性、方法，就可以自动生成类的文档。 典型例子：API DOC 通过在方法名称上添加注释： 12345678910/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. */ 然后运行编译程序就可以直接生成一个美观、排版整齐的 API 文档。 一些 IDE 提示工具也利用反射获取类的注释，然后实现提示的功能，注释时需要根据一定的规范。 注释示例： 12345678/** * 测试方法 * @param $a * @param $b */function test($a,$b)&#123; &#125; 批量复刻文件既然可以拿到类的所有成员，那么以类为母版，克隆出子类文件轻而易举，在一些框架或插件中经常用到。 Laravel 框架可以使用 php artisan make:controller UserController 命令创建一个控制器类的模板，还可以加上参数 -r 生成一个 RESTful 风格的 API 控制器类。 还有数据库迁移工具（Laravel 内置了此插件），可以通过命令： 1php vendor/bin/phinx create MyMigration 直接生成一个数据库迁移文件。 直接用命令的方式生成文件，可以少写很多重复的代码。 依赖注入先不需要知道依赖注入是什么，看下面的例子，Laravel 很普通的控制器类的写法： 1234567891011121314151617181920212223&lt;?phpnamespace App\\Http\\Controllers;use App\\Service\\UserService;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public $service; public function __construct(UserService $service) &#123; $this-&gt;service = $service; &#125; public function index() &#123; $users = $this-&gt;service-&gt;getAllUsers(); dd($users); &#125;&#125; 在这个例子中，我们通过构造函数赋予了属性 $service，但问题是——控制器类并没有被实例化！ 一般情况下，我们需要这样把参数传给构造方法： 12$service = new UserService();$user = new UserController($service); 上面的例子并没有 UserController 的实例化操作，而且在 PHP 中参数前面加上类名称，只是起到变量类型限制的作用。 到底是哪里传来实例化的 UserService 呢？ 其实是通过反射机制实现的，通过反射获取到了控制器类的构造方法，然后将这个控制器所需要依赖的类实例化后生成的对象注入到控制器里，所以这个叫做依赖注入。 依赖注入这个概念是从 Java 中传过来的，并非 Laravel 特有。 假设不使用反射机制注入依赖，那么我们的控制器是这样的： 1234567891011121314151617181920212223&lt;?phpnamespace App\\Http\\Controllers;use App\\Service\\UserService;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public $service; public function __construct() &#123; $this-&gt;service = new UserService(); &#125; public function index() &#123; $users = $this-&gt;service-&gt;getAllUsers(); dd($users); &#125;&#125; 嗯……？代码量好像差不多！ 依赖注入是一种设计模式，运行的结果没有差别。 其实在学 Laravel 的时候，我发现了一个很奇怪的地方。 比如存在路由： 12Route::get(&#x27;/users&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;users.index&#x27;);Route::get(&#x27;/users/&#123;id&#125;&#x27;, &#x27;UserController@show&#x27;)-&gt;name(&#x27;users.show&#x27;); 然后控制器的方法： 123456789101112131415161718&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function index(Request $request) &#123; dd($request); &#125; public function show(Request $request, $id) &#123; dd($request, $id); &#125;&#125; index 方法的第一个Illuminate\\Http\\Request 类型的参数，我们在路由中没有任何参数，既然不是通过匹配路由得到的参数，这个参数又是怎么来的呢？ 更不可思议的是第二个路由的 show 方法，我们在声明路由的时候只指明了一个参数 /users/&#123;id&#125;，但我们现在却在方法中写了两个参数，又是怎么精确地匹配到 ID 值的？ 其实同样是用了依赖注入的方法实现的，在学习了反射之后，它们的原理就大概知道了。 首先通过反射得到一个方法的参数，如果这个参数定义了某些类型，就将其实例化后再传递给该方法，在 Laravel 中有专门的解析类在处理这些参数。 通过注释生成路由Swoft 框架把注释当做定义路由的方法，称为“注解”。 1234567891011121314151617181920212223use Swoft\\Http\\Message\\Request;use Swoft\\Http\\Server\\Annotation\\Mapping\\Controller;use Swoft\\Http\\Server\\Annotation\\Mapping\\RequestMapping;/** * Class Home * * @Controller(prefix=&quot;home&quot;) */class Home&#123; /** * 该方法路由地址为 /home/index * * @RequestMapping(route=&quot;/index&quot;, method=&quot;post&quot;) * * @param Request $request */ public function index(Request $request) &#123; // TODO: &#125;&#125; 用 PHP 的反射机制可以做一些奇奇怪怪的事，这也算是 Swoft 独特的风格吧。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"技术","slug":"技术","permalink":"http://huotublog.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"PHP中的魔术方法","slug":"php-magic-methods","date":"2020-03-10T05:42:44.000Z","updated":"2023-02-16T06:50:23.265Z","comments":true,"path":"2020/03/10/php-magic-methods/","link":"","permalink":"http://huotublog.com/2020/03/10/php-magic-methods/","excerpt":"","text":"魔术方法是什么？魔术方法是 PHP 类中特殊的方法，以双下划线 __ 开头，具有特殊用途，比如我们常用的 __construct 构造函数就属于魔术方法，构造函数的作用是类实例化自动调用的方法。 魔术方法的名称都是系统预定义的，无法修改，我们在写 PHP 代码的时候，为了避免与系统预定义函数相同，不建议用双下划线 __ 作为函数的前缀。 魔术方法的作用可以归纳为：对象在 xxx 的时候，应该实现的功能。 比如，上述构造函数可以理解为：对象在“实例化”的时候，应该实现的功能。 除此之外，与构造函数相对的 析构函数 __destruct 可以在对象被回收时自动调用。 如果有 Java 基础，你可以发现类默认有一种 toString 方法，可以把对象转化成字符串。其实 PHP 中也存在同样的魔术方法 __toString，当类的对象被当做字符串调用时会自动执行此方法。 示例代码： 1234567891011&lt;?phpclass Dog&#123; public function __toString() &#123; return &#x27;Just a dog.&#x27;; &#125;&#125;$dog = new Dog();echo $dog; 执行的结果会输出：Just a dog. 为什么在上述代码中，echo 可以输出一个对象呢？ 这是因为我们设置了 __toString 方法，当对象被当做字符串调用时会自动触发 __toString 方法。 换而言之，魔术方法是一类由系统预定义了函数名称，在某些情况下被动触发的函数。 所有的魔术方法都不是用来主动调用的，如下错误示例： 123// 错误示范$obj = new MyClass();$obj-&gt;__construct(); 魔术方法也是类的方法，上述代码逻辑上没有问题而且可以运行且不会报错。不会报错不代表这么写没问题，魔术方法中不应该放入业务逻辑相关的代码。 应用场景魔术方法大都用于框架且与设计模式关联紧密，日常业务除了构造方法之外几乎很少接触到其他魔术方法。Laravel 框架将魔术方法用到了极致，被称为“优雅”的框架。 PHP 中的魔术方法下面介绍 PHP 常见的魔术方法以及应用场景和示例代码。 __construct俗称类的构造方法，当类被实例化为对象时自动调用。 示例： 12345678910&lt;?phpclass Dog&#123; public function __construct() &#123; echo &#x27;Just a dog.&#x27;; &#125;&#125;$dog = new Dog(); 输出：Just a dog. void __construct ([ mixed $args [, $… ]] ) 构造函数的几大特征： 构造函数可以接受参数，能够在创建对象时赋值给对象属性 构造函数可以调用类方法或其他函数 构造函数可以调用其他类的构造函数 构造函数的权限可以被修改 示例代码： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Animal&#123; public function __construct() &#123; echo &#x27;This is animal.&#x27;; &#125;&#125;class Dog extends Animal&#123; protected $name; public function __construct($name) &#123; // 父类构造函数不会自动调用，需要手动进行调用 parent::__construct(); // 对象赋值 $this-&gt;name = $name; // 调用类中的方法 $this-&gt;jump(); &#125; public function jump() &#123; echo $this-&gt;name . &#x27; jump.&#x27;; &#125;&#125;$dog = new Dog(&#x27;小白&#x27;); 最后一条：构造函数的权限可以被修改。 在设计模式中会用到，例如单例模式，为了防止子类被实例化，会将构造函数限制为 private 私有化。 一个比较标准的单例模式示例代码： 1234567891011121314151617181920&lt;?phpclass Singleton &#123; // 私有属性，用于保存实例 private static $instance; // 构造方法私有化，防止外部创建实例 private function __construct()&#123;&#125; // 公有方法，用于获取实例 public static function getInstance()&#123; // 没有的话创建实例并返回，有的话直接返回 if(!(self::$instance instanceof self))&#123; self::$instance = new self(); &#125; return self::$instance; &#125; // 克隆方法私有化，防止复制实例 private function __clone()&#123;&#125;&#125; __destruct俗称析构函数，当对象被回收时自动调用。 1234567891011&lt;?phpclass Dog&#123; public function __destruct() &#123; echo &#x27;The dog is dead.&#x27;; &#125;&#125;$dog = new Dog();unset($dog); 输出：The dog is dead. void __destruct ( void ) 析构函数的特征： 析构函数不能接受参数 析构函数不能抛出异常 由于析构函数在对象被回收时触发，因此如果抛出异常将无法被捕获，抛出异常情况下将报出致命错误。 和构造函数一样，父类的析构函数不会被隐式调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用： parent::__destruct(); __get当调用对象中不存在的属性时，自动触发该方法。 Laravel 框架里几乎随处可见，如 Model 对象调用表的字段： 12$user = User::find(1);echo $user-&gt;name; 示例代码： 123456789101112131415161718&lt;?phpclass Dog&#123; protected $attrs = []; public function __get($name) &#123; if(!isset($this-&gt;attrs[$name])) &#123; return null; &#125; return $this-&gt;attrs[$name]; &#125;&#125;$dog = new Dog();var_dump($dog-&gt;name); 输出：NULL 通常情况下，如果直接调用对象中不存在的属性会产生报错，但是设置了 __get 方法后，如果调用了不存在的属性则会转而调用这个方法处理。通常 __get 要结合 __set 一起使用。 __set当设置对象中不存在的属性时，自动触发该方法。 示例代码： 123456789101112131415161718192021222324&lt;?phpclass Dog&#123; protected $attrs = []; public function __get($name) &#123; if(!isset($this-&gt;attrs[$name])) &#123; return null; &#125; return $this-&gt;attrs[$name]; &#125; public function __set($name, $value) &#123; $this-&gt;attrs[$name] = $value; &#125;&#125;$dog = new Dog();$dog-&gt;name = &#x27;小白&#x27;;var_dump($dog-&gt;name); 输出：string(6) “小白” __toString当对象被当成字符串调用时，自动触发该方法。 12345678910111213141516171819&lt;?phpclass Dog&#123; protected $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function __toString() &#123; return &#x27;Dog name is &#x27; . $this-&gt;name; &#125;&#125;$dog = new Dog(&#x27;小黑&#x27;);echo $dog; 输出：Dog name is 小黑 这个魔术方法在调试的时候非常有用，可以把对象中的参数信息打印出来，记录到日志里。 __call当对象调用了一个类中不存在的方法或者没有权限调用的方法时，自动触发。 示例代码： 1234567891011121314151617181920&lt;?phpclass Dog&#123; protected $name; public function __call($name, $arguments) &#123; var_dump($name,$arguments); &#125; private function aPrivateMethod() &#123; echo &#x27;Im private.&#x27;; &#125;&#125;$dog = new Dog();$dog-&gt;fly(&#x27;666&#x27;);$dog-&gt;aPrivateMethod(); 第一个 fly 方法，不存在 Dog 类中；第二个 aPrivateMethod 是私有方法，不能直接被对象调用，因而触发了 __call 方法。 在 Laravel 中也可以看到许多 __call 应用的场景，还是 Model 类的例子： 12$user = User::whereName(&#x27;xiaobai&#x27;)-&gt;first();dd($user); 这里的 where 后面接大驼峰方式的参数，相当于如下代码： 1$user = User::where(&#x27;name&#x27;, &#x27;xiaobai&#x27;)-&gt;first(); 通过 __call 方法实现简写的目的。 __call 方法接收两个参数，第一个参数是调用方法的名称，第二个参数是调用方法时传入的参数，数组格式。 __callStatic当对象调用了一个不存在的静态方法时，自动触发。 __callStatic 与 __call 的作用基本相似，只不过 __callStatic 针对的是静态方法。 示例代码： 1234567891011121314&lt;?phpclass Dog&#123; protected $name; public static function __callStatic($name, $arguments) &#123; var_dump($name,$arguments); &#125;&#125;$dog = new Dog();$dog::whatsYourProblem(); 这样的设计在 Laravel 框架中也能看到，依然是 Model 的例子： 12$users = User::all();$items = Item::where(&#x27;price&#x27;, &#x27;&gt;&#x27;, 100)-&gt;paginate(20); Laravel 中的 Model 并不是把方法真的当做静态方法，而是利用 __callStatic 让你产生“静态调用”的错觉。 __invoke当尝试以调用方法的形式来调用一个对象时，自动触发该方法。 示例代码： 1234567891011121314&lt;?phpclass Dog&#123; protected $name; public function __invoke($parm1, $parm2) &#123; var_dump($parm1,$parm2); &#125;&#125;$dog = new Dog();$dog(&#x27;小白&#x27;,&#x27;小黑&#x27;); 输出： 12string(6) &quot;小白&quot;string(6) &quot;小黑&quot; __invoke 可以接收自定义的任意参数，与函数的形参规则一致。 我们知道这种方法有点奇怪，谁也不会把一个对象当成方法来用吧？ 让我们来康康 Laravel 框架是怎么利用 __invoke 让代码变得更“优雅”： 12345// 1、指定路由及对应的方法Route::get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;);// 2、不指定对应的方法，自动调用 __invokeRoute::get(&#x27;/user/default&#x27;, &#x27;UserController&#x27;); 1234567891011121314151617181920&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; // 1、/user 调用 index 方法 public function index() &#123; &#125; // 2、/user/default 没有指定方法，自动调用 __invoke public function __invoke() &#123; &#125;&#125; 不指定具体的方法时，Laravel 的路由会把对象当做方法来执行，从而调用 __invoke 方法，简化了路由部分的代码。 __clone当对象被克隆时，自动调用。 PHP 中存在一个关键词 clone 可以复制对象，并且复制出来的对象为独立的个体，与原对象不存在互相影响。 1234567891011121314151617181920212223&lt;?phpclass Dog&#123; public $name; public function __clone() &#123; echo &#x27;new dog birth.&#x27; . PHP_EOL; &#125;&#125;$dog = new Dog();$dog-&gt;name = &#x27;小白&#x27;;// 克隆出来的对象属性与原对象一模一样$cloneDog = clone $dog;var_dump($cloneDog-&gt;name);// 修改克隆对象的属性，不会影响原对象$cloneDog-&gt;name = &#x27;小黑&#x27;;var_dump($dog, $cloneDog); 输出： 1234567891011new dog birth.string(6) &quot;小白&quot;object(Dog)#1 (1) &#123; [&quot;name&quot;]=&gt; string(6) &quot;小白&quot;&#125;object(Dog)#2 (1) &#123; [&quot;name&quot;]=&gt; string(6) &quot;小黑&quot;&#125; 可以发现，克隆出来的对象修改了属性，但是原来对象的属性保持不变，它们是互相独立的个体，也就是说并非引用关系，clone 会开辟一块新的内存来存储复制出来的新对象。 __clone 方法在 clone 出新对象时自动调用。 clone 业务中用得比较少，应用场景能想到的一个是重构代码，我们需要增加一个新的接口来应对新的需求，但同时又不希望破坏旧接口的内部结构，也不希望直接在旧接口的代码上修改，此时可以使用 clone，既可以向下兼容作用，又能在旧接口上添加新功能。 1234567891011121314151617181920212223242526272829&lt;?phpclass NewDogAction&#123; // 新接口代码&#125;class OldDogAction&#123; // 旧版接口代码&#125;class Dog&#123; public $name; // 动作类对象 private $action; public function __construct() &#123; $this-&gt;action = new OldDogAction(); &#125; public function __clone() &#123; $this-&gt;action = new NewDogAction(); &#125;&#125; 当 clone 出来的时候，action 被替换成新的接口代码。 换成比较形象的例子： 鸣人使用多重影分身之术，可以看成是 clone 出很多个分身，但是这些分身并不能 100% 继承本体的能力，本体的能力可以看成上面的 oldDogAction，而分身的能力则是 newDogAction，分身除了 action 属性之外其他的地方与本体并无差异。 更多的魔术方法如果有兴趣了解全部的魔术方法，请访问 PHP：魔术方法","categories":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"技术","slug":"技术","permalink":"http://huotublog.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"进程管理工具 Supervisord","slug":"supervisord","date":"2020-03-09T16:56:30.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/10/supervisord/","link":"","permalink":"http://huotublog.com/2020/03/10/supervisord/","excerpt":"","text":"Supervisord 是什么？Supervisord 是一个进程管理工具，它可以用来执行一些需要在后台持续存在的进程（守护进程）的启动命令。 比如前端的 Nuxt 框架使用 SSR（服务端渲染），需要启动服务端的进程，会使用 pm2 来管理进程的启动。 Supervisord 同样是一种进程管理工具。 下文将演示 Supervisord 管理 Laravel 的队列任务进程。 安装 Supervisord以 Centos 为例，直接使用 yum 安装即可。 12345678# 1、安装 epel-releaseyum install -y epel-release# 2、安装 supervisoryum install -y supervisor# 3、将 supervisor 设置为开机启动systemctl enable supervisord 以上就安装完成了，但是还没有启动 supervisor，先不用着急启动。 Supervisor 配置文件supervisor 的配置文件默认路径为：/etc/supervisor/supervisord.conf，使用 vim 命令编辑，大致可以看到如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152; supervisor config file[unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; (&#x27;AUTO&#x27; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or&quot;/etc/supervisor/supervisord.conf&quot; 28L, 1178C 8,1 Top; supervisor config file[unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; (&#x27;AUTO&#x27; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files = /etc/supervisor/conf.d/*.conf 19,36 All 如果不一样说明版本不同，通过下面的命令可以查看自己安装的版本： 1234# 查看 supervisor 版本supervisord -v# 我下载的版本是 3.3.5 需要注意的地方只有最底下的一行： 12[include]files = /etc/supervisor/conf.d/*.conf 在一些旧的版本这里会有差别，这里的意思是说包含了路径 /etc/supervisor/conf.d 文件夹里面所有后缀为 .conf 的文件，现在不需要改动这个文件。 /etc/supervisor/conf.d/ 文件夹下默认是空的，我们要自己创建新的配置文件。 使用命令：vim /etc/supervisor/conf.d/my.conf，编辑并保存如下内容： 123456789[program:myprogram]process_name=%(program_name)s_%(process_num)02dcommand=/usr/local/bin/php /www/myproject/artisan queue:work --quiet --tries=3 --sleep=3directory=/www/myprojectautostart=trueautorestart=trueuser=www-datanumprocs=1redirect_stderr=true 这里我们启动了一个守护进程，用来执行 Laravel 的队列任务：php artisan queue:work。 配置项说明： 1234567891011121314151617181920212223242526# program:&lt;进程名字&gt;[program:myprogram]# 进程的名字规则，按照下面的配置就可以了process_name=%(program_name)s_%(process_num)02d# 执行的命令 /usr/local/bin/php 是 PHP 二进制文件位置，相当于在 Laravel 下执行 php artisan 一样command=/usr/local/bin/php /www/myproject/artisan queue:work --quiet --tries=3 --sleep=3# 项目所在目录，注意这里一定要填，网上搜的教程很多都忽略了这个字段directory=/www/myproject# 是否在 supervisor 启动的时候自动启动进程autostart=true# 当进程在 running 状态下 exit 时，是否自动重启autorestart=true# 这里一定要填对，如果你是用 Laravel 执行队列任务，那跟我填的一样就可以，如果你执行其他任务，请填写所属的用户组，不然会有权限问题user=www-data# 启动多少个子进程，一般启动 1 个就够了numprocs=1# 设置为 true 时，将进程报错的输出内容写到 supervisor 的输出文件 stdout 里，建议为 true，这样报错了可以查错误信息redirect_stderr=true 注意把上面的 myproject 替换成自己项目的路径 保存好配置文件后，就可以启动 supervisor 了。 1234567# 以下两种方法皆可启动 supervisor# 1、指定配置文件的方式启动 supervisor（推荐）supervisord -c /etc/supervisor/supervisord.conf# 2、服务的方式启动systemctl start supervisord 执行成功的情况下，你会看到如下信息： 1Unlinking stale socket /var/run/supervisor.sock 如果不是这个信息，说明你的配置文件有问题，检查一下 command 和 directory 路径是否填写正确，99% 启动不成功都是这两个字段填写不正确。 12345# 查看 supervisor 进程supervisorctl status# 可以看到下面的输出结果myproject:myprogram RUNNING pid 17, uptime 0:01:40 显示为 RUNNING 则说明正常运行，如果不是这个状态就是配置文件出错了。 如果修改了配置文件，或者创建了新的配置文件，需要重载才能读取到新的配置，执行如下命令： 12345# 重新读取配置文件supervisorctl reread# 更新运行状态supervisorctl update Laravel 队列任务无法写入 Log 日志问题用 supervisor 执行队列任务时发现 Laravel 的日志系统 Log 竟然无法写入日志文件，查了下也没有任何报错信息，问题的原因是所在用户组没有权限。 也就是配置文件中的，user 字段： 1user=www-data 这里一定要填写运行程序的用户组，比如 PHP 的用户组是 www-data，如果你填的是 root，这样就没有权限操作日志文件了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/categories/Linux/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://huotublog.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Supervisord","slug":"Supervisord","permalink":"http://huotublog.com/tags/Supervisord/"}]},{"title":"程序猿提升自我修养的网站推荐","slug":"programmer-recommend-website","date":"2020-03-09T14:27:59.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/09/programmer-recommend-website/","link":"","permalink":"http://huotublog.com/2020/03/09/programmer-recommend-website/","excerpt":"","text":"前言作为程序猿，阅读其他人分享的技术文章除了学习新的技术之外，对于提升自己的思维能力也有很大的帮助。比起自己摸爬滚打尝试出来所耗费的时间，也许别人一句简单的提醒就能使你豁然开朗。 当然，对于一些刚刚入坑的新人来说，也许依赖别人不是一个好的建议，自己摸索可以提升自学能力，作为新入道途的小司机来说，在听取别人的建议后，别忘了加入自己的思考。 对老司机老说，关键的学习能力和处理问题的能力已经在日常业务中得到锻炼，与其不断摸索不如听取建议以最快的速度解决问题。然后再细细回味其中的道理。 下面推荐一些自己平时经常去的论坛或社区，自己在早晨上班的时候都会花 30 分钟左右去阅（mo）读（yu）别人分享的文章，虽然不一定能学到什么，但这种无差别的阅读会成为你知识的积淀，说不定在哪一刻你突然听到同事谈到某个专业术语，你会惊奇的发现——这不是我早上读的那篇文章提到的东西吗！？ 前端人员前端人员不能满足于当个切图仔只会网页布局和 CSS 样式，JS 用的 JQuery 别的就不懂了。其实现在前后端的区分度已经不大了，从 nodeJS 出现以后，前端的格局就改变了，不要把自己的思维局限在“前端只是做网页样式”而已，如果你还保留这种思想，建议早点舍弃。前端学点后端的思维跟后端学点 HTML、CSS 都是很普通的事情。 除了 WEB 前端，安卓前端、IOS 前端同理。 下面的推荐顺序没有排名，纯粹是想到什么就写下来。 掘金社区前端技术有一个比较火的社区，而且里面也有许多大佬，这个社区叫做“掘金”： 传送门：大佬之家 - 掘金社区 掘金社区会有大佬发布技术相关的文章，也会有人告诉你面试的技巧 （还能相亲） 。 但是里面有一个地方我建议不要点开，那就是“沸点”，要是沉迷在沸点就跟刷微博差不多了。 前不久还上线了“掘金小册”，可以将自己的知识进行变现。 掘金是一个前端大佬云集的地方。 V2EX这也是一个神奇的社区，不过内容比较综合，各种东西都会有，偶尔还有大佬出现，也有人喜欢在这里刷帖摸鱼，鱼龙混杂的地方。 V2EX 可以让你发现许多黑科技，提升自己的姿势水平，偶尔会有人把自己异想天开的想法发到这里进行讨论，还有一些企业的黑幕（如暴力裁员等黑料）。 总之，在这里更多的是提升自己的阅历。 传送门：八卦与涨姿势的地方 - V2EX 这个社区的名字究竟是何义至今不明。 思否 &amp; stackOverFlow思否是国内比较大的交流讨论社区，应该是致敬国外的 stackOverFlow，从 UI 看起来两者非常相似。 可以把思否当做国内版的 stackOverFlow。 先来介绍国外的 stackOverFlow。 传送门：解决问题的宝库 - stackOverFlow 根据个人阅读的帖子来看，这里主要是解决问题的帖子居多，很多时候你搜索某个报错信息，跳出来的就是这个网站的帖子，而且你经常可以从帖子里找到解决问题的方法。 所以，这个网站给我的感觉是一个可以帮助你快速查错和解决问题的平台。如果遇到开发上的难题或者不明的报错信息，可以到这个平台上搜索看看（对英文稍有要求），大多数情况下都可以找到解决问题的方法。 接着是我们国内的思否，个人非常喜欢这个社区，因为这边文章详情页的排版、字体、背景颜色十分协调，可以拥有十分良好的阅读体验。 传送门：享受阅读的乐趣 - Segmentfault 这个社区同样也有许多解决问题的帖子，同时还有许多分享技术的帖子，也有人把这个平台当做了自己个人博客记录的地方。 思否上面提供了“视频课程”，价格上来看还算蛮便宜的，比起报培训班流水线式的作业，倒不如拿那些钱支持一些真正有技术的作者。 后端人员其实前面介绍的几个也有后端的文章，后端开发也可以去逛逛。 因为我的本职是 PHP 开发，所以这里推荐的是偏向 PHP 的社区。 Laravel - China现在更名为 LearnKu 了，PHP 较为出名的一个社区，也是 Laravel 框架最大的交流论坛之一。 传送门：刻意学习，与日精进 - LearnKu LearnKu 社区是 Summer 个人开发的 Laravel 技术论坛，如今已经扩展了更多的板块，不再局限于 Laravel 或是 PHP 语言，诸如 Python、Java 等语言也拥有独立的板块了。 LearnKu 里面比较有意思的一个地方是可以翻译国外的文档，然后留下你的大名，虽然本人的英文水平不咋样，但是也曾翻译过几篇文章的段落，成就感十足！ 除此之外，个人感觉要学习 Laravel 框架的话，首选 LearnKu，因为这里有最全、最新的 Laravel 文档（并且阅读体验良好）。 LearnKu 的前身 Laravel - China 曾经是国内最早一批提供 Composer 国内镜像源的地方，个人感觉 Summer 在推动 Laravel 框架在国内的推广做出了十分巨大的贡献，如果没有翻译国外的文档和提供 Composer 国内镜像源，想要入门这个“优雅”的框架可不容易。 LearnKu 是集文档、技术分享、问题提问的综合社区，想要入门 Laravel 的萌新，选择 LearnKu 准没错！ LearnKu 这个名字听起来怪怪的，难道是 learn Kungfu 的缩写！？ Laravel 学院现在改名为学院君（感觉之前的名字更好）。 Laravel 学院也是学习 Laravel 的好去处，只不过这里比较偏向于查阅资料的地方，虽然提供了“问题”的板块，但是讨论的氛围还是偏向于冷清。 传送门：优质的 Laravel 中文学习资料 - 学院君 Laravel 学院也为 Laravel 在国内的推广做出了重要贡献，在搜索 Laravel 相关问题的时候，经常能搜到 Laravel 学院的网站，而且从中找到解决问题的方法。 所以，个人感觉 Laravel 学院偏向于查资料与搜索问题。 本站点的起源本人尚不清楚，但是从文档的分享者来看居然全部都是同一个人——学院君。 只凭借网站本身的力量竟然能够整理出如此众多的文档，令人钦佩。 Laravel 学院除了文档之外，还有项目的实践教程，而且每一步都十分详细甚至还有配图，萌新想学不会都难！ 简书一个略微神奇的网站，咋看之下是文人墨客记录生活情感的地方，然而程序猿却在这开辟出一片属于自己的天地。 传送门：众多教程 - 简书 简书上面记录得比较多的是一些软件的安装教程和使用方法。 目前开通了钻石系统，口号是：“能让创作变现”。 如果有技术大佬喜欢写文章的，可以到这个平台试试，分享技术还能赚点小钱，不亦乐乎！ 简书有不少女性作家，说不定还有意外的邂逅（笑）。 CSDN“你们以后找工作，如果面试官问你经常去看哪些网站，你就说 CSDN。” 这是我大学老师跟我们说的一句话。 但是现在，我去面试的时候是绝对不会提 CSDN 的。 因为它已经完全变质了，也许在我老师的那个年代这是一个大神聚集的社区，但如今在我看来，它只不过是一个盗版成灾的地方，而且百度给的权重还很高，CSDN 的搜索结果总是置于前几名。 这里把 CSDN 列举出来是为了点名批评的。 盗版文章是对原作者版权不尊重；其次，我们搜索问题是为了找到解决方法的，但是 CSDN 盗版的文章经常还存在重复，造成我们搜索结果里面有很多条都是 CSDN 的文章而且还不能解决问题，CSDN 出现在搜索结果里大大增加了我们解决问题的时间成本。 小技巧：使用百度搜索时在关键词后面加上 -csdn 可以排除所有 CSDN 网站的结果 CSDN 做的恶不仅仅只是盗版文章。 还有盗版资源。 相信大家都有这样的体验：在百度搜索一个资源时，跳出的是 CSDN 的下载地址，点进去发现还要积分。而这些资源大都是从其他技术分享者那里拿到的，转手就成为了谋取利益的手段。","categories":[{"name":"资料","slug":"资料","permalink":"http://huotublog.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"WebSite","slug":"WebSite","permalink":"http://huotublog.com/tags/WebSite/"}]},{"title":"composer配置参数详解","slug":"composer-config","date":"2020-03-08T06:48:10.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/08/composer-config/","link":"","permalink":"http://huotublog.com/2020/03/08/composer-config/","excerpt":"","text":"composer.jsonComposer 使用配置文件 composer.json 来指明依赖关系或者包信息。 一个简单的 composer.json 配置文件如下所示： 12345678910111213141516171819&#123; &quot;require&quot;: &#123; &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;, &#125;, &quot;require-dev&quot;: &#123; &quot;robmorgan/phinx&quot;: &quot;^0.10.8&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\Library\\\\&quot;: &quot;application/library&quot;, &#125; &#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125;&#125; 开发配置项如果你不打算将自己的包开源，或者这个配置文件并不是一个库，而是你的项目依赖第三方包的配置文件，那么许多字段都是不需要用到的，以下是几个比较核心的配置字段。 require : 项目依赖关系执行 composer install 或者 composer update 将会下载依赖的包。 示例： 12345&#123; &quot;require&quot;: &#123; &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;, &#125;&#125; 这里我们声明了我们需要下载安装的包 phpmailer/phpmailer 和对应的版本信息 ^6.0。 require 也可以用来指明 PHP 的版本信息。 示例： 123&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.5.0&quot;,&#125; 它要求使用者的 PHP 版本至少是 5.5.0 以上的。 require-dev : 只在开发环境的依赖有时候，我们可能需要一些帮助我们调试的第三方包，但是线上环境并不需要用到这些包，这个时候可以将它们放在 require-dev 中进行声明： 12345&#123; &quot;require-dev&quot;: &#123; &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;, &#125;&#125; 线上环境在执行 composer install 或者 composer update 的时候，需要添加 --no-dev 参数来跳过 require-dev 依赖的包。 如果直接使用 composer install，则 require-dev 依赖的包也会被安装。 autoload : 自动加载通过配置 autoload 可以实现类的自动加载。 示例： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\Library\\\\&quot;: &quot;application/library&quot;, &#125; &#125;&#125; 上面的例子中，我们使用了 psr-4 的自动加载规范来加载 library 中的类。 除了 psr-4 还有几种可选的类型： psr-0 classmap files repositories : 仓库地址声明依赖所在仓库的地址，默认情况下使用 Packagist 官方网站：https://packagist.org。 国内镜像源： 12345// 阿里https://mirrors.aliyun.com/composer// Composer 中文网https://packagist.phpcomposer.com 此外，还可以搭建自己的仓库地址。 示例： 123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot; &#125; &#125; 支持以下类型（type）的包资源库： composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和&#x2F;或 source 信息。这个 packages.json 文件是用一个 PHP 流加载的。你可以使用 options 参数来设定额外的流信息。 vcs: 从 git、svn 和 hg 取得资源。 pear: 从 pear 获取资源。 package: 如果你依赖于一个项目，它不提供任何对 composer 的支持，你就可以使用这种类型。你基本上就只需要内联一个 composer.json 对象。 开源项目配置项如果你的包希望上传到 Packagist 提供给他人使用，需要提供包的基本信息，如作者、包的描述等等。 一个开源的项目，PHPMailer 的配置文件示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;name&quot;: &quot;phpmailer/phpmailer&quot;, &quot;type&quot;: &quot;library&quot;, &quot;description&quot;: &quot;PHPMailer is a full-featured email creation and transfer class for PHP&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Marcus Bointon&quot;, &quot;email&quot;: &quot;phpmailer@synchromedia.co.uk&quot; &#125;, &#123; &quot;name&quot;: &quot;Jim Jagielski&quot;, &quot;email&quot;: &quot;jimjag@gmail.com&quot; &#125;, &#123; &quot;name&quot;: &quot;Andy Prevost&quot;, &quot;email&quot;: &quot;codeworxtech@users.sourceforge.net&quot; &#125;, &#123; &quot;name&quot;: &quot;Brent R. Matzelle&quot; &#125; ], &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.5.0&quot;, &quot;ext-ctype&quot;: &quot;*&quot;, &quot;ext-filter&quot;: &quot;*&quot; &#125;, &quot;require-dev&quot;: &#123; &quot;friendsofphp/php-cs-fixer&quot;: &quot;^2.2&quot;, &quot;phpdocumentor/phpdocumentor&quot;: &quot;2.*&quot;, &quot;phpunit/phpunit&quot;: &quot;^4.8 || ^5.7&quot;, &quot;zendframework/zend-serializer&quot;: &quot;2.7.*&quot;, &quot;doctrine/annotations&quot;: &quot;1.2.*&quot;, &quot;zendframework/zend-eventmanager&quot;: &quot;3.0.*&quot;, &quot;zendframework/zend-i18n&quot;: &quot;2.7.3&quot; &#125;, &quot;suggest&quot;: &#123; &quot;psr/log&quot;: &quot;For optional PSR-3 debug logging&quot;, &quot;league/oauth2-google&quot;: &quot;Needed for Google XOAUTH2 authentication&quot;, &quot;hayageek/oauth2-yahoo&quot;: &quot;Needed for Yahoo XOAUTH2 authentication&quot;, &quot;stevenmaguire/oauth2-microsoft&quot;: &quot;Needed for Microsoft XOAUTH2 authentication&quot;, &quot;ext-mbstring&quot;: &quot;Needed to send email in multibyte encoding charset&quot;, &quot;symfony/polyfill-mbstring&quot;: &quot;To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;PHPMailer\\\\PHPMailer\\\\&quot;: &quot;src/&quot; &#125; &#125;, &quot;autoload-dev&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;PHPMailer\\\\Test\\\\&quot;: &quot;test/&quot; &#125; &#125;, &quot;license&quot;: &quot;LGPL-2.1-only&quot;&#125; name : 包名包的名称，它包括供应商名称和项目名称，使用 &#x2F; 分隔，左边为供应商名称，右边为项目名称。 示例： 12monolog/monologigorw/event-source 对于需要发布的包（库），这是必须填写的。 description : 描述一个包的简短描述，通常用来描述包的功能，最长只有一行。 对于需要发布的包（库），这是必须填写的。 version : 版本version 不是必须的，并且建议忽略。 它应该符合 ‘X.Y.Z’ 或者 ‘vX.Y.Z’ 的形式， -dev、-patch、-alpha、-beta 或 -RC 这些后缀是可选的。在后缀之后也可以再跟上一个数字。 示例： 1.0.0 1.0.2 1.0.0-dev 1.0.0-alpha3 1.0.0-beta2 1.0.0-RC5 type : 安装类型包的安装类型，默认为 library。 composer 原生支持以下4种类型： library: 这是默认类型，它会简单的将文件复制到 vendor 目录。 project: 这表示当前包是一个项目，而不是一个库。例：框架应用程序 Symfony standard edition，内容管理系统 SilverStripe installer 或者完全成熟的分布式应用程序。使用 IDE 创建一个新的工作区时，这可以为其提供项目列表的初始化。 metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。详细请查看 自定义安装类型。仅在你需要一个自定义的安装逻辑时才使用它。建议忽略这个属性，采用默认的 library。 keywords : 关键字非必选，但建议填写。 该包相关的关键词的数组，可用于搜索和过滤，相当于在 composer 中的 SEO，有助于让更多的人搜索到你的包。 homepage : 项目主页该项目网站的 URL 地址，可选。 time : 版本发布时间必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式，可选。 license : 许可协议包的许可协议，它可以是一个字符串或者字符串数组。 最常见的许可协议的推荐写法： Apache-2.0 BSD-2-Clause BSD-3-Clause BSD-4-Clause GPL-2.0 GPL-2.0+ GPL-3.0 GPL-3.0+ LGPL-2.1 LGPL-2.1+ LGPL-3.0 LGPL-3.0+ MIT 可选，但强烈建议提供此内容。 authors : 作者包的作者，这是一个对象数组。 这个对象必须包含以下属性： name: 作者的姓名，通常使用真名。 email: 作者的 email 地址。 homepage: 作者主页的 URL 地址。 role: 该作者在此项目中担任的角色（例：开发人员 或 翻译）。 示例： 12345678910111213141516&#123; &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Nils Adermann&quot;, &quot;email&quot;: &quot;naderman@naderman.de&quot;, &quot;homepage&quot;: &quot;http://www.naderman.de&quot;, &quot;role&quot;: &quot;Developer&quot; &#125;, &#123; &quot;name&quot;: &quot;Jordi Boggiano&quot;, &quot;email&quot;: &quot;j.boggiano@seld.be&quot;, &quot;homepage&quot;: &quot;http://seld.be&quot;, &quot;role&quot;: &quot;Developer&quot; &#125; ]&#125; 可选，但强烈建议提供此内容。 support : 支持信息获取项目支持的向相关信息对象。 这个对象必须包含以下属性： email: 项目支持 email 地址。 issues: 跟踪问题的 URL 地址。 forum: 论坛地址。 wiki: Wiki 地址。 irc: IRC 聊天频道地址，类似于 irc:&#x2F;&#x2F;server&#x2F;channel。 source: 网址浏览或下载源。 示例： 123456&#123; &quot;support&quot;: &#123; &quot;email&quot;: &quot;support@example.org&quot;, &quot;irc&quot;: &quot;irc://irc.freenode.org/composer&quot; &#125;&#125; 可选。 minimum-stability (root-only)这定义了通过稳定性过滤包的默认行为。默认为 stable（稳定）。因此如果你依赖于一个 dev（开发）包，你应该明确的进行定义。 对每个包的所有版本都会进行稳定性检查，而低于 minimum-stability 所设定的最低稳定性的版本，将在解决依赖关系时被忽略。对于个别包的特殊稳定性要求，可以在 require 或 require-dev 中设定。 可用的稳定性标识：dev、alpha、beta、RC、stable。 prefer-stable (root-only)当此选项被激活时，Composer 将优先使用更稳定的包版本。 使用 “prefer-stable”: true 来激活它。","categories":[{"name":"composer","slug":"composer","permalink":"http://huotublog.com/categories/composer/"}],"tags":[{"name":"composer","slug":"composer","permalink":"http://huotublog.com/tags/composer/"}]},{"title":"从零开始开发自己的Composer包","slug":"composer-package","date":"2020-03-08T06:42:18.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/08/composer-package/","link":"","permalink":"http://huotublog.com/2020/03/08/composer-package/","excerpt":"","text":"前言在使用 composer 的时候，我们几乎都是在用其他人分享出来的包，久而久之，难免会产生开发自己包的想法，不仅可以加深对 composer 的理解程度，同时还可以把自己常用的功能封装起来，作为自己的“小金库”储备起来。 使用 composer 开发依赖包是一项非常考验能力的事情，它涉及到一个微型系统的架构，阅读设计模式有助于帮助我们开发一个优秀的 composer 依赖包。 开发自己的第一个 Composer 包composer.json 是 composer 的基础，文件夹目录下存在 composer.json 文件，那么这个文件夹就是一个资源包。 我们可以手动创建 composer.json 文件，不过，我们推荐使用 composer init 命令。 composer init 命令帮助我们自动生成 composer.json，文件可以修改，不必担心按错了什么会产生不好的影响。 创建配置文件composer.json 配置项的字段较多，后续步骤如果对配置文件的字段抱有疑问，可以返回此处查看：composer.json 详解。 现在，不需要了解这些。 创建包目录我们的操作是在命令行界面操作的，如果是 Windows 系统，则需要进入 CMD 界面，进入到你的工作磁盘目录下，使用快捷键 Shift + 鼠标右键，在菜单栏中选择进入命令行（DOS 界面）。 首先，我们需要创建一个包的目录 packagist： 12345678# Mac OS 系统mkdir packagist# Windows 系统(可以直接右键创建）md packagist# 创建完成后进入文件夹cd packagist 输入包的名字在 packagist 目录下，执行 composer init，composer 会提示我们设置配置参数信息，如下图： 1Package name (&lt;vendor&gt;/&lt;name&gt;) [firerabbit/packagist]: 提示让你输入包的名字，格式为 &lt;vendor&gt;/&lt;name&gt;，vendor 为服务商名字，个人开发可以使用自己在 GitHub 中使用的昵称，name 为包的名字，&lt;vendor&gt;/&lt;name&gt; 不能存在同名，这里设置的名字即后面使用 composer require 的名字。 中括号内的 [firerabbit/packagist] 是默认值，直接按回车的话就会使用这个名字。 输入包的描述信息包名输入完成后，接下来需要设置 Description （描述）字段，这个字段是包的功能性描述，作为练习包就随便输入啦： 输入作者信息接下来设置 Author (作者信息)，格式为 name example@email.com，输入 n 可以跳过： minimum-stability 最小稳定版本通过设置 minimum-stability 的值，来告诉 Composer 当前开发的项目的依赖要求的包的全局稳定性级别，它的值包括：dev、alpha、beta、RC、stable，stable 是默认值。 稳定性介绍：理解 Composer 的稳定性（Stability）标识 我们直接按回车默认值即可。 Package Type 包类型接下来设置包的类型： composer 原生支持以下4种类型： library: 默认类型，它会简单的将文件复制到 vendor 目录。 project: 一个项目，而不是一个库。 metapackage: 空的包，包含依赖并且需要触发依赖的安装。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。 这里我们直接按回车，采用默认的 library。 License 许可协议接下来输入包的许可协议： 包的许可协议，它可以是一个字符串或者字符串数组。 最常见的许可协议的推荐写法： Apache-2.0 BSD-2-Clause BSD-3-Clause BSD-4-Clause GPL-2.0 GPL-2.0+ GPL-3.0 GPL-3.0+ LGPL-2.1 LGPL-2.1+ LGPL-3.0 LGPL-3.0+ MIT 这里我们输入 MIT （开源许可协议）。 定义依赖项接下来设置依赖项： 123Define your dependencies.Would you like to define your dependencies (require) interactively [yes]? 我们的练习项目不需要设置此项，输入 no。 dev 依赖项设置 dev 环境依赖项： 1Would you like to define your dev dependencies (require-dev) interactively [yes]? 同上，输入 no。 最后一步：确认信息最后一步，确认包的信息： 输入 yes，回车，然后查看当前目录即可看到 composer.json 文件。 composer init 命令帮助你自动生成文件，实际上你可以直接在包的目录下创建 composer.json，并且输入以下内容： 123456789101112&#123; &quot;name&quot;: &quot;huotu/test&quot;, &quot;description&quot;: &quot;我的第一个包。&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;火兔兔子&quot;, &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot; &#125; ], &quot;require&quot;: &#123;&#125;&#125; 本质上两种方式都是一样的。 依赖包的基本结构一个 composer 依赖包的基本结构，以我们上面的 packagist 为例： packagist src 类文件 … tests 单元测试文件 … README.md composer.json LICENSE src 文件夹src 是包所在的路径，一般我们都会将其命名为 src（业界共识），不建议改成其他的名字。 开发包的工作就是在这个目录下进行的，你可以在这个目录下创建更多的文件夹来划分不同功能的类。 tests 文件夹tests 文件夹用来存放单元测试的，如果你不写的话，这个文件夹可以不要。 README.md 文件README.md 是包描述的 Markdown 语法的介绍文档，在 GitHub 中将会自动解析这个文件并且展示出来，每一个包都应该要包含 README.md 文件，用来介绍这个包的基本信息和操作方法。 创建 README.md 文件的方法： 123456# Mac OSvim README.md# Windows 系统创建 README.txt，保存后改成 .md如需编辑，右键以文本文档打开即可 composer.json 文件包的配置信息。 LICENSE许可协议文本，文本格式。 练习项目中，我们只需要 src 和 README.md 即可。 推荐使用 PHPstorm 作为编辑工具，最后我们的包目录结构如图所示： 配置自动加载规则为了防止命名空间冲突，开发的包需要配置自动加载，修改 composer.json 添加 autoload 字段： 12345&quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;src/&quot; &#125; &#125; 我们采用 psr-4 的规范来自动加载包目录下 src 文件夹内的类文件，这里的 &quot;Huotu\\\\Test\\\\&quot; 是我们使用的命名空间，\\\\ 不能写成 \\，一般而言，命名空间以包的名字来命名。 完整的 composer.json 配置如下： 123456789101112131415161718&#123; &quot;name&quot;: &quot;huotu/test&quot;, &quot;description&quot;: &quot;我的第一个包。&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;火兔兔子&quot;, &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot; &#125; ], &quot;require&quot;: &#123;&#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;src/&quot; &#125; &#125;&#125; 创建包的类文件在 src 目录下创建 Robot.php 文件，我们希望写一个可以自动打招呼的机器人（类）： 12345678910&lt;?phpnamespace Huotu\\Test;class Robot&#123; public function sayHello($name) &#123; echo &#x27;hello,&#x27; . $name . PHP_EOL; &#125;&#125; 这样我们就完成了一个依赖包的开发，使用者只需要引入这个包就可以调用 Robot 的 sayHello 方法。 测试包的功能我们现在已经写好了一个包，但是开发过程以及准备发布的时候，我们都需要对功能进行调试，你可以在目录下创建一个 test.php，然后运行 php test.php 来测试，不过这样总是不太方便的，尤其是某些有其他依赖的操作（如需要连接数据库、Redis）等等。最好的方法是将包文件放在一个真实的项目里进行测试，下面模拟创造一个 project 来作为我们实际的项目。 在 packagist 同级目录下，创建一个文件夹 project。 由于我们本地开发的包并未上传的 Packagist，无法通过 composer require 进行安装，因此我们必须手动配置加载目录，进入 project 文件夹，创建 composer.json： project composer.json 编辑 composer.json，输入如下内容： 1234567&#123; &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Huotu\\\\Test\\\\&quot;: &quot;../packagist/src/&quot; &#125; &#125;&#125; 创建完成后，我们需要执行 composer dump-autoload 来生成自动加载文件。 如果对依赖包添加了新的类或者删除了类，涉及到类文件数量、名称改变的，都需要重新执行 composer dump-autoload，否则无法读取到最新的类文件 执行完成后，在当前目录下生成了 vendor 文件夹，这个文件夹里即包含了我们依赖包的自动加载信息。 接着一个文件用来测试结果 test.php： project composer.json test.php vendor composer … autoload.php 输入如下内容： 12345678&lt;?phprequire &#x27;./vendor/autoload.php&#x27;;use Huotu\\Test\\Robot;$robot = new Robot();$robot-&gt;sayHello(&#x27;IDCE.COM&#x27;); 终端中输入 php test.php 执行结果： 可以看到我们成功调用自己开发的包了！ 必须将 autoload 引入才能实现自动加载，如果提示找不到类可能就是没有正确引入的关系或者 composer.json 配置的 psr-4 路径不正确。 上传到 GitHub开发完成后，我们需要把包文件上传到 GitHub，如果没有账号则注册一个。 进入个人主页，在左侧的 Repositories（仓库）选择 New 创建一个新的仓库： 仓库信息，权限要选择 public（公开的），完成后点击 Create repository： 创建好的项目： GitHub 十分友好的提示了上传文件的步骤，我们只需要执行以下几个步骤即可： 12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin https://github.com/huoshaotuzi/test.gitgit push -u origin master 返回 packagist 目录下，我们按照 GitHub 上提示的内容，执行 git init，并添加文件： 注！由于 ide 产生的文件是必须添加 .gitigonre 排除的 然后添加上传的仓库信息，并执行 push 推送到 GitHub 的仓库： 返回 GitHub 仓库，刷新页面即可看到上传文件的信息： 上传到 Packagist如果希望自己的包被其他人安装，就需要将包上传到 Packagist 官网上。 Packagist 官网：https://packagist.org/ 如果没有账号可以注册一个，或者直接使用 GitHub 登录（推荐）。 登录后，选择右上角的 Submit（提交）： 在提交页面会提示你输入 GitHub 上仓库的地址： 输入刚才创建的仓库地址，点击 Check： 这边会提示一些同名的包，并且出现了 Submit 按钮，我们直接点击 Submit，此时会进入包页面，update 会进入转圈圈状态，表示正在同步包信息，稍等一会刷新页面即可看到包信息。 到目前为止，已经将包上传到 Packagist 官网了，但是我们还没有设置版本信息，需要返回到包目录下，给这个包打上标签。 输入以下命令： 12git tag -a v1.0 -m &quot;初始版本&quot;git push origin v1.0 然后返回 Packagist 官网，点击 update 同步包信息，然后刷新页面就能看到刚刚提交的版本信息了。 现在，用户可以使用 composer require 命令下载你的包了。 1composer require huotu/test:1.0 自动同步版本更新每次更新包都需要手动点击 update 十分不便，实际上 GitHub 提供了钩子可以用来推送更新信息到 Packagist，默认情况下已经帮助我们打开了自动更新功能。 回到 GitHub 的仓库地址，选择 Setting，左侧菜单 Webhook，可以看到配置的推送信息： 每当我们推送新的版本标签到 GitHub 时，Packagist 就会接收到一个 GitHub 的 Hook（钩子）发出的 POST 请求，这样 Packagist 上的包就会与 GitHub 上的同步了。 如果你不需要自动更新功能，可以点击右侧的 Delete 将其删除，删除后每次更新包都要前往 Packagist 点击 Update 手动进行更新。 开启自动更新情况下，每次 push 标签后都会自动同步到 Packagist，刷新页面即可看到最新提交的版本： 依赖包编写小建议开发依赖包需要要丰富的开发经验，可以多参考其他开源包，尤其是具有团队进行维护的，观察他们是如何区分目录和封装类的，可以学到很多知识。 推荐阅读：PHP 设计模式 编写依赖包能得到锻炼和成长的机会，开源自己的包也是一件十分具有成就感的事。 分享，是最好的学习方式 —— IDCE.COM","categories":[{"name":"composer","slug":"composer","permalink":"http://huotublog.com/categories/composer/"}],"tags":[{"name":"composer","slug":"composer","permalink":"http://huotublog.com/tags/composer/"}]},{"title":"SSH免密登录原理及方法","slug":"ssh-no-password-method","date":"2020-03-07T14:50:10.000Z","updated":"2023-02-16T06:50:23.266Z","comments":true,"path":"2020/03/07/ssh-no-password-method/","link":"","permalink":"http://huotublog.com/2020/03/07/ssh-no-password-method/","excerpt":"","text":"SSH 命令使用 ssh 用户名@服务器IP 可以连接到服务器，这样做的缺点是每次都要输入密码，一方面是不安全，另一方面是麻烦。 SSH 免密登录服务器在本地主机上使用 ssh-keygen -t rsa 生成密匙对，这里的 -t rsa 指的是用 rsa 加密方式生成密匙： 第一步，输入密匙存放目录，使用默认路径直接按回车即可： 12Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): 第二步，输入密码，建议直接回车使用空密码： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 如果输入了密码则需要再输入一次确认密码。这里的密码不是指远程登录主机的密码，而是使用密匙时的密码，既然我们是希望免密登录了，自然不希望再输入任何密码，因此此处填空即可。 1234567891011+---[RSA 2048]----+| .. . || o. . . o || o...+* + || .o+*+O || . =+So+o || . . . @.*B. || o . . Eoo. || o * .. || ..o o. |+----[SHA256]-----+ 上面会生成 randomart image 图案，这个图案是根据密匙生成的，因此每个人看到的都不同。 趣味小科普：为什么要生成这种图案呢？这是由于密匙对是一个很长的随机字符串，比起加密的字符串人们更容易接受图片，可以说是很贴心了 生成的密匙包含一对，公钥和私匙（其实叫做私钥，但感觉这样比较有意思所以就这么写）： 12Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub. 我们根据路径可以找到文件所在位置： 123[root@VM_0_8_centos ~]# cd /root/.ssh[root@VM_0_8_centos .ssh]# lsauthorized_keys id_rsa id_rsa.pub 这两个密匙文件分别是： id_rsa 生成的私钥文件 id_rsa.pub 生成的公钥文件 另外一个 authorized_keys 是保存远程免密登录公钥的文件，主要通过这个文件记录多台机器的公钥，我们要做的就是把本机的公钥发送到服务器主机的这个文件里。 接着，把公钥发到需要登录的服务器主机上： 1ssh-copy-id -i /root/.ssh/id_rsa.pub 服务器IP地址:/root/.ssh/authorized_keys 接着会要求你输入一次密码，输入完成后就可以实现免密登录了。 在本机上执行 ssh 用户名@服务器IP，不再需要输入密码验证。 SSH 添加别名网络上的教程一般到上一步就结束了，在这里传授一个小技巧可以事半功倍。 虽然我们现在跳过了输入密码这个步骤，但是每次都要输入 IP 也是很蛋疼的一件事，我们甚至想要不输入 IP 就能登录到远程服务器 ？ 这也能做到！ 在本地进入 .ssh 目录： 12# 进入 .ssh 目录FireRabbitdeMacBook-Pro:.ssh firerabbit$ cd ~/.ssh 使用 vim config 编辑文件并且输入以下内容： 1234Host devHostName 127.0.0.1User rootPort 22 这里的 dev 是我们给远程主机起的别名，127.0.0.1 是远程主机的地址，请替换成你的服务器 IP，User 即登录的用户名，Port 为服务器访问端口，如果修改了端口在这里也要修改。 现在我们的目录应该是这样的： 12FireRabbitdeMacBook-Pro:.ssh firerabbit$ lsconfig id_rsa id_rsa.pub known_hosts known_hosts 是连接过的主机记录，可以随意删除。 接着在命令行输入：ssh dev 即可连接到服务器！ 阅读至此，恭喜你！Linux Exp + 1 报错问题如果出现如下报错： 1/usr/bin/ssh-copy-id: ERROR: ssh: Could not resolve hostname xxx:/root/.ssh/authorized_keys: nodename nor servname provided, or not known 网上查了下，大都是说 hosts 文件的问题。 可以尝试修改 /etc/hosts 看看是否有如下行，如果没有则添加： 1127.0.0.1 localhost 经过本人尝试结果无效，可用别的方法。 那就是——手动上传！！！ 编辑本地主机的密匙文件： 1vim ~/.ssh/id_rsa.pub 把密匙内容全部拷贝下来。 接着先用 ssh root@远程主机IP 用密码登录进去，然后在远程主机中 vim /root/.ssh/authorized_keys。 把复制的密钥直接粘贴下来就可以啦！ 免密登录原理网上的教程一般都是直接贴出代码和操作步骤，但这样我们根本不清楚它的原理是什么。 我们希望能像侦探一样追根究底，查清楚它的原理是什么。 真正理解后的知识才能永远刻入你的脑海里 上面的步骤，我们在本机生成一个密匙对，一共包含两个文件，一个是公钥，一个是私匙，公钥是发送到服务器主机的，私匙是留在本地的。 这样包含一对公钥私匙的加密叫做“非对称加密”。 对称加密在了解非对称加密之前需要先了解对称加密，所有新事物的出现必然伴随着某种需求。 小红和小明私底下正在交往，但又不希望被别人发现，于是他们约定了一种加密算法，每个字母向后移动一位，如 a 往后移一位是 b，b 往后移一位是 c……z往后移是 a。 那么，ni hao 就变成了 oj ibp。 由于双方约定好了同样的加密算法，所以小红发给小明消息时，就可以按照约定好的算法进行解密。 于是他们大胆的在班级群里用加密后的消息进行聊天，其他同学一脸茫然的看着不明觉厉的消息。 但是此时，名侦探小刚破解了他们约定好的加密算法，并且截获了（截获很简单，毕竟他们公然秀恩爱）他们互通的消息，此时小红和小明的聊天记录就被小刚一清二楚的知道了！ 非对称加密聊天记录被小刚公开后，小明和小红十分尴尬，于是机智的小明想出了一种方法，把前面约定的加密算法做了一些小的改进，小明告诉小红，我发给你一个密匙串，你用这个给消息进行加密（某种加密算法），你发给我消息后，我再用我这边的密匙进行解密，我发给你的密匙和我本地的密匙是不同的，只有我本地的密匙才能解密你加密过的内容。 问题又来了……现在只有小明破解小红的消息，小明用公钥加密消息发给小红，小红是解密不了的；如果需要双向沟通的话，自然是用同样的方法，小红也给小明一个密匙，小红本地存有另外一个用来解密的密匙。但是 Linux 免密登录是本机免密登录到服务器，属于单向的沟通，如果你希望服务器也能免密登录本机（一般不会有这种需求），就在服务器用同样的方法生成密匙，把密匙发生到本机就可以了。 接下来的日子，小刚也无法破解他们的聊天记录，恼羞成怒的小刚带着三名小弟放学后去堵小红，逼迫小红把小明给她的加密密匙交出来，小红无奈之下将密匙交出，然而，即使拿到密匙，小刚依然无法破解小红的密码，因为，还需要小明手里的密匙才能解密小红的消息。 非对称加密的存在就是为了避免加密算法被第三者知道，导致密码泄露。上面的故事中小明交给小红的加密串叫做公钥，公钥可以让任何第三者知道，公钥加密过的密码只有小明手里的加密串——私匙才能解密，对于加密和解密使用不同的加密策略，叫做非对称加密。 使用公钥实现免密登录我们通过 ssh-keygen -t rsa 生成了公钥和私匙对，接着我们把公钥发送到服务器上，当连接的时候，服务端会发送一个用公钥加密的字符串过来，本地再使用私匙进行解密，实现了登录验证，从而不需要输入密码就能进行登录。 用盗来的一张图解释： RSA 非对称加密算法参考：百度百科 - RSA 只做兴趣了解，不需要掌握原理，因为我们的研究方向不是这个。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/tags/Linux/"}]},{"title":"Centos安装Gitlab","slug":"centos-install-gitlab","date":"2020-03-07T14:21:32.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/07/centos-install-gitlab/","link":"","permalink":"http://huotublog.com/2020/03/07/centos-install-gitlab/","excerpt":"","text":"1、安准基础依赖安装 Gitlab 所需依赖： 1sudo yum install -y curl policycoreutils-python openssh-server 启动 ssh 服务并设置开机启动： 12sudo systemctl start sshdsudo systemctl enable sshd 2、安装邮件服务Postfix 是一个邮件服务器，GitLab 发送邮件需要用到。 安装 postfix： 1sudo yum install -y postfix 启动 postfix 并设置为开机启动： 12sudo systemctl start postfixsudo systemctl enable postfix 3、开放 ssh 以及 http 服务（80 端口）查看防火墙是否启动： 1systemctl status firewalld 以下为我的服务器上的防火墙状态： 12345[root@ecs-86c0 ~]# systemctl status firewalld● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) 如果看到 Active: inactive (dead)，表示防火墙没有启动，执行下面的命令启动防火墙并且设置为开机启动： 12systemctl start firewalldsystemctl enable firewalld 此时，在查看防火墙状态： 12345678[root@ecs-86c0 ~]# systemctl status firewalld● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: active (running) since 一 2019-09-02 17:56:23 CST; 2s ago Docs: man:firewalld(1) Main PID: 26477 (firewalld) CGroup: /system.slice/firewalld.service └─26477 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid Active: active (running) 表示防火墙正常运行。 开放 ssh、http 服务： 12sudo firewall-cmd --add-service=ssh --permanentsudo firewall-cmd --add-service=http --permanent 只有防火墙开启状态才能执行上述命令，否则会报 FirewallD is not running 错误 重新加载防火墙： 1sudo firewall-cmd --reload 4、安装 Gitlab我们使用 Gitlab 的社区版：gitlab-ce，如果需要使用商业版，则安装：gitlab-ee。 4.1、添加 Gitlab 社区版资源包默认情况下 yum 源没有 gitlab-ce 软件包，需要手动下载： 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 4.2、使用 yum 安装 gitlab-ce在这里强烈推荐阅读：Centos 系统更新 yum 源为国内镜像源 1yum install -y gitlab-ce 软件包的安装大小足足有 1.4 G，更换镜像后只需要数十秒就下载完了。 安装成功后可以看到一个类似“狐狸头像”的图案： 4.3、配置 Gitlab 访问地址Gitlab 安装完成后，配置文件所在路径为 /etc/gitlab/gitlab.rb，编辑配置文件： 1vim /etc/gitlab/gitlab.rb 将 external_url 字段修改为你的域名信息，如果没有域名可以改成 IP:端口 的方式。 12345678910111213## GitLab configuration settings##! This file is generated during initial installation and **is not** modified##! during upgrades.##! Check out the latest version of this file to know about the different##! settings that can be configured by this file, which may be found at:##! https://gitlab.com/gitlab-org/omnibus-gitlab/raw/master/files/gitlab-config-template/gitlab.rb.template## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlabexternal_url &#x27;http://gitlab.example.com&#x27; 4.4、启动 Gitlab重新载入配置并启动 Gitlab（如果修改了配置文件需要再运行此命令）。 1sudo gitlab-ctl reconfigure 翻车现场： 报错原文： 123456789101112Running handlers:There was an error running gitlab-ctl reconfigure:Multiple failures occurred:* Chef::Exceptions::MultipleFailures occurred in chef run: Multiple failures occurred:* Errno::ENOMEM occurred in delayed notification: ruby_block[restart_log_service] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 69) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: ruby_block[reload_log_service] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 77) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 408) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: service[gitaly] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: runit_service[gitaly] (gitaly::enable line 75) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)* Errno::ENOMEM occurred in delayed notification: service[gitlab-workhorse] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2) %&gt;_&lt;% 原来是我的测试机内存（1G）不够！ 穷人没有资格安装 Gitlab （╯‵□′）╯︵┴─┴ 4.5、访问 Gitlab如果不出意外，输入 external_url 配置的地址，即可看到 Gitlab 页面。 第一次登陆 Gitlab 时需要设置 root 密码，然后就可以愉快的创建项目了。","categories":[{"name":"docker","slug":"docker","permalink":"http://huotublog.com/categories/docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://huotublog.com/tags/centos/"},{"name":"gitlab","slug":"gitlab","permalink":"http://huotublog.com/tags/gitlab/"}]},{"title":"再战！Docker 安装 Gitlab","slug":"docker-install-gitlab","date":"2020-03-07T14:21:32.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/07/docker-install-gitlab/","link":"","permalink":"http://huotublog.com/2020/03/07/docker-install-gitlab/","excerpt":"","text":"前言上一次因为服务器配置太低翻车了，现在重新挑战一次。 Gitlab 硬件要求Gitlab 十分吃机器的配置，Gitlab 官方推荐 2核 4G，最低建议 1 核 2G，再低的话可能会像我上次那样直接翻车或者运行起来十分卡顿。 由于是个人学习，就不打算将其部署到线上的服务器上了，这一次我采用在本地安装的方式搭建 Gitlab。 下载镜像拉取 Gitlab 官方最新版本镜像： 1docker pull gitlab/gitlab-ce:latest 由于镜像较大，建议换成国内镜像提高下载速度。 运行镜像下载完成后，再执行 run 启动容器： 123456789sudo docker run --detach \\ --hostname localhost \\ --publish 4443:443 --publish 999:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume ~/docker/gitlab/config:/etc/gitlab \\ --volume ~/docker/gitlab/logs:/var/log/gitlab \\ --volume ~/docker/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest run 参数说明： 123456--detach：让容器在后台运行--hostname：主机地址，本地使用 localhost，可以换成域名--publish：宿主机的端口映射到容器的端口，由于我本地已经有其他容器使用了 443 和 80 端口，因此我改成了 4443 和 999 端口。--name：自定义容器的名称--restart：容器重启策略，在退出时容器应该如何重启或不应该重启，always 始终重启 --volume：宿主机映射到容器的卷，用来做容器数据的持久化，这里我将卷的目录设置为 ~/docker/gitlab run 命令执行后，可以执行如下命令： 12cd ~/docker/gitlabls 可以看到自动生成了以下几个文件： 1config data logs 这些文件就是宿主机与容器之间通过卷映射的文件（容器数据持久化）。 执行 docker ps 可以看到容器运行状态： Gitlab 初始化容器启动后，需要稍等几分钟，然后再访问 127.0.0.1:999，如果直接访问的话可能 Gitlab 还未完全启动，这个时候是访问不了的。 第一次访问时，需要设置管理员（root 用户）密码： 初始化密码设置完成后，返回到登录页面，使用账户 root 以及刚才设置的密码进行登录： 登录成功后，就可以操作界面啦！ 添加 SSH key在开始使用之前，需要添加 ssh key 才能拉取或者推送到仓库，执行命令： 12cd ~/.sshls 查看是否生成过 ssh key，如果当前目录下没有文件，则需要创建新的 ssh key，执行以下命令生成 ssh key，-C 参数后面是你的邮箱地址： 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 完成后在当前目录下会生成 ssh key，包含两个文件，这是一对密匙： 1id_rsa id_rsa.pub 其中，id_rsa.pub 是公钥，我们需要的就是这个文件： 1cat id_rsa.pub 将输出的密匙字符串复制下来（注意是把所有的内容都复制下来，包括邮箱）。 接着返回 Gitlab，点击左上角个人头像，选择 Settings： 选择左侧菜单 SSH Keys，将你的 ssh key 黏贴到方框内，然后点击 Add key 即可： 接下来就可以愉快的开始使用 Gitlab 啦！ 为什么安装后的 Gitlab 可以直接访问？这是由于 Gitlab 内置了 nginx 服务器，所以才能在安装完成后通过地址进行访问。 完结撒花～ ҉٩(´︶&#96;)۶҉ ??","categories":[{"name":"docker","slug":"docker","permalink":"http://huotublog.com/categories/docker/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://huotublog.com/tags/gitlab/"},{"name":"docker","slug":"docker","permalink":"http://huotublog.com/tags/docker/"}]},{"title":"Gitlab + Satis 搭建私有 Composer 仓库","slug":"install-gitlab-satis-composer","date":"2020-03-07T14:21:18.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2020/03/07/install-gitlab-satis-composer/","link":"","permalink":"http://huotublog.com/2020/03/07/install-gitlab-satis-composer/","excerpt":"","text":"Satis 介绍Satis 是开源的静态 Composer 仓库生成器，可用于托管公司私有包的元数据。 环境要求：PHP &gt;&#x3D; 7.2 安装 GitlabCentos 搭建 Gitlab：Centos 系统安装 GitlabDocker 搭建 Gitlab：再战！Docker 安装 Gitlab 上传 Composer 包Composer 包开发教程：从零开始开发自己的 Composer 包 在 Gitlab 新建一个仓库，把自己开发完成的包上传到这个仓库，上传完成后的仓库如下： 包的配置文件 composer.json 如下： 包的名字叫做：huotu/test，我们后面需要用到。 这个仓库的地址就是我们私有包的地址，接下来拿这个包作为演示。 安装 Satis可以使用两种方式安装 Satis。 1、Composer 安装可以直接使用 composer 命令安装 Satis： 1composer create-project composer/satis --stability=dev --keep-vcs 2、从 GitHub 下载使用 git clone 将 Satis 下载到本地： 1git clone https://github.com/composer/satis.git 添加 Satis 配置文件在下载好的 satis 目录下，创建 satis.json 配置文件，一个示例的配置文件如下： 123456789101112131415&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http://packages.example.org&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https://github.com/mycompany/privaterepo&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://svn.example.org/private/repo&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https://github.com/mycompany/privaterepo2&quot; &#125; ], &quot;require&quot;: &#123; &quot;company/package&quot;: &quot;*&quot;, &quot;company/package2&quot;: &quot;*&quot;, &quot;company/package3&quot;: &quot;2.0.0&quot; &#125;, &quot;require-all&quot;: false&#125; name：仓库的名字，将会展示在页面上 homepage：satis 访问地址 repositories：\b包所在的地址 require：获取指定的包 require-all：如果为 true 表示获取所有包 根据自己的情况进行配置，这里我们拿刚刚上传到 Gitlab 的包演示，配置如下文件： 12345678&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http://satis.com&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test&quot; &#125; ], &quot;require-all&quot;: false&#125; http://satis.com 为 satis 访问页面地址，http://gitlab.com/huotu/test 为私有包所在地址。 Composer 配置由于我们使用 http，在这里需要修改设置： 1composer config -g secure-http false 生成 Satis 索引页面在 satis 目录下执行命令 composer install 安装所需依赖，然后再执行如下命令生成 satis 页面： 1234567php bin/satis build &lt;configuration file&gt; &lt;build dir&gt;# 示例 ：php bin/satis build satis.json public/# 跳过 Gitlab 密码验证php bin/satis build -n satis.json public/ 执行完命令后，在当前目录生成了 public 文件夹，接着配置 nginx，将域名指向这个目录： 1234567891011121314151617server &#123; listen 80; server_name satis.com; root /www/satis/public; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; include fastcgi_params; try_files $uri =404; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; &#125;&#125; 重启 nginx，不出意外就可以通过域名访问 satis 了！ 使用域名记得添加解析到服务器 访问 http://satis.com（这个是你配置的域名）： Composer 使用私有仓库我们现在完成了 Satis + Gitlab 的全部安装，接下来我们的项目就可以使用自己搭建的私有 Composer 源了。 新建一个 test 文件夹，在 test 目录下创建 compsoer.json，编辑 composer.json 添加如下内容： 123456789&#123; &quot;require&quot;: &#123; &quot;huotu/test&quot;: &quot;*&quot; &#125;, &quot;repositories&quot;: [&#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://satis.com&quot; &#125;]&#125; 保存，然后在当前目录下执行 composer install： 成功把自己私有仓库的包下载下来了。 如果有多个包，则添加多个仓库地址： 12345678910&#123; &quot;name&quot;: &quot;My Repository&quot;, &quot;homepage&quot;: &quot;http://satis.com&quot;, &quot;repositories&quot;: [ &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test2&quot; &#125;, &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test3&quot; &#125;, ], &quot;require-all&quot;: false&#125; 缓存包资源可以把所需要的包都缓存在本地 Satis 上，这样可以避免每次都需要从仓库中 clone，在 satis.json 添加： 12345678&#123; &quot;archive&quot;: &#123; &quot;directory&quot;: &quot;dist&quot;, &quot;format&quot;: &quot;tar&quot;, &quot;prefix-url&quot;: &quot;http://satis.com&quot;, &quot;skip-dev&quot;: true &#125;&#125; archive 参数： directory: 表示生成的压缩包存放的目录，会在我们 build 时的目录中 format: 压缩包格式，zip（默认） tar prefix-url: 下载链接的前缀的 Url, 默认从 homepage 中取 skip-dev: 默认为 false，是否跳过开发分支 absolute-directory: 可选，包文件存储到绝对路径的目录 whitelist: 可选，如果设置为包名称列表，则只会转储这些包的 dist 文件 blacklist: 可选，如果设置为包名称列表，则不会转储这些包的 dist 文件 checksum: 可选，默认情况下为 true，禁用时（false）不会为 dist 文件提供 sha1 校验 启用后，所有下载（包括来自 GitHub 和 BitBucket 的下载） 将替换为本地版本。 添加 archive 后，配置的包信息就会下载到本地 Satis 目录下 dist 文件夹中，从 Satis 下载依赖时将从这个文件夹获取资源。 定期更新 Satis需要定期执行 php bin/satis build satis.json public/ 命令来生成最新的 Composer 包信息，可以将此命令作为定期任务执行，或是增加一个钩子 push 来更新 Satis。","categories":[{"name":"composer","slug":"composer","permalink":"http://huotublog.com/categories/composer/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://huotublog.com/tags/gitlab/"},{"name":"composer","slug":"composer","permalink":"http://huotublog.com/tags/composer/"},{"name":"docker","slug":"docker","permalink":"http://huotublog.com/tags/docker/"}]},{"title":"游戏中的抽奖是否应该有保底机制？","slug":"game-draw-card-mechanism","date":"2020-03-07T14:12:52.000Z","updated":"2023-02-16T06:50:23.260Z","comments":true,"path":"2020/03/07/game-draw-card-mechanism/","link":"","permalink":"http://huotublog.com/2020/03/07/game-draw-card-mechanism/","excerpt":"","text":"前言游戏中的抽奖机制是几乎所有游戏都要面临的问题，在一定程度上来说，抽奖机制可以决定游戏的命运。 当一个打算弃坑的玩家，想在最后抽个爽，结果却出了许多氪金大佬都没有的神宠！在游戏广播下，世界频道异口同声的喊起“狗托”，豹子头“零充”玩家心情自然不言而喻，十有八九会享受万众羡慕的眼神继续愉快的玩耍。 反之，一个氪金大佬怒抽 100 连，砸了 N 个 648 结果还不出货，正气急败坏，却看楼上那位零氪玩家的广播 XXX 玩家抽到 XXX，试问氪金大佬此时作何感想？ 当然，上面的情景仅为 YY，实际上可能并没有那么夸张，举例只是为了说明在某些特定情况下可以决定玩家是否继续玩下去。 游戏中的抽奖机制游戏中的抽奖机制经过不断演变，发展为两种比较常见的形式：无保底机制 与 保底机制。 无保底机制如字面意思，无论抽几次，概率都是一样。 这种模型会造成某些玩家运气好，尤其是零元党在抽到好东西的时候很喜欢在 贴吧秀，对包括零氪、土豪玩家造成暴击伤害，“脸帝”是玩家公敌。 无保底机制的弊端会造成游戏过于依赖运气成分。 脸黑玩家可能永远抽不到，土豪玩家可能连砸 N 个 648 依然得不到。 站在游戏开发者的角度，希望绝大多数玩家可以体验到游戏绝大多数内容，而不是单纯的靠运气决定，这个时候就可以依靠俗话说的“努力就会有回报”。 保底机制玩家通过抽奖，达到一定次数就能得到最好的奖励，这就是保底奖励。 保底奖励又有两种形式。 积分兑换第一种是以累计 “积分” 的形式，玩家可以用积分在商店兑换到最好的奖励。 这种方式的好处是，玩家可以 明确的知道 抽几次一定可以拿到大奖，虽然可能会损失几分惊喜的感觉，但是会让玩家心里感到踏实。即使失败也不会有太大的负面影响，因为失败也会累计积分作为补偿。 幸运值第二种是通过抽奖累计 “幸运值”，每次抽奖都可以使下次抽到大奖的几率提高，幸运值达到满时必定抽到。比如王者荣耀的水晶&#x2F;积分抽奖，玩家可以通过日常获得的钻石去抽奖，即使没抽到也可以积累幸运值，慢慢积累直到抽到水晶然后兑换韩信这个英雄。有些游戏的强化系统也采用这种形式，每次强化失败，下一次强化的成功几率就会提高。 这种方式的好处是可以让玩家 保持对于抽奖的期待，因为概率不断提高，玩家的内心就会觉得可能下一次就中了，而且有保底满幸运值必中的结果，玩家对于失败的感觉就很淡然了，现在的抽奖已经变为 “可以让我省多少钱”，越早抽到，玩家反而会觉得赚到了。 游戏的抽奖该不该保底？回到标题，让我们思考下面几个问题： 游戏的抽奖该不该保底？ 开发商会因为保底而亏损吗？ 保底抽奖机制到底对哪种类型的玩家更有好处？ 1、个人的看法是游戏抽奖以保底机制更好 我是一个游戏开发者，我希望玩家可以体验到游戏的更多内容（毕竟是我亲自设计的），故意吊玩家的胃口，让某些神宠只让个别人拥有，固然可以提高玩家对神宠的追求，但如果一个永远无法达成的目标，只会让玩家失望，累积越来越多的失望最终就会失去玩家。 2、不会因为保底抽奖而亏损首先保底机制可以减少玩家的流失，这是其一；其二，保底机制也让土豪玩家更有动力去充钱，以上面的积分模型为例，土豪玩家如果想要得到所有最好的奖励，“最坏”的结果已经可以通过计算明确知道了，当人知道最坏结果时，对失败的承担能力就会越强，而且土豪也可以通过计算推出自己 应该充多少钱 才能拿到所有的奖励，土豪并不差钱，但是土豪并不想被 概率 忽悠。 策划也可以通过 临界值 来诱使玩家进行充值，这个方法十分见效，我自己就上过很多次当。 下面是我被网易坑的血泪史（┭┮﹏┭┮）： 网易新出的游戏百闻牌，里面故意设计红玉和蓝玉兑换机制，让玩家误以为充值的就是红玉，其实充值的是蓝玉，需要再兑换成红玉才能抽奖。 （这种欺骗玩家或者诱导玩家错觉的行为极其不可取！） 抽奖处显示抽 10 次就可以得到妖刀姬，我就充了 30（计算得出只要充 30 就可以抽 10 次奖），结果发现充值的是蓝玉，兑换之后只有 5 次抽奖机会（真是神坑！） 好吧，现在已经抽了 5 次，再抽 5 次才能抽到，那我是抽还是不抽呢？这里还涉及到沉默成本，后文介绍。 当然是选择继续抽，而且这次还充了 68，原因是首充有额外赠送。 落入策划步步设计的深坑 ┭┮﹏┭┮ 然后又抽了 5 次才拿到妖刀姬。 这里，由于我之前已经累积了 5 次，只要再抽 5 次就可以拿到大奖，因此我会有驱动力去继续抽下去，如果是在临界值，这个动力就会更强，例如：299&#x2F;300 的时候，只需要再一次就可以抽到！ 接下来谈一谈 沉默成本。 沉默成本是经济学里面的概念（我大学也是学过经济学的2333）。 比如你投一只股票，当天亏损了 5 万，你会卖掉还是等明天看看？ 很多人都会留着看看，因为这样白白亏损很不甘心。 但实际上，你亏损的 5 万已经成为了事实，已经无法改变，不应该影响下一步的决策。 就像上面我充了 30，结果发现只抽了 5 次，但此时我损失 30 块钱已经是板上钉钉子的事了，但是我的心里面就会想：“我已经充了 30，再充 30 就可以拿到想要的了，不能让之前充的白白浪费”。 这里就是沉默成本在作怪。 实际上，沉默成本也是决定游戏命运至关重要的要素，如果一个策划可以让玩家在游戏里投入更多的时间，那玩家就会越来越难以失去这个游戏，甚至以为是“情怀”什么的，比如魔兽玩家经常会说，“那不是游戏，而是我逝去的青春”，可以说是沉默成本非常形象的说明了。 3、保底机制更利于氪金玩家由于保底机制，只要无限氪金 必然可以得到一切，也就造成了有钱可以为所欲为的情况，难道开发商不希望土豪充更多的钱吗？所以，开发商是绝对不会亏的，这一点可以保证。 由于氪金玩家可以不断充钱得到所有的奖励，如果不是保底机制呢？氪金玩家投入将是无底洞，无论投入多少钱，也许永远都得不到想要的一只英雄或者宠物。 其次，对于零氪玩家来说也是极好的，只是提升的程度没有土豪玩家那么大而已。 保底机制对“脸帝”来说是最大的威胁，由于保底，这样他们根本 秀不起来，他们由于脸好得到的神宠已经是人手可得的普通宠物了，晒这样的宠物已经无法满足他们日渐膨胀的虚荣心。 作为贴吧 13 级的大水比，已经见惯了秀脸贴。 “萌新求问 XXX 有用吗？” 抽奖中的暗箱操作之前看了一期游戏抽奖的视频，介绍了游戏抽奖中的各种暗箱操作。 其中之一是最坑的，下面用一个故事来说明。 隔壁老王有一颗价值 1 万的钻石，他想了一个办法，可以让这颗钻石赚到更多钱。 他做了 300 个空盒子，接着把钻石放在其中一个盒子，其他 299 个盒子都放一颗与钻石等重的碎玻璃，然后他开始在大街上摆摊吆喝：300 个盒子里有一颗价值 1 万的钻石，其他都是玻璃，每个盒子卖 50 块，买盒子的人不能说出自己开到什么东西。 众人听到，纷纷想以 50 博 1 万，结果所有的盒子都卖出去了，老王共得 1.5 万，比直接出售钻石还多赚了 5000。 在这里有一个很坑的点，假设第一个买盒子的人开到钻石，那后面 299 个人必定无法开到钻石，也就是必定亏损的，但是由于 “不能说出自己开到什么” 导致后面来买盒子的人仍然抱有期待，因而继续购买盒子。 在一些游戏中，由于玩家并不能知道游戏的抽奖机制是什么，因此就会有策划想出这种“歪点子”，有些游戏里的大奖每天只会发放一份（或者固定份数），而后续的玩家永远抽不到。 除此之外，还有另一种暗箱操作——奖池机制。 这种方式的特点是全服玩家共享一个奖池，上面的例子也可以归为此类，只不过奖池机制有些不同。 奖池是彩票或者棋牌游戏中的概念，所有玩家一起打牌，每轮都要下赌资，赌资全部汇集到奖池中，直到某个玩家开牌，牌面最大的玩家得到所有奖池的钱。 游戏抽奖机制也存在这种情况，所有玩家都在一个奖池里抽奖，玩家的每次抽奖相当于 “投入赌资”，只有抽奖次数达到一定水平时才会出现大奖，大奖被一个玩家得到以后，奖池清空，开启下一轮的奖池，以此类推。 所以在某些游戏中，垫子之类的说法存在一定道理，一个服务器里面抽奖的玩家越多，抽到大奖的几率就越高，在鬼区没人抽奖的情况下，甚至有可能抽奖几率为负数。 后文在这里写一下个人的想法。 假如作为开发商，自然希望玩家能多充钱，因为开发商开发游戏的目的很明确就是为了赚钱。 作为游戏制作者，我希望玩家可以体验到更多的游戏内容，而不是靠运气和财富差距造成严重游戏体验偏差。至于钱，目前并没有太大的想法，现在只是单纯的因为喜欢游戏而做游戏，也许以后会为了钱设计坑玩家的套路，但是赚到钱（维持生计）的同时，一定会并行开发一款自己真正想做的游戏（单机游戏）。 作为玩家，希望策划别坑！","categories":[{"name":"游戏","slug":"游戏","permalink":"http://huotublog.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://huotublog.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"猴子都能学会的hexo博客安装教程","slug":"easy-to-start-hexo","date":"2020-03-01T02:49:10.000Z","updated":"2023-02-16T06:50:23.259Z","comments":true,"path":"2020/03/01/easy-to-start-hexo/","link":"","permalink":"http://huotublog.com/2020/03/01/easy-to-start-hexo/","excerpt":"","text":"hexo 简介hexo 是一款开源博客项目。 即使是小白借助 hexo 也能轻松搭建属于自己的博客。 根据下面的教程，你能学会搭建个人博客，并且其他人可以通过外网访问到你的博客！ hexo 官网：https://hexo.io/ 官方中文文档：https://hexo.io/zh-cn/docs/index.html 【FAQ】 需要买服务器和域名吗？ 通过 Github Pages 可以白嫖域名和服务器，所以不用买。 当然，如果你的钱包预算足够，买一款心仪的域名和自己的服务器那就更完美了！ 话不多说，接下来直接进入教学篇。 准备工作本教程主要基于 Linux 系统，如果是 Window 系统也不用急，只是增加一个配置环境变量的步骤，机智的你一定懂得怎么做！ 代码编辑器：VS Code 基础环境hexo 依赖于 node，首先需要安装 node 环境。 1、安装 NodejsWindows 系统 nodejs 官网下载：https://nodejs.org/zh-cn/download/ 如果确实是小白，建议下载 Windows 安装包 (.msi)，msi 安装包会自动配置环境变量，真正实现小白式操作。 Linux 系统 Linux 版本众多，在这里只介绍 Centos 的安装方法。 第一步：安装 node 相关依赖 1yum install -y gcc gcc-c++ openssl-devel epel-release 第二步：安装 nodejs 1yum install -y nodejs 安装完成后，在控制台输入命令： 1node -v 如果可以看得到版本信息说明安装成功。 安装完 node 之后，即可使用 npm 命令，由于 npm 的源是国外网站，速度会很慢，为了节省时间我们可以更换淘宝提供的镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后就可以使用 cnpm 命令了，在后续的操作用 cnpm 来代替 npm。 2、安装 GitGit 是代码托管工具，整个过程 Git 的戏份很少，不懂的小白也不用担心，安装好就对了！ Windows：https://git-scm.com/download/win. Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install -y git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install -y git-core Mac 用户请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 3、安装 hexo使用 cnpm 命令一键安装 hexo： 1cnpm install -g hexo-cli 安装完成后，在控制台输入命令： 1hexo 如果看得到如下信息说明安装成功： 1234567891011121314151617Usage: hexo &lt;command&gt;Commands: help Get help on a command. init Create a new Hexo folder. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use &#x27;hexo help [command]&#x27; for the detailed informationor you can check the docs: http://hexo.io/docs/ 搭建博客！现在开始搭建博客项目，运行命令： 1hexo init blog 这个 blog 是文件夹的名字，你可以随意取，在这里我把它取名 blog。 执行完这个命令会自动在当前目录下创建一个 blog 文件夹，使用命令 cd blog 进入这个文件夹，接着再执行 cnpm install。 安装完成后，文件夹的目录如下所示： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 需要注意两个主要的配置文件： 1、_config.yml网站的配置信息，比如网站的名字什么的，都在这里进行配置。 2、package.json网站依赖的包（小白不用管这个东西），默认已经帮你配置好常用的包了。 以上，你的博客已经搭建完啦！ 访问博客！什么鬼！？这就搭建完了？？ yes，我们打开控制台，在博客目录下执行命令启动博客： 1hexo s 如图所示： 然后打开浏览器，输入 http://localhost:4000 或 127.0.0.1:4000。 你就可以看到搭建好的博客啦！ 如下图所示： 写下第一篇博文！好吧，其实你的第一篇博客已经被系统写好了，也就是你在上图看到的标题为 Hello World 的博文。 接下来我们要手动创建第一篇博客！ 使用命令 hexo n &lt;博文标题&gt; 来创建一篇新的博文。 控制台下输入： 1hexo n &quot;我的第一篇博客&quot; 执行完命令后，可以看到生成了一个 .md 格式的文件 /blog/source/_posts/我的第一篇博客.md，如下图所示： 这个文件就是我们的博文内容，进入 /blog/source/_posts/ 然后打开 我的第一篇博客.md， 可以看到默认内容类似： 1234567---title: 我的第一篇博客date: 2020-03-01 10:49:10tags:--- 开头的部分不要动，在结尾部分写自己想写的文章即可，比如： 12345678910---title: 我的第一篇博客date: 2020-03-01 10:49:10tags:---# 兔子的日记今天的天气真好！ 如果你用的是 Markdown 还能看到预览效果！ Markdown 编辑器推荐：有道云笔记 （你可以在其他地方编辑好文章，然后复制过来） 我用的是 PHPstorm，预览效果如下： 文章内容已经写好了，接下来要生成静态页面，按 Ctrl+C 把刚才启动的博客关掉： 然后依次运行如下命令： 1hexo clean 清空数据库，如图所示： 接着输入 hexo g 重新编译生成静态页面： 1hexo g 运行结果如下： 最后，再启动 hexo： 1hexo s 浏览器输入：127.0.0.1:4000 就可以看到自己刚才写的那篇文章了。 如图所示： 至此，hexo 的基本操作已经 OK 了。 再来总结一下怎么发一篇博文。 1、执行 hexo n &lt;标题&gt; 创建博文文件 2、在 Markdown 编辑器完成博文书写，把内容复制到上面生成的博文文件里 3、执行 hexo clean 清空数据 4、执行 hexo g 重新编译生成静态文件 此外，本地调试用 hexo s 开启本地服务，在浏览器输入 127.0.0.1:4000 访问博客项目。 要记住这些步骤和命令对小白来说十分吃力，这是很正常的事情。 如果忘记了怎么操作，回头多看几遍本博文，熟能生巧！ 自定义主题！默认博客页面太丑，想换一个怎么办？ 网上找到其他人分享的主题：https://github.com/zhvala/hexo-material-x-black 然后把它下载下来，点击右侧 Clone or download： 下载下来并且解压，把解压后的文件复制到博客项目的 themes 目录下。 或者直接 clone 到 themes 目录下并且命名为 material-x： 1git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 主题文件都很大，等下载完成就可以了。 主题下载下来以后，目录结构如下： themes 下面的文件夹都是主题。 接着编辑 .config.yml，拉到底部，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: material-x theme 默认是 landscape，改成刚刚下载的主题 material-x（即文件夹的名字）。 然后安装主题所需的依赖： 1npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts 接着执行下面几个命令（如果之前启动了博客项目，记得按 Ctrl+C 先关掉）： 123hexo cleanhexo ghexo s 访问 http://localhost:4000，可以发现主题已经被更换成新的了。 在 Github 上还有更多主题可以选择：点击此处获取更多主题 发布博客！上面的步骤只能在自己的电脑打开博客项目，现在我们要把博客发到外网去，让别人来参观你的博客！ — 小剧场 — 你是想要节操，还是想白嫖域名和服务器？ 我是想要节操还把域名和服务器嫖了！ 嫖不成。 啪一声，你把 300 块大洋拍在桌子上。 这个能不能换来节操？ 能，但是钱包空了。 啪一声，你把节操拍在桌子上，300 块大洋收回兜里。 嫖谁的？ GitHub 的！ 就那个全球最大同性交流社区？ 正是。 敢问君为何方神圣？ GitHub 基佬是也。 — 小剧场（完） — 没错，我们要白嫖 GitHub 提供的免费域名和空间——GitHub Pages！ GitHub Pages 提供了免费的服务可以让我们部署博客项目。 Github：https://github.com/ 注册一个账户并登陆。 接着点击左侧 Repositories 旁边的按钮 New 创建一个新的仓库，如图： 仓库的配置有两点需要注意，如果你没按照下面的要求，你的博客就访问不了： 1、仓库名称必须为：你的 GitHub 用户名.github.io，比如我的 Github 用户名是 huoshaotuzi，那么仓库的名字就是：huoshaotuzi.github.io 2、仓库必须为 Public 公开权限，如果选择 Private，就不能白嫖了，这也是上面的小剧场所说的出卖节操的原因，一旦公开权限，你的仓库 任何人都能访问，你的仓库设置成 Public，相当于你光着屁股暴露在 Github 几百万基佬面前，知道啥意思了吧？ 创建好仓库后，可以看到如下的仓库信息： （xxoo 是随便取的名字，不要问 xxoo 是什么意思，问了也不会告诉你。） 在这里把 SSH 后面的仓库地址复制下来，后面会用到。 接着返回到你博客的目录下，执行命令安装 git 插件： 1cnpm install --save hexo-deployer-git 安装完成后，编辑根目录下的 _config.yml，拉到最底部，deploy 后面添加如下内容： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/huoshaotuzi/xxoo.git（填你自己的） branch: master 这里的 repo 填入上面说的仓库地址： 保存配置文件后，输入命令： 1hexo d 执行命令后开始自动编译并且上传到 GitHub 仓库，然后会提示要输入 Github 的账号跟密码。 为了避免每次上传都要重复输入账号密码，你可以输入下面的命令记住密码： 1git config --global credential.helper store 上传成功后，返回仓库就能看到上传好的代码。 然后就可以通过仓库名称访问到你的博客了！ 我的仓库名称是：huoshaotuzi.github.io 在浏览器输入：huoshaotuzi.github.io 刚刚部署上去的时候，需要等几分钟才能看到博客，不然会出现 404 或者其他问题。 白嫖党只能使用 GitHub 提供的域名，接下来给大家介绍如何指定域名进行访问。 比如我的网站是：blog.huotuyouxi.com 这是怎么实现的呢? 指定域名！首先，你得有一个域名。 万网阿里云、百度云、腾讯云、京东云、华为云、国外的 GoDaddy……诸如此类域名服务提供商，任选一家即可。 建议购买 .com 后缀的域名，域名的名称就按照你自己喜欢的挑选了。 比如张三：zhangsan.com 皮卡丘博客：pikachublog.com 简单好记的域名，这个没什么要求的，选你喜欢的就好。 域名买好之后，在仓库主页的菜单栏，选择 Settings： 拉到下面，直到看到 GitHub Pages，然后点击 Choose a theme 选择一个主题： 主题按照你喜欢的随便选一个就好： 比如选第一个，然后点击右下角 Select theme。 接着返回 Github Pages 配置域名： 在 Custom domain 栏处填写你购买的域名，然后点击 Save。 如果需要启用 https 域名，把 Enforce HTTPS 勾选即可，刚部署时需要等待几分钟 Enforce HTTPS 才会显示可选，并且勾选完成后也需要等待几分钟，Github 会为你免费提供 SSL 证书。 然后打开你购买域名的网站，例如阿里云，登录后打开右上角控制台-点击左上角展开菜单-选择域名： 在域名右侧选择解析： 点击“添加记录”，记录类型 CNAME，主机记录 @，记录值填你自己仓库的名字： 如果你希望可以用 www 访问，那就再添加一条记录，主机记录填 www，其他跟上面的一样： 完成这一步你就可以通过购买的域名访问到博客了！ 指定服务器！不想出卖节操，就买台服务器自己安装环境，这样可以保证代码不被其他基佬看到。 1、域名和服务器的选择选服务器可是很有讲究的，看你网站的受众，如果是面向海外用户，就选国外的服务器；如果面向国内用户，那就买国内的服务器。服务器放在哪很大程度上会影响你网站的打开速度。 再者，如果你选国内服务器，还需要注意域名备案的问题。 想要搭建博客，最好提前买个域名进行备案。 没有备案的域名只能选择国外主机。 只建议购买：com、cn、net 这三个老牌域名。 非主流域名即使能备案，搜索引擎也很难收录，所以不推荐。 有条件或者嫌备案麻烦的，可以购买香港或者台湾地区的服务器，靠近大陆，延迟相对低一点，域名即买即用。 2、服务器环境服务器推荐 Centos 系统，如果是小白也可以选 Windows Server。 要让网站解析到服务器，首先需要安装 Web 服务器，老牌的 Web 服务器软件有 Apache，Windows 的 IIS。 这两个本人几乎没用过，就不在这里介绍了。 推荐使用 Nginx。 以 Centos 为例，安装十分简单： 1yum install -y nginx 安装完成后，执行命令： 1vim /etc/nginx/conf.d/blog.conf 按下 i 键插入如下内容： 12345server &#123; server_name blog.huotuyouxi.com; root /var/www/blog; index index.html;&#125; 然后按 Esc，输入 wq! 保存。 接着重启 Nginx： 1nginx -s reload 在这里，server_name 是你的域名。 root 是你的博客项目路径，可以下载 FileZilla 把博客上传到服务器，或者直接使用 git clone 下来。 12cd /var/wwwgit clone &lt;你的博客仓库地址&gt; 然后你在哪买的域名，就登录到控制台把域名解析到服务器的公网 IP。 解析的方法在上面已经有介绍了，这里不再重复。 3、更新博客内容 前面的文章介绍了如何编写和更新博客： 123hexo cleanhexo ghexo d 更新博客内容并且推送到 Github 上面，你就可以回到服务器上，然后执行 git pull 把最新的博客内容拉取下来，实现博客的更新。 其中，hexo g 和 hexo d 两个命令可以简写成： 1hexo d -g 有兴趣的可以去了解一下 Git 自动构建，延伸的内容太多了，本文写不下 4、博客代码备份使用 hexo d 上传到 Github 的只是编译后的静态文件，博客的代码并没有上传到仓库里。 这样一旦你的博客代码丢失，你就无法继续更新了。 为了避免这种情况，我们要把博客代码也上传到仓库里，最好是上传到同一个仓库。 回到本地的博客项目，执行如下命令： 12git checkout -b developgit push origin develop 这两个步骤，第一个是切换到新的分支 develop（名字可以随便取），然后把新的分支推送到远程仓库。 如此一来，你的博客代码也被保存至仓库里。 前往 Github 查看，点击 Branch 即可看到新的分支： 还记得最早我们在 _config.yml 设置的 Github 仓库地址吗？ 这里我们把静态文件的分支设置成 master，因此我们可以专注于在 develop 分支上写博文，然后用 hexo d -g 进行推送，不需要进行分支切换，十分方便！ 把博客代码上传到远程仓库，即使你在另一台电脑上面也可以把项目克隆下来，然后执行如下命令： 1git checkout develop 切换到 develop 分支上去写博文。 结语借助 hexo 可以快速搭建属于自己的博客，平时学习到新东西的时候就可以记录下来，养成良好的习惯有助于学习成果的积累。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://huotublog.com/categories/Hexo/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://huotublog.com/tags/gitlab/"},{"name":"Hexo","slug":"Hexo","permalink":"http://huotublog.com/tags/Hexo/"}]}],"categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://huotublog.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"前端技术","slug":"前端技术","permalink":"http://huotublog.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"项目实战","slug":"项目实战","permalink":"http://huotublog.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"架构","slug":"架构","permalink":"http://huotublog.com/categories/%E6%9E%B6%E6%9E%84/"},{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/categories/MySQL/"},{"name":"通用技术","slug":"通用技术","permalink":"http://huotublog.com/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://huotublog.com/categories/JavaScript/"},{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/categories/Linux/"},{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/categories/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/categories/Docker/"},{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/categories/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/categories/Nginx/"},{"name":"资料","slug":"资料","permalink":"http://huotublog.com/categories/%E8%B5%84%E6%96%99/"},{"name":"composer","slug":"composer","permalink":"http://huotublog.com/categories/composer/"},{"name":"docker","slug":"docker","permalink":"http://huotublog.com/categories/docker/"},{"name":"游戏","slug":"游戏","permalink":"http://huotublog.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"http://huotublog.com/categories/Hexo/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huotublog.com/tags/PHP/"},{"name":"开发技术","slug":"开发技术","permalink":"http://huotublog.com/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"http://huotublog.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"FireRabbitEngine","slug":"FireRabbitEngine","permalink":"http://huotublog.com/tags/FireRabbitEngine/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huotublog.com/tags/Swoole/"},{"name":"MAC OS","slug":"MAC-OS","permalink":"http://huotublog.com/tags/MAC-OS/"},{"name":"解决方案","slug":"解决方案","permalink":"http://huotublog.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"MySQL","slug":"MySQL","permalink":"http://huotublog.com/tags/MySQL/"},{"name":"架构","slug":"架构","permalink":"http://huotublog.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://huotublog.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"技术","slug":"技术","permalink":"http://huotublog.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://huotublog.com/tags/JavaScript/"},{"name":"Linux","slug":"Linux","permalink":"http://huotublog.com/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"http://huotublog.com/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://huotublog.com/tags/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"http://huotublog.com/tags/Nginx/"},{"name":"Supervisord","slug":"Supervisord","permalink":"http://huotublog.com/tags/Supervisord/"},{"name":"WebSite","slug":"WebSite","permalink":"http://huotublog.com/tags/WebSite/"},{"name":"composer","slug":"composer","permalink":"http://huotublog.com/tags/composer/"},{"name":"centos","slug":"centos","permalink":"http://huotublog.com/tags/centos/"},{"name":"gitlab","slug":"gitlab","permalink":"http://huotublog.com/tags/gitlab/"},{"name":"docker","slug":"docker","permalink":"http://huotublog.com/tags/docker/"},{"name":"游戏","slug":"游戏","permalink":"http://huotublog.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"http://huotublog.com/tags/Hexo/"}]}
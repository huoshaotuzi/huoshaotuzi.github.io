<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录一下最新学到的东西</title>
      <link href="/2023/02/15/2023-news-1/"/>
      <url>/2023/02/15/2023-news-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本只打算用一年去做游戏，结果硬是拖了三年，现在总算做出来了，最后还是变成自己一个人在做，真是世事无常大肠包小肠，感兴趣的可以看看实机演示：<a href="https://www.bilibili.com/video/BV1XT411f7Pw/">https://www.bilibili.com/video/BV1XT411f7Pw/</a></p><p>最近重拾了这个博客，升级了下 hexo 的版本，并且也更换了主题与游戏博客保持一致，又新购了一个域名 huotutu.com，准备搭起来做一个小窝，研究前沿技术的同时顺便可以加入付费功能嘿嘿嘿~</p><p>好了，直接进入正题。</p><h2 id="PHP-是最好的语言吗？"><a href="#PHP-是最好的语言吗？" class="headerlink" title="PHP 是最好的语言吗？"></a>PHP 是最好的语言吗？</h2><p>因为使用 Unity 开发游戏，因此接触了 C#，结果现在重新撸 PHP，发现很不习惯了，比如 PHP 是弱类型语言，这样在编写代码的时候经常会很不规范，传来的值是什么，返回的值是什么都不清楚，就跟开盲盒一样……现在最新的 PHP 已经开始重视这点了，为了更加规范，PHP 也必须要注重变量类型和返回值的声明了。</p><p>第二点，PHP 的变量类型比较少，没有 Dictionary（字典），这个类型在开发游戏的时候非常好用，虽然 PHP 可以用关联数值实现相同的效果，但因为上面的第一点，会出现很复杂的情况，比如在 C# 可以用字典这么保存变量，声明一个敌人的模型数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 敌人模型数据</span><br><span class="line">public class Format_Enemy</span><br><span class="line">&#123;</span><br><span class="line">    public string id;</span><br><span class="line"></span><br><span class="line">    // 敌人的等级</span><br><span class="line">    public int level;</span><br><span class="line"></span><br><span class="line">    // 敌人的模型</span><br><span class="line">    public string prefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，当游戏载入时，读取本地 json 文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;id&quot;: &quot;goblin&quot;, &quot;level&quot;: 1, &quot;prefab&quot;: &quot;Goblin&quot;&#125;,</span><br><span class="line">    &#123;&quot;id&quot;: &quot;monkey&quot;, &quot;level&quot;: 3, &quot;prefab&quot;: &quot;Monkey&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>enemy.json 文件以数组形式保存 model 类型的变量，接着将敌人数据载入字典：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个字典用来存储敌人模型数据</span><br><span class="line">Dictionary&lt;string, Format_Enemy&gt; models = new Dictionary&lt;string, Format_Enemy&gt;();</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">public void InitLoad()</span><br><span class="line">&#123;</span><br><span class="line">    // 这里是读取json文件的方法</span><br><span class="line">    var items = ModelUtil.GetInstance().Load&lt;List&lt;Format_Enemy&gt;&gt;(&quot;enemy&quot;);</span><br><span class="line"></span><br><span class="line">    // 循环将敌人id作为键名保存到字典</span><br><span class="line">    foreach (var item in items)</span><br><span class="line">    &#123;</span><br><span class="line">        models.Add(item.id, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Debug.Log(&quot;敌人模板数据载入完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候就非常简单了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var monkey = $models[&quot;monkey&quot;];</span><br><span class="line"></span><br><span class="line">// 输出monkey敌人的等级</span><br><span class="line">Debug.Log(monkey.level);</span><br></pre></td></tr></table></figure><p>因为字典是以 <code>key-object</code> 的形式保存数据，通过 model[id] 的形式获得的是一个 object 对象，因而可以直接调用对象的属性，可是 PHP 就不能这么做了，如下为 PHP 的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$enemies = [</span><br><span class="line">    &#x27;goblin&#x27; =&gt; [&#x27;id&#x27; =&gt; &#x27;goblin&#x27;, &#x27;level&#x27; =&gt; 1, &#x27;prefab&#x27; =&gt; &#x27;goblin&#x27;],</span><br><span class="line">    &#x27;monkey&#x27; =&gt; [&#x27;id&#x27; =&gt; &#x27;money&#x27;, &#x27;level&#x27; =&gt; 1, &#x27;prefab&#x27; =&gt; &#x27;money&#x27;],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$monkey = $enemies[&#x27;monkey&#x27;];</span><br><span class="line">var_dump($monkey[&#x27;level&#x27;]);</span><br></pre></td></tr></table></figure><p>调用方法如出一辙，可是区别在于，PHP 是弱类型的语言，这里的所有数据都是“凭空”输入的，因此在编译器上面无法判断是否出错，而在 C# 有类的约束，可以直接用 <code>.</code> 调出属性，如果有写错的地方，编译器第一时间就会报错。</p><p>PHP 的数组没有任何约数，甚至可以直接凭空捏造一个 <code>key</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr[&#x27;abc&#x27;] = 123;</span><br><span class="line">var_dump($arr);</span><br></pre></td></tr></table></figure><p>上面是一段没有任何问题的 PHP 代码，输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [&quot;abc&quot;]=&gt;</span><br><span class="line">  int(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要任何声明可以凭空调用，这既是优点也是缺点，优点是写起来很方便，缺点是撸代码很不规范，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function updateGoods(array $goods)</span><br><span class="line">&#123;</span><br><span class="line">    if ($goods[&#x27;status&#x27;] == true) &#123;</span><br><span class="line">        // ... 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $price = $goods[&#x27;price&#x27;];</span><br><span class="line">    var_dump($price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个简单的数组调用，通过传入商品数据，在方法内更新商品状态，因为传入的是一个数组（关联数值），数组的键名完全就是凭空写进去的，没有任何约数，不知道的人根本不懂得应该传入什么键名，这样的代码后期无法维护，而当一个方法所需要的参数较多时，应该封装成类作为参数传入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class  GoodsData</span><br><span class="line">&#123;</span><br><span class="line">    public bool $status;</span><br><span class="line">    public int $price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateGoods(GoodsData $goods)</span><br><span class="line">&#123;</span><br><span class="line">    if ($goods-&gt;status == true) &#123;</span><br><span class="line">        // ... 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $price = $goods-&gt;price;</span><br><span class="line">    var_dump($price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能起到约束作用，没有约束就没有规范，没有规范就难以维护，C# 虽然写起来更舒服一点，但是开发网站还是得 PHP 效率高，光是等编译就能节省一大堆的时间了。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解是新时代编程的主流，PHP 8 也很快就跟上了，所谓的注解，其实就是通过「反射」获取到注释的内容，再通过解析获得想要的结果。先来说一下什么是反射，反射就是程序获取到自身属性的行为，这么说很难理解，看下面的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这是一个类</span><br><span class="line"> */</span><br><span class="line">class  TestClass</span><br><span class="line">&#123;</span><br><span class="line">    private string $name;</span><br><span class="line"></span><br><span class="line">    public function test(string $a, int $b): void</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($a, $b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 PHP 里面的一个类，有一个 string 类型的私有属性 <code>name</code>，还有一个简单的方法，那么问题来了，我们怎么获取到注释信息？你没看错，我们现在要获取这个类的<strong>注释</strong>……正常来说，哪有这么奇怪的需求啊？注释不是写给码农看的吗？我们要拿注释做什么呢？关于这个问题，下文会说明，但是先解决眼前的问题——我们到底该如何通过代码拿到注释信息呢？</p><p>我们顶多也就知道如何拿到类的名称，比如 PHP 8 里面最新加入了一个获取类名称的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$obj = new TestClass();</span><br><span class="line">var_dump(get_debug_type($obj));</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">string(9) &quot;TestClass&quot;</span><br></pre></td></tr></table></figure><p>可是老师从来没教过我们怎么获取注释……正确答案是：通过<strong>反射机制（Reflection）</strong>。反射就是程序获取自身属性的一种行为，不仅是注释，类有哪些属性，哪些方法等等都能给你查的明明白白，通过反射机制，类文件的任何标点符号都不会放过，一切尽收眼底~是不是很兴♂奋？</p><p>首先是类的注释，也就是在类声明上方的注释部分，为了通过反射获取类的注释，需要实例化反射类 <code>ReflectionClass</code>（PHP 自带）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$reflection = new ReflectionClass ( TestClass::class );</span><br><span class="line">$ref = $reflection-&gt;getDocComment();</span><br><span class="line"></span><br><span class="line">var_dump($ref);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(26) &quot;/**</span><br><span class="line"> * 这是一个类</span><br><span class="line"> */&quot;</span><br></pre></td></tr></table></figure><p>接下来，我们可以来点更“变态”的，我想要拿到类的方法，想知道它的参数名称！</p><blockquote><p>全部都要看光光！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$reflection = new ReflectionClass (TestClass::class);</span><br><span class="line">$res = $reflection-&gt;getMethod(&#x27;test&#x27;);</span><br><span class="line">$params = $res-&gt;getParameters();</span><br><span class="line">foreach ($params as $param) &#123;</span><br><span class="line">    var_dump($param-&gt;getType()-&gt;getName() . &#x27;_&#x27; . $param-&gt;getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(8) &quot;string_a&quot;</span><br><span class="line">string(5) &quot;int_b&quot;</span><br></pre></td></tr></table></figure><p>不仅是变量类型，形参的名字都拿到了，这就是反射的神奇之处，它可以获取到自身的属性，同时还可以改变属性的值，例如上面的 <code>name</code> 属性是私有变量，按照我们的常规思想是无法通过调用属性来改变值的，但是通过反射却可以，为了方便演示，增加了一个 <code>show</code> 方法用来输出 <code>name</code> 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    private string $name;</span><br><span class="line"></span><br><span class="line">    public function show(): void</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($this-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，通过反射来修改 <code>name</code> 的值并调用 <code>show</code> 方法查看结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$obj = new TestClass();</span><br><span class="line"></span><br><span class="line">$reflection = new ReflectionClass ($obj);</span><br><span class="line">$res = $reflection-&gt;getProperty(&#x27;name&#x27;);</span><br><span class="line">$res-&gt;setAccessible(true);</span><br><span class="line">$res-&gt;setValue($obj, &#x27;abc&#x27;);</span><br><span class="line">$obj-&gt;show();</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">string(3) &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>神奇吧！！！在无法访问私有变量的情况下，竟然可以通过反射修改私有变量的值。<br>emmm……仔细一想，虽然反射很牛杯，但是我一个只会增删改查的咸鱼，在开发中有什么用呢？<br>完全就是多此一举嘛~</p><p>如果想要修改变量的值，为什么不能直接写个 <code>get-set</code> 方法呢？<br>确实如此，反射在我们日常工作的用途并不大，也不会有多少人接触。<br>反射机制可以获取变量类型、方法名称、参数、注释信息等等，这些在日常处理业务几乎没有作用。<br>但是它在设计框架、构筑开发流程中非常重要！<br>就好比我们日常基本接触不到设计模式，可设计模式却是框架的核心。<br>而现代的主流框架已经开始利用反射机制实现独特的开发方式，现在很热门的“依赖注入”就是通过反射实现的，比如下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestController</span><br><span class="line">&#123;</span><br><span class="line">    private TestService $service;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service = new TestService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestService</span><br><span class="line">&#123;</span><br><span class="line">    public function show(): void</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;hell world&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个 <code>TestService</code> 类，我们想在 <code>TestController</code> 调用，需要手动 <code>new</code> 的方式在构造方法进行赋值，但是在 Laravel 框架里，却可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TestController</span><br><span class="line">&#123;</span><br><span class="line">    private TestService $service;</span><br><span class="line"></span><br><span class="line">    public function __construct(TestService $service)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service = $service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吗？现在不需要手动 <code>new</code> 创建对象了，因为当你在构造方法里设置了一个参数，在 Laravel 框架的作用下就会自动实例化这个对象进行赋值，这就叫做依赖注入，正如其名，你需要的“依赖”会被框架“注入”。</p><p>你可能会说，这不就是少写了一段代码吗？<br>实际上，别看着小小的变化，却涉及到整个编程流程方式的改变。</p><p>一个基本控制器如下，内有一个 <code>index</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TestController</span><br><span class="line">&#123;</span><br><span class="line">    private TestService $service;</span><br><span class="line"></span><br><span class="line">    public function __construct(TestService $service)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service = $service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        $params = $request-&gt;all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法通过依赖注入获取到了 <code>Request</code> 对象，而在 Laravel 中，这个对象保存了请求的信息，我们可以直接从这个对象获取到所有请求参数，是不是很方便？这样做既让编程更加“优雅”，同时也减少了系统之间的耦合度。</p><p>依赖注入是框架帮你实现的，上面我介绍了反射的原理，你完全可以自己写一个依赖注入来试试~</p><blockquote><p>框架并不是简单的函数封装，而是提供一个编程的环境。</p></blockquote><p>依赖注入和控制反转，还有反射……一大堆新的名词，老实说我十分反感，如果不能把复杂的问题简单的讲述，那说明理解不到位，或者故意把简单的说成复杂的，搞得好像很高大上一样，说的就是金融行业……如果你是初次看到这些名词，不用担心，因为你现在已经学 <del>废</del> 会了。</p><blockquote><p>我不推荐你去搜这些专有名词啥意思，因为看完你会更懵逼——by 傻瓜式编程指南（兔兔著）</p></blockquote><p>现在你已经知道了，依赖注入就是框架帮你注♂入一些东西，比如你想要的类的对象，只要写在方法的形参上，框架就会帮你实例化，你直接调用就完事。请参考 N 年之前我写的火兔引擎（开发框架），我在设计框架的时候就已经明确了目标：编程的最高境界是“无码”。</p><p>换句话说，除非你是非常喜欢写代码的人（高情商），否则，框架会自动帮你处理很多琐碎的事情，因此你不需要写太多的代码。市面上的 PHP 框架多如牛毛，什么阿猫阿狗阿兔都想“自创框架”，比如<strong>大名鼎鼎的 Fire Rabbit Engine</strong>，就是阿兔本兔原创的框架。</p><p>学习一门新的框架要不少时间成本，要我说的话，对大部分人来说，框架只要选择开发起来“舒服”的就行了，大部分情况下都不需要注意性能问题，小公司注重的是开发效率，指不定过完年公司就倒闭了 233，我以前上班的时候就是一个“项目杀手”，做一个项目死一个，入职一年，弄死的项目少则三个，多则五个！</p><p>其实是因为老板自己都不知道想干嘛就胡乱尝试，今天刚废了一个项目，第二天又看上新的东西，脑袋一热一拍屁股就决定要开发新项目了，很荣幸……当时的技术主管全丢给我了。最后，我离职了，原因是给的钱不多吗？不是，那个时候我才刚刚毕业，并不看重钱，而是每个项目都是我在负责，就好像辛辛苦苦养大的孩子突然夭折了……说多了都是泪。</p><p>所以，当一个项目立项的时候，如果负责人非得选用性能最好，开发舒适度最烂的时候，应该想想，这是不是一种傲慢，自信的认为这个项目一定能成功呢？小公司根本不在乎性能，只要快速构建项目，快速上线才是王道！尤其是老板催你进度的时候，那跟催命似的，到时候后悔就来不及了。</p><p>回归主题，接下来开始介绍什么是“注解”。注解其实就是注释的一种，原本注释是给人看的。现在，一些走在时尚前端的码农研究出了新的花活——让程序也能看注释。</p><p>例如 Java 里面有这种代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Deprecated</span><br><span class="line">@SuppressWarnings</span><br></pre></td></tr></table></figure><p>下面是我网上 copy 来的冒泡排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span><br><span class="line">            boolean flag = true;</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + 1];</span><br><span class="line">                    arr[j + 1] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在方法上方加了一个 <code>@Override</code>，这个就是注解，它的作用是检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p><p>这股时尚的潮流也 <del>内</del> 卷到 PHP 那边去了，于是，主打注解开发为亮点的 PHP 框架陆续出现，前有 Swoft，后有 Hyperf，Hyperf 的作者好像之前就是 Swoft 里的，后来单飞了，当然也有很多吃瓜事件，咱也不了解，至于为什么选择 Hyperf 而不是 Swoft，主要还是因为我个人对 Laravel 的偏爱，Hyperf 的代码几乎跟 Laravel 完全相似，相当于 Swoole 版的 Laravel，关于吃瓜问题就不多展开，技术本身无好坏，唯有人。本人也不了解真相就不多说了，看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">namespace App\Controller;</span><br><span class="line"></span><br><span class="line">use Hyperf\HttpServer\Contract\RequestInterface;</span><br><span class="line">use Hyperf\HttpServer\Annotation\AutoController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @AutoController()</span><br><span class="line"> */</span><br><span class="line">class IndexController</span><br><span class="line">&#123;</span><br><span class="line">    // Hyperf 会自动为此方法生成一个 /index/index 的路由，允许通过 GET 或 POST 方式请求</span><br><span class="line">    public function index(RequestInterface $request)</span><br><span class="line">    &#123;</span><br><span class="line">        // 从请求中获得 id 参数</span><br><span class="line">        $id = $request-&gt;input(&#x27;id&#x27;, 1);</span><br><span class="line">        return (string)$id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过写注释的方式来定义路由，是不是很新鲜？除此之外，注解也可以实现上面提到的依赖注入，比如我们需要一个类的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @AutoController()</span><br><span class="line"> */</span><br><span class="line">class IndexController</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * @Inject()</span><br><span class="line">     * @var UserService</span><br><span class="line">     */</span><br><span class="line">    private $userService;</span><br><span class="line">    </span><br><span class="line">    // /index/info</span><br><span class="line">    public function info(RequestInterface $request)</span><br><span class="line">    &#123;</span><br><span class="line">        $id = $request-&gt;input(&#x27;id&#x27;, 1);</span><br><span class="line">        return $this-&gt;userService-&gt;getInfoById((int)$id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在只要加入一个 <code>Inject</code> 注解，并且用 <code>var</code> 来声明变量的类型，框架就会自动为你注♂入这个类的实例，在 PHP 8 以前，注解都是非官方的，只是民间通过反射机制实现了 JAVA 类似的注解，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param Foo $argument</span><br><span class="line"> * @see https:/xxxxxxxx/xxxx/xxx.html</span><br><span class="line"> */    </span><br><span class="line"> function dummy($Foo) &#123;&#125;</span><br></pre></td></tr></table></figure><p>而且这种注解一般没有什么实际的意义，就是一种人为的规定，比如 <code>@param</code> 我们视为一个参数，当然你也可以写成 <code>@canshu</code>，这都是可以的，因为这就是一个注释而已，注释在程序中不会被认为是代码，你怎么写都可以。</p><p>然后自己再写一个解析注释的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ref = new ReflectionFunction(&quot;dummy&quot;);</span><br><span class="line">$doc = $ref-&gt;getDocComment();</span><br><span class="line">$see = substr($doc, strpos($doc, &quot;@see&quot;) + strlen(&quot;@see &quot;));</span><br></pre></td></tr></table></figure><p>上面是 PHP 最早的民间注解实现原理，而第一次尝试用注解作为开发的 Hyperf 框架很快就流行起来，习惯了这种开发方式会变得很愉♂悦，直到 PHP 8 开始，官方实现了 PHP 的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#[Params(&quot;Foo&quot;, &quot;argument&quot;)]</span><br><span class="line">#[See(&quot;https://xxxxxxxx/xxxx/xxx.html&quot;)]</span><br><span class="line">function dummy($argument) &#123;&#125;</span><br></pre></td></tr></table></figure><p>简单地说：<br>注释（comment）是给人看的，程序看不懂；<br>注解（annotation）既是给人看的，程序也看得懂。</p><p>我们可以通过注解实现依赖注入等许多功能，人有多大胆，地有多大产，Hyperf 的做法属实是一种大胆的尝试了，无论是路由、控制器、中间件等等，都可以用注解的方式书写。</p><p>以前我最喜欢的是 Laravel 框架，而现在 Hyperf 是基于 swoole 的框架，而且框架的设计者应该也是 Laravel 的重度爱好者，从 Laravel 转 Hyperf 几乎没有任何学习成本，最新的火兔小窝（huotutu.com）将使用 v3.0 版本开发~</p><p>好了，以上就是关于注解的说明，注解（Annotation）并不属于程序的代码，而是一种开发方式，就是通过特殊的格式定义注释，好让系统看得懂，因为注解的存在，注释也变成了一种开发方式，经典例子就是 Hyperf 框架。</p><p>框架并不是简单的函数封装，选择什么框架开发项目就决定了你的开发方式，开发方式是由框架设计者决定的，Hyperf 框架也不过是 swoole 框架的一个可选方案，只是因为我喜欢 Laravel 的开发方式，所以选择它。</p><p>可以缩减写代码工作量的框架都是好框架，现在 ChatGPT 火爆，甚至还能帮你写代码，以后说不定还会被 AI 取代。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>双叒叕是一个令人头痛的新名词！<br>先让我们来看摊煎饼的数学问题，假设一个锅每次只能摊两个煎饼，煎饼要求两面摊到金黄，单面摊到金黄需要 1 分钟，现在有三张饼要摊，请问把三张饼摊到两面金黄需要多久？</p><p>正常人的思维：先弄 A 和 B 两张饼，两面都金黄一共需要 2 分钟，接着再下 C，两面金黄又需要 2 分钟，总计需要 4 分钟。</p><p>机智的人可能发现问题了，A 和 B 在锅里的时候，C 是空闲的，当 A 和 B 摊熟了，C 一个饼占了整个锅（一个锅是可以放两张饼的），那是不是有点浪费资源了？于是，聪明的人就有了新的方法：</p><p>第一分钟，A 和 B 下锅，把一面摊到金黄，接着把 B 拿出来放到一旁，把 C 下锅；<br>第二分钟，A 两面全熟拿起来放到盘子，再把 B 翻过来继续摊，接着把刚才摊了一面的 B 下锅；<br>第三分钟，BC 两面全熟，收锅关火！</p><p>同样的锅，同样是三张饼，用这种方法竟然节约了 1 分钟！这是因为锅一直都是保持两张饼，而第一种方法，锅会出现空闲状态，原本能同时摊两张饼，却只摊了一张，这就是浪费时间的因素。</p><p>所谓的协程就是这种原理，最大化的利用程序的效率，锅就是服务器，为了把服务器的性能榨干就不能让它闲着，要永远让它“干活”。要知道，程序的执行速度是不同的，有的程序执行起来很慢（如读取 Excel），有的很快（给变量赋值），我们都知道程序是从上至下执行的，前面的代码没执行完毕，后面的代码就会一直处于等待状态，这就是浪费“资源”，就像上面的锅一样，原本可以同时摊两张饼，可一张饼占了整个锅，效率自然就低了。</p><p>例如 PHP 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;hello&#x27;;</span><br><span class="line">echo &#x27;world&#x27;;</span><br></pre></td></tr></table></figure><p>这段代码为什么永远都是按顺序输出 <code>hello</code> 和 <code>world</code> 呢？正是因为程序是自上而下执行的，而且这两段代码执行速度很快，所以瞬间就输出完毕了，接着我们再模拟一下，代码执行慢的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function loadFile()</span><br><span class="line">&#123;</span><br><span class="line">    echo &#x27;hello&#x27;;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayWorld()</span><br><span class="line">&#123;</span><br><span class="line">    echo &#x27;world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadFile();</span><br><span class="line">sayWorld();</span><br></pre></td></tr></table></figure><p>这段代码同样是输出两个单词，但是会发现因为 <code>sleep</code> 的存在，第一个 <code>hello</code> 输出完毕之后等了一秒才输出 <code>world</code>，两个单词的输出顺序依然没变，这是因为程序无论如何都是从上往下执行的，而这种「等待」完全就是不必要的，两个函数没有任何关联，为什么不能先让下面的代码进行输出呢？</p><p>就好比医院挂号，按照 1、2、3、4、5 顺序排列，1 号第一个进入窗口办理，很快就办完了，接下来轮到 2 号，可他身份证忘记带了，就打电话叫家人送过来，那么此时问题来了……现在确实是轮到 2 号办理手续，但是等他家人送身份证过来要半小时，后面的 3~5 号以及办理挂号的工作人员就这么干等着吗？那是不是可以通融一下，在 2 号的身份证送来之前，先让后面的人办理？等身份证到了，再让 2 号继续办理也不迟呀！</p><p>正常的程序可不会这么“通情达理”，程序是一定严格按照从上至下的顺序执行的，2 号蛮横的说：现在轮到我挂号，我没办完，凭什么让你们先办啊？所以此时必须等到 2 号身份证送来，后面的 3~5 号才能继续办理。</p><p>谁排到队谁就拥有“挂号权”，轮到 2 号挂号了，医院又没规定挂号的最大时间，那么自然 2 号有权等到自己身份证送来，后面的人就是得干等着没办法，虽然不通人情，但这也无可奈何，因为程序可不知道你下面的代码是不是跟上面的有关，万一执行顺序乱了就报错啦~</p><p>协程就是这个问题的解决方案：让你决定程序的控制权。<br>程序不知道该不该先让后面的代码执行，可是你知道呀！那交给你来控制不就完事了吗？</p><p>先来说一个 PHP 的关键词 <code>yield</code>，这个关键词并不是协程，而是用来生成迭代器（又叫生成器）的，迭代器就是一个能够被循环的对象，如果理解不了就直接认为是一个数组就好，例如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$items = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">foreach ($items as $item) &#123;</span><br><span class="line">    var_dump($item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不只是数组，只要实现了迭代器接口（Iterator）的类都可以被 <code>foreach</code> 循环，下面尝试自定义一个迭代器（注意，PHP 8.1 不支持）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Rabbit implements Iterator</span><br><span class="line">&#123;</span><br><span class="line">    // 这里我定义了一个 int 类型的指数物，用来标记当前进度，类似数组的下标</span><br><span class="line">    private int $pos;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;pos = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前返回的值</span><br><span class="line">    public function current()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将指数物向下移动一位，在foreach中每次调用都会前进一次</span><br><span class="line">    public function next()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;pos++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 迭代器的key（类似关联数值的键名）</span><br><span class="line">    public function key()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否可以继续向下执行，如果数据已经没了，就返回false，这里小于10是随便写的，让它打印0~10个数</span><br><span class="line">    public function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;pos &lt;= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重置指数物，该方法在迭代器执行一次就无法调用，否则报错</span><br><span class="line">    public function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;pos = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$rabbit = new Rabbit();</span><br><span class="line">foreach ($rabbit as $item) &#123;</span><br><span class="line">    var_dump($item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我定义了一个迭代器 <code>Rabbit</code>，通过 <code>foreach</code> 循环依次输出 0~10。任何类只要实现了 <code>Iterator</code> 迭代器接口就可以被 <code>foreach</code> 循环输出，接着我们的主角 <code>yield</code> 关键词要出现了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function rabbit()</span><br><span class="line">&#123;</span><br><span class="line">    for ($i = 0; $i &lt;= 10; $i++) &#123;</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$items = rabbit();</span><br><span class="line">foreach ($items as $item) &#123;</span><br><span class="line">    var_dump($item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结果也是依次输出 0~10，这就是 <code>yield</code> 关键词的作用，它看起来像是 <code>return</code>，但又不全是，因为 <code>return</code> 一旦返回函数就会结束，而 <code>yield</code> 返回了数字，但却没有退出函数，不仅如此，<code>yield</code> 的返回值是一个可以被循环体调用的迭代器。</p><p>接着再看有意思的一组数据，我们稍加修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function rabbit()</span><br><span class="line">&#123;</span><br><span class="line">    for ($i = 0; $i &lt;= 10; $i++) &#123;</span><br><span class="line">        var_dump(&#x27;a&#x27; . $i);</span><br><span class="line">        yield $i;</span><br><span class="line">        var_dump(&#x27;b&#x27; . $i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$items = rabbit();</span><br><span class="line">foreach ($items as $item) &#123;</span><br><span class="line">    var_dump($item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>yield</code> 关键词上面和下面分别进行输出，我们再运行一次查看结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string(2) &quot;a0&quot;</span><br><span class="line">int(0)</span><br><span class="line">string(2) &quot;b0&quot;</span><br><span class="line">string(2) &quot;a1&quot;</span><br><span class="line">int(1)</span><br><span class="line">string(2) &quot;b1&quot;</span><br><span class="line">string(2) &quot;a2&quot;</span><br><span class="line">int(2)</span><br><span class="line">string(2) &quot;b2&quot;</span><br><span class="line">string(2) &quot;a3&quot;</span><br><span class="line">int(3)</span><br><span class="line">string(2) &quot;b3&quot;</span><br><span class="line">string(2) &quot;a4&quot;</span><br><span class="line">int(4)</span><br><span class="line">string(2) &quot;b4&quot;</span><br><span class="line">string(2) &quot;a5&quot;</span><br><span class="line">int(5)</span><br><span class="line">string(2) &quot;b5&quot;</span><br><span class="line">string(2) &quot;a6&quot;</span><br><span class="line">int(6)</span><br><span class="line">string(2) &quot;b6&quot;</span><br><span class="line">string(2) &quot;a7&quot;</span><br><span class="line">int(7)</span><br><span class="line">string(2) &quot;b7&quot;</span><br><span class="line">string(2) &quot;a8&quot;</span><br><span class="line">int(8)</span><br><span class="line">string(2) &quot;b8&quot;</span><br><span class="line">string(2) &quot;a9&quot;</span><br><span class="line">int(9)</span><br><span class="line">string(2) &quot;b9&quot;</span><br><span class="line">string(3) &quot;a10&quot;</span><br><span class="line">int(10)</span><br><span class="line">string(3) &quot;b10&quot;</span><br></pre></td></tr></table></figure><p>这里发现了奇怪的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(2) &quot;a0&quot;</span><br><span class="line">int(0)</span><br><span class="line">string(2) &quot;b0&quot;</span><br></pre></td></tr></table></figure><p>我们的循环体是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ($i = 0; $i &lt;= 10; $i++) &#123;</span><br><span class="line">    var_dump(&#x27;a&#x27; . $i);</span><br><span class="line">    yield $i;</span><br><span class="line">    var_dump(&#x27;b&#x27; . $i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按照程序从上往下执行的观点，难道不是应该输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(2) &quot;a0&quot;</span><br><span class="line">string(2) &quot;b0&quot;</span><br><span class="line">int(0)</span><br></pre></td></tr></table></figure><p>这样才对吗？可为什么却先跳到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$items = rabbit();</span><br><span class="line">foreach ($items as $item) &#123;</span><br><span class="line">    var_dump($item); // 这个地方输出 int(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，程序是先返回了 0 这个数，接着再执行下面的 <code>var_dump</code> 输出 b，因为 <code>yield</code> 的存在导致程序的执行顺序发生了变化，接着继续演示 <code>yield</code> 是如何手动控制执行顺序的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function action_1()</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;action_1_1&#x27;);</span><br><span class="line">    yield;</span><br><span class="line">    var_dump(&#x27;action_1_2&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function action_2()</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;action_2_1&#x27;);</span><br><span class="line">    yield;</span><br><span class="line">    var_dump(&#x27;action_2_2&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$action_1 = action_1();</span><br><span class="line">$action_2 = action_1();</span><br><span class="line"></span><br><span class="line">$action_1-&gt;current();</span><br><span class="line">$action_2-&gt;current();</span><br><span class="line"></span><br><span class="line">var_dump(&#x27;ok&#x27;);</span><br><span class="line"></span><br><span class="line">$action_1-&gt;next();</span><br><span class="line">$action_2-&gt;next();</span><br></pre></td></tr></table></figure><p>上面有两个函数 <code>action_1</code> 和 <code>action_2</code>，通常情况下，如果没有 <code>yield</code> 关键词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var_dump(&#x27;action_1_1&#x27;);</span><br><span class="line">var_dump(&#x27;action_1_2&#x27;);</span><br></pre></td></tr></table></figure><p>这段代码会一股脑的全部输出，但是因为有了 <code>yield</code> 关键词，我们就可以手动调用 <code>next</code> 方法让它往下执行，如果你不调用 <code>next</code>，那它就会在 <code>yield</code> 处返回，不再往下执行。</p><p>结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(10) &quot;action_1_1&quot;</span><br><span class="line">string(10) &quot;action_1_1&quot;</span><br><span class="line">string(2) &quot;ok&quot;</span><br><span class="line">string(10) &quot;action_1_2&quot;</span><br><span class="line">string(10) &quot;action_1_2&quot;</span><br></pre></td></tr></table></figure><p>可以发现，因为 <code>yield</code> 返回的是一个生成器，倘若我们执行了 <code>next</code> 方法，它才会继续向下执行，否则，它就会“卡”在 <code>yield</code> 的地方，这就是我们可以手动调控程序执行顺序的原因了。</p><p>换句话说，<code>yield</code> 就跟断点一样，我们想让程序在哪停下，就在哪用 <code>yield</code> 返回就行了，但是与 <code>return</code> 不同的是 <code>yield</code> 返回的是控制权，并不是让程序中断，这是利用了 <code>yield</code> 返回的是一个迭代器的原理实现的。</p><p>协程与多线程很容易混淆，我们会误以为是不是用 <code>yield</code> 改变了控制权，程序就可以不会再阻塞执行了呢？如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;1&#x27;);</span><br><span class="line">    sleep(3);</span><br><span class="line">    yield;</span><br><span class="line">    var_dump(&#x27;2&#x27;);</span><br><span class="line">    yield;</span><br><span class="line">    var_dump(&#x27;3&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = test();</span><br><span class="line">$test-&gt;current();</span><br><span class="line">$test-&gt;next();</span><br><span class="line">$test-&gt;next();</span><br></pre></td></tr></table></figure><p>结果我们发现，在输出第一个“1”的时候，程序还是卡了 3 秒才继续输出，换句话说，这个代码依然是同步执行的，上面的代码如果不执行完毕，还是会卡在执行过程，那这个 <code>yield</code> 到底有什么用呢？它还不是卡住了吗？</p><p>回到摊煎饼的问题，现在只有一口锅，一口锅最多每次只能摊两个煎饼，那么为了提高效率，可以按照上面三分钟的摊法，还有一种方法——再多加一口锅，两口锅就可以同时摊 4 个煎饼了！</p><p>再加一口锅即代表多线程，「协程」不是多线程，这两者很容易混淆，多线程是再切出一条线程处理程序，而「协程」还是在那个线程，只是我们通过任务调度的方式提高执行效率，还是那条线程，还是原来的味道！</p><blockquote><p>多线程是利用 CPU 多线程处理任务的优势，而协程是将单个线程的性能压榨到极致。</p></blockquote><p>那么这个 <code>yield</code> 到底哪里神奇了啊？<br>它本身就是在一个线程里面执行的，它的作用只是对程序进行“调度”而已，并不能解决程序阻塞问题。</p><p>正如上面的例子，多线程是加了一口锅，而协程是合理的利用这口锅，使它保持着最高效率——同时摊两个饼！<br>用多线程可以解决效率低下的问题，那为什么还要协程呢？</p><p>线程本身就是一种资源，协程就是最大化利用这条线程的性能，一口锅明明可以同时摊两个煎饼，为什么非要再开一个新锅呢？诚然，摊一个煎饼两面金黄要 2 分钟，摊三个煎饼，只要你拿出三口锅，时间就缩短到了 2 分钟了，岂不是比 3 分钟还快？那你家里可能有矿才能这么霍霍……</p><p>这就是痛点所在了：协程就是为了解决资源利不充分的问题。</p><p>利用协程的特性可以让锅一直都在摊饼，能同时摊两张，那就一定同时摊两张，一刻都不许闲着，像极了煤老板压榨矿工。为了实现这个“监工”需要一个名为“调度器”的东西，调度器的作用就是依次执行所有协程任务，直到所有协程任务结束了，调度器才结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function create_task($max)</span><br><span class="line">&#123;</span><br><span class="line">    for ($i = 0; $i &lt; $max; $i++) &#123;</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$task1 = create_task(3);</span><br><span class="line">$task2 = create_task(5);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    var_dump($task1-&gt;current());</span><br><span class="line">    var_dump($task2-&gt;current());</span><br><span class="line"></span><br><span class="line">    $task1-&gt;next();</span><br><span class="line">    $task2-&gt;next();</span><br><span class="line">&#125; while ($task1-&gt;valid() || $task2-&gt;valid());</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>create_task</code> 创建了两个数值不等的任务，所谓调度器其实就是 <code>do-while</code> 循环体，<code>valid</code> 方法判断这个任务是否结束，如果两个任务全部结束才跳出这个循环（调度器），但是因为我们给这两个任务不同的最大值，导致两个任务执行的次数不一样，第一个任务只返回 3 个值，第二个任务却返回了 5 个值，最后输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int(0)</span><br><span class="line">int(0)</span><br><span class="line">int(1)</span><br><span class="line">int(1)</span><br><span class="line">int(2)</span><br><span class="line">int(2)</span><br><span class="line">NULL</span><br><span class="line">int(3)</span><br><span class="line">NULL</span><br><span class="line">int(4)</span><br></pre></td></tr></table></figure><p>前面三个数字，两个任务输出一模一样的结果，但是第一个任务从第四个数字开始就返回 <code>Null</code> 了，这是因为这个任务已经结束了，所以不再有新的返回值。同理，如果再添加任务三、任务四……那么这个调度器依然是依次执行所有任务，直到任务全部结束才跳出循环。</p><p>这就是协程的全部概念了……也就是说，协程是通过调度器实现依次执行全部的任务，这些任务绝对是不能阻塞进程的！否则任务阻塞了，后面的也得等在那边，所以如果使用协程，一定不能使用阻塞的代码，否则跟没用一样，协程的作用就是：把所有的煎饼都摊在锅里，这个锅能同时摊多少个煎饼，它就往里面塞多少个煎饼，而且雨露均沾，每个煎饼都只摊 1 秒，然后以迅雷不及掩耳之势换下一个煎饼，就这样，每个煎饼每次只摊 1 秒，直到全部的煎饼两面金黄为止。</p><blockquote><p>上面的 1 秒只是一个比喻，实际上程序的运行速度比这个快多了。</p></blockquote><p>协程的作用是控制程序的执行权限，通过权限转移的方式结合死循环（调度器）让每个任务每次循环都运行一次，直到所有任务结束才退出循环。</p><blockquote><p>上面的调度器也是举个栗子罢了，实际的调度器会优化性能，比方说上面 3 次循环结束了，后面全部都是 NULL，实际上应该把已经完成的任务从循环体去掉，避免重复执行节约性能，这里就不对调度器详细展开了。</p></blockquote><p>关于协程，我也是搞得很懵逼，最开始以为它跟多线程异步处理一样，就是把一些费时的任务切出去，然后执行下一段代码，其实并不是，如果两者混淆就理解不了协程了，协程……并不是异步处理，它也不是什么程序代码，它只是一种控制权转移。</p><p><strong>协程的调度器其实是利用协程的控制权转移让所有的代码放到一块轮番切换执行，直到全部的代码执行完成</strong>。它本身就是一段阻塞程序（用死循环来实现调度器，任务不全部结束就跳不出这个死循环），它只是在循环执行这些任务罢了。</p><p>协程本身并不是为你提供异步环境，它就是一个执行权限的转移而已，而它之所以能够异步执行……是因为你写的代码是异步的啊，不是协程的调度器是异步的，你写了异步代码，它就异步执行，你写的不是异步代码，它就会阻塞，只要把这个搞清楚就不会懵逼了。</p><p><strong>就跟打扑克一样，发牌的人每次都给在座的各位发一张扑克，直到所有玩家手牌满了才会停下，这就是协程的调度器，每次都只执行一次任务，然后遇到 yield 就立即切换到下一个任务，直到所有任务全部完成，这里的 yield 实现协程是 PHP 系统自带的，如果想要通过第三方实现，可以安装 swoole 扩展。</strong></p><h2 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h2><p>关于协程就抛到一边吧，因为理解起来很不容易，写完协程现在都凌晨一点半了，接下来看轻松一点的 AOP 编程，这也是现在很热门的编程思想，它就跟 OOP（面向对象编程）一样是现在广大码农喜欢的新理念。</p><p>切面（Aspect）是一个新的名词，理解起来非常简单，火腿肠吃过吧？现在我们有一根很♂粗的火腿肠，用刀从中间切开，然后塞一粒玉米进去，现在它就变成玉米热狗肠了！</p><blockquote><p>真特喵的黑心，一粒玉米也敢叫玉米肠？</p></blockquote><p>好了，结束，这就是面向切面编程。<br>用刀切开火腿肠，一刀两断，火腿肠赤果果的肉体的展示在你的面前，形成了两个完美的 Aspect（切面）。<br>面向切面编程，就是向这个切开的面塞入一粒玉米。</p><p>我们可以从任何地方切开火腿肠，在任何切面塞入玉米，甚至辣椒等等。<br>面向切面编程可以理解成「嵌入式」代码，你写一段代码，然后嵌入到任何其他代码里面。</p><blockquote><p>PHP 里面有一个 trait 可以复用代码，但这并不是切面，这只是复用代码，切面编程一定存在『拦截』。</p></blockquote><p>其实你早就用过 AOP 编程了，举个栗子就是 Laravel 的中间件，中间件会「拦截」请求，满足条件才进入下一步操作，如果不满足条件，那就 403 Forbidden，或者其他什么，总之，你通过中间件拦截请求，判断是否满足条件的这种行为就已经是面向切面编程了。</p><p>第二个栗子，如果你是前端开发，那么应该用过 Vue 框架，生命周期函数应该知道，就是那个什么 <code>beforeCreate</code>、<code>created</code> 之类的东西，如果你是 Unity 开发，那么也知道 <code>Monobehaviour</code> 也有生命周期函数，如 <code>Awake</code>、<code>Start</code> 等等，生命周期函数就是 AOP 的理念。</p><p>AOP 编程的核心理念就是「拦截请求」，通俗的说就是 “当 xxx 时，做 xxx”，这就是 AOP 编程的核心思想了，如下面一个更新用户积分的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class  UserController</span><br><span class="line">&#123;</span><br><span class="line">    public function update()</span><br><span class="line">    &#123;</span><br><span class="line">        $params = request()-&gt;all();</span><br><span class="line">        $model = User::find($params[&#x27;id&#x27;]);</span><br><span class="line">        $model-&gt;update([&#x27;score&#x27; =&gt; $params[&#x27;score&#x27;]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该控制器提供了一个更新用户积分的方法，只要传来 <code>id</code> 和 <code>score</code> 分数参数就能找到对应的用户并且更新积分，但这样有不少问题，首先没有任何权限验证，岂不是人人都可以利用这个接口来改自己的分数？第二个，积分流水没有任何记录，万一以后跟用户产生纠纷怎么办？为了解决这个问题（先别想中间件的事情），我们需要进行如下两项改动：</p><p>1、对权限进行验证，只有管理员才能更新用户数据<br>2、对积分流水进行记录</p><p>首先假设有一个 <code>checkAdmin</code> 方法，用来判断是否是管理员，该方法只需要传入一个 <code>jwt-token</code> 参数，如果是管理员就返回 true，否则返回 false，还有一个方法 <code>saveLog</code> 用来保存积分流水：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class  UserController</span><br><span class="line">&#123;</span><br><span class="line">    public function update()</span><br><span class="line">    &#123;</span><br><span class="line">        $params = request()-&gt;all();</span><br><span class="line"></span><br><span class="line">        if (!$this-&gt;checkAdmin($params[&#x27;token&#x27;])) &#123;</span><br><span class="line">            return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;没有修改权限&#x27;]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $model = User::find($params[&#x27;id&#x27;]);</span><br><span class="line">        $model-&gt;update([&#x27;score&#x27; =&gt; $params[&#x27;score&#x27;]]);</span><br><span class="line"></span><br><span class="line">        saveLog($params[&#x27;id&#x27;], $model-&gt;score);</span><br><span class="line"></span><br><span class="line">        return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;修改成功&#x27;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function saveLog($userID, $score)</span><br><span class="line">    &#123;</span><br><span class="line">        ScoreLog::create([&#x27;user_id&#x27; =&gt; $userID, &#x27;score&#x27; =&gt; $score]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkAdmin($jwtToken)</span><br><span class="line">    &#123;</span><br><span class="line">        // ... 此处省略逻辑</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在看起来安全多了，接下来，如果有一个修改用户所属用户组的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public function changeGroup()</span><br><span class="line">&#123;</span><br><span class="line">    $params = request()-&gt;all();</span><br><span class="line"></span><br><span class="line">    if (!$this-&gt;checkAdmin($params[&#x27;token&#x27;])) &#123;</span><br><span class="line">        return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;没有修改权限&#x27;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...逻辑代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又得判断一次权限……很是繁琐，现在毫无疑问你会说出用中间件消灭这些重复的代码。没错，中间件处理权限验证是非常方便的，所有需要验证权限的请求先经过中间件，通过中间件过滤不符合条件的请求。</p><p>中间件就是一个嵌入式的代码，当请求进来的时候，为什么不会直接进入到控制器呢？因为 Laravel 框架对请求进行了拦截，只有通过你设定的中间件请求才会进入 Controller，否则就过滤掉，如果用生命周期来形容，就是 <code>before</code> 阶段就进行了处理，请求还没进入 Controller 就先被过滤掉了！</p><blockquote><p>Laravel 的中间件如何实现拦截请求可以看我开发 FireRabbitEngine 的相关文章</p></blockquote><p>中间件拦截不符合要求的请求，这就是通过切面“嵌入”一段代码，只要封装一个拦截器就可以实现这个功能了，但实际上拦截请求有很多种方式，接下来以 Hyperf 为例，演示如何通过切面的方式执行设计好的代码，假设有一个控制器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[AutoController(prefix: &#x27;/test&#x27;)]</span><br><span class="line">class TestController</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;test&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要在这个控制器中嵌入其他代码，只需要声明一个切面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#[Aspect]</span><br><span class="line">class TestAspect extends AbstractAspect</span><br><span class="line">&#123;</span><br><span class="line">    public array $classes = [</span><br><span class="line">        &#x27;App\Controller\Front\TestController::test&#x27;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public function process(ProceedingJoinPoint $proceedingJoinPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;insert&#x27;);</span><br><span class="line">        return $proceedingJoinPoint-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>classes</code> 数组内加入想要插入的控制器方法，在 <code>process</code> 方法里面写入想要插入的代码，这段代码会在访问 <code>/test</code> 路由的时候一并被执行，注意，这里一定要返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $proceedingJoinPoint-&gt;process();</span><br></pre></td></tr></table></figure><p>这段代码是返回原控制器的处理结果，它跟 Laravel 的中间件几乎一模一样，如果你嵌入了多个切面，那么必须要全部返回，只要有一个没有返回程序就不会继续执行。</p><p>Hyperf 是以注解的方式开发的，我们还可以用注解的方式插入切面，声明一个注解，该注解还带有一个参数，参数在后面可以获取到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Annotation;</span><br><span class="line"></span><br><span class="line">use Hyperf\Di\Annotation\AbstractAnnotation;</span><br><span class="line"></span><br><span class="line">#[\Attribute] class TestAnnotation extends AbstractAnnotation</span><br><span class="line">&#123;</span><br><span class="line">    public string $val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着修改切面，把 classes 注释掉，改用注解的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class TestAspect extends AbstractAspect</span><br><span class="line">&#123;</span><br><span class="line">    public array $classes = [</span><br><span class="line">//        &#x27;App\Controller\Front\TestController::test&#x27;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public array $annotations = [</span><br><span class="line">        TestAnnotation::class,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public function process(ProceedingJoinPoint $proceedingJoinPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        // 这里拿到注解传来的参数</span><br><span class="line">        $val = $proceedingJoinPoint-&gt;getAnnotationMetadata()-&gt;method[TestAnnotation::class];</span><br><span class="line">        var_dump($val-&gt;val);</span><br><span class="line"></span><br><span class="line">        return $proceedingJoinPoint-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着返回控制器，在想要嵌入的地方插入注解即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[TestAnnotation(val: &#x27;kkk&#x27;)]</span><br><span class="line">public function test()</span><br><span class="line">&#123;</span><br><span class="line">    $res = &#x27;test-value&#x27;;</span><br><span class="line">    var_dump(&#x27;controller&#x27;);</span><br><span class="line"></span><br><span class="line">    return $res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了，在切面里也可以拿到 <code>val</code> 的值。</p><p>关于切面有几个注意的地方，<code>process</code> 方法只会执行一次，所以不用担心如果有多个切面会重复执行的问题，放心大胆的 <code>return</code> 即可，第二点，classes 和注解的方式只要写一个即可，我个人比较偏向于用注解的方法，第三，被切入的地方，可以通过 <code>ProceedingJoinPoint $proceedingJoinPoint</code> 变量获取其他数据，比如方法的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$params = $proceedingJoinPoint-&gt;getArguments();</span><br><span class="line">var_dump($params);</span><br></pre></td></tr></table></figure><p>那么 AOP 到底有什么用呢？它就是一种编程理念而已，正如最开始说的那样，这只是决定了你开发方式，AOP 可以帮你节省很多重复的劳动，节约时间就是节约生命~中间件就是最好的例子，除此之外，一些数据库的更新操作，记录日志操作也可以用面向切面编程实现，因为这些都是重复性的劳动，全部交给框架去办才是正解。</p><p>除此之外，上面的代码几乎没有任何耦合，从而变得十分简洁优雅~</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（Pipeline）就是因为像水管一样，从水管的这头输入一滴水，经过管道拐来拐去，最后流到你家里，这个过程呢，这滴水可能与其他管道流进来的水混合在一起，你最后得到的这滴水是混合了很多次的水。</p><p>去年冬奥会冰墩墩火到爆，如果你没看过冰墩墩的制作过程，那么我在这里科普一下，冰墩墩陶瓷版是全手工制作的，第一道工序就是烧陶瓷了，用模板烧出冰墩墩的模样，烧好的冰墩墩是就是个模具生产出来的粘土人而已，没有任何色彩，因此进入第二道工序，上色！冰墩墩的本体是熊猫，因此只要黑白两种颜色，用毛笔蘸一点颜料慢慢涂满整个冰墩墩，白色的身体，黑色的手手和眼睛鼻子，到这里第二道工序就完成了，涂了色的冰墩墩接下来要送到第三道工序——贴眼睛，眼睛是用贴片式的，把提前准备好的眼睛贴片沾到冰墩墩眼睛处即可，这样第三道工序也完成了，最后一道工序就是给冰墩墩套上宇航员外壳，ok，整个流程结束，冰墩墩制作完成。</p><p>现在让我们捋一捋，烧好的冰墩墩陶瓷是原始对象，送到 1~4 道工序加工后变成了一个成品的冰墩墩，用户拿到手的就是加工好的冰墩墩，这个制作流程就叫做「管道」，通过这个管道设计，输入一只无色陶瓷冰墩墩，经过管道出来的就是一只上好色的成品冰墩墩。</p><p>管道的理念是从 Unix 系统出来的，比如查看日志的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 300 text.log</span><br></pre></td></tr></table></figure><p>上面的命令会查询最新的 300 行日志，但是日志记录的内容太多了，我们如果想要某些关键词，比如 <code>rabbit</code>，可以用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 300 text.log |grep rabbit</span><br></pre></td></tr></table></figure><p>上述代码就会从日志最新的 300 行里过滤出包含 <code>rabbit</code> 关键词的行数，这其实就是一个链式调用，像 javascript 里面的 axios 可以通过如下调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;/user&#x27;, &#123;</span><br><span class="line">params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;).catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码表示发起一个 ajax 请求，当返回响应的时候，执行 <code>then</code> 的代码，如果执行过程发生异常就执行 <code>catch</code> 的代码，那么为什么可以用链式调用呢？其实很简单，就是让方法的返回值返回自身即可，用 PHP 来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    private string $content;</span><br><span class="line"></span><br><span class="line">    public function __construct(string $content)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;content = $content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function add(string $newStr): TestClass</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;content .= $newStr;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function show()</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($this-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new TestClass(&#x27;abc&#x27;);</span><br><span class="line">$test-&gt;add(&#x27;e&#x27;)-&gt;add(&#x27;f&#x27;)-&gt;add(&#x27;g&#x27;)-&gt;show();</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;abcefg&quot;</span><br></pre></td></tr></table></figure><p>上面演示了最简单的链式调用，当一个对象的方法返回值是自身时，那么是不是可以继续调用其他方法？这就是链式调用的原理。现代主流框架基本都是支持这种链式调用的，比如 Laravel 框架的 ORM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$users = User::select([&#x27;id&#x27;])-&gt;where(&#x27;score&#x27;, &#x27;&gt;&#x27;, 100)</span><br><span class="line">            -&gt;limit(5)</span><br><span class="line">            -&gt;get()</span><br><span class="line">            -&gt;toArray();</span><br></pre></td></tr></table></figure><p>上面的代表表示查询用户积分大于 100 的用户 id，并且限制只取出 5 个数据，最后再把结果转化成数组形式。</p><p>管道还可以设计的更加复杂，例如上一个类执行完的结果，再传递给下一个类当做参数……简单地说，管道就是「传递」的过程，就好比一滴水从源头流进水管，万一水管接到了下水道，那这滴水不是被污染了吗？最后再流进你家里，当然，它也可能流到一根生锈的水管，因此融进了一些铁屑等杂质……诸如此类，这滴水流过什么样的水管就沾染上什么样的颜色，你把自己当成马里奥就行了，你想让管道怎么接就怎么接。</p><p>管道有很多实现的方法，比如 Laravel 的中间件，没错，又是它！只要你去研究 Laravel 中间件是如何实现的，你一定会被惊叹到，像洋葱一样一层一层剥开你的皮进入你的心……</p><p>总之，管道就是 <code>输入-输出</code> 的过程，如果说切面的核心是拦截，那么管道的核心就是「连接」与「传递」。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站性能优化之静态资源加速</title>
      <link href="/2021/03/24/web-optimize-1/"/>
      <url>/2021/03/24/web-optimize-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片、css、js 等等不会在用户访问时改变的资源统称静态资源。</p><p>网站的打开速度除了跟代码有关，静态资源也会拖后腿，优化静态资源加载速度比起优化代码更能显著提高访问速度。</p><h2 id="WEB-服务器"><a href="#WEB-服务器" class="headerlink" title="WEB 服务器"></a>WEB 服务器</h2><p>Apache 和 Nginx 是常用的 WEB 服务器。</p><p>Nginx 处理静态资源的速度比 Apache 更快，所以选择 Nginx 可以提高静态资源访问速度。</p><p>Nginx 可以配置静态资源缓存，参考资料：<a href="https://www.w3cschool.cn/nginxsysc/nginxsysc-cache.html">Nginx 静态资源缓存设置</a></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>两台电脑的远近距离会影响到访问速度，例如在大陆地区访问国外的服务器就会延迟。</p><p>CDN 即内容分发网络，它会根据就近原则为你分配访问的节点。</p><p>比如在广州有一台服务器，上面保存着图片 A，在美国也有一台服务器，也保存着相同的图片 A，假设你的网站客户群体是全球范围，那么让国内用户访问广州的服务器上面的图片 A，美国用户访问美国服务器的图片 A，这样访问速度就是最快的。</p><p>更细分一点，在广州、上海、福州、香港……等等很多个地区都有一台服务器，这些服务器都保存着图片 A，这样广州的人访问广州的服务器，上海的人访问上海的服务器……这就是内容分发，就近原则访问资源。</p><p>我们个人是没办法做到那么多节点的，只有依靠服务商。</p><p>CDN 的原理就是负载均衡，根据 IP 来分配节点。</p><p>有很多免费的 CDN 服务商，推荐使用 jsdelivr + Github 来作为个人的 CDN。</p><p>Github：<a href="http://github.com/">http://github.com/</a></p><p>首先到 Github 创建一个账号，然后新建一个仓库，上传一张图片，比如图片名字为：avatar.png。</p><p>然后就可以直接用 jsdelivr 加载这张图片了。</p><p>格式：<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></p><p>版本号不是必须的，但是加上去可以防止用户本地缓存了资源导致没有更新，你可以随意编写自己的版本号，如：@1.0，不过如果你要加上版本号的话，需要用 git 命令打一个版本的标签。</p><p>示例：<a href="https://github.com/laravel/laravel">https://github.com/laravel/laravel</a></p><p>这是 Laravel 框架的仓库地址，仓库根目录下有一个 <code>webpack.mix.js</code> 文件。</p><p>那么可以访问下面的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/laravel/laravel/webpack.mix.js</span><br><span class="line">https://cdn.jsdelivr.net/gh/laravel/laravel@8.5.15/webpack.mix.js</span><br></pre></td></tr></table></figure><p>这样就 OK 了！</p><p>上面的 @8.5.15 是 Laravel 框架已经打好的版本标签。</p><p>在仓库的 tags 页面可以查看所有标签 ：<a href="https://github.com/laravel/laravel/tags">https://github.com/laravel/laravel/tags</a></p><p>默认不写标签就是引用最新版。</p><p>前端用的最多的 js 即 JQeury 了，仓库地址：<a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a></p><p>可以试着拿这个仓库练习一下，首先是确定自己要用的 JQuery 版本：<a href="https://github.com/jquery/jquery/tags">https://github.com/jquery/jquery/tags</a></p><p>例如我要引用最新的 v3.6.0，然后发现 dist 里有不同类型的文件：<a href="https://github.com/jquery/jquery/tree/3.6.0/dist">https://github.com/jquery/jquery/tree/3.6.0/dist</a></p><p>带有 min 即压缩过的，一般我们都是引用这个。 </p><p>可以用下面的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/jquery/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>CDN 不止可以用 js、css 等，还可以把图片也上传到自己的 github 仓库，用相同的办法引入即可。</p><blockquote><p>需要注意的是 jsdelivr 可能不太稳定，一旦它挂了你的网站资源就加载不出来了，这也是用 cdn 的风险</p></blockquote><h2 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h2><p>推荐两个免费图床：</p><p>SM.MS：<a href="http://sm.ms/">http://sm.ms/</a></p><p>牛图网：<a href="http://niupic.com/">http://niupic.com/</a></p><p>把图片上传到这两个网站，它们自带 CDN。</p><p>上传图片之前，可以到 TinyPng：<a href="https://tinypng.com/">https://tinypng.com/</a> 将图片压缩一下，体积减小之后访问的速度也就 更快了。</p><blockquote><p>需要注意的是压缩画质会受损，请根据实际需求选择是否压缩</p></blockquote><p>除此之外，图片的 jpg 格式比起 png 更小，因为 jpg 是压缩的格式，而 png 可以保留透明背景，如果不需要透明背景可以将图片压缩为 jpg 格式。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FireRabbit-Engine 实战 从零搭建个人博客（四）完结篇</title>
      <link href="/2021/03/24/firerabbit-engin-4/"/>
      <url>/2021/03/24/firerabbit-engin-4/</url>
      
        <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个多月没更新了，大致总结一下。</p><p>博客已经做完而且上线了，框架也在边写博客业务的时候边更新，具体过程略。</p><p>静态资源使用 CDN 可以实现秒开，AB 测试的结果差强人意，原本一个单纯的框架测试 hello world 时 RPS 可以达到 200-300，而博客上线后，测试 5000 篇文章使用 Redis 缓存的情况下，RPS 只剩下 20-30，太丢 swoole 的脸了……</p><p>总的来说，通过自己写框架的过程还是学到蛮多知识的，尤其是在做自己的游戏的时候，思维方式发生了很大的改变。</p><p>平时写网站几乎用不到的「设计模式」，对写框架和游戏开发来说却是最根本的基础，现在我已经决定好好学一下各种设计模式了。不然以后做游戏开发的时候，代码肯定是乱糟糟的一团。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FireRabbitEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FireRabbit-Engine 实战 从零搭建个人博客（三）登录与注册</title>
      <link href="/2021/02/19/firerabbit-engin-3/"/>
      <url>/2021/02/19/firerabbit-engin-3/</url>
      
        <content type="html"><![CDATA[<h2 id="视图文件"><a href="#视图文件" class="headerlink" title="视图文件"></a>视图文件</h2><p>在 app 下新建一个文件夹 view 用来保存视图模板，</p><p>再创建一个 storage，并继续在 storage 下创建 view_cache 用来保存编译后的视图文件。</p><p>然后修改 app.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant::VIEW_CONFIG =&gt; [</span><br><span class="line">    &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;,</span><br><span class="line">    &#x27;cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/view_cache&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>此处的文件路径即上述创建的文件夹。</p><h2 id="视图母版"><a href="#视图母版" class="headerlink" title="视图母版"></a>视图母版</h2><p>母版即所有页面共用的代码，比如每个页面都有顶部导航栏跟底部栏，</p><p>只是中间的部分不同，因此只要把内容单独提取出来，顶部和底部的结构可以复用。</p><p>在 view 下新建 layout 用来保存母版，同时创建 app.blade.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot;</span><br><span class="line">          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;火兔博客&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;导航栏&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    </span><br><span class="line">    @yield(&#x27;content&#x27;)</span><br><span class="line"></span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p align=&quot;center&quot;&gt;火兔博客©2021&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>中间的 <code>yield(&#39;content&#39;)</code> 即抽取出来的内容页。</p><h2 id="登录-x2F-注册页面"><a href="#登录-x2F-注册页面" class="headerlink" title="登录&#x2F;注册页面"></a>登录&#x2F;注册页面</h2><p>添加登录注册的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbit\Engine\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Http\\Controller\\&#x27;,</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/register&#x27;, &#x27;IndexController@register&#x27;)-&gt;name(&#x27;register&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>接着修改控制器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/19</span><br><span class="line"> * Time：12:39</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller;</span><br><span class="line"></span><br><span class="line">use FireRabbit\Engine\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function login()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;show(&#x27;login&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function register()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;show(&#x27;register&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建对应的 blade 模板，login.blade.php：</p><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FireRabbitEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FireRabbit-Engine 实战 从零搭建个人博客（二）创建博客所需的表</title>
      <link href="/2021/02/19/firerabbit-engin-2/"/>
      <url>/2021/02/19/firerabbit-engin-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Phinx"><a href="#Phinx" class="headerlink" title="Phinx"></a>Phinx</h2><p>官方网站：<a href="https://book.cakephp.org/phinx/0/en/index.html">Phinx - 官方文档</a></p><p>phinx 是一个数据库迁移插件，它可以帮你实现不使用 sql 文件来创建表。</p><p>框架还没集成数据库迁移系统，因此就需要自己手动安装了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行命令：<code>composer require robmorgan/phinx</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>第一次安装还需要进行初始化：<code>vendor/bin/phinx init</code>，不然 phinx 不知道你的数据库账号密码就无法连接了。</p><p>初始化完成后，在项目根目录会出现一个配置文件 phinx.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">[</span><br><span class="line">    &#x27;paths&#x27; =&gt; [</span><br><span class="line">        &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;,</span><br><span class="line">        &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;</span><br><span class="line">    ],</span><br><span class="line">    &#x27;environments&#x27; =&gt; [</span><br><span class="line">        &#x27;default_migration_table&#x27; =&gt; &#x27;phinxlog&#x27;,</span><br><span class="line">        &#x27;default_environment&#x27; =&gt; &#x27;development&#x27;,</span><br><span class="line">        &#x27;production&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;production_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        &#x27;development&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;development_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        &#x27;testing&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;testing_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    &#x27;version_order&#x27; =&gt; &#x27;creation&#x27;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>默认是 development 环境，在这里修改自己的数据库配置。</p><p>虽然 phinx 是数据库迁移，但它本身创建不了数据库，需要手动创建。</p><p>修改完成后，再创建一个名词叫做 blog 的数据库即可。</p><h3 id="迁移目录"><a href="#迁移目录" class="headerlink" title="迁移目录"></a>迁移目录</h3><p>根据配置文件最上方的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;paths&#x27; =&gt; [</span><br><span class="line">    &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;,</span><br><span class="line">    &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>创建对应的文件夹。</p><h3 id="创建表迁移"><a href="#创建表迁移" class="headerlink" title="创建表迁移"></a>创建表迁移</h3><p>命令：<code>vendor/bin/phinx create xxxx</code>。</p><p>xxx 是表名，使用大驼峰方式。</p><h3 id="执行迁移"><a href="#执行迁移" class="headerlink" title="执行迁移"></a>执行迁移</h3><p>命令：<code>vendor/bin/phinx migrate</code>。</p><h2 id="项目所需表"><a href="#项目所需表" class="headerlink" title="项目所需表"></a>项目所需表</h2><p>博客项目需要的表及对应的字段，表名默认为复数形式（即加一个 s）。</p><p>所有的表都有一个自增主键。</p><h3 id="用户表：users"><a href="#用户表：users" class="headerlink" title="用户表：users"></a>用户表：users</h3><ul><li>name：昵称</li><li>email：注册邮箱</li><li>password：密码，采用明文方式存储（本项目只是测试而已~~~好孩子不要学）</li><li>created：注册时间</li></ul><p>执行命令：<code>vendor/bin/phinx create User</code></p><p>在迁移目录 migrations 即可看到迁移文件，修改迁移文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">use Phinx\Migration\AbstractMigration;</span><br><span class="line"></span><br><span class="line">final class User extends AbstractMigration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Change Method.</span><br><span class="line">     *</span><br><span class="line">     * Write your reversible migrations using this method.</span><br><span class="line">     *</span><br><span class="line">     * More information on writing migrations is available here:</span><br><span class="line">     * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method</span><br><span class="line">     *</span><br><span class="line">     * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working</span><br><span class="line">     * with the Table class.</span><br><span class="line">     */</span><br><span class="line">    public function change(): void</span><br><span class="line">    &#123;</span><br><span class="line">        $table = $this-&gt;table(&#x27;users&#x27;, [&#x27;signed&#x27; =&gt; false]);</span><br><span class="line">        $table-&gt;addColumn(&#x27;name&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 16])</span><br><span class="line">            -&gt;addColumn(&#x27;email&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64])</span><br><span class="line">            -&gt;addColumn(&#x27;password&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64])</span><br><span class="line">            -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;])</span><br><span class="line">            -&gt;addIndex([&#x27;email&#x27;, &#x27;password&#x27;])</span><br><span class="line">            -&gt;create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邮箱和密码设置为关联索引，这样用户在登录的时候可以直接从索引返回查询结果，查询速度非常快。</p><p>created 是时间戳，直接使用当前时间作为值。</p><h3 id="文章表：articles"><a href="#文章表：articles" class="headerlink" title="文章表：articles"></a>文章表：articles</h3><ul><li>user_id：作者 ID</li><li>title：标题</li><li>classify：分类</li><li>cover：封面图</li><li>view_count：浏览次数</li><li>created：发布日期</li></ul><p>执行命令：<code>vendor/bin/phinx create ArticleContent</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">use Phinx\Migration\AbstractMigration;</span><br><span class="line"></span><br><span class="line">final class Article extends AbstractMigration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Change Method.</span><br><span class="line">     *</span><br><span class="line">     * Write your reversible migrations using this method.</span><br><span class="line">     *</span><br><span class="line">     * More information on writing migrations is available here:</span><br><span class="line">     * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method</span><br><span class="line">     *</span><br><span class="line">     * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working</span><br><span class="line">     * with the Table class.</span><br><span class="line">     */</span><br><span class="line">    public function change(): void</span><br><span class="line">    &#123;</span><br><span class="line">        $table = $this-&gt;table(&#x27;articles&#x27;, [&#x27;signed&#x27; =&gt; false]);</span><br><span class="line">        $table-&gt;addColumn(&#x27;title&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32])</span><br><span class="line">            -&gt;addColumn(&#x27;classify&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32])</span><br><span class="line">            -&gt;addColumn(&#x27;cover&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 255])</span><br><span class="line">            -&gt;addColumn(&#x27;user_id&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false])</span><br><span class="line">            -&gt;addColumn(&#x27;view_count&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false])</span><br><span class="line">            -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;])</span><br><span class="line">            -&gt;addIndex([&#x27;user_id&#x27;])</span><br><span class="line">            -&gt;create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文章内容表：article-contents"><a href="#文章内容表：article-contents" class="headerlink" title="文章内容表：article_contents"></a>文章内容表：article_contents</h3><ul><li>article_id：文章 ID</li><li>content：内容</li></ul><p>执行命令：<code>vendor/bin/phinx create ArticleContent</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">use Phinx\Migration\AbstractMigration;</span><br><span class="line"></span><br><span class="line">final class ArticleContent extends AbstractMigration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Change Method.</span><br><span class="line">     *</span><br><span class="line">     * Write your reversible migrations using this method.</span><br><span class="line">     *</span><br><span class="line">     * More information on writing migrations is available here:</span><br><span class="line">     * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method</span><br><span class="line">     *</span><br><span class="line">     * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working</span><br><span class="line">     * with the Table class.</span><br><span class="line">     */</span><br><span class="line">    public function change(): void</span><br><span class="line">    &#123;</span><br><span class="line">        $table = $this-&gt;table(&#x27;article_contents&#x27;, [&#x27;signed&#x27; =&gt; false]);</span><br><span class="line">        $table-&gt;addColumn(&#x27;article_id&#x27;, &#x27;integer&#x27;, [&#x27;signed&#x27; =&gt; false])</span><br><span class="line">            -&gt;addColumn(&#x27;content&#x27;, &#x27;text&#x27;)</span><br><span class="line">            -&gt;addIndex([&#x27;article_id&#x27;])</span><br><span class="line">            -&gt;create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="email-codes：邮件验证码"><a href="#email-codes：邮件验证码" class="headerlink" title="email_codes：邮件验证码"></a>email_codes：邮件验证码</h3><ul><li>email：邮箱</li><li>code：验证码</li><li>created：创建日期</li></ul><p>执行命令：<code>vendor/bin/phinx create EmailCode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">use Phinx\Migration\AbstractMigration;</span><br><span class="line"></span><br><span class="line">final class EmailCode extends AbstractMigration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Change Method.</span><br><span class="line">     *</span><br><span class="line">     * Write your reversible migrations using this method.</span><br><span class="line">     *</span><br><span class="line">     * More information on writing migrations is available here:</span><br><span class="line">     * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method</span><br><span class="line">     *</span><br><span class="line">     * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working</span><br><span class="line">     * with the Table class.</span><br><span class="line">     */</span><br><span class="line">    public function change(): void</span><br><span class="line">    &#123;</span><br><span class="line">        $table = $this-&gt;table(&#x27;email_codes&#x27;, [&#x27;signed&#x27; =&gt; false]);</span><br><span class="line">        $table-&gt;addColumn(&#x27;email&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64])</span><br><span class="line">            -&gt;addColumn(&#x27;code&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 8])</span><br><span class="line">            -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;])</span><br><span class="line">            -&gt;addIndex([&#x27;email&#x27;])</span><br><span class="line">            -&gt;create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成表"><a href="#生成表" class="headerlink" title="生成表"></a>生成表</h2><p>执行命令：<code>vendor/bin/phinx migrate</code></p><p>然后打开数据库，可以看到：</p><p><img src="https://i.loli.net/2021/02/19/BR72FLbv4SoQ1tU.jpg" alt="QQ20210219-193050.jpg"></p><p>生成了这些表之后，就可以直接用框架集成的 ORM 调用了。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>ORM 默认使用的表名即复数形式，也可以指定一个表名，只需要修改 $table 变量即可。</p><p>创建一个用来保存模型文件的目录 app&#x2F;Http&#x2F;Model。</p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/19</span><br><span class="line"> * Time：14:00</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace App\Http\Model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">    public $timestamps = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Article"><a href="#Article" class="headerlink" title="Article"></a>Article</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/19</span><br><span class="line"> * Time：19:43</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace App\Http\Model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class Article extends Model</span><br><span class="line">&#123;</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">    public $timestamps = false;</span><br><span class="line"></span><br><span class="line">    public function content()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;hasOne(ArticleContent::class)-&gt;withDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArticleContent"><a href="#ArticleContent" class="headerlink" title="ArticleContent"></a>ArticleContent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/19</span><br><span class="line"> * Time：19:43</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace App\Http\Model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class ArticleContent extends Model</span><br><span class="line">&#123;</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">    public $timestamps = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EmailCode"><a href="#EmailCode" class="headerlink" title="EmailCode"></a>EmailCode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/19</span><br><span class="line"> * Time：19:44</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace App\Http\Model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class EmailCode extends Model</span><br><span class="line">&#123;</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">    public $timestamps = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>现在数据库和模型已经设定好了，接下来就可以直接开始业务处理了！</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FireRabbitEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FireRabbit-Engine 实战 从零搭建个人博客（一）项目规划</title>
      <link href="/2021/02/19/firerabbit-engin-1/"/>
      <url>/2021/02/19/firerabbit-engin-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>居然非常不要脸的在标题写上自己引擎的名字了！</p><p>FireRabbit-Engine（火兔引擎）是基于 swoole 的 Laravel 劣质山寨版！</p><p>但是就性能而言，相比 Laravel 的提升非常巨大！</p><p>（这是 swoole 的功劳啊、喂！）</p><p>我要高呼框架的口号：有手就行，火兔引擎！</p><h2 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h2><p>为了测试框架的性能和发现框架的不足之处，因此我打算用一个博客系统来测试。</p><p>这个博客系统会包含博客应该具备的基本功能，但绝不是手把手每一步都写得清清楚楚。</p><p>而且我的前端技术也不咋样，于是这个博客系统干脆就不需要 css 代码……</p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>博客包含以下几个简单模块：</p><ul><li>登录&#x2F;注册（注册需要验证邮箱，顺便测试异步任务）</li><li>文章的增删改查</li><li>数据库迁移</li><li>权限认证（中间件来实现）</li><li>缓存</li></ul><h2 id="制作周期"><a href="#制作周期" class="headerlink" title="制作周期"></a>制作周期</h2><p>这几个模块只要一晚上就能完成，但是昨天晚上睡眠不足，</p><p>现在头有点昏昏沉沉，如果今天晚上没做完，就留到明天继续。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FireRabbitEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十九）封包，发到composer仓库！</title>
      <link href="/2021/02/19/my-swoole-framework-19/"/>
      <url>/2021/02/19/my-swoole-framework-19/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过年的假期也结束了，大家都陆续上班了。</p><p>2020 年我辞职回家一年也没有实现游戏梦，2021 年还有最后一次为梦想拼搏的机会。</p><p>再加上今年还有买房的梦想，所以今年开始没有太多任性的时间了，</p><p>如果家里有矿的话，我也想要归隐山林，专心钻研技术，无奈。</p><p>今年是毕业第五年的开始，五年……足以让一个人发生巨大的改变，</p><p>而我却连毕业时当架构师的梦想都没有实现，于是退而求其次才想要自己写一个框架。</p><p>即使是现在雏形完成了，但是技术方面还是没有很大的提升。</p><p>原因我很清楚，因为急于求成，因为想要证明自己给某个人看……</p><p>后悔的是大学没有好好学习，然悔之无用。</p><p>看过一部电视剧，里面有一句台词深深的触动了我：“当你觉得一切都晚了的时候，恰恰是最早的时机。”</p><p>在 30 岁之前幡然醒悟，也许是一种值得庆幸的事，如果再晚几年，恐怕翻身的机会只会愈加渺茫。</p><p>所以今年，2021 年，我要把握最后一年的机会，尽全力实现自己的游戏梦。</p><p>一边实现梦想，一边学好技术，打铁还需自身硬，只有自己变强了，才能掌控自己的生活。</p><h2 id="封装扩展包"><a href="#封装扩展包" class="headerlink" title="封装扩展包"></a>封装扩展包</h2><p>关于 composer 如何发布自己的扩展包，我在去年的时候写过一篇比较详细的文章了。</p><p>传送链接：<a href="https://huotublog.com/composer-package/">https://huotublog.com/composer-package/</a></p><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>因为用到了变量类型声明和返回值声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public function test(int num) : int &#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 PHP7.4 新增的功能，所以要对 PHP 的版本进行限制。</p><p>修改框架下的 composer.json 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;firerabbit/engine&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;基于swoole的个人框架。&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;火烧兔子&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;php&quot;: &quot;^7.4&quot;,</span><br><span class="line">    &quot;illuminate/database&quot;: &quot;^7.30&quot;,</span><br><span class="line">    &quot;xiaoler/blade&quot;: &quot;^5.4&quot;,</span><br><span class="line">    &quot;monolog/monolog&quot;: &quot;^2.2&quot;,</span><br><span class="line">    &quot;firebase/php-jwt&quot;: &quot;^5.2&quot;,</span><br><span class="line">    &quot;phpmailer/phpmailer&quot;: &quot;^6.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;FireRabbit\\Engine\\&quot;: &quot;src/&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files&quot;: [</span><br><span class="line">      &quot;src/function.php&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了限制 PHP 版本之外，添加了作者和描述信息。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>将框架的目录进行一番修改，大致如下：</p><p><img src="https://i.loli.net/2021/02/19/zMH3gN2DjJWoaAU.jpg" alt="QQ20210219-134228.jpg"></p><h2 id="Github-仓库"><a href="#Github-仓库" class="headerlink" title="Github 仓库"></a>Github 仓库</h2><p>Github 上创建一个公开的仓库。</p><p>然后将框架的代码上传至仓库。</p><p><img src="https://i.loli.net/2021/02/19/JpyXLvh6kqHV9AK.jpg" alt="QQ20210219-115347.jpg"></p><h2 id="Packagist-仓库"><a href="#Packagist-仓库" class="headerlink" title="Packagist 仓库"></a>Packagist 仓库</h2><p>接着发布到 composer 仓库。</p><p>地址：<a href="https://packagist.org/">https://packagist.org/</a></p><p>点击上面的 Submit 按钮，然后把 Github 的仓库地址复制过来，然后提交，检测包名字，没问题就继续点下一步。</p><p>等待 composer 抓取 github 的信息，完成之后显示如下界面：</p><p><img src="https://i.loli.net/2021/02/19/j6VymxTihnfwUJ8.jpg" alt="QQ20210219-120712.jpg"></p><p>说明已经成功传到 composer 的仓库了，现在这个包可供所有人拉取，但包还未指定版本号，因此仍然无法安装成功。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>任何包都需要有一个版本号，第一个版本可以计作：v1.0.0</p><p>版本号是个人自定义的，我定义的版本号规则如下：</p><ul><li>第一个 1，代表大版本，除非框架有翻天覆地的更新，否则这个版本不会改变，一旦大版本号改变就说明原来的代码已经无法保证正常使用了，不应该直接从旧版本升级到新版本，无法保证向下兼容</li><li>第二个 0，代表中版本号，此版本更新说明添加了一些新功能，但是兼容旧版，可以直接升级</li><li>第三个 0，代表小版本号，此版本更新说明一些微不足道的改变，例如优化代码或者结构，不影响正常使用，可以直接升级</li></ul><p>composer 包的版本是通过 git 标签实现的。</p><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0.0 -m &quot;初始版本&quot;</span><br><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure><p>发布一个标签之后，回到 Packagist 页面，看看右下角是否有更新，</p><p>如果没有更新，手动点击 Update 按钮，同步完成之后就可以看到右下角多出了一个 v1.0.0。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>现在就可以从远程仓库直接安装框架包了。</p><p>在任意位置创建一个空文件夹，然后进入文件夹，执行命令：<code>composer require firerabbit/engine</code></p><p>具体的使用方法可以参照框架的 readme 文件。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>框架部分大致就到这结束了，后续我还会不断更新框架功能。</p><p>接下来就要开始使用这个框架雏形来开发一个博客系统了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十八）异步任务</title>
      <link href="/2021/02/18/my-swoole-framework-18/"/>
      <url>/2021/02/18/my-swoole-framework-18/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>框架现在拥有发送邮件的能力了，但是发送邮件是非常耗时的一件事，</p><p>因此需要用异步任务来解决这个问题。</p><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>swoole 内置了异步任务处理，参照文档：<a href="https://wiki.swoole.com/#/start/start_task">https://wiki.swoole.com/#/start/start_task</a></p><p>一个简单的异步任务示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;set([</span><br><span class="line">    &#x27;task_worker_num&#x27; =&gt; 1,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;Request&#x27;, function ($request, $response) use ($http) &#123;</span><br><span class="line"></span><br><span class="line">    // 投递任务</span><br><span class="line">    $params = [&#x27;name&#x27; =&gt; &#x27;花花&#x27;];</span><br><span class="line">    $taskID = $http-&gt;task($params);</span><br><span class="line">    var_dump(&#x27;投递了一个任务，ID：&#x27; . $taskID . &#x27;，参数：&#x27; . json_encode($params, JSON_UNESCAPED_UNICODE));</span><br><span class="line"></span><br><span class="line">    $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);</span><br><span class="line">    $response-&gt;end(&#x27;&lt;h1&gt;Hello Swoole. #&#x27; . rand(1000, 9999) . &#x27;&lt;/h1&gt;&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//处理异步任务(此回调函数在task进程中执行)</span><br><span class="line">$http-&gt;on(&#x27;Task&#x27;, function ($serv, $task_id, $reactor_id, $data) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;收到任务，开始处理，任务ID：&#x27; . $task_id . &#x27;，参数：&#x27; . json_encode($data, JSON_UNESCAPED_UNICODE));</span><br><span class="line"></span><br><span class="line">    // 业务逻辑</span><br><span class="line">    $result = &#x27;那只猫的名字叫做&#x27; . $data[&#x27;name&#x27;];</span><br><span class="line"></span><br><span class="line">    //返回任务执行的结果</span><br><span class="line">    $serv-&gt;finish($result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//处理异步任务的结果(此回调函数在worker进程中执行)</span><br><span class="line">$http-&gt;on(&#x27;Finish&#x27;, function ($serv, $task_id, $data) &#123;</span><br><span class="line">    // 任务执行完成后的回调</span><br><span class="line">    var_dump(&#x27;【处理结果】任务ID：&#x27; . $task_id . &#x27;，返回结果：&#x27; . $data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>要开启任务，必须设置 <code>task_worker_num</code>，此参数是处理任务的进程数。</p><p>要投递一个任务，只要调用 server 的 task 方法即可，task 方法接收一个参数，执行完成后返回任务 ID。</p><p>投递的任务会在 task 事件中执行，要监听事件只需要调用 on 方法。</p><p>task 事件处理完成后的结果可以通知给 finish 事件，也可以不通知。</p><p>上述代码输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(59) &quot;投递了一个任务，ID：0，参数：&#123;&quot;name&quot;:&quot;花花&quot;&#125;&quot;</span><br><span class="line">string(71) &quot;收到任务，开始处理，任务ID：0，参数：&#123;&quot;name&quot;:&quot;花花&quot;&#125;&quot;</span><br><span class="line">string(78) &quot;【处理结果】任务ID：0，返回结果：那只猫的名字叫做花花&quot;</span><br></pre></td></tr></table></figure><p>如果多次执行，任务 ID 会从 0 开始不断加 1，第二个任务的 ID 为 1，第三个任务的 ID 为 2，以此类推。</p><p>如果关闭程序再重新启动，任务 ID 又会从 0 开始。</p><p>即使将 <code>task_worker_num</code> 改为 2 或者更大，ID 也是保持相同规则自增，因此可以判定 ID 是多个工作进程共享的，不会出现 ID 重复的情况。</p><h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p>swoole 的异步任务必须接受一个数组作为参数，而不能直接将对象作为参数传给任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 错误的方法</span><br><span class="line">$server-&gt;task(new MyTask());</span><br><span class="line"></span><br><span class="line"># 正确的方法</span><br><span class="line">$server-&gt;task([&#x27;name&#x27; =&gt; &#x27;花花&#x27;]);</span><br></pre></td></tr></table></figure><p>只要想起之前路由是怎么设计的，任务系统就很简单了。</p><p>既然只能传递数组作为参数，那只要传一个任务名称，再实际调用的时候实例化就可以了。</p><h2 id="实现任务"><a href="#实现任务" class="headerlink" title="实现任务"></a>实现任务</h2><p>分发任务必须要在 <code>Swoole\Http\Server</code>，因此原来的代码就需要修改一遍了。</p><h3 id="传参：server"><a href="#传参：server" class="headerlink" title="传参：server"></a>传参：server</h3><p>要调用任务的地方，目前只有 controller，因此 server 必须传给 controller。</p><p>只要修改路由模块传递参数即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理路由</span><br><span class="line"> * @param Server $server</span><br><span class="line"> * @param $request</span><br><span class="line"> * @param $response</span><br><span class="line"> */</span><br><span class="line">public function handle(Server $server, $request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    $route = $this-&gt;findRoute($request);</span><br><span class="line"></span><br><span class="line">    if ($route == null) &#123;</span><br><span class="line">        (new NotFoundResponse)-&gt;response($request, $response, $route);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $route-&gt;createResponse($server, $request, $response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle 多接收一个 server 参数，</p><p>然后再在实例化路由配置的时候把 server 传给路由，</p><p>路由实例化控制器的时候，再把 server 传给控制器就行了，详细的代码就不贴出来了。</p><p>控制器现在已经可以拿到 server 了，但这是 swoole 的方法，</p><h3 id="TaskInterface：标准任务接口"><a href="#TaskInterface：标准任务接口" class="headerlink" title="TaskInterface：标准任务接口"></a>TaskInterface：标准任务接口</h3><p>基于面向对象的思想，此处应该有封装。</p><p>在框架目录下新建 Task 目录，再创建 TaskInterface 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：20:23</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Task;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface TaskInterface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 处理逻辑</span><br><span class="line">     * @param $params</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function handle($params);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理完成回调</span><br><span class="line">     * @param $params</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function finish($result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口就是一个统一标准的 Task 类，以后用户想要创建一个任务，就实现这个接口。</p><p>handle 方法即 swoole 监听的 task 事件中处理任务逻辑的地方；</p><p>finish 方法即 swoole 监听的 finish 事件处理完任务执行回调的地方。</p><h3 id="Task：分发任务"><a href="#Task：分发任务" class="headerlink" title="Task：分发任务"></a>Task：分发任务</h3><p>统一的标准任务类已经有了，但还需要一个任务处理类，在 Task 文件夹下创建 Task 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：20:29</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Task;</span><br><span class="line"></span><br><span class="line">use Swoole\Http\Server;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分发一个任务</span><br><span class="line">     * @param Server $server</span><br><span class="line">     * @param TaskInterface $task</span><br><span class="line">     * @param array $data</span><br><span class="line">     * @return int</span><br><span class="line">     */</span><br><span class="line">    public static function dispatch(Server $server, string $task, array $data = []): int</span><br><span class="line">    &#123;</span><br><span class="line">        $params = [</span><br><span class="line">            &#x27;task&#x27; =&gt; $task,</span><br><span class="line">            &#x27;data&#x27; =&gt; $data,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        var_dump($task);</span><br><span class="line"></span><br><span class="line">        return $server-&gt;task($params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类只需要一个 dispatch 方法，接收任务类的名称以及附加参数。</p><p>然后再修改框架的 controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:16 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Controller;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Task\Task;</span><br><span class="line">use FireRabbitEngine\Module\Http\Kernel as HttpKernel;</span><br><span class="line"></span><br><span class="line">class Controller</span><br><span class="line">&#123;</span><br><span class="line">    protected $httpKernel;</span><br><span class="line"></span><br><span class="line">    public function __construct(HttpKernel $httpKernel)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;httpKernel = $httpKernel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分发任务</span><br><span class="line">     * @param $task</span><br><span class="line">     * @param $data</span><br><span class="line">     * @return int</span><br><span class="line">     */</span><br><span class="line">    public function dispatch($task, $data)</span><br><span class="line">    &#123;</span><br><span class="line">        $server = $this-&gt;httpKernel-&gt;getServer();</span><br><span class="line">        return Task::dispatch($server, $task, $data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showMessage($message)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;httpKernel-&gt;getResponse()-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">        $this-&gt;httpKernel-&gt;getResponse()-&gt;end($message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;httpKernel-&gt;getRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getResponse()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;httpKernel-&gt;getResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 是通过 httpKernel 在路由时传参得到的，</p><p>如果没有 server 就无法调用 swoole 的 task 方法。</p><p>controller 也声明了一个 dispatch 方法供用户直接调用。</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>执行任务是在 HttpServer 处通过监听 task 和 finish 两个事件。</p><p>修改 HttpServer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/15</span><br><span class="line"> * Time：16:26</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Auth\Auth;</span><br><span class="line">use FireRabbitEngine\Module\Cache\Cache;</span><br><span class="line">use FireRabbitEngine\Module\Constant;</span><br><span class="line">use FireRabbitEngine\Module\Database\Manager as DatabaseManager;</span><br><span class="line">use FireRabbitEngine\Module\Logger\Log as Logger;</span><br><span class="line">use FireRabbitEngine\Module\Mail\Mailer;</span><br><span class="line">use FireRabbitEngine\Module\Route\Router;</span><br><span class="line">use FireRabbitEngine\Module\Task\TaskInterface;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line">use Swoole\Http\Server;</span><br><span class="line"></span><br><span class="line">class HttpServer</span><br><span class="line">&#123;</span><br><span class="line">    public $server;</span><br><span class="line">    public $router;</span><br><span class="line"></span><br><span class="line">    public function __construct($host, $port, $config = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server = new Server($host, $port);</span><br><span class="line">        $this-&gt;server-&gt;set($config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function loadRouter(Router $router)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;router = $router;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function loadMiddleware($middleware)</span><br><span class="line">    &#123;</span><br><span class="line">        \FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig($middleware);</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function bootstrap($config)</span><br><span class="line">    &#123;</span><br><span class="line">        // 视图</span><br><span class="line">        Blade::setConfig($config[Constant::VIEW_CONFIG]);</span><br><span class="line">        // 数据库ORM</span><br><span class="line">        DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]);</span><br><span class="line">        // 日志</span><br><span class="line">        Logger::setConfig($config[Constant::LOGGER_CONFIG]);</span><br><span class="line">        // 缓存</span><br><span class="line">        $cache = $config[Constant::CACHE_CONFIG];</span><br><span class="line">        Cache::setConfig($cache[&#x27;driver&#x27;], $cache[$cache[&#x27;driver&#x27;]]);</span><br><span class="line">        // JWT</span><br><span class="line">        Auth::setConfig($config[Constant::JWT_CONFIG]);</span><br><span class="line">        // 邮件</span><br><span class="line">        Mailer::setConfig($config[Constant::MAIL_CONFIG]);</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">        $this-&gt;registerError($response);</span><br><span class="line">        $this-&gt;router-&gt;handle($this-&gt;server, $request, $response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function registerError($response)</span><br><span class="line">    &#123;</span><br><span class="line">        register_shutdown_function(function () use ($response) &#123;</span><br><span class="line">            $error = error_get_last();</span><br><span class="line">            var_dump($error);</span><br><span class="line">            switch ($error[&#x27;type&#x27;] ?? null) &#123;</span><br><span class="line">                case E_ERROR :</span><br><span class="line">                case E_PARSE :</span><br><span class="line">                case E_CORE_ERROR :</span><br><span class="line">                case E_COMPILE_ERROR :</span><br><span class="line">                    $response-&gt;status(500);</span><br><span class="line">                    $response-&gt;end($error[&#x27;message&#x27;]);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function task()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server-&gt;on(&#x27;task&#x27;, function ($server, $taskID, $reactorID, $data) &#123;</span><br><span class="line">            var_dump(&#x27;收到任务，开始处理，任务ID：&#x27; . $taskID . &#x27;，参数：&#x27; . json_encode($data));</span><br><span class="line"></span><br><span class="line">            if (isset($data[&#x27;task&#x27;]) &amp;&amp; class_exists($data[&#x27;task&#x27;])) &#123;</span><br><span class="line"></span><br><span class="line">                $task = new $data[&#x27;task&#x27;];</span><br><span class="line"></span><br><span class="line">                if ($task instanceof TaskInterface) &#123;</span><br><span class="line">                    $resultData = $task-&gt;handle($data[&#x27;data&#x27;]);</span><br><span class="line">                    $result = [</span><br><span class="line">                        &#x27;task&#x27; =&gt; $data[&#x27;task&#x27;],</span><br><span class="line">                        &#x27;result&#x27; =&gt; $resultData ?? null,</span><br><span class="line">                    ];</span><br><span class="line">                    $server-&gt;finish($result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function finish()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server-&gt;on(&#x27;finish&#x27;, function ($server, $taskID, $data) &#123;</span><br><span class="line">            var_dump(&#x27;任务处理完了，任务ID：&#x27; . $taskID);</span><br><span class="line"></span><br><span class="line">            if (isset($data[&#x27;task&#x27;]) &amp;&amp; class_exists($data[&#x27;task&#x27;])) &#123;</span><br><span class="line"></span><br><span class="line">                $task = new $data[&#x27;task&#x27;];</span><br><span class="line"></span><br><span class="line">                if ($task instanceof TaskInterface) &#123;</span><br><span class="line">                    $task-&gt;finish($data[&#x27;result&#x27;]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function start()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server-&gt;on(&#x27;request&#x27;, [$this, &#x27;request&#x27;]);</span><br><span class="line">        $this-&gt;server-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新增了两个方法：task 和 finish，只要调用此方法即可实现监听事件。</p><h3 id="开启监听"><a href="#开启监听" class="headerlink" title="开启监听"></a>开启监听</h3><p>在启动程序 http_server.php 处新增监听事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Http\HttpServer;</span><br><span class="line"></span><br><span class="line">date_default_timezone_set(&quot;Asia/Shanghai&quot;);</span><br><span class="line">define(&#x27;ROOT_PATH&#x27;, __DIR__);</span><br><span class="line"></span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">$config = require &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">$server = new HttpServer(&#x27;0.0.0.0&#x27;, 9527, [</span><br><span class="line">    &#x27;worker_num&#x27; =&gt; 4,</span><br><span class="line">    &#x27;task_worker_num&#x27; =&gt; 1,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$router = require &#x27;./app/route/web.php&#x27;;</span><br><span class="line">$middleware = require &#x27;./app/config/middleware.php&#x27;;</span><br><span class="line"></span><br><span class="line">$server-&gt;task();</span><br><span class="line">$server-&gt;finish();</span><br><span class="line"></span><br><span class="line">$server-&gt;bootstrap($config[&#x27;framework&#x27;])</span><br><span class="line">    -&gt;loadMiddleware($middleware)</span><br><span class="line">    -&gt;loadRouter($router)</span><br><span class="line">    -&gt;start();</span><br></pre></td></tr></table></figure><p>task 和 finish 必须在 start 之前，</p><p>而且 swoole 的参数必须加上 <code>task_worker_num</code>，该值是处理事件的进程数量。</p><blockquote><p>通俗的讲 task_worker_num 就是工具人的数量，工具人越多，堆积的任务处理速度越快，swoole 会轮询分发给工具人任务，工具人至少也要有 1 个，如果没有工具人谁来干活呢？</p></blockquote><p>由于我的博客系统只需要发送邮件这个简单的任务，并不会堆积很多，所以只需要 1 个进程用来处理任务就够了。</p><h2 id="项目任务"><a href="#项目任务" class="headerlink" title="项目任务"></a>项目任务</h2><p>前面已经完成了邮件系统，现在可以把发送邮件当做异步任务来执行了。</p><p>在博客项目新建存放任务类的文件夹 app&#x2F;Http&#x2F;Task，再创建一个用来发送邮件的任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：21:46</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Task;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Mail\Mailer;</span><br><span class="line">use FireRabbitEngine\Module\Task\TaskInterface;</span><br><span class="line"></span><br><span class="line">class MailTask implements TaskInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function handle($params)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;调用handle处理任务&#x27;);</span><br><span class="line"></span><br><span class="line">        $mailer = new Mailer();</span><br><span class="line">        $mailer-&gt;subject(&#x27;测试异步任务发送邮件&#x27;)</span><br><span class="line">            -&gt;body(&#x27;这是邮件内容&#x27;)</span><br><span class="line">            -&gt;address($params[&#x27;email&#x27;])</span><br><span class="line">            -&gt;send();</span><br><span class="line"></span><br><span class="line">        return &#x27;发送成功&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function finish($result)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 controller 添加测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use App\Http\Task\MailTask;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;dispatch(MailTask::class, [&#x27;email&#x27; =&gt; &#x27;874811226@qq.com&#x27;]);</span><br><span class="line">        $this-&gt;showMessage(&#x27;ok&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(17) &quot;请求URI：/test&quot;</span><br><span class="line">string(126) &quot;收到任务，开始处理，任务ID：0，参数：&#123;&quot;task&quot;:&quot;App\\Http\\Task\\MailTask&quot;,&quot;data&quot;:&#123;&quot;email&quot;:&quot;874811226@qq.com&quot;&#125;&#125;&quot;</span><br><span class="line">string(24) &quot;调用handle处理任务&quot;</span><br><span class="line">string(33) &quot;任务处理完了，任务ID：0&quot;</span><br><span class="line">string(12) &quot;发送成功&quot;</span><br></pre></td></tr></table></figure><p>并且邮箱也能正常收到测试邮件。</p><p>如此一来，框架的异步任务也算完成了。</p><h2 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h2><p>swoole 提供了毫秒定时器，可以用来延迟分发任务。</p><p>而定时器又分为 after（一次性）与 tick（重复）两种类型。</p><p>一次性定时器执行完就会销毁，而重复定时器则会间隔执行，直到手动销毁为止。</p><p>Swoole 官方文档：<a href="https://wiki.swoole.com/#/timer">swoole - 定时器</a></p><h3 id="一次性任务"><a href="#一次性任务" class="headerlink" title="一次性任务"></a>一次性任务</h3><p>调用 delay 即可实现延迟发布任务。</p><h3 id="重复性任务"><a href="#重复性任务" class="headerlink" title="重复性任务"></a>重复性任务</h3><p>例如每隔半小时就将缓存中的数据写入到数据库，或者是爬虫任务每小时执行一次，诸如此类。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>修改 Task 类，添加对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：20:29</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Task;</span><br><span class="line"></span><br><span class="line">use Swoole\Http\Server;</span><br><span class="line">use Swoole\Timer;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分发一个任务</span><br><span class="line">     * @param Server $server</span><br><span class="line">     * @param TaskInterface $task</span><br><span class="line">     * @param array $data</span><br><span class="line">     * @return int</span><br><span class="line">     */</span><br><span class="line">    public static function dispatch(Server $server, string $task, array $data = []): int</span><br><span class="line">    &#123;</span><br><span class="line">        $params = [</span><br><span class="line">            &#x27;task&#x27; =&gt; $task,</span><br><span class="line">            &#x27;data&#x27; =&gt; $data,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return $server-&gt;task($params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 延迟分发任务</span><br><span class="line">     * @param Server $server</span><br><span class="line">     * @param int $ms</span><br><span class="line">     * @param string $task</span><br><span class="line">     * @param array $data</span><br><span class="line">     */</span><br><span class="line">    public static function delay(Server $server, int $ms, string $task, array $data = []): int</span><br><span class="line">    &#123;</span><br><span class="line">        $params = [</span><br><span class="line">            &#x27;task&#x27; =&gt; $task,</span><br><span class="line">            &#x27;data&#x27; =&gt; $data,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return Timer::after($ms, function () use ($server, $params) &#123;</span><br><span class="line">            $server-&gt;task($params);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function tick(Server $server, int $ms, string $task, array $data = []): int</span><br><span class="line">    &#123;</span><br><span class="line">        $params = [</span><br><span class="line">            &#x27;task&#x27; =&gt; $task,</span><br><span class="line">            &#x27;data&#x27; =&gt; $data,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return Timer::tick(1000, function () use ($server, $params) &#123;</span><br><span class="line">            $server-&gt;task($params);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function clear(int $timerID): bool</span><br><span class="line">    &#123;</span><br><span class="line">        return Timer::clear($timerID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行延迟任务时，可以返回一个 int 类型的时钟 ID，调用 clear 可以将定时器清除。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十七）发送邮件</title>
      <link href="/2021/02/18/my-swoole-framework-17/"/>
      <url>/2021/02/18/my-swoole-framework-17/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人站长一般很难支付起短信的费用，因此邮件认证比较适合个人站长。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>发送邮件是完全免费的，只要搭建一台用于发送邮件的服务器即可，</p><p>但是搭建邮件服务器的成本太昂贵了，因此我选择使用第三方提供的邮箱服务。</p><p>市面上的各大邮箱基本都是免费注册的，比如 QQ 邮箱，163 邮箱等等。</p><p>每种邮箱配置大同小异，我选择网易的 163 邮箱作为演示。</p><p>网易邮箱：<a href="https://www.163.com/">https://www.163.com/</a></p><p>右上角即可免费注册，注册成功后，进入个人中心，点击上方的“设置”，然后可以看到 <strong>POP3&#x2F;SMTP&#x2F;IMAP</strong>。</p><p>下方有两个可以选择的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMAP/SMTP服务已关闭 | 开启</span><br><span class="line">POP3/SMTP服务已关闭 | 开启</span><br></pre></td></tr></table></figure><p>选择 <code>POP3/SMTP</code> 右边的“开启”按钮，网易会要求你发送短信进行认证，认证后就可以开通了。</p><p>然后会获得一段用于验证的“神秘代码”，要把这个代码存下来，一旦关闭页面就无法再次查看了（但是可以重新创建）。</p><p>这样就申请好一个可以发送邮件的邮箱了。</p><h2 id="安装插件包"><a href="#安装插件包" class="headerlink" title="安装插件包"></a>安装插件包</h2><p>PHP 内置的方法也可以发送邮件，但是我选择使用一个比较成熟的插件包：<code>phpmailer/phpmailer</code>。</p><p>在框架目录下执行：<code>composer require phpmailer/phpmailer</code></p><p>即可完成安装。</p><h2 id="Mailer"><a href="#Mailer" class="headerlink" title="Mailer"></a>Mailer</h2><p>插件安装完成后，需要封装成方便调用的形式。</p><p>在框架目录新建一个 Mail 文件夹用来保存邮件发送相关代码，并且创建 Mailer 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：14:29</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Mail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use PHPMailer\PHPMailer\PHPMailer;</span><br><span class="line"></span><br><span class="line">class Mailer</span><br><span class="line">&#123;</span><br><span class="line">    protected static $mail;</span><br><span class="line">    protected static $config;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 轮询计数器</span><br><span class="line">     * @var int</span><br><span class="line">     */</span><br><span class="line">    protected static $sort = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 邮件节点</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected static $pool = [];</span><br><span class="line"></span><br><span class="line">    protected $subject, $body, $altBody, $reciverMail;</span><br><span class="line"></span><br><span class="line">    public static function setConfig($config)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$config = $config;</span><br><span class="line">        self::$pool = $config[&#x27;pool&#x27;];</span><br><span class="line"></span><br><span class="line">        self::$mail = new PHPMailer();</span><br><span class="line">        self::$mail-&gt;isSMTP();</span><br><span class="line">        self::$mail-&gt;SMTPAuth = true;</span><br><span class="line">        self::$mail-&gt;SMTPDebug = $config[&#x27;debug&#x27;];</span><br><span class="line">        self::$mail-&gt;isHTML($config[&#x27;html&#x27;]);</span><br><span class="line">        self::$mail-&gt;SMTPSecure = $config[&#x27;secure&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function subject($title)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;subject = $title;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function body($html)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;body = $html;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function altBody($text)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;altBody = $text;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function address($mail)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;reciverMail = $mail;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        $node = self::$pool[self::$sort];</span><br><span class="line"></span><br><span class="line">        self::$sort++;</span><br><span class="line"></span><br><span class="line">        if (self::$sort &gt;= count(self::$pool)) &#123;</span><br><span class="line">            self::$sort = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 载入节点配置</span><br><span class="line">        self::$mail-&gt;Host = $node[&#x27;host&#x27;];</span><br><span class="line">        self::$mail-&gt;Port = $node[&#x27;port&#x27;];</span><br><span class="line">        self::$mail-&gt;Username = $node[&#x27;user&#x27;];</span><br><span class="line">        self::$mail-&gt;Password = $node[&#x27;password&#x27;];</span><br><span class="line">        self::$mail-&gt;setFrom($node[&#x27;user&#x27;], $node[&#x27;name&#x27;]);</span><br><span class="line">        self::$mail-&gt;addReplyTo($node[&#x27;user&#x27;], $node[&#x27;name&#x27;]);</span><br><span class="line"></span><br><span class="line">        // 生成邮件信息</span><br><span class="line">        self::$mail-&gt;addAddress($this-&gt;reciverMail);</span><br><span class="line">        self::$mail-&gt;Subject = $this-&gt;subject;</span><br><span class="line">        self::$mail-&gt;Body = $this-&gt;body;</span><br><span class="line">        self::$mail-&gt;AltBody = $this-&gt;altBody ?? &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">        self::$mail-&gt;send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mailer 类重新封装了插件包发送邮件的代码，外部调用起来方便多了。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>一个 163 邮箱大约每天只能发送 500-1500 封邮件，</p><p>一旦超过这个数，网易就会限制该账户继续发送邮件。</p><p>为了避免被限制导致业务无法正常执行，通常我们需要申请很多个邮箱（毕竟注册免费）。</p><p>然后类似负载均衡一样轮询多个邮箱，所以在 Mailer 类有一个用来控制轮询的变量 <code>$sort</code>，</p><p>并且在 <code>send</code> 方法动态获取节点配置。</p><p>因此需要配置足够多的邮箱以供邮件系统调用，编辑 app.php，添加邮件相关配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Constant::MAIL_CONFIG =&gt; [</span><br><span class="line">    &#x27;debug&#x27; =&gt; 1,</span><br><span class="line">    &#x27;html&#x27; =&gt; true,</span><br><span class="line">    &#x27;secure&#x27; =&gt; &#x27;ssl&#x27;,</span><br><span class="line">    &#x27;pool&#x27; =&gt; [</span><br><span class="line">        [</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; 465,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;huotu_001@163.com&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;火兔博客1号&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;,</span><br><span class="line">        ],[</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; 465,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;huotu_002@163.com&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;火兔博客2号&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;,</span><br><span class="line">        ],[</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;smtp.163.com&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; 465,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;huotu_003@163.com&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;火兔博客3号&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;xxxx&#x27;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>通过增加 <code>pool</code> 内邮箱的数量，即可实现一天发送成千上万封邮件。</p><p>而且邮箱的配置完全是独立的，不仅可以在这里配置 163 邮箱，QQ 邮箱同样可以。</p><p>只要注册多个平台的多个邮箱，这个邮件系统的稳定性就越强，一般而言，个人博客配置 2-5 个邮箱就差不多了。</p><p>具体数量根据博客的功能决定，如果发送邮件的场景只有注册和找回密码，那配置 2 个就差不多了；</p><p>如果你想要在发布新文章的时候，同时发送一封邮件通知博客的订阅者，那就要多准备一些了（反正申请邮箱不要钱）。</p><h2 id="实战调用"><a href="#实战调用" class="headerlink" title="实战调用"></a>实战调用</h2><p>在需要发送邮件的场景，调用 Mailer 提供的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line">use FireRabbitEngine\Module\Mail\Mailer;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        $mail = new Mailer();</span><br><span class="line">        $mail-&gt;subject(&#x27;测测&#x27;)</span><br><span class="line">            -&gt;body(&#x27;bbb&#x27;)</span><br><span class="line">            -&gt;altBody(&#x27;xxxx&#x27;)</span><br><span class="line">            -&gt;address(&#x27;874811226@qq.com&#x27;)</span><br><span class="line">            -&gt;send();</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage(&#x27;ok&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试，邮件确实可以正常发送。</p><p>值得一提的是，这里的 <code>body</code> 方法可以接收 HTMl 代码，</p><p>因此可以结合 blade 模板发出十分美观的邮件。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十六）JWT用户认证</title>
      <link href="/2021/02/18/my-swoole-framework-16/"/>
      <url>/2021/02/18/my-swoole-framework-16/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户认证模块也是网页中非常重要的一个环节，</p><p>比如接口无法使用 session，因此只能传一个特殊的参数 “token”，</p><p>token 是一个加密的字符串，在服务端进行解密，如果没问题就代表认证成功。</p><p>由于自己写的加密系统不安全，所以直接使用比较成熟的加密系统——JWT。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>jwt 模块集成在框架里，因此要进入框架目录进行安装，而不是直接安装在博客系统里面。</p><p>执行命令：<code>composer requiire firebase/php-jwt</code>。</p><h2 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h2><p>上一个步骤已经安装了 jwt 插件包，用户只需要关注加密和解密，</p><p>对 jwt 具体是怎么实现的，则不需要了解。</p><p>因此我封装了一个 Auth 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：12:19</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Auth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Firebase\JWT\JWT;</span><br><span class="line"></span><br><span class="line">class Auth</span><br><span class="line">&#123;</span><br><span class="line">    protected static $config;</span><br><span class="line"></span><br><span class="line">    public static function setConfig($config)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$config = $config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function decode($token)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JWT::$leeway = self::$config[&#x27;leeway&#x27;];</span><br><span class="line">            $decoded = JWT::decode($token, self::$config[&#x27;key&#x27;], [self::$config[&#x27;alg&#x27;]]);</span><br><span class="line">            $data = (array)$decoded;</span><br><span class="line"></span><br><span class="line">            return $data[&#x27;data&#x27;] ?? null;</span><br><span class="line">        &#125; catch (\Exception $e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function encode($data, $expired)</span><br><span class="line">    &#123;</span><br><span class="line">        $currentTimestamp = time();</span><br><span class="line">        $key = self::$config[&#x27;key&#x27;];</span><br><span class="line"></span><br><span class="line">        $token = [</span><br><span class="line">            &#x27;iat&#x27; =&gt; $currentTimestamp,</span><br><span class="line">            &#x27;nbf&#x27; =&gt; $currentTimestamp,</span><br><span class="line">            &#x27;exp&#x27; =&gt; $currentTimestamp + $expired,</span><br><span class="line">            &#x27;data&#x27; =&gt; $data,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        return JWT::encode($token, $key, self::$config[&#x27;alg&#x27;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户只需要调用 Auth 暴露的加密和解密方法即可。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>在 app.php 添加新的配置参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant::JWT_CONFIG =&gt; [</span><br><span class="line">    &#x27;key&#x27; =&gt; &#x27;password&#x27;,</span><br><span class="line">    &#x27;alg&#x27; =&gt; &#x27;HS256&#x27;,</span><br><span class="line">    &#x27;leeway&#x27; =&gt; 60,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>其中 <code>key</code> 是加密字符串，<code>alg</code> 是加密方法，</p><p><code>leeway</code> 是时间偏差值，意思是说这个 token 在这个偏差的时间内都可以算作认证成功(防止服务器时钟偏差)。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>在 test 方法添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Auth\Auth;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        $token = Auth::encode([</span><br><span class="line">            &#x27;test&#x27; =&gt; 123,</span><br><span class="line">        ], 60);</span><br><span class="line"></span><br><span class="line">        var_dump($token, base64_decode($token));</span><br><span class="line"></span><br><span class="line">        $value = Auth::decode($token);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage(json_encode($value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的 <code>encode</code> 的参数是一个数组，即用户的信息，可以是用户的 ID，</p><p>但绝对不能是密码或者其他敏感信息，因为 jwt 最终生成的 token 使用的是 base64，可以轻松解密。</p><p>上述代码打印的结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string(17) &quot;请求URI：/test&quot;</span><br><span class="line">string(177) &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MTM2MjUwMTIsIm5iZiI6MTYxMzYyNTAxMiwiZXhwIjoxNjEzNjI1MDcyLCJkYXRhIjp7InRlc3QiOjEyM319.ygfIeSOkifgPqWyUyIb5rJFLnHlaYMvGTue0WEsTvP4&quot;</span><br><span class="line">string(131) &quot;&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;&#123;&quot;iat&quot;:1613625012,&quot;nbf&quot;:1613625012,&quot;exp&quot;:1613625072,&quot;data&quot;:&#123;&quot;test&quot;:123&#125;&#125;��y#����l�Ȇ���K�yZ`��N�XK��&quot;</span><br><span class="line">object(stdClass)#30 (1) &#123;</span><br><span class="line">  [&quot;test&quot;]=&gt;</span><br><span class="line">  int(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，JWT 加密模块就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十五）缓存模块</title>
      <link href="/2021/02/18/my-swoole-framework-15/"/>
      <url>/2021/02/18/my-swoole-framework-15/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存可以大幅提高程序的性能以及减轻数据库压力。</p><p>今天就来设计框架的缓存模块。</p><p>缓存可以用很多种方法实现，例如：redis、数据库或者文件。</p><p>从性能来看，redis 是最优的，因此本框架将会使用 redis 作为缓存系统。</p><h2 id="驱动接口"><a href="#驱动接口" class="headerlink" title="驱动接口"></a>驱动接口</h2><p>虽然现在使用 redis 作为缓存驱动，但是未来可能会添加其他的。</p><p>因此将缓存驱动声明为一个接口，以后就不需要修改业务代码了。</p><p>在框架目录下新建一个 Cache 文件夹用来存放缓存相关的代码。</p><p>接着声明一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：10:54</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Cache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">interface DriverInterface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 载入参数</span><br><span class="line">     * @param $config</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function load($config);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 含有过期时间的键值对</span><br><span class="line">     * @param string $key</span><br><span class="line">     * @param int $ttl</span><br><span class="line">     * @param Closure $initFun</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    public function remember(string $key, int $ttl, Closure $initFun): string;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 没有过期时间的键值对</span><br><span class="line">     * @param string $key</span><br><span class="line">     * @param Closure $initFun</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    public function rememberForever(string $key, Closure $initFun): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂且实现两个键值对缓存的方法，</p><p><code>remember</code> 记住一个键值对 ttl 秒；</p><p><code>rememberForever</code> 记住一个键值对，且不过期。</p><p>上述两个方法如果没有默认值，则从 <code>$initFun</code> 闭包函数中获取，同时将数据写入缓存。</p><p>除此之外，还有一个 <code>load</code> 方法用于获取缓存的配置信息。</p><h2 id="RedisDriver"><a href="#RedisDriver" class="headerlink" title="RedisDriver"></a>RedisDriver</h2><p>接着在 Cache 下新建一个 Driver 文件夹，用来保存对应的驱动。</p><p>创建 RedisDriver，让它实现 DriverInterface：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：10:53</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Cache\Driver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line">use FireRabbitEngine\Module\Cache\DriverInterface;</span><br><span class="line"></span><br><span class="line">class RedisDriver implements DriverInterface</span><br><span class="line">&#123;</span><br><span class="line">    protected $instance;</span><br><span class="line"></span><br><span class="line">    public function load($config)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;instance = new \Redis();</span><br><span class="line">        $this-&gt;instance-&gt;connect($config[&#x27;host&#x27;], $config[&#x27;port&#x27;]);</span><br><span class="line">        $this-&gt;instance-&gt;auth($config[&#x27;password&#x27;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function remember($key, int $ttl, Closure $initFun): string</span><br><span class="line">    &#123;</span><br><span class="line">        $value = $this-&gt;instance-&gt;get($key);</span><br><span class="line"></span><br><span class="line">        if ($value !== false) &#123;</span><br><span class="line">            var_dump(&#x27;从缓存获取&#x27;);</span><br><span class="line"></span><br><span class="line">            return $value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_dump(&#x27;从闭包获取&#x27;);</span><br><span class="line"></span><br><span class="line">        $value = $initFun();</span><br><span class="line">        $this-&gt;instance-&gt;setEx($key, $ttl, $value);</span><br><span class="line"></span><br><span class="line">        return $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function rememberForever($key, Closure $initFun): string</span><br><span class="line">    &#123;</span><br><span class="line">        $value = $this-&gt;instance-&gt;get($key);</span><br><span class="line"></span><br><span class="line">        if ($value !== false) &#123;</span><br><span class="line">            return $value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $value = $initFun();</span><br><span class="line">        $this-&gt;instance-&gt;set($key, $value);</span><br><span class="line"></span><br><span class="line">        return $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 驱动直接调用 PHP 的 redis 扩展提供的方法。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>现在有了缓存驱动，但是并不是直接在控制器或者其他地方实例化这个缓存驱动来调用。</p><p>而是创建一个通用的 Cache 类来让用户调用，</p><p>如果不这样做，项目的缓存系统就相当于写死了，以后如果要把 redis 换成数据库缓存就很麻烦。</p><p>因此我们提供一个 Cache 类，用户只要调用 Cache 暴露出来的方法即可。</p><p>在框架的 Cache 目录下新建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/18</span><br><span class="line"> * Time：10:53</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Cache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Cache\Driver\RedisDriver;</span><br><span class="line"></span><br><span class="line">class Cache</span><br><span class="line">&#123;</span><br><span class="line">    protected static DriverInterface $driver;</span><br><span class="line"></span><br><span class="line">    public static function setConfig($cache, $config)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($cache) &#123;</span><br><span class="line">            case &#x27;redis&#x27;:</span><br><span class="line">                self::redisDriver($config);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static function redisDriver($config)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$driver = new RedisDriver();</span><br><span class="line">        self::$driver-&gt;load($config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function driver(): DriverInterface</span><br><span class="line">    &#123;</span><br><span class="line">        return self::$driver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cache 类对外提供了 <code>driver</code> 方法用于获取缓存驱动，</p><p>用户调用框架的缓存系统时，只需要从 driver 方法获得缓存驱动的实例，</p><p>然后再调用 DriverInterface 声明的标准方法即可。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>缓存系统需要在启动程序的时候连接到 redis，</p><p>因此声明一个新的常量，然后在 app.php 添加框架配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Constant::CACHE_CONFIG =&gt; [</span><br><span class="line">    &#x27;driver&#x27; =&gt; &#x27;redis&#x27;,</span><br><span class="line">    &#x27;redis&#x27; =&gt; [</span><br><span class="line">        &#x27;host&#x27; =&gt; &#x27;redis&#x27;,</span><br><span class="line">        &#x27;port&#x27; =&gt; &#x27;6379&#x27;,</span><br><span class="line">        &#x27;password&#x27; =&gt; &#x27;123123&#x27;,</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接着，在封装好的启动程序 HttpServer 初始化时加入缓存系统的初始化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public function bootstrap($config)</span><br><span class="line">&#123;</span><br><span class="line">    Blade::setConfig($config[Constant::VIEW_CONFIG]);</span><br><span class="line">    DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]);</span><br><span class="line">    Logger::setConfig($config[Constant::LOGGER_CONFIG]);</span><br><span class="line"></span><br><span class="line">    // 新增代码</span><br><span class="line">    $cache = $config[Constant::CACHE_CONFIG];</span><br><span class="line">    Cache::setConfig($cache[&#x27;driver&#x27;], $cache[$cache[&#x27;driver&#x27;]]);</span><br><span class="line"></span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，缓存系统就算完成了。</p><h2 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h2><p>创建一个 test 路由，控制器的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Cache\Cache;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        $value = Cache::driver()-&gt;remember(&#x27;test&#x27;, 5, function () &#123;</span><br><span class="line">            return &#x27;aaa&#x27;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage(json_encode($value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从缓存驱动中获取名称为 “test” 的键，如果不存在则执行闭包，</p><p>闭包里面是用户的业务逻辑，例如从数据库查询数据等等，最终将结果以字符串的形式返回，</p><p>缓存系统将闭包返回的值写入到缓存，最后再把该值返回。</p><p>通俗的讲，就是 <strong>从缓存获取该键的值，如果没有就执行闭包的函数进行初始化。</strong></p><p>测试结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@0a71c06b420b:/www/blog# php http_server.php </span><br><span class="line">string(17) &quot;请求URI：/test&quot;</span><br><span class="line">string(15) &quot;从闭包获取&quot;</span><br><span class="line">string(17) &quot;请求URI：/test&quot;</span><br><span class="line">string(15) &quot;从缓存获取&quot;</span><br><span class="line"></span><br><span class="line"># 间隔5秒后再访问</span><br><span class="line">string(17) &quot;请求URI：/test&quot;</span><br><span class="line">string(15) &quot;从闭包获取&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，第一次因为缓存没有数据，因此执行了闭包的函数，</p><p>第二次缓存已经有数据了，所以直接返回缓存中的数据，证明了闭包成功将数据写入到缓存了。</p><p>然后 5 秒之后再访问，可以发现又调用了闭包，证明缓存在 5 秒的时候过期了。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>键值对只是 redis 的基本类型，后续还会加入更多的操作方法。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十四）启动程序优化</title>
      <link href="/2021/02/17/my-swoole-framework-14/"/>
      <url>/2021/02/17/my-swoole-framework-14/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面几篇文章临时修改程序的启动文件，结果变成如下这般惨不忍睹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">date_default_timezone_set(&quot;Asia/Shanghai&quot;);</span><br><span class="line"></span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br><span class="line">require_once &#x27;./app/route/web.php&#x27;;</span><br><span class="line">require_once &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">\FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);</span><br><span class="line">\FireRabbitEngine\Module\View\Blade::setConfig($config[&#x27;view&#x27;][&#x27;view_path&#x27;], $config[&#x27;view&#x27;][&#x27;view_cache_path&#x27;]);</span><br><span class="line">\FireRabbitEngine\Module\Database\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);</span><br><span class="line"></span><br><span class="line">// 新增行</span><br><span class="line">\FireRabbitEngine\Module\Logger\Log::setConfig($config[&#x27;logger&#x27;]);</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数的加载方式也需要优化一下，接下来就开始整改。</p><h2 id="参数文件统一"><a href="#参数文件统一" class="headerlink" title="参数文件统一"></a>参数文件统一</h2><p>除了路由配置和中间件映射关系配置，其他的都可以移动到 app.pho 统一管理。</p><p>比如数据库的配置、redis 的配置、模板文件的存放位置等，都属于项目的配置。</p><p>因此将原来几个单独的配置文件删掉，统一放到 app.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Constant;</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line">    &#x27;framework&#x27; =&gt; [</span><br><span class="line">        Constant::DATABASE_CONFIG =&gt; [</span><br><span class="line">            &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;database&#x27; =&gt; &#x27;blog&#x27;,</span><br><span class="line">            &#x27;username&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;123123&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">            &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;,</span><br><span class="line">            &#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        Constant::LOGGER_CONFIG =&gt; [</span><br><span class="line">            &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../storage/logs/log.log&#x27;,</span><br><span class="line">            &#x27;level&#x27; =&gt; &#x27;info&#x27;,</span><br><span class="line">            &#x27;channel&#x27; =&gt; &#x27;channel-name&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        Constant::VIEW_CONFIG =&gt; [</span><br><span class="line">            &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;,</span><br><span class="line">            &#x27;cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个 Constant 类是框架配置的常量，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/16</span><br><span class="line"> * Time：10:08</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module;</span><br><span class="line"></span><br><span class="line">class Constant</span><br><span class="line">&#123;</span><br><span class="line">    const DATABASE_CONFIG = &#x27;firerabbiit_database&#x27;;</span><br><span class="line">    const LOGGER_CONFIG = &#x27;firerabbit_logger&#x27;;</span><br><span class="line">    const VIEW_CONFIG = &#x27;firerabbit_view&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是统一配置的键名。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>框架现在是直接使用 swoole 的函数来启动程序，</p><p>基于面向对象的思想，现在把 server 也封装为一个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/15</span><br><span class="line"> * Time：16:26</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Constant;</span><br><span class="line">use FireRabbitEngine\Module\Database\Manager as DatabaseManager;</span><br><span class="line">use FireRabbitEngine\Module\Logger\Log as Logger;</span><br><span class="line">use FireRabbitEngine\Module\Route\Router;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line">use Swoole\Http\Server;</span><br><span class="line"></span><br><span class="line">class HttpServer</span><br><span class="line">&#123;</span><br><span class="line">    public $server;</span><br><span class="line">    public $router;</span><br><span class="line"></span><br><span class="line">    public function __construct($host, $port, $config = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server = new Server($host, $port);</span><br><span class="line">        $this-&gt;server-&gt;set($config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function loadRouter(Router $router)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;router = $router;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function loadMiddleware($middleware)</span><br><span class="line">    &#123;</span><br><span class="line">        \FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig($middleware);</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function bootstrap($config)</span><br><span class="line">    &#123;</span><br><span class="line">        Blade::setConfig($config[Constant::VIEW_CONFIG]);</span><br><span class="line">        DatabaseManager::setConfig($config[Constant::DATABASE_CONFIG]);</span><br><span class="line">        Logger::setConfig($config[Constant::LOGGER_CONFIG]);</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">        $this-&gt;registerError($response);</span><br><span class="line">        $this-&gt;router-&gt;handle($request, $response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function registerError($response)</span><br><span class="line">    &#123;</span><br><span class="line">        register_shutdown_function(function () use ($response) &#123;</span><br><span class="line">            $error = error_get_last();</span><br><span class="line">            var_dump($error);</span><br><span class="line">            switch ($error[&#x27;type&#x27;] ?? null) &#123;</span><br><span class="line">                case E_ERROR :</span><br><span class="line">                case E_PARSE :</span><br><span class="line">                case E_CORE_ERROR :</span><br><span class="line">                case E_COMPILE_ERROR :</span><br><span class="line">                    $response-&gt;status(500);</span><br><span class="line">                    $response-&gt;end($error[&#x27;message&#x27;]);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function start()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server-&gt;on(&#x27;request&#x27;, [$this, &#x27;request&#x27;]);</span><br><span class="line">        $this-&gt;server-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改启动程序"><a href="#修改启动程序" class="headerlink" title="修改启动程序"></a>修改启动程序</h2><p>现在就可以用 server 类来启动程序了，修改 http_server.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Http\HttpServer;</span><br><span class="line"></span><br><span class="line">date_default_timezone_set(&quot;Asia/Shanghai&quot;);</span><br><span class="line">define(&#x27;ROOT_PATH&#x27;, __DIR__);</span><br><span class="line"></span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">$config = require &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">$server = new HttpServer(&#x27;0.0.0.0&#x27;, 9527, [</span><br><span class="line">    &#x27;worker_num&#x27; =&gt; 4,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$router = require &#x27;./app/route/web.php&#x27;;</span><br><span class="line">$middleware = require &#x27;./app/config/middleware.php&#x27;;</span><br><span class="line"></span><br><span class="line">$server-&gt;bootstrap($config[&#x27;framework&#x27;])</span><br><span class="line">    -&gt;loadMiddleware($middleware)</span><br><span class="line">    -&gt;loadRouter($router)</span><br><span class="line">    -&gt;start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就实现了用类来控制启动程序，启动程序的代码也变得整洁了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十三）框架性能小测</title>
      <link href="/2021/02/14/my-swoole-framework-13/"/>
      <url>/2021/02/14/my-swoole-framework-13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从写完路由模块之后就各种偷懒了……</p><p>如果所有功能都要自己写的话，工作量实在太大了。</p><p>而且我对于 swoole 也没有花时间来学习，现在写的框架也只不过是简单的封装而已。</p><p>swoole 的优势很难体现出来，但是相比于用 Laravel 这种重型框架来说，</p><p>自己写的框架虽然是“山寨”版 Laravel，但是性能应该比 Laravel 强不少。</p><p>于是忍不住就想用 ab 工具来测一下了。</p><h2 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h2><p>如果是访问域名的话，其实是先经过 nginx，然后再通过反向代理转发给 swoole，</p><p>这种方法与直接访问 swoole 端口有区别，于是就分作两租测试。</p><p>Nginx 反向代理：<code>ab -c 100 -n 10000 http://firerabbit-engine.ht/</code></p><p>直接访问 Swoole 端口：<code>ab -c 100 -n 10000 http://127.0.0.1：9527/</code></p><p>两种情况分别测试三组数据，取平均值。</p><p>测试的路由配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Http\\Controller\\Home\\&#x27;,</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;a&#x27;, &#x27;b&#x27;]);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>路由加入了两个中间件，中间件处理过程也是比较消耗性能的地方。</p><p>然后是测试的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use App\Http\Model\User;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line">use FireRabbitEngine\Module\Logger\Log;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $user = User::find(1);</span><br><span class="line">        $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage($html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法通过 ORM 查询 users 表的数据，然后传给视图，最后输出视图页面。</p><p>这样可以模拟普通的业务逻辑，看看这个框架写的 WEB 程序到底能跑多少分吧！</p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>第一组数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.15.12</span><br><span class="line">Server Hostname:        firerabbit-engine.ht</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   51.355 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5570000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    194.72 [#/sec] (mean)</span><br><span class="line">Time per request:       513.548 [ms] (mean)</span><br><span class="line">Time per request:       5.135 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          105.92 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.8      0      51</span><br><span class="line">Processing:    42  511  35.3    512     629</span><br><span class="line">Waiting:       30  506  35.2    508     629</span><br><span class="line">Total:         42  511  35.0    512     629</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    512</span><br><span class="line">  66%    523</span><br><span class="line">  75%    529</span><br><span class="line">  80%    533</span><br><span class="line">  90%    546</span><br><span class="line">  95%    557</span><br><span class="line">  98%    572</span><br><span class="line">  99%    581</span><br><span class="line"> 100%    629 (longest request)</span><br></pre></td></tr></table></figure><p>第二组数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.15.12</span><br><span class="line">Server Hostname:        firerabbit-engine.ht</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   54.842 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5570000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    182.34 [#/sec] (mean)</span><br><span class="line">Time per request:       548.422 [ms] (mean)</span><br><span class="line">Time per request:       5.484 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          99.18 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.5      0      40</span><br><span class="line">Processing:    56  544  49.7    543    1046</span><br><span class="line">Waiting:       50  539  49.6    538    1043</span><br><span class="line">Total:         61  544  49.8    543    1050</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    543</span><br><span class="line">  66%    557</span><br><span class="line">  75%    567</span><br><span class="line">  80%    573</span><br><span class="line">  90%    588</span><br><span class="line">  95%    602</span><br><span class="line">  98%    619</span><br><span class="line">  99%    633</span><br><span class="line"> 100%   1050 (longest request)</span><br></pre></td></tr></table></figure><p>第三组数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.15.12</span><br><span class="line">Server Hostname:        firerabbit-engine.ht</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   54.510 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5570000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    183.45 [#/sec] (mean)</span><br><span class="line">Time per request:       545.097 [ms] (mean)</span><br><span class="line">Time per request:       5.451 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          99.79 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   3.1      0     196</span><br><span class="line">Processing:    28  542 112.1    527    1561</span><br><span class="line">Waiting:        9  538 111.6    522    1557</span><br><span class="line">Total:         28  543 111.9    527    1561</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    527</span><br><span class="line">  66%    542</span><br><span class="line">  75%    554</span><br><span class="line">  80%    562</span><br><span class="line">  90%    589</span><br><span class="line">  95%    614</span><br><span class="line">  98%    745</span><br><span class="line">  99%   1471</span><br><span class="line"> 100%   1561 (longest request)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="直接访问-swoole-程序"><a href="#直接访问-swoole-程序" class="headerlink" title="直接访问 swoole 程序"></a>直接访问 swoole 程序</h3><p>第一组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9527</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   41.408 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5620000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    241.50 [#/sec] (mean)</span><br><span class="line">Time per request:       414.077 [ms] (mean)</span><br><span class="line">Time per request:       4.141 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          132.54 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   1.4      0      15</span><br><span class="line">Processing:    41  412  34.8    410     580</span><br><span class="line">Waiting:       26  411  34.8    410     580</span><br><span class="line">Total:         41  412  34.4    410     591</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    410</span><br><span class="line">  66%    421</span><br><span class="line">  75%    428</span><br><span class="line">  80%    435</span><br><span class="line">  90%    454</span><br><span class="line">  95%    469</span><br><span class="line">  98%    489</span><br><span class="line">  99%    507</span><br><span class="line"> 100%    591 (longest request)</span><br></pre></td></tr></table></figure><p>第二组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9527</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   40.637 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5620000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    246.08 [#/sec] (mean)</span><br><span class="line">Time per request:       406.368 [ms] (mean)</span><br><span class="line">Time per request:       4.064 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          135.06 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   1.4      0      20</span><br><span class="line">Processing:    38  404  38.0    404     594</span><br><span class="line">Waiting:       19  404  38.0    403     594</span><br><span class="line">Total:         39  404  37.3    404     594</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    404</span><br><span class="line">  66%    415</span><br><span class="line">  75%    423</span><br><span class="line">  80%    428</span><br><span class="line">  90%    443</span><br><span class="line">  95%    461</span><br><span class="line">  98%    484</span><br><span class="line">  99%    497</span><br><span class="line"> 100%    594 (longest request)</span><br></pre></td></tr></table></figure><p>第三组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9527</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   41.103 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5620000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    243.29 [#/sec] (mean)</span><br><span class="line">Time per request:       411.031 [ms] (mean)</span><br><span class="line">Time per request:       4.110 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          133.52 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       5</span><br><span class="line">Processing:    39  408  49.5    402    1022</span><br><span class="line">Waiting:       38  407  49.4    402    1022</span><br><span class="line">Total:         43  408  49.5    402    1024</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    402</span><br><span class="line">  66%    413</span><br><span class="line">  75%    420</span><br><span class="line">  80%    426</span><br><span class="line">  90%    441</span><br><span class="line">  95%    463</span><br><span class="line">  98%    521</span><br><span class="line">  99%    628</span><br><span class="line"> 100%   1024 (longest request)</span><br></pre></td></tr></table></figure><h3 id="对比结果"><a href="#对比结果" class="headerlink" title="对比结果"></a>对比结果</h3><p>主要对比 <code>Requests per second</code> 参数，</p><p>RPS（也叫 QPS）即平均每秒完成的请求数，这个值越大代币能承受的并发量越高。</p><p>nginx 转发的三组分别为：194.72、182.34、182.45</p><p>直接访问 swoole 的三组分别为：241.50、246.08、243.29</p><p>取平均值即：nginx&#x3D;186.50，swoole&#x3D;243.62</p><p>也就是说，通过 nginx 反向代理会损失一部分的性能。</p><p>而且距离最开始想要实现在几十毫秒内返回也差了很多，即使是直接访问 swoole 最快的也需要 600ms。</p><p>而且通过 nginx 转发之后，QPS 只有不到 200，相比其他 swoole 框架，自己写的框架性能已经大幅下降了。</p><p>这中间应该是有一些非异步的请求，比如 MySQL 查询，只有完成查询后才会继续往下执行，导致程序阻塞了。</p><p>不过总体而言，使用了 swoole 自己写的框架性能比起普通的 php-fpm 框架要高得多，</p><p>如果再加上一些逻辑业务处理，QPS 应该也能维持在 100-200 之间，这样的结果还是比较满意的。</p><p>关于 swoole 的特性还是需要仔细学习一番，框架方面的代码也还有很大的优化空间。</p><p>如果后续不断更新的话，可支持的并发量应该也会不断变大吧！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>为了提高性能，我把 PHP 升级到 7.4，同时 swoole 扩展也升级到 4.6.3，</p><p>然后重新测试了一遍。</p><h3 id="Nginx-反向代理-1"><a href="#Nginx-反向代理-1" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.15.12</span><br><span class="line">Server Hostname:        firerabbit-engine.ht</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   55.727 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5570000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    179.45 [#/sec] (mean)</span><br><span class="line">Time per request:       557.265 [ms] (mean)</span><br><span class="line">Time per request:       5.573 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          97.61 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.6      0      26</span><br><span class="line">Processing:    37  555  58.0    550     938</span><br><span class="line">Waiting:       24  550  57.8    545     938</span><br><span class="line">Total:         37  555  57.8    550     938</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    550</span><br><span class="line">  66%    565</span><br><span class="line">  75%    576</span><br><span class="line">  80%    583</span><br><span class="line">  90%    604</span><br><span class="line">  95%    628</span><br><span class="line">  98%    676</span><br><span class="line">  99%    797</span><br><span class="line"> 100%    938 (longest request)</span><br></pre></td></tr></table></figure><h3 id="直接访问-swoole-程序-1"><a href="#直接访问-swoole-程序-1" class="headerlink" title="直接访问 swoole 程序"></a>直接访问 swoole 程序</h3><p>测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Completed 1000 requests</span><br><span class="line">Completed 2000 requests</span><br><span class="line">Completed 3000 requests</span><br><span class="line">Completed 4000 requests</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 6000 requests</span><br><span class="line">Completed 7000 requests</span><br><span class="line">Completed 8000 requests</span><br><span class="line">Completed 9000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10000 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9527</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   41.988 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5620000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    238.16 [#/sec] (mean)</span><br><span class="line">Time per request:       419.885 [ms] (mean)</span><br><span class="line">Time per request:       4.199 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          130.71 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       5</span><br><span class="line">Processing:    44  416  50.0    411    1090</span><br><span class="line">Waiting:       44  416  50.0    410    1090</span><br><span class="line">Total:         47  416  50.1    411    1092</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    411</span><br><span class="line">  66%    421</span><br><span class="line">  75%    428</span><br><span class="line">  80%    434</span><br><span class="line">  90%    448</span><br><span class="line">  95%    464</span><br><span class="line">  98%    520</span><br><span class="line">  99%    559</span><br><span class="line"> 100%   1092 (longest request)</span><br></pre></td></tr></table></figure><h3 id="对比结果-1"><a href="#对比结果-1" class="headerlink" title="对比结果"></a>对比结果</h3><p>升级了 PHP 和 swoole 扩展的版本后，</p><p>nginx&#x3D;179.45，swoole&#x3D;238.16</p><blockquote><p>原本为：nginx&#x3D;186.50，swoole&#x3D;243.62</p></blockquote><p>好像也没有肉眼可见的提升……</p><p>然后又尝试优化 composer 生成的自动加载：<code>composer dump-autoload -o</code></p><p>测试的结果也没有太大的变化。</p><p>看来，如果想进一步提升 QPS 的话，重点应该是解决阻塞的地方了。</p><h3 id="工作进程数"><a href="#工作进程数" class="headerlink" title="工作进程数"></a>工作进程数</h3><p>忽然想到提高工作进程数，按道理应该可以提高一定的性能，</p><p>编辑 http_server.php 为 swoole 的 http 设置参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$http-&gt;set([</span><br><span class="line">    &#x27;worker_num&#x27; =&gt; 8,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>我的电脑是 4 核 i5，把工作进程设置为核心数的两倍，然后继续测试 swoole 程序和 nginx 转发的结果。</p><p>nginx 转发的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.15.12</span><br><span class="line">Server Hostname:        firerabbit-engine.ht</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   59.781 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5570000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    167.28 [#/sec] (mean)</span><br><span class="line">Time per request:       597.808 [ms] (mean)</span><br><span class="line">Time per request:       5.978 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          90.99 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.8      0      38</span><br><span class="line">Processing:    46  595  84.2    591    1436</span><br><span class="line">Waiting:       39  590  84.2    585    1435</span><br><span class="line">Total:         46  595  84.7    591    1445</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    591</span><br><span class="line">  66%    607</span><br><span class="line">  75%    618</span><br><span class="line">  80%    624</span><br><span class="line">  90%    647</span><br><span class="line">  95%    668</span><br><span class="line">  98%    697</span><br><span class="line">  99%    742</span><br><span class="line"> 100%   1445 (longest request)</span><br></pre></td></tr></table></figure><p>直接访问 swoole：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        swoole-http-server</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9527</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        398 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   39.114 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5620000 bytes</span><br><span class="line">HTML transferred:       3980000 bytes</span><br><span class="line">Requests per second:    255.66 [#/sec] (mean)</span><br><span class="line">Time per request:       391.139 [ms] (mean)</span><br><span class="line">Time per request:       3.911 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          140.32 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.4      0       6</span><br><span class="line">Processing:    61  387  77.4    380    1409</span><br><span class="line">Waiting:       61  387  77.4    380    1409</span><br><span class="line">Total:         67  388  77.6    381    1413</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    381</span><br><span class="line">  66%    395</span><br><span class="line">  75%    405</span><br><span class="line">  80%    413</span><br><span class="line">  90%    433</span><br><span class="line">  95%    452</span><br><span class="line">  98%    494</span><br><span class="line">  99%    543</span><br><span class="line"> 100%   1413 (longest request)</span><br></pre></td></tr></table></figure><p>nginx&#x3D;167.28，swoole&#x3D;255.66</p><blockquote><p>PHP 和 swoole 未升级前：nginx&#x3D;186.50，swoole&#x3D;243.62<br>PHP 和 swoole 升级后：nginx&#x3D;179.45，swoole&#x3D;238.16</p></blockquote><p>嗯？？？nginx 的反而下降了？swoole 的倒是有一定的提升。</p><p>也许是因为没有足够的业务，导致测试的结果准确性不高。</p><p>测试就到这里吧，博客系统也还没开始制作，框架也属于半成品，等到完成度比较高的时候再测测看。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十二）日志系统</title>
      <link href="/2021/02/14/my-swoole-framework-12/"/>
      <url>/2021/02/14/my-swoole-framework-12/</url>
      
        <content type="html"><![CDATA[<h2 id="安装日志系统"><a href="#安装日志系统" class="headerlink" title="安装日志系统"></a>安装日志系统</h2><p>日志习题属于框架的一部分，因此在框架目录下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require monolog/monolog</span><br></pre></td></tr></table></figure><h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>在框架 module 下新建 Logger 文件夹用来保存日志相关功能代码，</p><p>在 Logger 创建 Log 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/14</span><br><span class="line"> * Time：13:38</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Logger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Monolog\Handler\StreamHandler;</span><br><span class="line">use Monolog\Logger;</span><br><span class="line">use Monolog\Formatter\JsonFormatter;</span><br><span class="line"></span><br><span class="line">class Log</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 日志配置</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected static $config;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志对象实例</span><br><span class="line">     * @var Logger</span><br><span class="line">     */</span><br><span class="line">    protected static $instance = null;</span><br><span class="line"></span><br><span class="line">    public static function setConfig($config)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$config = $config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getLogger()</span><br><span class="line">    &#123;</span><br><span class="line">        if (self::$instance == null) &#123;</span><br><span class="line">            self::$instance = new Logger(self::$config[&#x27;channel&#x27;]);</span><br><span class="line"></span><br><span class="line">            if (!file_exists(self::$config[&#x27;path&#x27;])) &#123;</span><br><span class="line">                $file = fopen(self::$config[&#x27;path&#x27;], &#x27;w&#x27;);</span><br><span class="line">                fwrite($file, &#x27;&#x27;);</span><br><span class="line">                fclose($file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $streamHandler = new StreamHandler(self::$config[&#x27;path&#x27;], self::$config[&#x27;level&#x27;]);</span><br><span class="line">//            $streamHandler-&gt;setFormatter(new JsonFormatter());</span><br><span class="line"></span><br><span class="line">            self::$instance-&gt;pushHandler($streamHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>setConfig</code> 加载配置参数，<code>getLogger</code> 判断是否存在日志文件，如果没有则创建，同时返回插件包的 Logger。</p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>打开 app&#x2F;config&#x2F;app.php，添加日志配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$config = [</span><br><span class="line"></span><br><span class="line">    &#x27;view&#x27; =&gt; [</span><br><span class="line">        &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;,</span><br><span class="line">        &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#x27;logger&#x27; =&gt; [</span><br><span class="line">        &#x27;path&#x27; =&gt; __DIR__ . &#x27;/../storage/logs/log.log&#x27;,</span><br><span class="line">        &#x27;level&#x27; =&gt; \Monolog\Logger::INFO,</span><br><span class="line">        &#x27;channel&#x27; =&gt; &#x27;channel-name&#x27;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#x27;database&#x27; =&gt; [</span><br><span class="line">        &#x27;mysql&#x27; =&gt; [</span><br><span class="line">            &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;database&#x27; =&gt; &#x27;blog&#x27;,</span><br><span class="line">            &#x27;username&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;123123&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">            &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;,</span><br><span class="line">            &#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">return $config;</span><br></pre></td></tr></table></figure><p>这里的 view 也被我修改了下，这样看起来更整齐。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>编辑 http_server.php 加载日志配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">date_default_timezone_set(&quot;Asia/Shanghai&quot;);</span><br><span class="line"></span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br><span class="line">require_once &#x27;./app/route/web.php&#x27;;</span><br><span class="line">require_once &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">\FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);</span><br><span class="line">\FireRabbitEngine\Module\View\Blade::setConfig($config[&#x27;view&#x27;][&#x27;view_path&#x27;], $config[&#x27;view&#x27;][&#x27;view_cache_path&#x27;]);</span><br><span class="line">\FireRabbitEngine\Module\Database\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);</span><br><span class="line"></span><br><span class="line">// 新增行</span><br><span class="line">\FireRabbitEngine\Module\Logger\Log::setConfig($config[&#x27;logger&#x27;]);</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调用日志"><a href="#调用日志" class="headerlink" title="调用日志"></a>调用日志</h2><p>在 IndexController 测试日志是否能正常写入，添加测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use App\Http\Model\User;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line">use FireRabbitEngine\Module\Logger\Log;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $user = User::find(1);</span><br><span class="line">        $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]);</span><br><span class="line"></span><br><span class="line">        Log::getLogger()-&gt;error(&#x27;日志&#x27;);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage($html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后访问首页，可以看到配置日志路径的文件夹下多了一个 log.log：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2021-02-14T14:26:29.828157+08:00] channel-name.ERROR: 日志 [] []</span><br></pre></td></tr></table></figure><p>这样日志系统也完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十一）数据库模型</title>
      <link href="/2021/02/14/my-swoole-framework-11/"/>
      <url>/2021/02/14/my-swoole-framework-11/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库操作类自己写不安全，而且也有比较成熟的插件包了，</p><p>因此我打算直接引入 Laravel 相同的 ORM。</p><h2 id="插件包安装"><a href="#插件包安装" class="headerlink" title="插件包安装"></a>插件包安装</h2><p>数据库操作属于框架层面的，因此在框架的目录下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require illuminate/database</span><br></pre></td></tr></table></figure><p>框架目录下也会自动创建一个 composer.json 文件，同时安装完成后会生成 vendor 文件夹。</p><p>在框架目录添加 .gitignore 忽略上传 vendor 文件夹。</p><h2 id="Blade-包错误修正"><a href="#Blade-包错误修正" class="headerlink" title="Blade 包错误修正"></a>Blade 包错误修正</h2><p>在前面完成 blade 模板时，blade 模板的包是在 app 目录下的，</p><p>这样就不是在框架里了，因此回到博客目录用 <code>composer remove xiaoler/blade</code> 命令移除 blade 包。</p><p>然后再进入框架目录重新安装 blade 即可，这样 blade 模块就属于框架内部了。</p><p>框架现在还不是一个 composer 包，因此框架的自动加载文件需要手动添加，</p><p>编辑 swoole 启动文件，http_server.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">// 新增行</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br></pre></td></tr></table></figure><p>在引入自动加载文件的下一行添加框架的自动加载，这样就完成了。</p><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p>编辑 app&#x2F;config&#x2F;app.php，添加数据库配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$config = [</span><br><span class="line">    &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;,</span><br><span class="line">    &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;,</span><br><span class="line"></span><br><span class="line">    &#x27;database&#x27; =&gt; [</span><br><span class="line">        &#x27;mysql&#x27; =&gt; [</span><br><span class="line">            &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;127.0.0.1&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;database&#x27; =&gt; &#x27;blog&#x27;,</span><br><span class="line">            &#x27;username&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;password&#x27; =&gt; &#x27;123456&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">            &#x27;collation&#x27; =&gt; &#x27;utf8_unicode_ci&#x27;,</span><br><span class="line">            &#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">return $config;</span><br></pre></td></tr></table></figure><h2 id="ORM-模块加载"><a href="#ORM-模块加载" class="headerlink" title="ORM 模块加载"></a>ORM 模块加载</h2><p>在框架 module 新建文件夹 Database 用来存储数据库相关功能模块代码，</p><p>在 Database 文件夹下新建 Manager.php 用于加载数据库配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/14</span><br><span class="line"> * Time：13:02</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Database;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Manager</span><br><span class="line">&#123;</span><br><span class="line">    protected static $config;</span><br><span class="line"></span><br><span class="line">    public static function setConfig($config)</span><br><span class="line">    &#123;</span><br><span class="line">        $db = new \Illuminate\Database\Capsule\Manager();</span><br><span class="line">        $db-&gt;addConnection($config);</span><br><span class="line">        $db-&gt;setAsGlobal();</span><br><span class="line">        $db-&gt;bootEloquent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getConfig()</span><br><span class="line">    &#123;</span><br><span class="line">        return self::$config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setConfig</code> 方法加载一个数组参数的配置。</p><p>编辑 http_server.php 加入一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./firerabbit-engine/vendor/autoload.php&#x27;;</span><br><span class="line">require_once &#x27;./app/route/web.php&#x27;;</span><br><span class="line">require_once &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">\FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);</span><br><span class="line">\FireRabbitEngine\Module\View\Blade::setConfig($config[&#x27;view_path&#x27;], $config[&#x27;view_cache_path&#x27;]);</span><br><span class="line"></span><br><span class="line">// 新增行</span><br><span class="line">\FireRabbitEngine\Module\Database\Manager::setConfig($config[&#x27;database&#x27;][&#x27;mysql&#x27;]);</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 on 之前加载数据库配置。</p><blockquote><p>现在这个启动文件已经不堪入目了，等以后再优化</p></blockquote><h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a>创建 Model</h2><p>在 app&#x2F;Http 下新建 Model 文件夹用来保存模型文件。</p><p>在 Model 新建第一个模型文件 User：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/14</span><br><span class="line"> * Time：13:05</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace App\Http\Model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">    public $timestamps = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要让它继承 <code>Illuminate\Database\Eloquent\Model</code> 即可。</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>打开数据库，在 users 表加入一行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name：花花 - 001</span><br><span class="line">password：123123</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>打开 IndexController，修改  index 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:17 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controller\Home;</span><br><span class="line"></span><br><span class="line">use App\Http\Model\User;</span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $user = User::find(1);</span><br><span class="line">        $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; $user-&gt;name]);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage($html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的代码是直接传入 name 字符串，现在改成从数据库查询数据然后传给模板。</p><p>然后测试，发现页面输出了名字：花花 - 001</p><p>如此一来，ORM 模块也完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（十）数据库迁移</title>
      <link href="/2021/02/14/my-swoole-framework-10/"/>
      <url>/2021/02/14/my-swoole-framework-10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常情况下我们要创建 MySQL 数据库的表需要手动创建 SQL 语句。</p><p>然而这样一方面是很不方便，另一方面也不安全，如果修改表结构的时候不小心改错了，就会造成无法挽回的后果，而且最关键的是还不知道是谁干的！</p><p>之前上班的时候同事就遇到这种情况，有一个同事不小心删了另一个同事要用的表，结果不言而喻……</p><h2 id="Phinx"><a href="#Phinx" class="headerlink" title="Phinx"></a>Phinx</h2><p>官方网站：<a href="https://book.cakephp.org/phinx/0/en/install.html">https://book.cakephp.org/phinx/0/en/install.html</a></p><p>Phinx 是一个数据库迁移插件，使用它可以通过 PHP 代码来创建表或者修改表结构。</p><p>如此一来就不需要手动使用 SQL 语句去修改数据库了。</p><h2 id="安装-Phinx"><a href="#安装-Phinx" class="headerlink" title="安装 Phinx"></a>安装 Phinx</h2><p>使用命令：<code>require robmorgan/phinx</code></p><p>完成安装后，再执行 <code>vendor/bin/phinx init</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/www/blog# vendor/bin/phinx init</span><br><span class="line">Phinx by CakePHP - https://phinx.org.</span><br><span class="line"></span><br><span class="line">created /www/blog/phinx.php</span><br></pre></td></tr></table></figure><p>可以发现它在项目根目录自动创建了一个文件。</p><h2 id="配置-Phinx"><a href="#配置-Phinx" class="headerlink" title="配置 Phinx"></a>配置 Phinx</h2><p>打开上一步得到的 phinx.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">[</span><br><span class="line">    &#x27;paths&#x27; =&gt; [</span><br><span class="line">        &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;,</span><br><span class="line">        &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;</span><br><span class="line">    ],</span><br><span class="line">    &#x27;environments&#x27; =&gt; [</span><br><span class="line">        &#x27;default_migration_table&#x27; =&gt; &#x27;phinxlog&#x27;,</span><br><span class="line">        &#x27;default_environment&#x27; =&gt; &#x27;development&#x27;,</span><br><span class="line">        &#x27;production&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;production_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        &#x27;development&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;development_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ],</span><br><span class="line">        &#x27;testing&#x27; =&gt; [</span><br><span class="line">            &#x27;adapter&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">            &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;testing_db&#x27;,</span><br><span class="line">            &#x27;user&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">            &#x27;pass&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">            &#x27;port&#x27; =&gt; &#x27;3306&#x27;,</span><br><span class="line">            &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    &#x27;version_order&#x27; =&gt; &#x27;creation&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是数据库的配置表，在这里填上自己的数据库账户和密码。</p><p>这里有不同的开发环境配置：production（线上环境）、development（开发环境）、testing（测试环境）。</p><p>我们暂且只要配置：development 即可。</p><p>paths 字段是数据库迁移文件的存放位置，默认是在项目根目录下的 db 文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;paths&#x27; =&gt; [</span><br><span class="line">    &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/migrations&#x27;,</span><br><span class="line">    &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/db/seeds&#x27;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>数据库迁移文件属于项目的一部分，因此我把它修改成了在 app 目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;paths&#x27; =&gt; [</span><br><span class="line">    &#x27;migrations&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/app/database/migrations&#x27;,</span><br><span class="line">    &#x27;seeds&#x27; =&gt; &#x27;%%PHINX_CONFIG_DIR%%/app/database/seeds&#x27;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>然后创建对应的文件夹即可。</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>配置好之后就可以使用命令来创建表了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vendor/bin/phinx create User</span><br></pre></td></tr></table></figure><p>上述命令生成了 User 表的数据库迁移文件，</p><p>可以发现在 app&#x2F;database&#x2F;migrations 目录下多出了一个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">declare(strict_types=1);</span><br><span class="line"></span><br><span class="line">use Phinx\Migration\AbstractMigration;</span><br><span class="line"></span><br><span class="line">final class User extends AbstractMigration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Change Method.</span><br><span class="line">     *</span><br><span class="line">     * Write your reversible migrations using this method.</span><br><span class="line">     *</span><br><span class="line">     * More information on writing migrations is available here:</span><br><span class="line">     * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method</span><br><span class="line">     *</span><br><span class="line">     * Remember to call &quot;create()&quot; or &quot;update()&quot; and NOT &quot;save()&quot; when working</span><br><span class="line">     * with the Table class.</span><br><span class="line">     */</span><br><span class="line">    public function change(): void</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 change 方法里添加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public function change()</span><br><span class="line">&#123;</span><br><span class="line">    // create the table</span><br><span class="line">    $table = $this-&gt;table(&#x27;users&#x27;);</span><br><span class="line">    $table-&gt;addColumn(&#x27;name&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 32])</span><br><span class="line">        -&gt;addColumn(&#x27;password&#x27;, &#x27;string&#x27;, [&#x27;limit&#x27; =&gt; 64])</span><br><span class="line">        -&gt;addColumn(&#x27;created&#x27;, &#x27;timestamp&#x27;, [&#x27;default&#x27; =&gt; &#x27;CURRENT_TIMESTAMP&#x27;])</span><br><span class="line">        -&gt;create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一张 users 表，包括名称、密码和注册日期。</p><p>然后打开 MySQL 数据库，创建一个名字叫做 blog 的数据库。</p><blockquote><p>注意！这里的数据库名字要与 phinx.php 配置文件对应</p></blockquote><h2 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h2><p>数据库迁移文件写好之后，就可以用命令执行数据库迁移了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vendor/bin/phinx migrate</span><br></pre></td></tr></table></figure><p>执行完成之后再返回查看 blog 数据库，可以发现 users 表已经创建好了。</p><p>除了 users 表之外，还有一张 phinxlog 表，这是用来保存迁移记录的。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>数据库迁移属于项目单独引用的，以后再考虑封装到框架里面。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（九）视图blade模板</title>
      <link href="/2021/02/13/my-swoole-framework-9/"/>
      <url>/2021/02/13/my-swoole-framework-9/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>路由模块终于告一段落了，虽然完成了但还没有经过严格测试，</p><p>因此可能会存在一些问题，具体问题就等接下来的开发过程发现就好了。</p><h2 id="视图模块"><a href="#视图模块" class="headerlink" title="视图模块"></a>视图模块</h2><p>由于我的框架不是专门做 API 的，也不是微服务架构，而是单体应用，</p><p>也就是说会出现 HTML 代码跟 PHP 代码混合在一块的视图文件，</p><p>直接用原生的 PHP 来写 HTML 页面肯定不是好方法，而模板引擎比较好用的就是 blade 模板了。</p><h2 id="安装-blade-模板"><a href="#安装-blade-模板" class="headerlink" title="安装 blade 模板"></a>安装 blade 模板</h2><p>模板引擎的开发成本太高了，因此我打算直接用别人写好的。</p><p>使用 composer 命令 <code>composer require xiaoler/blade</code>，</p><p>安装完成后 composer.json 的 require 字段即可看到刚才的安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;xiaoler/blade&quot;: &quot;^5.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\&quot;: &quot;app/&quot;,</span><br><span class="line">      &quot;FireRabbitEngine\\Module\\&quot;: &quot;firerabbit-engine/module/&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files&quot;: [</span><br><span class="line">      &quot;firerabbit-engine/common/function.php&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板引擎的配置"><a href="#模板引擎的配置" class="headerlink" title="模板引擎的配置"></a>模板引擎的配置</h2><p>模板引擎在第一次运行时，会根据模板创建出编译后的 php 文件，</p><p>也就是说，它需要将模板语言转化成 PHP 语言，生成对应解析后的文件。</p><p>在 app 下创建 view 文件夹，用来存放视图模板文件。</p><p>在 app 下创建 storage 文件夹，用来保存上传的文件或者缓存文件。</p><p>在 storage 目录下继续创建 cache，在 cache 目录下创建 view_cache 用来保存视图缓存文件。</p><blockquote><p>view_cache 要加入到 .gitignore 忽略的目录，缓存文件不需要同步上传</p></blockquote><p>视图缓存文件即经过模板引擎编译后生成的 PHP 文件。</p><p>为了方便管理全局配置，在博客目录下创建 app&#x2F;config&#x2F;app.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$config = [</span><br><span class="line">    &#x27;view_path&#x27; =&gt; __DIR__ . &#x27;/../view&#x27;,</span><br><span class="line">    &#x27;view_cache_path&#x27; =&gt; __DIR__ . &#x27;/../storage/cache/view_cache&#x27;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">return $config;</span><br></pre></td></tr></table></figure><p>app.php 是博客系统全局的配置文件。</p><h2 id="视图模块-1"><a href="#视图模块-1" class="headerlink" title="视图模块"></a>视图模块</h2><p>接下来在框架的 module 目录创建文件夹 View 用来保存视图相关的功能类。</p><p>创建 Blade 调用 composer 引入的 blade 模板引擎插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2021/2/13</span><br><span class="line"> * Time：22:06</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\View;</span><br><span class="line"></span><br><span class="line">use Xiaoler\Blade\Compilers\BladeCompiler;</span><br><span class="line">use Xiaoler\Blade\Engines\CompilerEngine;</span><br><span class="line">use Xiaoler\Blade\Engines\EngineResolver;</span><br><span class="line">use Xiaoler\Blade\Factory;</span><br><span class="line">use Xiaoler\Blade\Filesystem;</span><br><span class="line">use Xiaoler\Blade\FileViewFinder;</span><br><span class="line"></span><br><span class="line">class Blade</span><br><span class="line">&#123;</span><br><span class="line">    protected static $viewPath, $cachePath;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置模板文件目录</span><br><span class="line">     * @param $viewPath</span><br><span class="line">     * @param $cachePath</span><br><span class="line">     */</span><br><span class="line">    public static function setConfig($viewPath, $cachePath)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$viewPath = $viewPath;</span><br><span class="line">        self::$cachePath = $cachePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取模板引擎返回的html代码</span><br><span class="line">     * @param $blade</span><br><span class="line">     * @param $params</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    public static function view($blade, $params)</span><br><span class="line">    &#123;</span><br><span class="line">        $file = new Filesystem;</span><br><span class="line">        $compiler = new BladeCompiler($file, self::$cachePath);</span><br><span class="line"></span><br><span class="line">        $resolver = new EngineResolver;</span><br><span class="line">        $resolver-&gt;register(&#x27;blade&#x27;, function () use ($compiler) &#123;</span><br><span class="line">            return new CompilerEngine($compiler);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $factory = new Factory($resolver, new FileViewFinder($file, [self::$viewPath]));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return $factory-&gt;make($blade, $params)-&gt;render();</span><br><span class="line">        &#125; catch (\Throwable $e) &#123;</span><br><span class="line">            return $e-&gt;getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setConfig</code> 方法可以用来设置视图和缓存文件的目录。</p><p>修改 http_server.php，引入上面创建的 app.php 全局配置文件，同时视图模板加载对应的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require_once &#x27;./app/route/web.php&#x27;;</span><br><span class="line">require_once &#x27;./app/config/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">\FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);</span><br><span class="line">\FireRabbitEngine\Module\View\Blade::setConfig($config[&#x27;view_path&#x27;], $config[&#x27;view_cache_path&#x27;]);</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>现在这个启动文件看起来乱七八糟的，后面再慢慢优化吧。</p><p>通过上面的配置，已经可以调用 Blade 类来生成视图文件了。</p><h2 id="视图文件"><a href="#视图文件" class="headerlink" title="视图文件"></a>视图文件</h2><p>在 app&#x2F;view 下创建 layout，layout 是视图共用的模板，</p><p>比如顶部导航栏，底部 footer 之类的，也就是说 HTML 的母版。</p><p>在 layout 目录下面创建 app.blade.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot;</span><br><span class="line">          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    @yield(&#x27;content&#x27;)</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>blade 模板文件的命名规则是：视图名称.blade，当然也可以通过配置取消 blade 后缀</p></blockquote><p>这是一个简单的 HTML 代码，<code>@yield(&#39;content&#39;)</code> 即子页需要编写的内容。</p><blockquote><p>关于 blade 模板的使用方法可以网上自行了解</p></blockquote><p>接着在 app&#x2F;view 目录下创建首页 index.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@extends(&#x27;layout.app&#x27;)</span><br><span class="line"></span><br><span class="line">@section(&#x27;content&#x27;)</span><br><span class="line">    &lt;h1&gt;index 首页&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;这是一个参数：&#123;&#123; $name &#125;&#125;&lt;/p&gt;</span><br><span class="line">@endsection</span><br></pre></td></tr></table></figure><p>index 继承了 layout&#x2F;app.blade.php，只需要编写 ‘content’ 部分即可，</p><p>这里输出了一个 $name 参数，用来测试模板传参。</p><h2 id="调用-blade-模板"><a href="#调用-blade-模板" class="headerlink" title="调用 blade 模板"></a>调用 blade 模板</h2><p>编辑 IndexController 的 index 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line">use FireRabbitEngine\Module\View\Blade;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $html = Blade::view(&#x27;index&#x27;, [&#x27;name&#x27; =&gt; &#x27;花花&#x27;]);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage($html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用视图的方法为：<code>Blade::view(视图文件名, [参数])</code></p><p>视图文件名即去掉 blade 的名字，如：index.blade.php，即 index。</p><p><code>showMessage</code> 方法即调用 swoole 的 response 输出字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public function showMessage($message)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;httpKernel-&gt;getResponse()-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">    $this-&gt;httpKernel-&gt;getResponse()-&gt;end($message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开浏览器，访问首页，即可看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index 首页</span><br><span class="line">这是一个参数：花花</span><br></pre></td></tr></table></figure><p>这样，框架的视图模块就完成了！</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（八）路由中间件</title>
      <link href="/2021/02/12/my-swoole-framework-8/"/>
      <url>/2021/02/12/my-swoole-framework-8/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><p>中间件就是一种系统之间互相连接的“中间的一层”。</p><p>通俗的讲类似古代的关口，西游记里唐僧每到一个国家都要取得这个国家的“通关文凭”，如果没有通关文凭就无法离开国界。边关的守卫就可以理解为“中间件”，唐僧就是请求，如果没有通过文凭（即达不到某种要求）就会被拦截在关口。</p><p>也就是说，中间件的主要功能是“拦截不符合规范的请求”。</p><p>它就是一种 <code>if-else</code> 条件判断结构，如果……就……</p><p>比如要设计一个活动页面，只有今天晚上 9：00 到 10：00 这个时间段才会进入活动页，如果还不到 9 点就打开这个页面就会显示“活动还未开始”，如果是 10 点之后打开这个页面，就会显示“活动已结束”。</p><p>要实现这种功能十分简单，直接用 <code>if-else</code> 结构就可以了。</p><p>但是这种思想属于面向过程，在框架里可以将判断条件封装为“中间件”实现自动化处理请求，满足要求的就放过，不满足要求的就拦截下来，返回失败的处理。</p><h2 id="中间件的应用场景"><a href="#中间件的应用场景" class="headerlink" title="中间件的应用场景"></a>中间件的应用场景</h2><p>中间件即拦截不符合规范的请求，因此它能用的场景非常多。</p><p>例如规定了某个时间段开放、关闭的活动页面；</p><p>表单验证、用户登录状态验证等等。</p><p>总之，凡是能用“如果……就……”描述的，几乎都可以用中间件实现，因为它本身即是一种条件判断结构。</p><h2 id="Laravel-中的中间件"><a href="#Laravel-中的中间件" class="headerlink" title="Laravel 中的中间件"></a>Laravel 中的中间件</h2><p>Laravel 中的中间件的使用非常优雅！</p><p>创建一个中间件，用于验证用户是否登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">class AuthCheck</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Handle an incoming request.</span><br><span class="line">     *</span><br><span class="line">     * @param \Illuminate\Http\Request $request</span><br><span class="line">     * @param \Closure $next</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function handle($request, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        // 判断用户是否登录状态，如果已登录则进入下一步</span><br><span class="line">        if (auth()-&gt;check()) &#123;</span><br><span class="line">            return $next($request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果未登录则返回提示页面的视图</span><br><span class="line">        $message = &#x27;用户未登录，无法操作，&lt;a href=&quot;#&quot;&gt;前往登录&lt;/a&gt;。&#x27;;</span><br><span class="line">        return $this-&gt;showErrorPage($message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public functio showErrorPage($message) &#123;</span><br><span class="line">        // ... 返回自定义视图页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 Kernel.php 中注册中间件，并且命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected $routeMiddleware = [</span><br><span class="line">    &#x27;auth.check&#x27; =&gt; AuthCheck::class,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>最后只要在路由配置中为需要验证用户身份的路由加上中间件即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;middleware(&#x27;auth.check&#x27;)-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;user.index&#x27;);</span><br></pre></td></tr></table></figure><p>只需如此简单的配置即可实现路由拦截。</p><h2 id="Laravel-中间件的原理"><a href="#Laravel-中间件的原理" class="headerlink" title="Laravel 中间件的原理"></a>Laravel 中间件的原理</h2><p>一个路由可以有很多中间件，只有满足所有中间件才让请求继续下去，否则就终端请求返回错误的结果。</p><p>看起来只需要一个 foreach 循环就能实现中间件了，用伪代码实现思路如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$flag = true;</span><br><span class="line"></span><br><span class="line">$conditions = [条件1, 条件2, 条件3];</span><br><span class="line"></span><br><span class="line">foreach ($conditions as $condition) &#123;</span><br><span class="line">    if($condition == false) &#123;</span><br><span class="line">        $flag = false;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($flag == true) &#123;</span><br><span class="line">    // 成功，进入下一步</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 失败，返回失败页</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像确实可以，但我出于好奇研究了一下 Laravel 的源码。</p><h3 id="Laravel-源码"><a href="#Laravel-源码" class="headerlink" title="Laravel 源码"></a>Laravel 源码</h3><p>在定义 Middleware 类的时候，我发现 Middleware 不需要继承任何框架的基类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">class AuthCheck</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Handle an incoming request.</span><br><span class="line">     *</span><br><span class="line">     * @param \Illuminate\Http\Request $request</span><br><span class="line">     * @param \Closure $next</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function handle($request, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        // 判断用户是否登录状态，如果已登录则进入下一步</span><br><span class="line">        if (auth()-&gt;check()) &#123;</span><br><span class="line">            return $next($request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果未登录则返回提示页面的视图</span><br><span class="line">        $message = &#x27;用户未登录，无法操作，&lt;a href=&quot;#&quot;&gt;前往登录&lt;/a&gt;。&#x27;;</span><br><span class="line">        return $this-&gt;showErrorPage($message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public functio showErrorPage($message) &#123;</span><br><span class="line">        // ... 返回自定义视图页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是定义一个 handle 方法，一共接收两个参数，</p><p>一个是 Laravel 的 $request，另一个是闭包类型 $next。</p><p>如果请求验证成功，则直接返回闭包执行结果 <code>$next($request)</code>，</p><p>如果请求不符合要求，就自定义一个响应返回。</p><p>看来，玄机并不在 Middleware 的定义里。</p><p>基于 php-fpm 的框架入口文件基本上都是 index.php，</p><p>因此找到 Laravel 的入口文件在 public 目录下面，index.php 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Laravel - A PHP Framework For Web Artisans</span><br><span class="line"> *</span><br><span class="line"> * @package  Laravel</span><br><span class="line"> * @author   Taylor Otwell &lt;taylor@laravel.com&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">define(&#x27;LARAVEL_START&#x27;, microtime(true));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Register The Auto Loader</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Composer provides a convenient, automatically generated class loader for</span><br><span class="line">| our application. We just need to utilize it! We&#x27;ll simply require it</span><br><span class="line">| into the script here so that we don&#x27;t have to worry about manual</span><br><span class="line">| loading any of our classes later on. It feels great to relax.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">require __DIR__.&#x27;/../vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Turn On The Lights</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| We need to illuminate PHP development, so let us turn on the lights.</span><br><span class="line">| This bootstraps the framework and gets it ready for use, then it</span><br><span class="line">| will load up this application so that we can run it and send</span><br><span class="line">| the responses back to the browser and delight our users.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Run The Application</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Once we have the application, we can handle the incoming request</span><br><span class="line">| through the kernel, and send the associated response back to</span><br><span class="line">| the client&#x27;s browser allowing them to enjoy the creative</span><br><span class="line">| and wonderful application we have prepared for them.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br><span class="line"></span><br><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$response-&gt;send();</span><br><span class="line"></span><br><span class="line">$kernel-&gt;terminate($request, $response);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里引入了一个文件，然后得到一个 $app 对象，接着调用 handle 方法执行响应事件，</p><p>然后就没有其他代码了，因此这个引入的 app.php 是关键所在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;</span><br></pre></td></tr></table></figure><p>找到 app.php 发现如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Create The Application</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| The first thing we will do is create a new Laravel application instance</span><br><span class="line">| which serves as the &quot;glue&quot; for all the components of Laravel, and is</span><br><span class="line">| the IoC container for the system binding all of the various parts.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$app = new Illuminate\Foundation\Application(</span><br><span class="line">    $_ENV[&#x27;APP_BASE_PATH&#x27;] ?? dirname(__DIR__)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Bind Important Interfaces</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Next, we need to bind some important interfaces into the container so</span><br><span class="line">| we will be able to resolve them when needed. The kernels serve the</span><br><span class="line">| incoming requests to this application from both the web and CLI.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Console\Kernel::class,</span><br><span class="line">    App\Console\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Debug\ExceptionHandler::class,</span><br><span class="line">    App\Exceptions\Handler::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Return The Application</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| This script returns the application instance. The instance is given to</span><br><span class="line">| the calling script so we can separate the building of the instances</span><br><span class="line">| from the actual running of the application and sending responses.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">return $app;</span><br></pre></td></tr></table></figure><p>这里是注册服务容器的地方，服务容器 Laravel 实例化类的一种设计模式，</p><p>具体的原理我也没有搞懂，只要知道这是一个“注册和实例化类”的地方就可以了。</p><p>跟 HTTP 请求相关的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>按住 Ctrl 点击 <code>App\Http\Kernel::class</code> 可以跳转到类定义的地方，</p><p>结果发现跳转到中间件配置的地方了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http;</span><br><span class="line"></span><br><span class="line">use Illuminate\Foundation\Http\Kernel as HttpKernel;</span><br><span class="line"></span><br><span class="line">class Kernel extends HttpKernel</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The application&#x27;s global HTTP middleware stack.</span><br><span class="line">     *</span><br><span class="line">     * These middleware are run during every request to your application.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $middleware = [</span><br><span class="line">        // \App\Http\Middleware\TrustHosts::class,</span><br><span class="line">        \App\Http\Middleware\TrustProxies::class,</span><br><span class="line">        \Fruitcake\Cors\HandleCors::class,</span><br><span class="line">        \App\Http\Middleware\CheckForMaintenanceMode::class,</span><br><span class="line">        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,</span><br><span class="line">        \App\Http\Middleware\TrimStrings::class,</span><br><span class="line">        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The application&#x27;s route middleware groups.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $middlewareGroups = [</span><br><span class="line">        &#x27;web&#x27; =&gt; [</span><br><span class="line">            \App\Http\Middleware\EncryptCookies::class,</span><br><span class="line">            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,</span><br><span class="line">            \Illuminate\Session\Middleware\StartSession::class,</span><br><span class="line">            // \Illuminate\Session\Middleware\AuthenticateSession::class,</span><br><span class="line">            \Illuminate\View\Middleware\ShareErrorsFromSession::class,</span><br><span class="line">            \App\Http\Middleware\VerifyCsrfToken::class,</span><br><span class="line">            \Illuminate\Routing\Middleware\SubstituteBindings::class,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &#x27;api&#x27; =&gt; [</span><br><span class="line">//            &#x27;throttle:60,1&#x27;,</span><br><span class="line">            \Illuminate\Routing\Middleware\SubstituteBindings::class,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The application&#x27;s route middleware.</span><br><span class="line">     *</span><br><span class="line">     * These middleware may be assigned to groups or used individually.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $routeMiddleware = [</span><br><span class="line">        &#x27;auth&#x27; =&gt; \App\Http\Middleware\Authenticate::class,</span><br><span class="line">        &#x27;auth.basic&#x27; =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来离想要找到的结果不远了，这个配置也没什么奇怪的地方，</p><p>接着发现这个类继承了另一个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Illuminate\Foundation\Http\Kernel as HttpKernel;</span><br></pre></td></tr></table></figure><p>于是我们继续前往这个类，发现这个类有很多方法，</p><p>我就直接截取关键部分了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle an incoming HTTP request.</span><br><span class="line"> *</span><br><span class="line"> * @param  \Illuminate\Http\Request  $request</span><br><span class="line"> * @return \Illuminate\Http\Response</span><br><span class="line"> */</span><br><span class="line">public function handle($request)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        $request-&gt;enableHttpMethodParameterOverride();</span><br><span class="line"></span><br><span class="line">        $response = $this-&gt;sendRequestThroughRouter($request);</span><br><span class="line">    &#125; catch (Throwable $e) &#123;</span><br><span class="line">        $this-&gt;reportException($e);</span><br><span class="line"></span><br><span class="line">        $response = $this-&gt;renderException($request, $e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $this-&gt;app[&#x27;events&#x27;]-&gt;dispatch(</span><br><span class="line">        new RequestHandled($request, $response)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle 方法？也就是说最开始入口文件执行的便是这个方法了。</p><p>根据注释：Handle an incoming HTTP request</p><p>可以知道这里确实是处理进来请求的地方。</p><p>第一行执行的方法：<code>enableHttpMethodParameterOverride</code>，即 Laravel 重写请求方法的地方，</p><p>在 Laravel 除了 GET 和 POST 之外，还定义了 PUT、DELETE 等方法，</p><p>这里就是判断 <code>_method</code> 变量生成特殊请求方法的地方。</p><p>接着查看 <code>sendRequestThroughRouter</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Send the given request through the middleware / router.</span><br><span class="line"> *</span><br><span class="line"> * @param  \Illuminate\Http\Request  $request</span><br><span class="line"> * @return \Illuminate\Http\Response</span><br><span class="line"> */</span><br><span class="line">protected function sendRequestThroughRouter($request)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;app-&gt;instance(&#x27;request&#x27;, $request);</span><br><span class="line"></span><br><span class="line">    Facade::clearResolvedInstance(&#x27;request&#x27;);</span><br><span class="line"></span><br><span class="line">    $this-&gt;bootstrap();</span><br><span class="line"></span><br><span class="line">    return (new Pipeline($this-&gt;app))</span><br><span class="line">                -&gt;send($request)</span><br><span class="line">                -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware)</span><br><span class="line">                -&gt;then($this-&gt;dispatchToRouter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码应该就是我想要找的了，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return (new Pipeline($this-&gt;app))</span><br><span class="line">                -&gt;send($request)</span><br><span class="line">                -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware)</span><br><span class="line">                -&gt;then($this-&gt;dispatchToRouter());</span><br></pre></td></tr></table></figure><p>send 方法非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Set the object being sent through the pipeline.</span><br><span class="line"> *</span><br><span class="line"> * @param  mixed  $passable</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function send($passable)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;passable = $passable;</span><br><span class="line"></span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是处理中间件的逻辑，接着看 through：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Set the array of pipes.</span><br><span class="line"> *</span><br><span class="line"> * @param  array|mixed  $pipes</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function through($pipes)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args();</span><br><span class="line"></span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也不是，最后的 then：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Run the pipeline with a final destination callback.</span><br><span class="line"> *</span><br><span class="line"> * @param  \Closure  $destination</span><br><span class="line"> * @return mixed</span><br><span class="line"> */</span><br><span class="line">public function then(Closure $destination)</span><br><span class="line">&#123;</span><br><span class="line">    $pipeline = array_reduce(</span><br><span class="line">        array_reverse($this-&gt;pipes()), $this-&gt;carry(), $this-&gt;prepareDestination($destination)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return $pipeline($this-&gt;passable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也只有短短数行的代码，难道最后也没找到中间件的实现逻辑？</p><p>而且……这个 <code>array_reduce</code> 是什么鬼？</p><p>仔细的研究了一番，发现这里的代码虽然只有 4 行，可真的不简单！</p><p>其中，最关键的部分是这个叫做 carry 的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a Closure that represents a slice of the application onion.</span><br><span class="line"> *</span><br><span class="line"> * @return \Closure</span><br><span class="line"> */</span><br><span class="line">protected function carry()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($stack, $pipe) &#123;</span><br><span class="line">        return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (is_callable($pipe)) &#123;</span><br><span class="line">                    // If the pipe is a callable, then we will call it directly, but otherwise we</span><br><span class="line">                    // will resolve the pipes out of the dependency container and call it with</span><br><span class="line">                    // the appropriate method and arguments, returning the results back out.</span><br><span class="line">                    return $pipe($passable, $stack);</span><br><span class="line">                &#125; elseif (! is_object($pipe)) &#123;</span><br><span class="line">                    [$name, $parameters] = $this-&gt;parsePipeString($pipe);</span><br><span class="line"></span><br><span class="line">                    // If the pipe is a string we will parse the string and resolve the class out</span><br><span class="line">                    // of the dependency injection container. We can then build a callable and</span><br><span class="line">                    // execute the pipe function giving in the parameters that are required.</span><br><span class="line">                    $pipe = $this-&gt;getContainer()-&gt;make($name);</span><br><span class="line"></span><br><span class="line">                    $parameters = array_merge([$passable, $stack], $parameters);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // If the pipe is already an object we&#x27;ll just make a callable and pass it to</span><br><span class="line">                    // the pipe as-is. There is no need to do any extra parsing and formatting</span><br><span class="line">                    // since the object we&#x27;re given was already a fully instantiated object.</span><br><span class="line">                    $parameters = [$passable, $stack];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                $carry = method_exists($pipe, $this-&gt;method)</span><br><span class="line">                                ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters)</span><br><span class="line">                                : $pipe(...$parameters);</span><br><span class="line"></span><br><span class="line">                return $this-&gt;handleCarry($carry);</span><br><span class="line">            &#125; catch (Throwable $e) &#123;</span><br><span class="line">                return $this-&gt;handleException($passable, $e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array_reduce"></a>array_reduce</h3><p>如果猜的没错，Laravel 应该就是使用 <code>array_reduce</code> 来实现中间件的。</p><p>查了一下 PHP 的官方文档，它对 <code>array_reduce</code> 的描述是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br></pre></td></tr></table></figure><p>嗯……不愧是官方文档，说了跟没讲一样。</p><p>还是通过实战来了解一下什么是 <code>array_reduce</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">$result = array_reduce($params, function ($carry, $item) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;carry=&#x27; . $carry);</span><br><span class="line">    var_dump(&#x27;item=&#x27; . $item);</span><br><span class="line"></span><br><span class="line">    return $carry . $item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>声明一个数组 $params 且包含三个字符串，</p><p>然后通过 array_reduce 传入数组参数，同时还有一个闭包，</p><p>闭包接收两个参数 $carry, $item，然后试着打印这两个参数以及最终结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;carry=&quot;</span><br><span class="line">string(6) &quot;item=a&quot;</span><br><span class="line">string(7) &quot;carry=a&quot;</span><br><span class="line">string(6) &quot;item=b&quot;</span><br><span class="line">string(8) &quot;carry=ab&quot;</span><br><span class="line">string(6) &quot;item=c&quot;</span><br><span class="line">string(3) &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>也就是说，一开始 $carry 的值是空的（Null），然后随着循环，</p><p>$carry 会逐渐合并数组的每一个元素。</p><p><code>array_reduce</code> 可以说是如下代码构成的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">$result = null;</span><br><span class="line"></span><br><span class="line">foreach ($params as $param) &#123;</span><br><span class="line">    $result .= $param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>循环遍历数组的每一个元素，然后保持一个不变的值。</p><p>与官方文档的描述对应起来了！<strong>将数组简化为一个单一的值。</strong></p><p>也就是说通过 <code>array_reduce</code> 最终会返回一个值作为处理的结果。</p><p><code>array_reduce</code> 可以接收第三个参数，即初始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">$result = array_reduce($params, function ($carry, $item) &#123;</span><br><span class="line">    return $carry . $item;</span><br><span class="line">&#125;, &#x27;init&#x27;);</span><br><span class="line"></span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>最终会输出：<code>initabc</code></p><p>如果不设置第三个参数，那么初始值就会默认为 Null。</p><p>最开始，我以为会是返回 true 或者 false 来判定中间件的执行结果，</p><p>但是 Laravel 的设计却令人惊叹！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a Closure that represents a slice of the application onion.</span><br><span class="line"> *</span><br><span class="line"> * @return \Closure</span><br><span class="line"> */</span><br><span class="line">protected function carry()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($stack, $pipe) &#123;</span><br><span class="line">        return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (is_callable($pipe)) &#123;</span><br><span class="line">                    // If the pipe is a callable, then we will call it directly, but otherwise we</span><br><span class="line">                    // will resolve the pipes out of the dependency container and call it with</span><br><span class="line">                    // the appropriate method and arguments, returning the results back out.</span><br><span class="line">                    return $pipe($passable, $stack);</span><br><span class="line">                &#125; elseif (! is_object($pipe)) &#123;</span><br><span class="line">                    [$name, $parameters] = $this-&gt;parsePipeString($pipe);</span><br><span class="line"></span><br><span class="line">                    // If the pipe is a string we will parse the string and resolve the class out</span><br><span class="line">                    // of the dependency injection container. We can then build a callable and</span><br><span class="line">                    // execute the pipe function giving in the parameters that are required.</span><br><span class="line">                    $pipe = $this-&gt;getContainer()-&gt;make($name);</span><br><span class="line"></span><br><span class="line">                    $parameters = array_merge([$passable, $stack], $parameters);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // If the pipe is already an object we&#x27;ll just make a callable and pass it to</span><br><span class="line">                    // the pipe as-is. There is no need to do any extra parsing and formatting</span><br><span class="line">                    // since the object we&#x27;re given was already a fully instantiated object.</span><br><span class="line">                    $parameters = [$passable, $stack];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                $carry = method_exists($pipe, $this-&gt;method)</span><br><span class="line">                                ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters)</span><br><span class="line">                                : $pipe(...$parameters);</span><br><span class="line"></span><br><span class="line">                return $this-&gt;handleCarry($carry);</span><br><span class="line">            &#125; catch (Throwable $e) &#123;</span><br><span class="line">                return $this-&gt;handleException($passable, $e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码十分生涩难懂，简直如同“天书”，</p><p>因此我自己尝试实现相同的逻辑并且让代码变成“说人话”。</p><h3 id="对暗号游戏"><a href="#对暗号游戏" class="headerlink" title="对暗号游戏"></a>对暗号游戏</h3><p>接下来我开始参考着 Laravel 中间件的代码实现一个“对暗号”的“游戏”，</p><p>比如在一个军营里，一共有 A、B、C 三个巡逻队，</p><p>为了避免整个暗号泄露出去，规定每一个巡逻队都只持有暗号的其中一句，</p><p>今晚的暗号是：“上山打老虎”，</p><p>那么三个巡逻队分别得到的暗号是：</p><p>A：上山</p><p>B：打</p><p>C：老虎</p><p>而你半夜出去嘘嘘，刚好被巡逻队给碰上了……</p><p>于是，你必须说出你的口令，否则就会被当做奸细就地正法……</p><p>三只巡逻队可以抽象成“巡逻队”概念，即定义一个 Middleware 作为父类，</p><p>他们都有核对口号的方法 handle，以及自己的密令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">abstract class Middleware</span><br><span class="line">&#123;</span><br><span class="line">    public $keyword;</span><br><span class="line"></span><br><span class="line">    public function handle($value, Closure $closure)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword);</span><br><span class="line"></span><br><span class="line">        // 包含指定关键词的口令视为核对成功</span><br><span class="line">        if (strstr($value, $this-&gt;keyword) != false) &#123;</span><br><span class="line">            return $closure($value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &#x27;口令核对失败&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建三个巡逻队，继承基类并且拥有独立的口令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Middleware_A extends Middleware</span><br><span class="line">&#123;</span><br><span class="line">    public $keyword = &#x27;上山&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Middleware_B extends Middleware</span><br><span class="line">&#123;</span><br><span class="line">    public $keyword = &#x27;打&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Middleware_C extends Middleware</span><br><span class="line">&#123;</span><br><span class="line">    public $keyword = &#x27;老虎&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现具体的逻辑，声明一个包含 N 只巡逻队的数组（可以是 0-3 个）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function middlewares()</span><br><span class="line">&#123;</span><br><span class="line">    $params = [&#x27;Middleware_A&#x27;, &#x27;Middleware_B&#x27;, &#x27;Middleware_C&#x27;];</span><br><span class="line">    $params = array_reverse($params);</span><br><span class="line"></span><br><span class="line">    return $params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里增加了一个 <code>array_reverse</code> 将数组反转的方法，下文会解释。</p><p>然后实现核对密令的逻辑，比如你遇到巡逻队 A，那就核对巡逻队 A 的密令，</p><p>如果同时遇到两只巡逻队，A+B 或者 A+C 或者 B+C，那就应该核对两个巡逻队的密令，</p><p>如果你非常不幸的同时遇到三只巡逻队，那就要核对 ABC 的密令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function carry()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($stack, $pipe) &#123;</span><br><span class="line">        return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">            if ($pipe instanceof Closure) &#123;</span><br><span class="line">                return $pipe($passable, $stack);</span><br><span class="line">            &#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">                $pipe = new $pipe;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function init()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($destination) &#123;</span><br><span class="line"></span><br><span class="line">        var_dump($destination);</span><br><span class="line"></span><br><span class="line">        return &#x27;ok&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$response = array_reduce(middlewares(), carry(), init());</span><br><span class="line"></span><br><span class="line">var_dump($response(&#x27;小鸡炖蘑菇&#x27;));</span><br><span class="line">var_dump($response(&#x27;上山打野鸡&#x27;));</span><br><span class="line">var_dump($response(&#x27;上山打老虎&#x27;));</span><br></pre></td></tr></table></figure><p>上面的代码虽然很短，但是要理解起来非常不易。</p><p><code>array_reduce</code> 可以接收三个参数：</p><p>第一个参数是数组，即要遍历的数组；</p><p>第二个参数是一个方法&#x2F;闭包（匿名函数），即执行遍历的逻辑；</p><p>第三个参数是初始值。</p><p>初始值是最终想要实现的结果，当满足所有条件后，就会返回初始值函数里的代码。</p><p>而 <code>middlewares</code> 是最开始定义巡逻队的地方，很不幸你同时遇到三只巡逻队：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function middlewares()</span><br><span class="line">&#123;</span><br><span class="line">    $params = [&#x27;Middleware_A&#x27;, &#x27;Middleware_B&#x27;, &#x27;Middleware_C&#x27;];</span><br><span class="line">    $params = array_reverse($params);</span><br><span class="line"></span><br><span class="line">    return $params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array_reverse</code> 这里的反转数组与接下来的堆栈调用有关，</p><p>栈结构是先进后出，会导致乱序，我们希望的结果是按照 A、B、C 的顺序执行。</p><p><code>init</code> 方法定义了最终希望输出的值，如果满足所有条件的话，就返回这个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function init()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($destination) &#123;</span><br><span class="line"></span><br><span class="line">        var_dump($destination);</span><br><span class="line"></span><br><span class="line">        return &#x27;ok&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>carry</code> 是整个逻辑最关键的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function carry()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($stack, $pipe) &#123;</span><br><span class="line">        return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">            if ($pipe instanceof Closure) &#123;</span><br><span class="line">                return $pipe($passable, $stack);</span><br><span class="line">            &#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">                $pipe = new $pipe;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法涉及了闭包的递归调用，<strong>最终的返回结果依然是一个闭包。</strong></p><p>carry 方法传入两个参数 $stack, </p><p>$stack 即遍历过程中持续引用的值，而 $pipe 则是当前元素。</p><p>回忆一下上面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$params = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">$result = array_reduce($params, function ($carry, $item) &#123;</span><br><span class="line">    return $carry . $item;</span><br><span class="line">&#125;, &#x27;init&#x27;);</span><br><span class="line"></span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>应该不难理解，这里就是循环遍历一个数组，依次取值进行计算，最终返回一个结果而已。</p><p>接下来分析代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return function ($stack, $pipe) &#123;</span><br><span class="line">    return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">        if ($pipe instanceof Closure) &#123;</span><br><span class="line">            return $pipe($passable, $stack);</span><br><span class="line">        &#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">            $pipe = new $pipe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>carry 返回一个闭包，同时它内层的代码也是返回一个闭包，并且接收一个 $passable 作为参数。</p><blockquote><p>$passable 的作用就是递归函数中不断传给下一次调用的值</p></blockquote><p>在最内层，是一个条件判断语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ($pipe instanceof Closure) &#123;</span><br><span class="line">    return $pipe($passable, $stack);</span><br><span class="line">&#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">    $pipe = new $pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return $pipe-&gt;handle($passable, $stack);</span><br></pre></td></tr></table></figure><p>如果传来的值不是 Closure（闭包类型），则判断它是否是一个对象，</p><p>如果不是对象则根据这个元素的名字实例化出对象来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!is_object($pipe)) &#123;</span><br><span class="line">    $pipe = new $pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用实例化对象的 handle 方法，并且把 $passable 和 持续保留的那个值 $stack 传给 handle。</p><p>再看一次执行的逻辑，并且模拟每一次执行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return function ($stack, $pipe) &#123;</span><br><span class="line">    return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">        if ($pipe instanceof Closure) &#123;</span><br><span class="line">            return $pipe($passable, $stack);</span><br><span class="line">        &#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">            $pipe = new $pipe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// array_reduce 返回的是一个闭包，可以当做函数调用</span><br><span class="line">$response = array_reduce(middlewares(), carry(), init());</span><br><span class="line"></span><br><span class="line">// 传入一个用来验证的口令</span><br><span class="line">$result = $response(&#x27;上山打野鸡&#x27;);</span><br><span class="line"></span><br><span class="line">// 打印出验证结果</span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>第一次遍历：</p><p>通过 init 方法赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 第一步：$stack 赋值，init 方法也是一个闭包，接收一个 $destination 参数</span><br><span class="line">// $stack 的初始值即 init 方法返回的闭包，所以是：</span><br><span class="line"></span><br><span class="line">$stack = function ($destination) &#123;</span><br><span class="line">     var_dump($destination);</span><br><span class="line">     </span><br><span class="line">     return &#x27;ok&#x27;;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">// 接着，取出数组的第一个元素</span><br><span class="line">$pipe = &#x27;Middleware_A&#x27;;</span><br><span class="line"></span><br><span class="line">// 第二步，进入闭包：function ($passable) use ($stack, $pipe)</span><br><span class="line">// 这里的 $passable 就是上面调用时传入的值：“上山打野鸡”</span><br><span class="line">// 执行判断语句</span><br><span class="line"></span><br><span class="line">if ($pipe instanceof Closure) &#123;</span><br><span class="line">    return $pipe($passable, $stack);</span><br><span class="line">&#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">    $pipe = new $pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 很明显 $pipe 此时只是一个字符串，因此不满足 $pipe instanceof Closure</span><br><span class="line">// 于是进入 else 条件 !is_object($pipe) 它并不是一个对象，因此满足此条件</span><br><span class="line">// 所以将 $pipe = new $pipe; 实例化成对象</span><br><span class="line">// 此处的代码即：$pipe = new Middleware_A();</span><br><span class="line">// 实例化出巡逻队A的对象，然后调用他的 handle 方法并返回</span><br><span class="line"></span><br><span class="line">return $pipe-&gt;handle($passable, $stack);</span><br><span class="line"></span><br><span class="line">// Middleware_A 继承了父类 Middleware，因此 handle 为：</span><br><span class="line"></span><br><span class="line">public function handle($value, Closure $closure)</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword);</span><br><span class="line"></span><br><span class="line">    // 包含指定关键词的口令视为核对成功</span><br><span class="line">    if (strstr($value, $this-&gt;keyword) != false) &#123;</span><br><span class="line">        return $closure($value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#x27;口令核对失败&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时 value 的值为：上山打野鸡，巡逻队A的暗号是：上山</span><br><span class="line">// 因此巡逻队A验证成功，将这个值传给闭包然后返回</span><br><span class="line"></span><br><span class="line">return $closure($value);</span><br><span class="line"></span><br><span class="line">// 接收到参数的 $closure 就是 $stack，也就是我们最开始定义的 init 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二次遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 此时已经不会经过 init 初始化了，</span><br><span class="line">// $stack的值是第一步返回的 return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">// 也就是说init方法</span><br><span class="line"></span><br><span class="line">// 第二次遍历$pipe就会取第二个巡逻队：Middleware_B</span><br><span class="line">// 继续进入 function ($passable) use ($stack, $pipe) 执行判断语句</span><br><span class="line"></span><br><span class="line">if ($pipe instanceof Closure) &#123;</span><br><span class="line">    return $pipe($passable, $stack);</span><br><span class="line">&#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">    $pipe = new $pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样Middleware_B只是一个字符串，因此会被实例化成类</span><br><span class="line">// 然后与第一步一样，进行比对暗号，Middleware_B的暗号是：打</span><br><span class="line">// 因此：上山打野鸡包含了这个字符，就符合巡逻队B的暗号</span><br><span class="line">// 又经过父类的方法：</span><br><span class="line"></span><br><span class="line">public function handle($value, Closure $closure)</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword);</span><br><span class="line"></span><br><span class="line">    // 包含指定关键词的口令视为核对成功</span><br><span class="line">    if (strstr($value, $this-&gt;keyword) != false) &#123;</span><br><span class="line">        return $closure($value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#x27;口令核对失败&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// init 方法继续被传递给下一个执行的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步，也就是最后的一个巡逻队了，这里产生了一个分歧点，即最后一个暗号不符合要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 第三次遍历$pipe就会取第三个巡逻队：Middleware_C</span><br><span class="line">// 继续进入 function ($passable) use ($stack, $pipe) 执行判断语句</span><br><span class="line"></span><br><span class="line">if ($pipe instanceof Closure) &#123;</span><br><span class="line">    return $pipe($passable, $stack);</span><br><span class="line">&#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">    $pipe = new $pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一样是实例化的过程，然后分歧点出现了</span><br><span class="line">// 第三个巡逻队的暗号是：老虎，而此时给出的却是：上山打野鸡</span><br><span class="line">// 不包括“老虎”两个字</span><br><span class="line"></span><br><span class="line">public function handle($value, Closure $closure)</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword);</span><br><span class="line"></span><br><span class="line">    // 包含指定关键词的口令视为核对成功</span><br><span class="line">    if (strstr($value, $this-&gt;keyword) != false) &#123;</span><br><span class="line">        return $closure($value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#x27;口令核对失败&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不符合结果就直接返回了一个字符串“口令核对失败”</span><br><span class="line">// 这个返回的值会被当做$stack的值</span><br><span class="line">// 最后就跟递归函数一样层层返回，将“口令核对失败”作为array_reduce将数组简化的唯一值</span><br><span class="line"></span><br><span class="line">// 也就是说，$response(&#x27;上山打野鸡&#x27;) 最后返回的是“口令核对失败”</span><br><span class="line"></span><br><span class="line">// array_reduce 返回的是一个闭包，可以当做函数调用</span><br><span class="line">$response = array_reduce(middlewares(), carry(), init());</span><br><span class="line"></span><br><span class="line">// 传入一个用来验证的口令</span><br><span class="line">$result = $response(&#x27;上山打野鸡&#x27;);</span><br><span class="line"></span><br><span class="line">// 打印出验证结果</span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure><p>如果是传入正确的口令：上山打老虎呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 巡逻队C核对口令正确，就会继续把参数传给闭包</span><br><span class="line">public function handle($value, Closure $closure)</span><br><span class="line">&#123;</span><br><span class="line">    var_dump(&#x27;暗号：&#x27; . $this-&gt;keyword);</span><br><span class="line"></span><br><span class="line">    // 包含指定关键词的口令视为核对成功</span><br><span class="line">    if (strstr($value, $this-&gt;keyword) != false) &#123;</span><br><span class="line">        return $closure($value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#x27;口令核对失败&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时三个巡逻队已经遍历完了，还记得一直传下来的$stack的值是什么吗？</span><br><span class="line">// 答案是：init</span><br><span class="line">// 你可以重新返回去查看第一步到第三步，只要是验证口令成功的时候，</span><br><span class="line">// init 方法都会被当做下一个闭包传递下去，init 闭包即 $stack 的值</span><br><span class="line">// 所以最终返回的 $stack 即 init 方法</span><br></pre></td></tr></table></figure><blockquote><p>注意！上面的 array_reduce 执行完毕后并不是真的执行了代码，而是返回一个层层嵌套的递归函数（闭包），只有在调用的时候才会一层一层的执行，因而最先调用的中间件反而会变成最后执行（栈结构先进后出），所以我们才会在最开始反转数组，以保证执行顺序。</p></blockquote><p>至此，Laravel 中间件验证路由请求的原理也就搞清楚了。</p><p>捋顺之后只剩下久久的深思，一段简单的代码却蕴藏着如此精深的奥妙。</p><p>可是……写完了如此长篇的文章，我的框架的中间件却还没有开始着手……</p><h2 id="为框架添加中间件"><a href="#为框架添加中间件" class="headerlink" title="为框架添加中间件"></a>为框架添加中间件</h2><h3 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h3><p>中间件其实跟路由的原理类似，即创建一个专门保存命名和映射关系的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 键值对数组的键即中间件名称，值即对应的中间件</span><br><span class="line">&#x27;auth&#x27; =&gt; &#x27;App\\Middleware\\AuthMiddleware&#x27;</span><br></pre></td></tr></table></figure><p>只需要用一个简单的名称字符串即可映射到对应的中间件类。</p><p>由于一个路由可以有很多个中间件，所以路由配置里需要添加一个数组用来存储中间件的名称。</p><h3 id="优化路由模块"><a href="#优化路由模块" class="headerlink" title="优化路由模块"></a>优化路由模块</h3><p>在之前的设计中，Router 的 $routes 设计为静态变量，</p><p>其实只要修改 http_server.php 修改引入方式即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require_once &#x27;./app/route/web.php&#x27;;</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>而路由配置文件 web.php 只要返回 $router 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>这样 Router 的 $routes 就不再需要设置为静态变量了。</p><h3 id="路由添加中间件"><a href="#路由添加中间件" class="headerlink" title="路由添加中间件"></a>路由添加中间件</h3><p>在路由配置的时候，期望效果是可以通过如下两种方式配置中间件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line">    &#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;]</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;)-&gt;middleware([&#x27;auth&#x27;]);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>第一种是在分组的时候，配置全组共用的中间件，</p><p>第二种是在单个路由配置的时候，可以自定义该路由的中间件，</p><p>如果使用第二种方法，并且该路由在一个分组里，该路由不仅有分组的中间件，还有自己单独添加的中间件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line">    &#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;]</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    // 这个路由的中间件为：[auth, other]</span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;other&#x27;]);</span><br><span class="line"></span><br><span class="line">    // 这个路由的中间件为：[auth]</span><br><span class="line">    $router-&gt;get(&#x27;/admin&#x27;, &#x27;IndexController@index&#x27;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>上面的 &#x2F;user 路由额外添加了一个中间件 other，而 &#x2F;admin 路由不会受到影响。</p><p>中间件的合并顺序为：分组&gt;自定义</p><p>即优先执行分组设置的全局中间件，然后再执行自定义中间件。</p><p>middleware 方法必须放在 get&#x2F;post&#x2F;any 方法之后。</p><p>修改 name 方法，让该方法也返回 $this，这样就可以链式调用了。</p><p>然后为 Router 添加 middleware 方法，该方法接收一个数组参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 新增属性(全局中间件)</span><br><span class="line">protected $middlewares = [];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 路由添加中间件</span><br><span class="line">*</span><br><span class="line">* @param array $middlewares</span><br><span class="line">* @return Router</span><br><span class="line">*/</span><br><span class="line">public function middleware(array $middlewares)</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;lastHandleRouteIndex === null) &#123;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合并中间件，优先级为：分组&gt;单个路由自定义配置</span><br><span class="line">    $middlewares = array_merge($this-&gt;middlewares, $middlewares);</span><br><span class="line">    // 去除重复中间件</span><br><span class="line">    $middlewares = array_unique($middlewares);</span><br><span class="line">    // 找到最后一个添加的路由</span><br><span class="line">    $route = $this-&gt;routes[$this-&gt;lastHandleRouteIndex];</span><br><span class="line">    $route-&gt;middleware = $middlewares;</span><br><span class="line"></span><br><span class="line">    $this-&gt;routes[$this-&gt;lastHandleRouteIndex] = $route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是分组的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 设置参数</span><br><span class="line">* @param $key</span><br><span class="line">* @param $value</span><br><span class="line">*/</span><br><span class="line">protected function createConfig($key, $value)</span><br><span class="line">&#123;</span><br><span class="line">    switch ($key) &#123;</span><br><span class="line">        case &#x27;namespace&#x27;:</span><br><span class="line">            $this-&gt;namespace = $value;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;middleware&#x27;:</span><br><span class="line">            $this-&gt;middlewares = $value;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组配置时将中间件加入全局的中间件数组。</p><p>在调用结束的时候，应该把这个数组清空：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 路由分组</span><br><span class="line">* @param $func</span><br><span class="line">*/</span><br><span class="line">public function group($func)</span><br><span class="line">&#123;</span><br><span class="line">    $func();</span><br><span class="line"></span><br><span class="line">    // 执行完成后将参数初始化</span><br><span class="line">    $this-&gt;namespace = &#x27;&#x27;;</span><br><span class="line">    $this-&gt;middlewares = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给路由增加中间件的功能就完成了。</p><p>现在 RouteParams 路由配置对象里已经可以取到 middleware 属性的值了。</p><h3 id="封装请求与响应"><a href="#封装请求与响应" class="headerlink" title="封装请求与响应"></a>封装请求与响应</h3><p>框架的请求和响应是 swoole 的对象，内置的方法无法满足框架的需求，</p><p>因此需要将请求和响应进行封装，在框架的 module 目录新建文件夹 Http，</p><p>Http 模块用于实现 Http 请求相关的处理类，新建两个类：Request 和 Response 用于封装请求和响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"># Request.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Route\RouteParams;</span><br><span class="line"></span><br><span class="line">class Request</span><br><span class="line">&#123;</span><br><span class="line">    protected $request, $route;</span><br><span class="line"></span><br><span class="line">    public function __construct($request, $route)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;request = $request;</span><br><span class="line">        $this-&gt;route = $route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取路由</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getRoute(): RouteParams</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断该请求是否ajax</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public function isAjax()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;XMLHttpRequest&#x27; == $this-&gt;request-&gt;header[&#x27;x-requested-with&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取get参数</span><br><span class="line">     * @param null $key</span><br><span class="line">     * @param null $default</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getQueryParams($key = null, $default = null)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($key == null) &#123;</span><br><span class="line">            return $this-&gt;request-&gt;get;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isset($this-&gt;request-&gt;get[$key]) ? $this-&gt;request-&gt;get[$key] : $default;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取post参数</span><br><span class="line">     * @param null $key</span><br><span class="line">     * @param null $default</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getPostParams($key = null, $default = null)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($key == null) &#123;</span><br><span class="line">            return $this-&gt;request-&gt;post;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isset($this-&gt;request-&gt;post[$key]) ? $this-&gt;request-&gt;post[$key] : $default;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求方法</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    public function getRequestMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;request-&gt;server[&#x27;request_method&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求IP地址</span><br><span class="line">     * @return string | null</span><br><span class="line">     */</span><br><span class="line">    public function getRequestIP()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;request-&gt;header[&#x27;x-real-ip&#x27;] ?? null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求头</span><br><span class="line">     * @param $key</span><br><span class="line">     * @return string | null</span><br><span class="line">     */</span><br><span class="line">    public function getHeaders($key = null)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($key == null) &#123;</span><br><span class="line">            return $this-&gt;request-&gt;header;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;request-&gt;header[$key] ?? null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取cookie</span><br><span class="line">     * @param $key</span><br><span class="line">     * @return string | null</span><br><span class="line">     */</span><br><span class="line">    public function getCookies($key = null)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($key == null) &#123;</span><br><span class="line">            return $this-&gt;request-&gt;cookie;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;request-&gt;cookie[$key] ?? null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求URI</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getRequestURI()</span><br><span class="line">    &#123;</span><br><span class="line">        return rtrim($this-&gt;request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request 请求类实现了一些简单方法的封装，后续如有需求还可以继续扩展。</p><p>接下来创建 Response 响应类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/12/21</span><br><span class="line"> * Time：11:31 AM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Response</span><br><span class="line">&#123;</span><br><span class="line">    protected $response;</span><br><span class="line"></span><br><span class="line">    public function __construct($response)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;response = $response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getResponse()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showMessage($message)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">        $this-&gt;response-&gt;end($message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了一个简单的输出消息的方法，后续将会增加输出 view 和 API 类型的响应。</p><p>现在 Request 和 Response 都有了，但是每次都要分别取这两个对象不太方便，</p><p>于是我又定义了一个 Kernel（Http 请求核心类）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">class Kernel</span><br><span class="line">&#123;</span><br><span class="line">    protected $request, $response;</span><br><span class="line"></span><br><span class="line">    public function __construct(Request $request, Response $response)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;request = $request;</span><br><span class="line">        $this-&gt;response = $response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;request-&gt;getRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getResponse()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;response-&gt;getResponse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getHttpRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getHttpResponse()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以取到 swoole 的请求和响应，也可以取到框架自定义的请求和响应。</p><p>这样就把请求和响应封装成一个 Http 核心类了。</p><h3 id="中间件类"><a href="#中间件类" class="headerlink" title="中间件类"></a>中间件类</h3><p>Laravel 的中间件不需要继承任何类，完全由用户自定义，</p><p>为了统一规范，我定义了一个中间件的父类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">abstract class Middleware</span><br><span class="line">&#123;</span><br><span class="line">    abstract public function handle(Kernel $kernel, Closure $next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里类只有一个抽象方法 handle，所有的中间件继承这个类实现统一的标准。</p><p>handle 第一个参数即上文封装的 kernel，在中间件里通过 kernel 来获取参数和返回响应。</p><p>再在博客项目的路径下，新建 app&#x2F;middleware 用来存放中间件 TestMiddlewareA 和 TestMiddlewareB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line">use FireRabbitEngine\Module\Http\Kernel;</span><br><span class="line">use FireRabbitEngine\Module\Http\Middleware;</span><br><span class="line"></span><br><span class="line">class TestMiddlewareA extends Middleware</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Kernel $kernel, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        $request = $kernel-&gt;getHttpRequest();</span><br><span class="line"></span><br><span class="line">        if ($request-&gt;getQueryParams(&#x27;a&#x27;) == 1) &#123;</span><br><span class="line">            $kernel-&gt;getHttpResponse()-&gt;showMessage(&#x27;aa&#x27;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $next($kernel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestMiddlewareB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line">use FireRabbitEngine\Module\Http\Kernel;</span><br><span class="line">use FireRabbitEngine\Module\Http\Middleware;</span><br><span class="line"></span><br><span class="line">class TestMiddlewareB extends Middleware</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public function handle(Kernel $kernel, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        $request = $kernel-&gt;getHttpRequest();</span><br><span class="line"></span><br><span class="line">        if ($request-&gt;getQueryParams(&#x27;b&#x27;) == 1) &#123;</span><br><span class="line">            $kernel-&gt;getHttpResponse()-&gt;showMessage(&#x27;bb&#x27;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $next($kernel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个中间件的逻辑非常简单，就是通过 get 参数来判断是否通过请求，</p><p>这样在测试的时候就很方便了，只要在路径上面修改参数即可看到中间件的效果。</p><blockquote><p>中间件实际上可以不需要 return null，为了美观后面会对此处的代码进行优化。</p></blockquote><h3 id="中间件逻辑"><a href="#中间件逻辑" class="headerlink" title="中间件逻辑"></a>中间件逻辑</h3><p>前文通过 array_reduce 来演示 Laravel 中间件的处理逻辑，</p><p>现在就要把这个逻辑在框架中进行实现，在 Http 文件夹下新建一个 PipeLine 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">class Pipeline</span><br><span class="line">&#123;</span><br><span class="line">    protected $pipes, $kernel;</span><br><span class="line"></span><br><span class="line">    public function send(Kernel $kernel)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;kernel = $kernel;</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function through($pipes)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;pipes = $pipes;</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function then(Closure $destination)</span><br><span class="line">    &#123;</span><br><span class="line">        return array_reduce($this-&gt;pipes, $this-&gt;carry(), $this-&gt;dispatchRouter($destination));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function carry()</span><br><span class="line">    &#123;</span><br><span class="line">        return function ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">            return function ($passable) use ($stack, $pipe) &#123;</span><br><span class="line"></span><br><span class="line">                if ($pipe instanceof Closure) &#123;</span><br><span class="line">                    return $pipe($passable, $stack);</span><br><span class="line">                &#125; elseif (!is_object($pipe)) &#123;</span><br><span class="line">                    $pipe = new $pipe;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return $pipe-&gt;handle($passable, $stack);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dispatchRouter($destination)</span><br><span class="line">    &#123;</span><br><span class="line">        return function ($passable) use ($destination) &#123;</span><br><span class="line">            $destination($passable);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就是用来处理中间件逻辑的地方，具体逻辑与前文“对口令游戏”一样。</p><p>这个类通过 send 方法接收上面封装好的 Http 核心类 Kernel，</p><p>Kernel 类具有获取请求参数和返回响应的权限，它会被传到中间件里。</p><blockquote><p>中间件要根据请求参数判断是否符合条件，在中间件还可以直接返回响应</p></blockquote><p>中间件的逻辑类也完成了，接下来就要修改 RouteParams 解析路由实例化控制器的地方。</p><p>将原来创建控制器实例的方法抽取出来，封装为 routeResponse：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 执行路由响应</span><br><span class="line">* @return \Closure</span><br><span class="line">*/</span><br><span class="line">protected function routeResponse()</span><br><span class="line">&#123;</span><br><span class="line">    return function ($kernel) &#123;</span><br><span class="line"></span><br><span class="line">        // 实例化类</span><br><span class="line">        $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">        $controllerObject = new $controllerName($kernel);</span><br><span class="line">        $this-&gt;uri = rtrim($this-&gt;request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;);</span><br><span class="line"></span><br><span class="line">        $params = $this-&gt;getRouteParams();</span><br><span class="line"></span><br><span class="line">        // 执行方法时，路径参数作为方法的参数</span><br><span class="line">        call_user_func_array([$controllerObject, $this-&gt;action], $params);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的是一个闭包，也就是说返回值是一个匿名函数。</p><p>接下来修改原来的 createResponse 方法，现在可以直接实例化 PipeLine 来调用中间件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 执行路由</span><br><span class="line">    * @param $request</span><br><span class="line">    * @param $response</span><br><span class="line">    */</span><br><span class="line">public function createResponse($request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    // 判断请求方法是否正确</span><br><span class="line">    if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123;</span><br><span class="line">        (new MethodErrorResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断方法是否存在</span><br><span class="line">    $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">    if (!class_exists($controllerName)) &#123;</span><br><span class="line">        (new ClassNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $action = $this-&gt;action;</span><br><span class="line"></span><br><span class="line">    // 不存在方法则返回404</span><br><span class="line">    if (!method_exists($controllerName, $action)) &#123;</span><br><span class="line">        (new ActionNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $this-&gt;request = $request;</span><br><span class="line">    $this-&gt;response = $response;</span><br><span class="line"></span><br><span class="line">    // 测试用</span><br><span class="line">    $pipes = [&#x27;App\\middleware\\TestMiddlewareA&#x27;, &#x27;App\\middleware\\TestMiddlewareB&#x27;];</span><br><span class="line"></span><br><span class="line">    $pipeline = new Pipeline();</span><br><span class="line"></span><br><span class="line">    $kernel = new Kernel(new Request($request, $this), new Response($response));</span><br><span class="line"></span><br><span class="line">    $routeResponse = $pipeline-&gt;send($kernel)</span><br><span class="line">        -&gt;through(array_reverse($pipes))</span><br><span class="line">        -&gt;then($this-&gt;routeResponse());</span><br><span class="line"></span><br><span class="line">    $routeResponse($kernel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pipes = [&#x27;App\\Middleware\\TestMiddlewareA&#x27;, &#x27;App\\middleware\\TestMiddlewareB&#x27;];</span><br></pre></td></tr></table></figure><p>手动声明了两个中间件，然后访问任意路由就可以看到中间件的效果了。</p><p>测试之后发现中间件正常运行。</p><h3 id="添加映射关系"><a href="#添加映射关系" class="headerlink" title="添加映射关系"></a>添加映射关系</h3><p>框架现在没有中间件名称和类名的映射关系，所以才只能用上面的测试代码来调试。</p><p>接下来创建一个配置中间件映射关系的文件，在博客目录下创建 app&#x2F;Middleware&#x2F;Kernel.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Middleware;</span><br><span class="line"></span><br><span class="line">class Kernel</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 实例化的中间件</span><br><span class="line">     *</span><br><span class="line">     * @var [Middleware]</span><br><span class="line">     */</span><br><span class="line">    protected static $instances;</span><br><span class="line"></span><br><span class="line">    protected static $middlewares = [</span><br><span class="line">        &#x27;a&#x27; =&gt; TestMiddlewareA::class,</span><br><span class="line">        &#x27;b&#x27; =&gt; TestMiddlewareB::class,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public static function getMiddlewareInstance($name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 从已实例化的对象数组中取</span><br><span class="line">        if(isset(self::$instances[$name])) &#123;</span><br><span class="line">           return self::$instances[$name]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 未实例化的创建新对象</span><br><span class="line">        $middlewareName = self::$middlewares[$name] ?? null;</span><br><span class="line"></span><br><span class="line">        if($middlewareName == null) &#123;</span><br><span class="line">            self::$instances[$name] = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self::$instances[$name] = new $middlewareName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return self::$instances[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我用一个静态变量来保存实例化的中间件，因为中间件的对象是固定的，</p><p>没必要每次调用的时候都重新创建一次，一旦实例化之后就直接放进内存，这样可以提高效率。</p><p>这样就完成整个中间件的功能了。</p><h2 id="测试中间件"><a href="#测试中间件" class="headerlink" title="测试中间件"></a>测试中间件</h2><p>编辑 web.php，添加两个测试路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line">    &#x27;middleware&#x27; =&gt; [&#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    // 这个路由的中间件为：[auth, other]</span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;IndexController@index&#x27;)-&gt;middleware([&#x27;b&#x27;]);</span><br><span class="line"></span><br><span class="line">    // 这个路由的中间件为：[auth]</span><br><span class="line">    $router-&gt;get(&#x27;/admin&#x27;, &#x27;IndexController@index&#x27;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return $router;</span><br></pre></td></tr></table></figure><p>通过访问上述定义的路由，然后修改 a 和 b 参数的值即可看到中间件的拦截功能。</p><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><h3 id="中间件配置化"><a href="#中间件配置化" class="headerlink" title="中间件配置化"></a>中间件配置化</h3><p>修改时间：2020-02-13 22:47</p><p>突然发现 PipeLine 方法调用 Kernel 类十分不合理。</p><p>框架的代码不应该依赖项目的代码，因此需要优化。</p><p>在 app&#x2F;config 目录下创建 middleware.php 用来保存中间件的名称映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line">    &#x27;a&#x27; =&gt; App\Middleware\TestMiddlewareA::class,</span><br><span class="line">    &#x27;b&#x27; =&gt; App\Middleware\TestMiddlewareB::class,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>接着将原本放在 app&#x2F;Middleware 下面的 Kernel 删掉，</p><p>并且在框架 module&#x2F;Http 目录新建一个 Middleware 目录，将 Middleware.php 移到这个目录下。</p><p>同时重新创建一个 Kernel 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Http\Middleware;</span><br><span class="line"></span><br><span class="line">class Kernel</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 实例化的中间件</span><br><span class="line">     *</span><br><span class="line">     * @var [Middleware]</span><br><span class="line">     */</span><br><span class="line">    protected static $instances;</span><br><span class="line"></span><br><span class="line">    protected static $middlewares = [];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取配置文件</span><br><span class="line">     * @param $middlewares</span><br><span class="line">     */</span><br><span class="line">    public static function setConfig($middlewares)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$middlewares = $middlewares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getMiddlewareInstance($name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 从已实例化的对象数组中取</span><br><span class="line">        if (isset(self::$instances[$name])) &#123;</span><br><span class="line">            return self::$instances[$name];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 未实例化的创建新对象</span><br><span class="line">        $middlewareName = self::$middlewares[$name] ?? null;</span><br><span class="line"></span><br><span class="line">        if ($middlewareName == null) &#123;</span><br><span class="line">            self::$instances[$name] = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self::$instances[$name] = new $middlewareName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return self::$instances[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件的配置不再直接写在这个类里，而是通过 <code>setConfig</code> 读取配置参数。</p><p>接着在修改文件 http_server.php，加入一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\FireRabbitEngine\Module\Http\Middleware\Kernel::setConfig(require &#x27;./app/config/middleware.php&#x27;);</span><br></pre></td></tr></table></figure><p>这样框架和项目之间就不再有直接的依赖关系了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（七）路由动态注入参数</title>
      <link href="/2021/02/11/my-swoole-framework-7/"/>
      <url>/2021/02/11/my-swoole-framework-7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经写到第七章了，竟然还是在写路由 &#x3D; &#x3D;</p><p>今天就来实现路由给方法动态传参的功能。</p><p>动态传参就是说路由定义的规则：<code>/article/&#123;id&#125;</code>，会自动注入到 ArticleController 的 show 方法。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个路由</span><br><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);</span><br><span class="line"></span><br><span class="line">// 有了上面的路由，用户访问地址：/article/1 就会自动调用ArticleController的show方法</span><br><span class="line">// 在前面Controller定义了一个setRouteParams方法把路由参数传给控制器</span><br><span class="line">// 控制器内部就存储了一个一维数组：[1]</span><br><span class="line">// 但是这样调用起来很麻烦，尤其是参数比较多的时候容易造成混乱</span><br><span class="line">// 最优雅的方式就是Laravel的路由参数自动注入</span><br><span class="line">// 只要在ArticleController定义一个show方法，接收一个id参数，而路由参数会自动注入到这个方法</span><br><span class="line"></span><br><span class="line">public function show($id) &#123;</span><br><span class="line">    var_dump($id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果是多个参数的呢？也是一样的。</span><br><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;/edit/&#123;classify&#125;&#x27;, &#x27;ArticleController@test&#x27;)-&gt;name(&#x27;article.test&#x27;);</span><br><span class="line"></span><br><span class="line">public function test($id, $classify) &#123;</span><br><span class="line">    var_dump($id, $classify);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>这里涉及到一个函数动态传参的问题，</p><p>“如何将数组元素的值，依次作为参数传给函数？”</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>PHP 支持函数不定参数，就是用三个点加上参数名即视为可变参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 支持可变参数的函数</span><br><span class="line">function test(...$args) &#123;</span><br><span class="line">    var_dump($args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试传入不同的参数</span><br><span class="line">test(&#x27;a&#x27;);</span><br><span class="line">test(&#x27;a&#x27;, &#x27;b&#x27;);</span><br><span class="line">test(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;a&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;a&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(1) &quot;b&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(3) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;a&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(1) &quot;b&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(1) &quot;c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在函数中可以将可变参数当成数组来使用，</p><p>那是不是说明我们传一个数组进去，就会被当成多个参数了呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 支持可变参数的函数</span><br><span class="line">function test(...$args) &#123;</span><br><span class="line">    var_dump($args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试传入不同的参数</span><br><span class="line">$params = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;];</span><br><span class="line">test($params);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码，我们传入一个数组，按照设想的情况，</p><p>数组中的三个值应该会作为三个参数传入 test 方法，</p><p>假设的情况是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$params = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;];</span><br><span class="line"></span><br><span class="line">// 想象中的样子</span><br><span class="line">test($params); =&gt; test(&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;);</span><br></pre></td></tr></table></figure><p>但实际的打印结果却是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  array(3) &#123;</span><br><span class="line">    [0]=&gt;</span><br><span class="line">    string(2) &quot;aa&quot;</span><br><span class="line">    [1]=&gt;</span><br><span class="line">    string(2) &quot;bb&quot;</span><br><span class="line">    [2]=&gt;</span><br><span class="line">    string(2) &quot;cc&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，数组只是被当成了一个参数传给 test 方法，</p><p>其实不难想像，如果数组会被解析成多个参数，</p><p>那可变参数不是不能传入数组作为参数了吗？</p><h3 id="函数的动态调用"><a href="#函数的动态调用" class="headerlink" title="函数的动态调用"></a>函数的动态调用</h3><p>通常情况下，没办法实现将数组依次当做函数的参数。</p><p>而要用到 PHP 内置的一个方法：<code>call_user_func_array</code></p><blockquote><p>注意！有一个类似的方法：call_user_func，不要输错！</p></blockquote><p>这个方法可以动态调用函数，它可以接收两个数组作为参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array([调用对象，方法名称]，[参数1，参数2，参数3...]);</span><br></pre></td></tr></table></figure><p>第一个数组，第一个元素是调用的对象，即类的实例化，第二个参数是一个字符串即要调用对象的方法名称。</p><p>第二个数组即是要依次传入方法的参数。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class  Test</span><br><span class="line">&#123;</span><br><span class="line">    public function show($name)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function playGame($name, $game)</span><br><span class="line">    &#123;</span><br><span class="line">        $text = $name . &#x27;在玩&#x27; . $game;</span><br><span class="line">        var_dump($text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test();</span><br><span class="line"></span><br><span class="line">call_user_func_array([$test, &#x27;show&#x27;], [&#x27;小白&#x27;]);</span><br><span class="line">call_user_func_array([$test, &#x27;playGame&#x27;], [&#x27;小白&#x27;, &#x27;俄罗斯方块&#x27;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">string(27) &quot;小白在玩俄罗斯方块&quot;</span><br></pre></td></tr></table></figure><h2 id="RouteParams：动态传参"><a href="#RouteParams：动态传参" class="headerlink" title="RouteParams：动态传参"></a>RouteParams：动态传参</h2><p>动态传参的原理已经弄明白了，接下来只要改造原来的解析方法就可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行路由</span><br><span class="line"> * @param $request</span><br><span class="line"> * @param $response</span><br><span class="line"> */</span><br><span class="line">public function createResponse($request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    // 判断请求方法是否正确</span><br><span class="line">    if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123;</span><br><span class="line">        (new MethodErrorResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断方法是否存在</span><br><span class="line">    $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">    if (!class_exists($controllerName)) &#123;</span><br><span class="line">        (new ClassNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $action = $this-&gt;action;</span><br><span class="line"></span><br><span class="line">    // 不存在方法则返回404</span><br><span class="line">    if (!method_exists($controllerName, $action)) &#123;</span><br><span class="line">        (new ActionNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化类</span><br><span class="line">    $controllerObject = new $controllerName($request, $response, $this-&gt;name);</span><br><span class="line">    $this-&gt;uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;);</span><br><span class="line"></span><br><span class="line">    $params = $this-&gt;getRouteParams();</span><br><span class="line"></span><br><span class="line">    // ... 以后的中间件写在这里</span><br><span class="line"></span><br><span class="line">    // 执行方法时，路径参数作为方法的参数</span><br><span class="line">    call_user_func_array([$controllerObject, $action], $params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取路由参数</span><br><span class="line"> * @return array</span><br><span class="line"> */</span><br><span class="line">public function getRouteParams()</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;uri == &#x27;&#x27;) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preg_match_all($this-&gt;pattern, $this-&gt;uri, $result);</span><br><span class="line"></span><br><span class="line">    if (count($result[0]) == 0) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $params = [];</span><br><span class="line"></span><br><span class="line">    for ($i = 1; $i &lt; count($result); $i++) &#123;</span><br><span class="line">        $params[] = $result[$i][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RouteParams 将获取路由参数的方法抽离出来，</p><p>并且移除了 Controller 的 setRouteParams 方法，改用动态注入参数。</p><p>这样路由的参数注入也完成了！</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>编辑 web.php 添加路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;/edit/&#123;classify&#125;&#x27;, &#x27;ArticleController@test&#x27;)-&gt;name(&#x27;article.test&#x27;);</span><br><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);</span><br></pre></td></tr></table></figure><p>编辑 ArticleController 添加方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class ArticleController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function show($id)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($id);</span><br><span class="line">        $this-&gt;showMessage(&#x27;ok&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function test($id, $classify)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($id,$classify);</span><br><span class="line"></span><br><span class="line">        $this-&gt;showMessage(&#x27;ok&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果均能正确打印出注入的参数。</p><p>另外，发现到一个新问题就是路由的顺序，由于是使用正则匹配的，只要修改声明路由的顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/article/&#123;id&#125;</span><br><span class="line">/article/&#123;id&#125;/edit/&#123;classify&#125;</span><br></pre></td></tr></table></figure><p>结果访问：<a href="http://firerabbit-engine.ht/article/1/edit/aa">http://firerabbit-engine.ht/article/1/edit/aa</a></p><p>就会优先匹配到上面的正则，而 id 参数则是：1&#x2F;edit&#x2F;aa</p><p>只能人为避免因为书写顺序而产生奇奇怪怪的问题了，在编辑路由的时候优先将匹配规则较多的写在上面就不会弄错了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（六）为路由模块添加命名功能</title>
      <link href="/2021/02/10/my-swoole-framework-6/"/>
      <url>/2021/02/10/my-swoole-framework-6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考 Laravel 的路由，希望我的框架可以跟 Laravel 一样给路由命名，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/home&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;);</span><br></pre></td></tr></table></figure><p>然后提供一个全局函数 <code>route</code> 生成链接。</p><p>比如定义一个路由名 index，路由规则是：“&#x2F;home”，</p><p>然后通过 <code>route(&#39;index&#39;)</code> 会生成 “&#x2F;home” 链接。</p><p>其实就是从路由配置表里找到对应名字的路由然后取出路由规则而已。</p><p>对于需要解析路由参数的就不能只是简单的返回字符串了，</p><p>比如显示文章详情：路由命名为：<code>article.show</code>，对应的路由规则：<code>/article/&#123;id&#125;</code>，</p><p>通过全局函数生成文章详情的链接 <code>route(&#39;article.show&#39;, [&#39;id&#39;=&gt;1])</code> 返回：“&#x2F;article&#x2F;1”。</p><p>原理与解析路由参数一样，即正则匹配进行替换。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>只要方法返回类本身就可以实现链式调用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    protected $word = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    public function say($word)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;word .= $word . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showResult()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test();</span><br><span class="line"></span><br><span class="line">$test-&gt;say(&#x27;hello&#x27;)-&gt;say(&#x27;world&#x27;)-&gt;showResult();</span><br></pre></td></tr></table></figure><h2 id="Router：添加命名功能"><a href="#Router：添加命名功能" class="headerlink" title="Router：添加命名功能"></a>Router：添加命名功能</h2><p>其实这个地方我有点疑惑，为什么 name 方法是写在最后面，</p><p>get 方法已经将路由参数写入到配置里面了，写在链式调用最后的方法如何修改前面设定的值？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/home&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;);</span><br></pre></td></tr></table></figure><p>结果灵鸡一动！突然想到一种奇妙的方法来实现“后调改前值”，</p><p>就是加入一个 lastIndex，在插入路由配置的时候，计算这个插入值所在数组的索引并保存下来。</p><p>如果要修改最后一个调用的配置，就可以从 lastIndex 获取到了。</p><p>修改 Router 原来生成路由配置的方法，</p><p>为了链式调用必须返回类本身，同时加入 lastIndex 变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保存最后一个操作的路由对象索引</span><br><span class="line"> * @var null</span><br><span class="line"> */</span><br><span class="line">private $lastHandleRouteIndex = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个 GET 请求路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @return Router</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function get($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    return $this-&gt;addRoute(RequestMethod::GET, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个 POST 请求路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @return Router</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function post($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    return $this-&gt;addRoute(RequestMethod::POST, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个任意请求皆可的路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @return Router</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function any($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    return $this-&gt;addRoute(RequestMethod::ANY, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将路由加入配置数组</span><br><span class="line"> * @param $method</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @return Router</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">protected function addRoute($method, $route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $param = new RouteParams();</span><br><span class="line"></span><br><span class="line">    $param-&gt;method = $method;</span><br><span class="line">    $param-&gt;route = $route;</span><br><span class="line"></span><br><span class="line">    // 格式为：控制器@方法名</span><br><span class="line">    $actions = explode(&#x27;@&#x27;, $controller);</span><br><span class="line"></span><br><span class="line">    // 如果不按照规则设置控制器和方法名则抛出异常</span><br><span class="line">    if (count($actions) != 2) &#123;</span><br><span class="line">        throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $param-&gt;controller = $actions[0];</span><br><span class="line">    $param-&gt;action = $actions[1];</span><br><span class="line">    $param-&gt;namespace = $this-&gt;namespace;</span><br><span class="line">    $param-&gt;pattern = $this-&gt;getPattern($route);</span><br><span class="line"></span><br><span class="line">    self::$routes[] = $param;</span><br><span class="line"></span><br><span class="line">    // 新加入行</span><br><span class="line">    $this-&gt;lastHandleRouteIndex = count(self::$routes) - 1;</span><br><span class="line"></span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引一开始是空的，所以赋值为 null，在插入路由配置的时候，</p><p>通过 <code>count(self::$routes) - 1</code> 计算当前新插入值的索引。</p><p>接下来新增一个 name 方法，路由名相当于唯一的 ID，因此不允许重复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给路由命名</span><br><span class="line"> * @param $routeName</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function name($routeName)</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;lastHandleRouteIndex === null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断路由是否存在同名</span><br><span class="line">    foreach (self::$routes as $route) &#123;</span><br><span class="line">        if ($route-&gt;name == $routeName) &#123;</span><br><span class="line">            throw  new RouteParamException(&#x27;路由名称重复[&#x27; . $routeName . &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $route = self::$routes[$this-&gt;lastHandleRouteIndex];</span><br><span class="line">    $route-&gt;name = $routeName;</span><br><span class="line"></span><br><span class="line">    self::$routes[$this-&gt;lastHandleRouteIndex] = $route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 lastIndex 找到最后一个修改的路由配置，然后给它赋值 name 属性。</p><h3 id="避坑指南：诡异的-null-值"><a href="#避坑指南：诡异的-null-值" class="headerlink" title="避坑指南：诡异的 null 值"></a>避坑指南：诡异的 null 值</h3><blockquote><p>这里有个神坑！</p></blockquote><p><strong>PHP 对 null 值的判定很诡异</strong>。</p><p>在 PHP 中，<code>0 == null</code> 的结果为 true。</p><p>因此必须使用三等号：<code>===</code> 来判定包括类型也必须完全一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($this-&gt;lastHandleRouteIndex === null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 if 本来是为了判定是否有路由配置，如果还没配置路由就调用 name 就直接跳过，</p><p>第一次操作时，lastIndex 的索引是 0，如果不使用三等号第一个配置的路由就会被跳过了。</p><blockquote><p>在使用判空操作，如：empty、isset 时必须注意 0、null、false 这几个值</p></blockquote><p>再来个有趣的小测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(0 == false);</span><br><span class="line">var_dump(0 == null);</span><br><span class="line">var_dump(0 == &#x27;&#x27;);</span><br></pre></td></tr></table></figure><p>以上三个，全部输出：<code>bool(true)</code>，是不是惊到了！</p><p>在某些场合双等号判定会造成失误，应该改用三等号。</p><h2 id="测试路由名称"><a href="#测试路由名称" class="headerlink" title="测试路由名称"></a>测试路由名称</h2><p>编辑 web.php 修改路由配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line"></span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line"></span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;user.index&#x27;);</span><br><span class="line">    $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;)-&gt;name(&#x27;login.submit&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 Router 执行 <code>var_dump(self::$routes)</code> 即可看到所有路由，name 字段已经变成设置的值了。</p><h2 id="RouteParams：生成链接"><a href="#RouteParams：生成链接" class="headerlink" title="RouteParams：生成链接"></a>RouteParams：生成链接</h2><p>RouteParams 保存了路由的所有配置，接下来要让它能根据路由规则生成对应的链接。</p><p>PHP 提供了一个正则替换函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$uri = &#x27;/article/&#123;id&#125;/classify/&#123;classify&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">$pattern = &#x27;/&#123;id&#125;/&#x27;;</span><br><span class="line"></span><br><span class="line">$res = preg_replace($pattern, &#x27;123&#x27;, $uri);</span><br><span class="line"></span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure><p>上面的示例代码通过正则替换将自定义规则的 id 替换成数字 123。</p><p>接着，继续看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$uri = &#x27;/article/&#123;id&#125;/classify/&#123;classify&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">$patterns = [&#x27;/&#123;id&#125;/&#x27;, &#x27;/&#123;classify&#125;/&#x27;, ];</span><br><span class="line">$replacements = [123, 456];</span><br><span class="line"></span><br><span class="line">$res = preg_replace($patterns, $replacements, $uri);</span><br><span class="line"></span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(25) &quot;/article/123/classify/456&quot;</span><br></pre></td></tr></table></figure><p>通过传入数组参数即可实现批量替换，输出的字符串即链接地址。</p><p>原理已经搞清楚了，开始实际上手，修改 RouteParams，创建一个空方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function createLink($params)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建一个用来生成 query 参数的私有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 构建query参数的地址</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $query</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">private function buildQuery($route, $query)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return $route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $route . &#x27;?&#x27; . http_build_query($query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有参数就直接返回，不然就返回包含 query 参数的路由地址。</p><p>现在可以开始编写 createLink 的方法体了，</p><p>因为斜杠是正则符号，所以首页的路由“&#x2F;”要单独返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function createLink($params)</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;route == &#x27;/&#x27;) &#123;</span><br><span class="line">        return $this-&gt;buildQuery($this-&gt;route, $params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着判断是否包含路由参数，没有参数的也直接返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public function createLink($params)</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;route == &#x27;/&#x27;) &#123;</span><br><span class="line">        return $this-&gt;buildQuery($this-&gt;route, $params);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 取出自定义规则</span><br><span class="line">    $pattern = &#x27;/.*?\/(\&#123;.*?\&#125;)/&#x27;;</span><br><span class="line">    preg_match_all($pattern, $this-&gt;route, $result);</span><br><span class="line"></span><br><span class="line">    // 如果匹配不到自定义参数则直接返回路由规则</span><br><span class="line">    if (count($result[0]) == 0) &#123;</span><br><span class="line">        return $this-&gt;buildQuery($this-&gt;route, $params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我希望实现全局函数 <code>route</code> 传入指定的参数就可以替换掉路由自定义的参数，生成替换了值的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过调用全局函数生成路由</span><br><span class="line">route(&#x27;article.show&#x27;, [&#x27;id&#x27; =&gt; 1])    =&gt; 返回结果：/article/1</span><br><span class="line"></span><br><span class="line">// 也就是说，路由规则需要实现如下变换效果</span><br><span class="line">/article/&#123;id&#125;   =&gt; 从 route 函数传入的数组中取出 id 变量，然后再替换掉 &#123;id&#125;</span><br></pre></td></tr></table></figure><p>这一步比较复杂，要先获取到匹配的规则：<code>&#123;id&#125;</code>，以及花括号里面的参数名 <code>id</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获取自定义匹配规则</span><br><span class="line">$patterns = [];</span><br><span class="line">$paramNames = [];</span><br><span class="line"></span><br><span class="line">for ($i = 1, $count = count($result[1]); $i &lt;= $count; $i++) &#123;</span><br><span class="line"></span><br><span class="line">    // 此处得到自定义规则的参数，如：&#123;id&#125;</span><br><span class="line">    $rule = $result[1][$i - 1];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 花括号是正则表达式的符号，必须加上反斜杠转转义</span><br><span class="line">     * 最后，在前后加上斜杠才是一个完整的正则表达式</span><br><span class="line">     */</span><br><span class="line">    $patterns[] = &#x27;/&#x27; . str_replace([&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;\&#123;&#x27;, &#x27;\&#125;&#x27;], $rule) . &#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 截取中间的变量名</span><br><span class="line">     */</span><br><span class="line">    $paramNames[] = substr($rule, 1, strlen($rule) - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共得到了两个数组，<code>$patterns</code> 是正则替换表达式，而 <code>$paramNames</code> 是自定义路由参数的名字。</p><p>接下来把自定义路由中的 <code>&#123;id&#125;</code> 替换成  <code>$params</code> 传入的变量值，</p><p>因为传入的 <code>$params</code> 是一个关联数组，而 PHP 的正则替换函数是一维数组，</p><p>所以要把 <code>$params</code> 中对应的参数提取出来，</p><p>从 <code>$paramNames</code> 获取到的路径参名称作为键，取 <code>$params</code> 传进来的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成要替换的数组结构，根据规则与传入的参数一一对应</span><br><span class="line"> * 假设路由规则是 /article/&#123;id&#125;</span><br><span class="line"> * 那么$params传入的参数就应该是：[&#x27;id&#x27;=&gt;1]</span><br><span class="line"> */</span><br><span class="line">$replacements = [];</span><br><span class="line">foreach ($paramNames as $key) &#123;</span><br><span class="line"></span><br><span class="line">    if (!isset($params[$key])) &#123;</span><br><span class="line">        throw new RouteParamException(&#x27;路由缺失参数[&#x27; . $key . &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $replacements[] = $params[$key];</span><br><span class="line"></span><br><span class="line">    // 移除路径参数</span><br><span class="line">    unset($params[$key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的数组不符合规则就抛出一个 <code>RouteParamException</code> 异常（这个异常是之前定义的）。</p><p>生成替换的值后，就可以把这个键从 <code>$params</code> 里面移除了，因为最后我们要生成 query 参数，</p><p>而路径参数已经被使用了，如果不去掉，最后就会变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/article/1?id=1</span><br></pre></td></tr></table></figure><p>所以这一步顺便使用 <code>unset</code> 方法把已经用过的数组元素去掉。</p><p>接下来就可以使用正则替换将规则中的 <code>&#123;id&#125;</code> 替换成对应的值了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 然后将替换值根据规则进行置换</span><br><span class="line">$res = preg_replace($patterns, $replacements, $this-&gt;route);</span><br></pre></td></tr></table></figure><p>最后再构建 query 参数就大功告成，完整代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成链接</span><br><span class="line"> * @param $params</span><br><span class="line"> * @return string</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function createLink($params)</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;route == &#x27;/&#x27;) &#123;</span><br><span class="line">        return $this-&gt;buildQuery($this-&gt;route, $params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取出自定义规则</span><br><span class="line">    $pattern = &#x27;/.*?\/(\&#123;.*?\&#125;)/&#x27;;</span><br><span class="line">    preg_match_all($pattern, $this-&gt;route, $result);</span><br><span class="line"></span><br><span class="line">    // 如果匹配不到自定义参数则直接返回路由规则</span><br><span class="line">    if (count($result) == 0) &#123;</span><br><span class="line">        return $this-&gt;buildQuery($this-&gt;route, $params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取自定义匹配规则</span><br><span class="line">    $patterns = [];</span><br><span class="line">    $paramNames = [];</span><br><span class="line"></span><br><span class="line">    for ($i = 1, $count = count($result[1]); $i &lt;= $count; $i++) &#123;</span><br><span class="line"></span><br><span class="line">        // 此处得到自定义规则的参数，如：&#123;id&#125;</span><br><span class="line">        $rule = $result[1][$i - 1];</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 花括号是正则表达式的符号，必须加上反斜杠转转义</span><br><span class="line">         * 最后，在前后加上斜杠才是一个完整的正则表达式</span><br><span class="line">         */</span><br><span class="line">        $patterns[] = &#x27;/&#x27; . str_replace([&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;\&#123;&#x27;, &#x27;\&#125;&#x27;], $rule) . &#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 截取中间的变量名</span><br><span class="line">         */</span><br><span class="line">        $paramNames[] = substr($rule, 1, strlen($rule) - 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成要替换的数组结构，根据规则与传入的参数一一对应</span><br><span class="line">     * 假设路由规则是 /article/&#123;id&#125;</span><br><span class="line">     * 那么$params传入的参数就应该是：[&#x27;id&#x27;=&gt;1]</span><br><span class="line">     */</span><br><span class="line">    $replacements = [];</span><br><span class="line">    foreach ($paramNames as $key) &#123;</span><br><span class="line"></span><br><span class="line">        if (!isset($params[$key])) &#123;</span><br><span class="line">            throw new RouteParamException(&#x27;路由缺失参数[&#x27; . $key . &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $replacements[] = $params[$key];</span><br><span class="line"></span><br><span class="line">        // 移除路径参数</span><br><span class="line">        unset($params[$key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 然后将替换值根据规则进行置换</span><br><span class="line">    $res = preg_replace($patterns, $replacements, $this-&gt;route);</span><br><span class="line"></span><br><span class="line">    return $this-&gt;buildQuery($res, $params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建query参数的地址</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $query</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">private function buildQuery($route, $query)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return $route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $route . &#x27;?&#x27; . http_build_query($query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router：查找路由名"><a href="#Router：查找路由名" class="headerlink" title="Router：查找路由名"></a>Router：查找路由名</h2><p>路由的名称是唯一的，每一个名称对应一个路由，相当于路由的唯一 ID。</p><p>只要根据这个 ID 就可以找到对应的路由。</p><p>Router 方法应该暴露一个可供外部调用的查找路由名方法，修改 Router 添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据路由名称寻找路由</span><br><span class="line"> * @param $routeName</span><br><span class="line"> * @return mixed|null</span><br><span class="line"> */</span><br><span class="line">public function findRouteFromName($routeName)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (self::$routes as $route) &#123;</span><br><span class="line">        if ($route-&gt;name == $routeName) &#123;</span><br><span class="line">            return $route;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法倒是很简单，只要循环找到对应名字的路由配置就行了。</p><blockquote><p>查找数组效率最高的方法不是遍历而是通过数组的下标，我考虑过将路由分为已命名路由和未命名路由，未命名路由就是一个普通的索引数组，而已命名路由则是关联数组，键即路由的名字，这样查找路由时优先从已命名路由通过下标查询，如果没有再去遍历未命名路由，但是如果改成这样，Router 匹配路由规则时就要再进行一次数组合并，反而会降低路由解析的性能，因此舍弃了这种想法</p></blockquote><h2 id="route：全局函数"><a href="#route：全局函数" class="headerlink" title="route：全局函数"></a>route：全局函数</h2><p>只要 <code>new</code> 一个 Router 对象就可以调用 <code>findRouteFromName</code> 找到对应的路由，</p><p>然后再调用路由的 <code>createLink</code> 生成路由链接。</p><p>现在缺少一个全局函数：<code>route</code>。</p><p>同样借助 composer 的自动加载功能，修改 composer.jsp，添加加载规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;&#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\&quot;: &quot;app/&quot;,</span><br><span class="line">      &quot;FireRabbitEngine\\Module\\&quot;: &quot;firerabbit-engine/module/&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files&quot;: [</span><br><span class="line">      &quot;firerabbit-engine/common/function.php&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 psr-4 下面增加了一个字段 files，而这个文件即框架的通用函数库。</p><p>创建 <code>firerabbit-engine/common/function.php</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * 根据路由名称生成对应路由</span><br><span class="line"> * @param $routeName</span><br><span class="line"> * @param array $params</span><br><span class="line"> * @return mixed|null</span><br><span class="line"> * @throws \FireRabbitEngine\Module\Route\Exception\RouteNotFoundException</span><br><span class="line"> */</span><br><span class="line">function route($routeName, $params = [])</span><br><span class="line">&#123;</span><br><span class="line">    $router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">    $route = $router-&gt;findRouteFromName($routeName);</span><br><span class="line"></span><br><span class="line">    if ($route == null) &#123;</span><br><span class="line">        throw new \FireRabbitEngine\Module\Route\Exception\RouteNotFoundException(&#x27;不存在路由[&#x27; . $routeName . &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $route-&gt;createLink($params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我不使用 <code>function_exists</code> 来判断方法是否存在，即使真的冲突了就直接报错，</p><p>实际上使用了这个方法来判断也没任何意义，重名了就不定义这个函数？</p><p>那连错在哪都不知道，为何要屏蔽可能报错的信息？我是百思不得其解。</p><p>如果遇到重名的函数，在我们执行 <code>php http_server.php</code> 启动程序的时候就会报错了，完全不用担心。</p><p>如果我们引入了第三方的包，其他人也定义了 route 函数那样才会产生麻烦。</p><p>一般的第三方包也不会去定义全局函数，而是封装成类进行调用，</p><p>函数是面向过程开发，也不符合开发包的理念，所以这一点完全不用担心。</p><p>因为我开发的是框架，只有框架才会定义全局函数，我的框架里也不可能引入其他框架。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>三种不同类型的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;)-&gt;name(&#x27;login&#x27;);</span><br><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;)-&gt;name(&#x27;article.show&#x27;);</span><br><span class="line">$router-&gt;get(&#x27;/test/&#123;id&#125;/user/&#123;name&#125;/goods/&#123;qq&#125;&#x27;, &#x27;TestController@test&#x27;)-&gt;name(&#x27;test&#x27;);</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$link = route(&#x27;test&#x27;, [&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;哈哈怪&#x27;, &#x27;qq&#x27; =&gt; &#x27;okok&#x27;]);</span><br><span class="line">$link2 = route(&#x27;article.show&#x27;, [&#x27;id&#x27; =&gt; 123]);</span><br><span class="line">$link3 = route(&#x27;login&#x27;);</span><br><span class="line"></span><br><span class="line">var_dump($link, $link2, $link3);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(33) &quot;/test/1/user/哈哈怪/goods/okok&quot;</span><br><span class="line">string(12) &quot;/article/123&quot;</span><br><span class="line">string(6) &quot;/login&quot;</span><br></pre></td></tr></table></figure><p>看上去没有问题了！</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（五）为路由模块添加解析路径参数功能</title>
      <link href="/2021/02/09/my-swoole-framework-5/"/>
      <url>/2021/02/09/my-swoole-framework-5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文已经实现简单路由，但还没办法解析路由参数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.huotublog.com/article/1</span><br></pre></td></tr></table></figure><p>包含了路径参数，即 article 后面的 1。</p><p>本章将为路由模块添加解析路径参数的功能。</p><p>另外，Query 参数不叫路由参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.huotublog.com/article/1?a=222</span><br></pre></td></tr></table></figure><p>这里的 a 是 query 参数，不是路径参数。</p><h2 id="匹配原理"><a href="#匹配原理" class="headerlink" title="匹配原理"></a>匹配原理</h2><p>假设路径参数可以有无限多个，在这样无法确定数量情况，</p><p>无法使用一般的 if-else 来获取。</p><p>这个时候就需要用到<strong>正则表达式</strong>了。</p><p>正则表达式可以按照某种规则来匹配特殊的字符串，包括替换字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$url = &#x27;/article/123&#x27;;</span><br><span class="line">$pattern = &#x27;/article\/(\d+)/&#x27;;</span><br><span class="line">preg_match_all($pattern, $url, $res);</span><br><span class="line"></span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure><p>以上示例输出结果：123</p><p>正则表达式不仅可以匹配特定的规则，而且只要加上括号就可以把匹配规则视为一个变量单独取出来。</p><p>如果不了解正则表达式可以自行搜索，这里不扩展。</p><p>因为我的路由配置参考 Laravel，所以要实现 Laravel 一样的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/article/&#123;id&#125;</span><br><span class="line">/article/&#123;id&#125;/edit</span><br></pre></td></tr></table></figure><p>用花括号包起来的部分视为变量，即有如下匹配规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/article/&#123;id&#125;       =&gt;  /article/1</span><br><span class="line">/article/&#123;id&#125;/edit  =&gt;  /article/1/edit</span><br></pre></td></tr></table></figure><p>还要获取路径上面的变量，也就是说 <code>&#123;id&#125;</code> 部分视为一个路径参数。</p><p>既要匹配路由规则，又要获得路径参数，一共需要两步才能实现这样的效果。</p><p>第一步是把 <code>/article/&#123;id&#125;</code> 转化为一个正则表达式，</p><p>第二步是拿上一步得到的正则表达式去匹配 URI。</p><p>路径参数不只是数字，也有可能是别的什么，甚至是中文都可以当做路径参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是一个正确的 URI</span><br><span class="line">http://www.huotublog.com/article/我的swoole框架</span><br></pre></td></tr></table></figure><p>只不过你在浏览器输入上面的地址，然后再复制下来，会被 urlencode。</p><p>结果就会变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://huotublog.com/article/%E6%88%91%E7%9A%84swoole%E6%A1%86%E6%9E%B6</span><br></pre></td></tr></table></figure><p>所以如果我们只匹配数字是不行的，而是要用全匹配 <code>.</code>。</p><blockquote><p>.（点）在正则表达式里是匹配除了换行之外所有字符串</p></blockquote><p>例如有一个包括两个路径参数的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$url = &#x27;/article/&#123;id&#125;/show/&#123;classify&#125;&#x27;;</span><br><span class="line">$pattern = &#x27;/.*?\/(\&#123;.*?\&#125;)/&#x27;;</span><br><span class="line"></span><br><span class="line">preg_match_all($pattern, $url, $result);</span><br><span class="line"></span><br><span class="line">$transform = str_replace($result[1], &#x27;(.*?)&#x27;, $url);</span><br><span class="line"></span><br><span class="line">var_dump($transform);</span><br></pre></td></tr></table></figure><p>这里的规则 <code>.*?</code> 是三个正则表达式符号，意思是说尽可能多的匹配字符串。</p><p>加上括号就可以取出匹配的字符串了，匹配到的结果存入 $result 变量，</p><p>也就是说一共会得到两个值：<code>&#123;id&#125;</code>、<code>&#123;classify&#125;</code></p><p>然后用 PHP 的 <code>str_replace</code> 函数进行简单的替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(25) &quot;/article/(.*?)/show/(.*?)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>如果不懂正则表达式，直接套用 (.*?) 即可，既简单又粗暴</p></blockquote><p>替换后的字符串还不是表达式，只是加入了正则表达式符号而已。</p><blockquote><p>就跟 json 字符串不是 json 对象一个道理，还需要转换一下才能变成表达式</p></blockquote><p>斜杠是正则表达式里比较敏感的字符，过滤掉干扰字符串，修改为完整的正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$transform = &#x27;/article/(.*?)/show/(.*?)&#x27;</span><br><span class="line">$pattern = &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\/&#x27;, $transform) . &#x27;$/&#x27;;</span><br><span class="line"></span><br><span class="line">var_dump($pattern);</span><br></pre></td></tr></table></figure><blockquote><p>rtrim 去掉右侧的斜杠，防止匹配不到</p></blockquote><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(32) &quot;/\/article\/(.*?)\/show\/(.*?)$/&quot;</span><br></pre></td></tr></table></figure><p>转换得到的正则表达式，用它就可以匹配出路由规则中的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 用户请求的 URI</span><br><span class="line">$requestUri = &#x27;/article/123/show/abc&#x27;;</span><br><span class="line"></span><br><span class="line">// 通过匹配得到参数</span><br><span class="line">preg_match_all(&#x27;/\/article\/(.*?)\/show\/(.*?)$/&#x27;, $requestUri, $params);</span><br><span class="line"></span><br><span class="line">var_dump($params);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array(3) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  array(1) &#123;</span><br><span class="line">    [0]=&gt;</span><br><span class="line">    string(21) &quot;/article/123/show/abc&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  array(1) &#123;</span><br><span class="line">    [0]=&gt;</span><br><span class="line">    string(3) &quot;123&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  array(1) &#123;</span><br><span class="line">    [0]=&gt;</span><br><span class="line">    string(3) &quot;abc&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由参数解析原理已经搞清楚了，接下来就在路由解释器里实现这个功能。</p><h2 id="实现解析路由功能"><a href="#实现解析路由功能" class="headerlink" title="实现解析路由功能"></a>实现解析路由功能</h2><p>有一个特殊的路由，即 <code>/</code>（首页的地址），</p><p>所有的路由都带有 <code>/</code>，导致无法正确匹配，因此这个路由需要单独判断。</p><h3 id="RouteParams：解析参数传给控制器"><a href="#RouteParams：解析参数传给控制器" class="headerlink" title="RouteParams：解析参数传给控制器"></a>RouteParams：解析参数传给控制器</h3><p>RouteParams 增加一个新的变量用来保存替换后的正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 正则表达式匹配规则</span><br><span class="line"> * @var string</span><br><span class="line"> */</span><br><span class="line">public $pattern;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public function createResponse($request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    // 判断请求方法是否正确</span><br><span class="line">    if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123;</span><br><span class="line">        (new MethodErrorResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断方法是否存在</span><br><span class="line">    $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">    if (!class_exists($controllerName)) &#123;</span><br><span class="line">        (new ClassNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $action = $this-&gt;action;</span><br><span class="line">    </span><br><span class="line">    // 不存在方法则返回404</span><br><span class="line">    if (!method_exists($controllerName, $action)) &#123;</span><br><span class="line">        (new ActionNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化类</span><br><span class="line">    $controllerObject = new $controllerName($request, $response, $this-&gt;name);</span><br><span class="line"></span><br><span class="line">    $uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;);</span><br><span class="line"></span><br><span class="line">    if ($uri != &#x27;&#x27;) &#123;</span><br><span class="line">        // 匹配路径参数</span><br><span class="line">        preg_match_all($this-&gt;pattern, $uri, $result);</span><br><span class="line"></span><br><span class="line">        if (count($result[0]) != 0) &#123;</span><br><span class="line"></span><br><span class="line">            $params = [];</span><br><span class="line"></span><br><span class="line">            for ($i = 1; $i &lt; count($result); $i++) &#123;</span><br><span class="line">                $params[] = $result[$i][0];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $controllerObject-&gt;setRouteParams($params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ... 以后的中间件写在这里</span><br><span class="line"></span><br><span class="line">    // 执行方法</span><br><span class="line">    $controllerObject-&gt;$action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RouteParams 创建出控制器对象的时候解析出路径参数，把路径参数传给控制器。</p><h3 id="Controller：接收路径参数"><a href="#Controller：接收路径参数" class="headerlink" title="Controller：接收路径参数"></a>Controller：接收路径参数</h3><p>控制器还没有 setRouteParams 方法，修改控制器的基类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Controller;</span><br><span class="line"></span><br><span class="line">class Controller</span><br><span class="line">&#123;</span><br><span class="line">    protected $request, $response, $route, $routeParams;</span><br><span class="line"></span><br><span class="line">    public function __construct($request, $response, $route)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;request = $request;</span><br><span class="line">        $this-&gt;response = $response;</span><br><span class="line">        $this-&gt;route = $route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showMessage($message)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">        $this-&gt;response-&gt;end($message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setRouteParams($params)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;routeParams = $params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来控制器也能够获取到路径参数了。</p><h3 id="Router：赋值匹配规则"><a href="#Router：赋值匹配规则" class="headerlink" title="Router：赋值匹配规则"></a>Router：赋值匹配规则</h3><p>Router 在生成配置的时候，可以同时生成路由的正则匹配规则。</p><p>修改生成路由配置的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将路由加入配置数组</span><br><span class="line"> * @param $method</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">protected function addRoute($method, $route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $param = new RouteParams();</span><br><span class="line"></span><br><span class="line">    $param-&gt;method = $method;</span><br><span class="line">    $param-&gt;route = $route;</span><br><span class="line"></span><br><span class="line">    // 格式为：控制器@方法名</span><br><span class="line">    $actions = explode(&#x27;@&#x27;, $controller);</span><br><span class="line"></span><br><span class="line">    // 如果不按照规则设置控制器和方法名则抛出异常</span><br><span class="line">    if (count($actions) != 2) &#123;</span><br><span class="line">        throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $param-&gt;controller = $actions[0];</span><br><span class="line">    $param-&gt;action = $actions[1];</span><br><span class="line">    $param-&gt;namespace = $this-&gt;namespace;</span><br><span class="line">    $param-&gt;pattern = $this-&gt;getPattern($route);</span><br><span class="line"></span><br><span class="line">    self::$routes[] = $param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected function getPattern($route)</span><br><span class="line">&#123;</span><br><span class="line">    if ($route == &#x27;/&#x27;) &#123;</span><br><span class="line">        return &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $pattern = &#x27;/.*?\/(\&#123;.*?\&#125;)/&#x27;;</span><br><span class="line"></span><br><span class="line">    preg_match_all($pattern, $route, $result);</span><br><span class="line"></span><br><span class="line">    // 如果第一个数组的个数为0，表示没有匹配到路径参数</span><br><span class="line">    if (count($result[0]) == 0) &#123;</span><br><span class="line">        return &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\/&#x27;, $route) . &#x27;/&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $transform = str_replace($result[1], &#x27;(.*?)&#x27;, $route);</span><br><span class="line">    $transform = &#x27;/&#x27; . str_replace(&#x27;/&#x27;, &#x27;\/&#x27;, $transform) . &#x27;$/&#x27;;</span><br><span class="line"></span><br><span class="line">    return $transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPattern 方法将路由中自定义的规则解析成对应的正则表达式，</p><p>然后赋值给 RouteParams 对象。</p><h3 id="Router：修改匹配规则"><a href="#Router：修改匹配规则" class="headerlink" title="Router：修改匹配规则"></a>Router：修改匹配规则</h3><p>现在已经可以获取到正则表达式了，接下来修改路由匹配规则。</p><p>将之前 Router 直接匹配的方法改成正则匹配，</p><p>PHP 有一个用来测试正则匹配结果的函数：<code>preg_match</code>。</p><p>没有匹配到正则表达式的字符，这个函数会返回 0，以此来判断是否符合路由规则。</p><p>修改 findRoute 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 寻找路由</span><br><span class="line"> * @param $request</span><br><span class="line"> * @return mixed|null</span><br><span class="line"> */</span><br><span class="line">public function findRoute($request)</span><br><span class="line">&#123;</span><br><span class="line">    $uri = rtrim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;);</span><br><span class="line"></span><br><span class="line">    foreach (self::$routes as $route) &#123;</span><br><span class="line"></span><br><span class="line">        if (empty($uri)) &#123;</span><br><span class="line"></span><br><span class="line">            if ($route-&gt;route != &#x27;/&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return $route;</span><br><span class="line"></span><br><span class="line">        &#125; else if ($route-&gt;pattern != &#x27;&#x27; &amp;&amp; preg_match($route-&gt;pattern, $uri) != 0) &#123;</span><br><span class="line"></span><br><span class="line">            return $route;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由解释器的解析功能也改完了，接下来创建一个新的控制器来测试是否能获取到参数。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>在 app&#x2F;controller&#x2F;Home 创建 ArticleController：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class ArticleController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function show()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;showMessage(json_encode($this-&gt;routeParams));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编辑 web.php 添加一条路由配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;);</span><br></pre></td></tr></table></figure><p>然后访问地址：<a href="http://firerabbit-engine.ht/article/1">http://firerabbit-engine.ht/article/1</a></p><p>可以看到输出了一个数组，且只有一个值：1。</p><h2 id="防止路由冲突"><a href="#防止路由冲突" class="headerlink" title="防止路由冲突"></a>防止路由冲突</h2><p>由于匹配规则具有先后级，就是书写的顺序。</p><p>定义具有歧义的路由时要注意先后顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/user/&#123;id&#125;&#x27;, &#x27;UserController@test&#x27;);</span><br><span class="line">$router-&gt;get(&#x27;/user/home&#x27;, &#x27;UserController@home&#x27;);</span><br></pre></td></tr></table></figure><p>上面将 <code>/</code> 后面的参数视为 id 变量，</p><p>所以会匹配到第一个路由，第二个路由就被忽略了。</p><p>在配置路由的时候要注意先后顺序，最好不要定义具有歧义的路由。</p><h2 id="防止路由重名"><a href="#防止路由重名" class="headerlink" title="防止路由重名"></a>防止路由重名</h2><p>在 Laravel 里面可以有相同匹配规则但是请求方法不同的路由，</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;get(&#x27;/user/home&#x27;, &#x27;UserController@homeGet&#x27;);</span><br><span class="line">$router-&gt;post(&#x27;/user/home&#x27;, &#x27;UserController@homePost&#x27;);</span><br></pre></td></tr></table></figure><p>我设计的路由模块不支持这个功能，不能定义同名路由。</p><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>路由解析是框架里面最核心且使用频率最高的一个部分，</p><p>正则表达式的性能可能会比较低。</p><p>有一个优化的方法就是增加路由缓存，将匹配成功的路由记录下来，</p><p>下次访问先检测这条记录是不是在缓存里，如果是的话就不去正则匹配而是直接从缓存取出记录过的路由对象。</p><p>现在还不需要考虑到性能优化，如果到时候真的有问题了再优化也不迟。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（四）路由模块</title>
      <link href="/2021/02/09/my-swoole-framework-4/"/>
      <url>/2021/02/09/my-swoole-framework-4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>路由是一个框架最基本的功能，</p><p>虽然没研究过框架的路由是怎么加载的，</p><p>这里就凭直觉和使用 Laravel 的经验来自己写一个。</p><h2 id="REQUEST-URI"><a href="#REQUEST-URI" class="headerlink" title="REQUEST_URI"></a>REQUEST_URI</h2><p>用户请求网页输入的网址叫做 URL，URL 在网上已经被统称为 URI 了，下文也采用 URI 的说法。</p><p>（注意区分：一个是i，一个是l）</p><blockquote><p>其实 URL 跟 URI 有区别，如果你有兴趣可以了解一下这个小知识：URL 是 URI 的子集，URI 是一种抽象的概念，只要是任何可以可以找到某个资源的方法就叫做 URI，它还包括：URN，就是通过资源名字+身份证的方式找资源，但是 URN 几乎没人用，导致 URI 几乎全部是 URL，所以现在把 URL 当做 URI 也没什么问题，实际上它们算是抽象父类和子类的关系</p></blockquote><p>swoole 可以通过 <code>$request-&gt;server[&#39;request_uri&#39;]</code> 获取到请求的资源路径。</p><h2 id="路由模块原理"><a href="#路由模块原理" class="headerlink" title="路由模块原理"></a>路由模块原理</h2><p>用户访问网站的本质就是请求服务器上面的一个文件。</p><p>比如请求一张图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 名称为 1.jpg 的文件</span><br><span class="line">http://www.huotublog.com/img/1.jpg</span><br></pre></td></tr></table></figure><p>不仅是图片，js、css 都是文件，包括 php 也是一种文件。</p><p>我们在 nginx 的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name firerabbit-engine.ht;</span><br><span class="line"></span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|css|js|ico|ttf|woff|woff2|svg|map)$ &#123;</span><br><span class="line">        root /www/firerabbit-engine/public;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;keep-alive&quot;;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        </span><br><span class="line">        if (!-e $request_filename)&#123;</span><br><span class="line">            proxy_pass http://php-fpm72:9527; # 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把图片等静态文件全部指向 &#x2F;www&#x2F;firerabbit-engine&#x2F;public 目录。</p><p>如果没有找到文件，就转发给 <code>http://php-fpm72:9527</code> 来处理。</p><p>而监听这个端口的，就是 swoole 程序。</p><p>例如用户访问网页地址为：<a href="http://www.huotublog.com/article/1">http://www.huotublog.com/article/1</a></p><p>这个地址的后缀不符合 nginx 配置的设定，属于“找不到文件”的情况，</p><p>因此 nginx 就会把请求转发给我们设置的 swoole 监听的端口，</p><blockquote><p>nginx 在转发时会将请求的参数、cookie 等也一并转发</p></blockquote><p>swoole 接收到的 URI 即：&#x2F;article&#x2F;1</p><p>“&#x2F;article&#x2F;1” 只是一个字符串，</p><p>究竟是怎么变成 Controller 里的方法被执行的？</p><p>这就是路由解释器的作用了：<strong>将字符串解析成对应的控制器和方法。</strong></p><h3 id="PHP-实例化方法"><a href="#PHP-实例化方法" class="headerlink" title="PHP 实例化方法"></a>PHP 实例化方法</h3><p>在 PHP 中实例化对象是通过：<code>new 类名</code> 的方法，但是我们这里只能拿到字符串。</p><p>那应该怎么实例化出对象呢？</p><p>下面这样明显是错的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class IndexController</span><br><span class="line">&#123;</span><br><span class="line">    public function sayHello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;hello&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 想要实例化一个字符串的错误方法</span><br><span class="line">$obj = new &#x27;IndexController&#x27;;</span><br></pre></td></tr></table></figure><p>这里就要用到 PHP 中的一个概念：<strong>可变变量</strong>。</p><p>这里的“可变”不是指变量的类型，而是变量本身就是可变的。</p><p>直接看示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义两个变量</span><br><span class="line">$dog = &#x27;狗狗&#x27;;</span><br><span class="line">$cat = &#x27;猫猫&#x27;;</span><br><span class="line"></span><br><span class="line">// 再定义一个变量，取名为 $dog 变量的名字 </span><br><span class="line">$test = &#x27;dog&#x27;;</span><br><span class="line">// 会输出什么？</span><br><span class="line">echo $$test;</span><br><span class="line"></span><br><span class="line">// 接着，改变 $test 的值为 $cat 变量的名字</span><br><span class="line">$test = &#x27;cat&#x27;;</span><br><span class="line">// 会输出什么？</span><br><span class="line">echo $$test;</span><br></pre></td></tr></table></figure><p>结果是：狗狗猫猫</p><p>可变变量也就是可以“改变”的变量，我们利用这个特性就可以实例化对象和调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class IndexController</span><br><span class="line">&#123;</span><br><span class="line">    public function sayHello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;hello&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$controller = &#x27;IndexController&#x27;;</span><br><span class="line">$obj = new $controller;</span><br><span class="line"></span><br><span class="line">$obj-&gt;sayHello();</span><br></pre></td></tr></table></figure><p>可变变量是实现路由的基础。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>最后只需要将 URI 解析成对应的控制器和方法的字符串就可以了，</p><p>至少有三种方法可以实现。</p><h4 id="方法一：Query-参数"><a href="#方法一：Query-参数" class="headerlink" title="方法一：Query 参数"></a>方法一：Query 参数</h4><p>简单的粗暴的 query 参数。</p><p>query 参数就是 GET 方法的查询参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># a 就是 query 参数</span><br><span class="line">http://www.huotublog.com?a=1</span><br></pre></td></tr></table></figure><p>我们可以直接指定请求的控制器和方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># c 是控制器名称，a 是方法，其他的是参数</span><br><span class="line">http://www.huotublog.com?c=article&amp;a=show&amp;id=1</span><br></pre></td></tr></table></figure><p>上面的例子即请求 ArticleController 的 Show 方法，显示 ID&#x3D;1 的文章。</p><p>这种方法简单粗暴，并且十分无脑，<strong>最大的问题是太丑了</strong>，所以直接舍弃这个方案。</p><p>好看的路由应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示文章详情</span><br><span class="line">http://www.huotublog.com/article/1</span><br><span class="line"></span><br><span class="line"># 编辑文章页面</span><br><span class="line">http://www.huotublog.com/article/edit</span><br><span class="line"></span><br><span class="line"># 文章列表 ，可适当加入 query 参数</span><br><span class="line">http://www.huotublog.com/article_list?classify=1</span><br></pre></td></tr></table></figure><h4 id="方法二：文件映射"><a href="#方法二：文件映射" class="headerlink" title="方法二：文件映射"></a>方法二：文件映射</h4><p>建立文件映射关系，即路由映射到指定目录下的文件。</p><p>比如有一个路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.huotublog.com/article/show/1</span><br></pre></td></tr></table></figure><p>我们拿到 “&#x2F;article&#x2F;show&#x2F;1” 这个字符串，以 “&#x2F;“ 为分割符，可以得到对应的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$uri = &#x27;/article/show/1&#x27;;</span><br><span class="line"></span><br><span class="line">$route = explode(&#x27;/&#x27;, $uri);</span><br></pre></td></tr></table></figure><p>然后将 $route[0] 作为控制器的名字，</p><p>$route[1] 作为方法的名字，</p><p>如果有 $route[2] 则视为路由参数。</p><p>遇到特殊的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 网站首页</span><br><span class="line">http://www.huotublog.com</span><br><span class="line"></span><br><span class="line"># 列表页</span><br><span class="line">http://www.huotublog.com/article_list</span><br></pre></td></tr></table></figure><p>则进行特殊处理，当访问首页时，接收到的字符串是 “&#x2F;”,</p><p>即 $route[0] 为空，这种情况就默认请求 IndexController，</p><p>如果 $route[1] 是空的（即方法名为空），</p><p>则默认请求 index 这个方法。</p><p>实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$uri = &#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">$route = array_filter(explode(&#x27;/&#x27;, $uri));</span><br><span class="line"></span><br><span class="line">// 控制器名称</span><br><span class="line">$controllerName = &#x27;Index&#x27;;</span><br><span class="line"></span><br><span class="line">if(isset($route[0])) &#123;</span><br><span class="line">    $controllerName = ucfirst(strtolower($route[0]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法名称</span><br><span class="line">$method = &#x27;index&#x27;;</span><br><span class="line"></span><br><span class="line">if(isset($route[1])) &#123;</span><br><span class="line">    $method = $route[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路由参数</span><br><span class="line">$param = isset($route[2]) ?? null;</span><br></pre></td></tr></table></figure><p>这样就解决了特殊路由无法匹配的问题，</p><p>这种方法的好处是直接将请求的路由解析成对应的控制器和方法名称，</p><p>但是局限性也比较大，所有的路由都是相同规格的，而且不支持路由命名。</p><p>如果你要生成一个链接就只能写硬编码了。</p><p>最好的方法是给路由命名，然后通过一个函数来生成对应的路由。</p><h4 id="方法三：映射关系表"><a href="#方法三：映射关系表" class="headerlink" title="方法三：映射关系表"></a>方法三：映射关系表</h4><p>配置映射关系表关联数组)，</p><p>键名即路由的名字，值保存了路由的配置，</p><p>这样我们就可以实现路由命名的功能了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$routes = [</span><br><span class="line">    &#x27;home&#x27; =&gt; [</span><br><span class="line">        &#x27;route&#x27; =&gt; &#x27;/&#x27;,</span><br><span class="line">        &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\&#x27;,</span><br><span class="line">        &#x27;controller&#x27; =&gt; &#x27;IndexController&#x27;,</span><br><span class="line">        &#x27;method&#x27; =&gt; &#x27;index&#x27;,</span><br><span class="line">    ],</span><br><span class="line">    &#x27;user.home&#x27; =&gt; [</span><br><span class="line">        &#x27;route&#x27; =&gt; &#x27;/user&#x27;,</span><br><span class="line">        &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\&#x27;,</span><br><span class="line">        &#x27;controller&#x27; =&gt; &#x27;UserController&#x27;,</span><br><span class="line">        &#x27;method&#x27; =&gt; &#x27;index&#x27;,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>其中路由配置里包含了 namespace（命名空间），controller（对应控制器的名称），</p><p>method（控制器方法名称），route 是匹配的路由规则。</p><p>如果我们要引用一个路由地址，例如首页：<code>$routes[&#39;home&#39;][&#39;route&#39;]</code>。</p><p>如果要匹配一个路由，例如请求为：“&#x2F;”，则可以遍历 $routes，然后匹配 route 字段是否符合要求。</p><p>到这里，思路已经很清晰了，我们现在就可以创建一个 <code>routes.php</code> 路由配置表，</p><p>但是这样属于硬编码，我们不应该直接用一个数组文件来配置路由，</p><p>（这样是面向编程开发了，而框架应该是面向对象开发。）</p><p>接下来开始封装类，通过类来执行路由的初始化。</p><h2 id="路由对象"><a href="#路由对象" class="headerlink" title="路由对象"></a>路由对象</h2><p>在框架 module 目录下，创建 Route 文件夹，作为路由模块相关代码存放点。</p><h3 id="Router：路由解释器"><a href="#Router：路由解释器" class="headerlink" title="Router：路由解释器"></a>Router：路由解释器</h3><p>接着创建类文件 <code>Router</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   `-- public</span><br><span class="line">|-- composer.json</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">|       `-- Route</span><br><span class="line">|           `-- Router.php</span><br><span class="line">|-- http_server.php</span><br><span class="line">`-- vendor</span><br></pre></td></tr></table></figure><p>给 Router 加上命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Laravel 的路由配置是比较优雅的，</p><p>我打算直接参考 Laravel 路由的调用方法再自己实现一个。</p><p>Laravel 的路由配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;)-&gt;name(&#x27;index&#x27;);</span><br></pre></td></tr></table></figure><p>简单地说就是在 Route 类里面以数组存储路由配置，也就是上面的数组格式，</p><p>然后通过调用方法将路由规则写入到数组里面。</p><h3 id="RequestMethod：请求方法常量"><a href="#RequestMethod：请求方法常量" class="headerlink" title="RequestMethod：请求方法常量"></a>RequestMethod：请求方法常量</h3><p>我们知道请求方法主要有 GET、POST，</p><p>请求方法也是路由的一部分，可以通过限制请求方法来阻止一些不符合规范的请求。</p><p>创建一个专门用来保存常量的类 <code>/module/Route/RequestMethod.php</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">class RequestMethod</span><br><span class="line">&#123;</span><br><span class="line">    const GET = &#x27;GET&#x27;;</span><br><span class="line">    const POST = &#x27;POST&#x27;;</span><br><span class="line">    const ANY = &#x27;ANY&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，any 意思是两种方法都允许。</p><h3 id="RouteParams：路由对象"><a href="#RouteParams：路由对象" class="headerlink" title="RouteParams：路由对象"></a>RouteParams：路由对象</h3><p>每个路由配置都当成一个对象来处理，因此同样封装一个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：12:48 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">class RouteParams</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 路由名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 路由匹配规则</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $route;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 命名空间</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $namespace;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 控制器名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $controller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用的控制器方法名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $action;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求方法</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $method;</span><br><span class="line">    </span><br><span class="line">    public function createResponse($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        // 待实现</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function getFullControllerName()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;namespace . $this-&gt;controller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类里的 createResponse 方法暂时放空，待会实现。</p><h3 id="Controller：控制器"><a href="#Controller：控制器" class="headerlink" title="Controller：控制器"></a>Controller：控制器</h3><p>现在还没有控制器，因此在 module 文件夹里面创建一个 Controller，</p><p>并创建一个 Controller 基类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm</span><br><span class="line"> * Author：FireRabbit</span><br><span class="line"> * Date：2/9/21</span><br><span class="line"> * Time：1:16 PM</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Controller</span><br><span class="line">&#123;</span><br><span class="line">    protected $request, $response;</span><br><span class="line"></span><br><span class="line">    protected $route;</span><br><span class="line"></span><br><span class="line">    public function __construct($request, $response, $route)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;request = $request;</span><br><span class="line">        $this-&gt;response = $response;</span><br><span class="line">        $this-&gt;route = $route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showMessage($message)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">        $this-&gt;response-&gt;end($message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后博客的控制器全部继承框架的基类，目前里面只有一个简单的显示消息的方法。</p><p>然后为了测试路由，在 app&#x2F;controller 下面创建两个控制器：IndexController 和 UserController：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;showMessage(&#x27;网站首页&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function login()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;showMessage(&#x27;登录页面&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\controller\Home;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Controller\Controller;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;showMessage(&#x27;用户中心&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function loginSubmit()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;showMessage(&#x27;注册成功！&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前的文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   |-- controller</span><br><span class="line">|      `-- Home</span><br><span class="line">|          |--- IndexController.php</span><br><span class="line">|          `--- UserController.php</span><br><span class="line">|-- composer.json</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">|       |-- Controller</span><br><span class="line">|       |   `-- Controller.php</span><br><span class="line">|       `-- Route</span><br><span class="line">|           |-- RouteParams.php</span><br><span class="line">|           `-- Router.php</span><br><span class="line">`-- http_server.php</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Router：生成路由配置"><a href="#Router：生成路由配置" class="headerlink" title="Router：生成路由配置"></a>Router：生成路由配置</h3><p>接下来实现路由解释器的配置功能，编辑 Router.php，添加方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 保存路由配置的数组</span><br><span class="line">protected static $routes = [];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个 GET 请求路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function get($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;addRoute(RequestMethod::GET, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个 POST 请求路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function post($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;addRoute(RequestMethod::POST, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个任意请求皆可的路由</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">public function any($route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;addRoute(RequestMethod::ANY, $route, $controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将路由加入配置数组</span><br><span class="line"> * @param $method</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">protected function addRoute($method, $route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $param = new RouteParams();</span><br><span class="line"></span><br><span class="line">    $param-&gt;method = $method;</span><br><span class="line">    $param-&gt;route = $route;</span><br><span class="line"></span><br><span class="line">    // 格式为：控制器@方法名</span><br><span class="line">    $actions = explode(&#x27;@&#x27;, $controller);</span><br><span class="line"></span><br><span class="line">    // 如果不按照规则设置控制器和方法名则抛出异常</span><br><span class="line">    if (count($actions) != 2) &#123;</span><br><span class="line">        throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $param-&gt;controller = $actions[0];</span><br><span class="line">    $param-&gt;action = $actions[1];</span><br><span class="line"></span><br><span class="line">    self::$routes[] = $param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了 get、post、any 方法实现路由配置，</p><p>控制器和方法的格式就模仿 Laravel，如：<code>IndexController@index</code>，</p><p>就是请求 IndexController 控制器的 index 方法。</p><h3 id="RouteParamException：自定义异常"><a href="#RouteParamException：自定义异常" class="headerlink" title="RouteParamException：自定义异常"></a>RouteParamException：自定义异常</h3><p>这里我还抛出了一个自定义异常，因此需要在 module&#x2F;Route 下再创建一个 Exception 文件夹用来保存自定义异常类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route\Exception;</span><br><span class="line"></span><br><span class="line">use Exception;</span><br><span class="line"></span><br><span class="line">class RouteParamException extends Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常类只要有一个壳就好了。</p><h3 id="web-php：路由配置文件"><a href="#web-php：路由配置文件" class="headerlink" title="web.php：路由配置文件"></a>web.php：路由配置文件</h3><p>现在路由添加参数的功能也做好了，接下来就要一个用来配置路由的文件。</p><p>在 app 目录下新建一个 route 文件夹，再创建一个 web.php 用来保存页面路由。</p><blockquote><p>以后还可以创建 api.php 用来实现接口路由</p></blockquote><p>web.php 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line">$router-&gt;get(&#x27;/&#x27;, &#x27;App\\Controller\\Home\\IndexController@index&#x27;);</span><br></pre></td></tr></table></figure><p>这样显然很不美观，命名空间应该被提取出来。</p><h3 id="Router：增加分组功能"><a href="#Router：增加分组功能" class="headerlink" title="Router：增加分组功能"></a>Router：增加分组功能</h3><p>重新编辑 Router.php，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 分组命名空间</span><br><span class="line">protected $namespace = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置配置参数外部调用方法</span><br><span class="line"> * @param $configs</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function setConfig($configs)</span><br><span class="line">&#123;</span><br><span class="line">    foreach ($configs as $key =&gt; $value) &#123;</span><br><span class="line">        $this-&gt;createConfig($key, $value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置参数</span><br><span class="line"> * @param $key</span><br><span class="line"> * @param $value</span><br><span class="line"> */</span><br><span class="line">protected function createConfig($key, $value)</span><br><span class="line">&#123;</span><br><span class="line">    switch ($key) &#123;</span><br><span class="line">        case &#x27;namespace&#x27;:</span><br><span class="line">            $this-&gt;namespace = $value;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由分组</span><br><span class="line"> * @param $func</span><br><span class="line"> */</span><br><span class="line">public function group($func)</span><br><span class="line">&#123;</span><br><span class="line">    $func();</span><br><span class="line"></span><br><span class="line">    // 执行完成后将参数初始化</span><br><span class="line">    $this-&gt;namespace = &#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将路由加入配置数组</span><br><span class="line"> * @param $method</span><br><span class="line"> * @param $route</span><br><span class="line"> * @param $controller</span><br><span class="line"> * @throws RouteParamException</span><br><span class="line"> */</span><br><span class="line">protected function addRoute($method, $route, $controller)</span><br><span class="line">&#123;</span><br><span class="line">    $param = new RouteParams();</span><br><span class="line"></span><br><span class="line">    $param-&gt;method = $method;</span><br><span class="line">    $param-&gt;route = $route;</span><br><span class="line"></span><br><span class="line">    // 格式为：控制器@方法名</span><br><span class="line">    $actions = explode(&#x27;@&#x27;, $controller);</span><br><span class="line"></span><br><span class="line">    // 如果不按照规则设置控制器和方法名则抛出异常</span><br><span class="line">    if (count($actions) != 2) &#123;</span><br><span class="line">        throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $param-&gt;controller = $actions[0];</span><br><span class="line">    $param-&gt;action = $actions[1];</span><br><span class="line">    </span><br><span class="line">    $param-&gt;namespace = $this-&gt;namespace; // 将命名空间赋值给路由对象</span><br><span class="line"></span><br><span class="line">    self::$routes[] = $param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个 group 分组方法，现在就可以把路由按照分组进行配置了，</p><p>createConfig 方法以后可以支持更多的分组配置参数。</p><p>重新编辑 web.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;);</span><br><span class="line">    $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看起来好多了，配置文件也弄好了。</p><h3 id="RouteParams：执行路由"><a href="#RouteParams：执行路由" class="headerlink" title="RouteParams：执行路由"></a>RouteParams：执行路由</h3><p>Router 里只负责解析路由和生成路由配置，执行路由不应该在 Router，</p><p>上面定义了 RouteParams 类（路由对象），这个类才是实际的执行者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public function createResponse($request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    // 判断请求方法是否正确</span><br><span class="line">    if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123;</span><br><span class="line">        (new MethodErrorResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断方法是否存在</span><br><span class="line">    $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">    if (!class_exists($controllerName)) &#123;</span><br><span class="line">        (new ClassNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $action = $this-&gt;action;</span><br><span class="line">    // 不存在方法则返回404</span><br><span class="line">    if (!method_exists($controllerName, $action)) &#123;</span><br><span class="line">        (new ActionNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化类</span><br><span class="line">    $controllerObject = new $controllerName($request, $response, $this-&gt;name);</span><br><span class="line"></span><br><span class="line">    // ... 以后的中间件写在这里</span><br><span class="line"></span><br><span class="line">    // 执行方法</span><br><span class="line">    $controllerObject-&gt;$action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照面向对象的编程思想，RouteParams 类即一个实际的路由，这个类暴露 createResponse （创建响应）方法供外部调用。</p><h3 id="RouteResponse：路由响应"><a href="#RouteResponse：路由响应" class="headerlink" title="RouteResponse：路由响应"></a>RouteResponse：路由响应</h3><p>这个类里还有一些返回响应的方法，比如找不到方法或者类文件，</p><p>因此需要创建一个 module&#x2F;Route&#x2F;Response 文件夹用来保存响应相关的类。</p><p>创建一个响应类的基类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route\Response;</span><br><span class="line"></span><br><span class="line">abstract class RouteResponse</span><br><span class="line">&#123;</span><br><span class="line">    public abstract function response($request, $response, $route);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再创建几个继承该类的响应，例如 NotFoundResponse 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route\Response;</span><br><span class="line"></span><br><span class="line">class NotFoundResponse extends RouteResponse</span><br><span class="line">&#123;</span><br><span class="line">    public function response($request, $response, $route)</span><br><span class="line">    &#123;</span><br><span class="line">        $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">        $response-&gt;end(&#x27;不存在页面，404&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的响应类都一样，这里是临时用的，以后要让用户可以自定义错误页面。</p><h3 id="Router：解析路由"><a href="#Router：解析路由" class="headerlink" title="Router：解析路由"></a>Router：解析路由</h3><p>路由的执行方法也弄好了，但是现在还没办法匹配路由，</p><p>Router 做的事情是匹配用户的请求，判断是否在 $routes 的配置里，</p><p>如果找到对应的配置就去执行路由，现在还缺少匹配路由的方法。</p><p>回到 Router.php 新增一个解析路由的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理路由</span><br><span class="line"> * @param $request</span><br><span class="line"> * @param $response</span><br><span class="line"> */</span><br><span class="line">public function handle($request, $response)</span><br><span class="line">&#123;</span><br><span class="line">    $uri = $request-&gt;server[&#x27;request_uri&#x27;];</span><br><span class="line">    $route = $this-&gt;findRoute($uri);</span><br><span class="line"></span><br><span class="line">    if ($route == null) &#123;</span><br><span class="line">        (new NotFoundResponse)-&gt;response($request, $response, $route);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $route-&gt;createResponse($request, $response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找路由</span><br><span class="line"> * @param $uri</span><br><span class="line"> * @return mixed|null</span><br><span class="line"> */</span><br><span class="line">public function findRoute($request)</span><br><span class="line">&#123;</span><br><span class="line">    $uri = $request-&gt;server[&#x27;request_uri&#x27;];</span><br><span class="line"></span><br><span class="line">    // 查找规则和方法都匹配的路由</span><br><span class="line">    foreach (self::$routes as $route) &#123;</span><br><span class="line">        if ($route-&gt;route == $uri) &#123;</span><br><span class="line">            return $route;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 findRoute 即路由解释器的核心功能，通过循环逐一与配置文件进行匹配，</p><p>如果符合要求就返回路由对象，然后执行路由。</p><p>现在先简单的实现，如果一个请求路径完全匹配 route 字段即认为匹配。</p><h3 id="引入路由配置"><a href="#引入路由配置" class="headerlink" title="引入路由配置"></a>引入路由配置</h3><p>路由解析功能也完成了，但是路由配置文件 web.php 还没引入，</p><p>配置文件应该是在程序启动时就加载到内存中的，直接用 require 引入就可以了，</p><p>我把 $routes 定义成静态变量了，它的作用范围是全局的。</p><p>编辑根目录下面的 http_server.php，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line">require &#x27;./app/route/web.php&#x27;;</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    var_dump(&#x27;请求URI：&#x27; . $request-&gt;server[&#x27;request_uri&#x27;]);</span><br><span class="line"></span><br><span class="line">    $router-&gt;handle($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入 var_dump 方便调试，每次刷新网页的时候都可以在终端看到输出结果，</p><p>实际上线的时候要删掉这一句。</p><p>这里通过 require 引入 web.php，然后在 <code>$http-&gt;on</code> 里调用解释器解析路由。</p><p>路由模块仅仅只是暴露一个简单的 handle 方法：<code>$router-&gt;handle($request, $response)</code></p><p>代码十分整洁干净，符合自己的预期要求。</p><p>到这一步已经完成了，但还有一个地方要做！</p><h3 id="类的自动加载"><a href="#类的自动加载" class="headerlink" title="类的自动加载"></a>类的自动加载</h3><p>最开始创建的 Controller 并没有被加入 psr-4 自动加载配置里，</p><p>编辑根目录下面的 composer.json，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;&#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\&quot;: &quot;app/&quot;,</span><br><span class="line">      &quot;FireRabbitEngine\\Module\\&quot;: &quot;firerabbit-engine/module/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 App 自动加载路径，这样以后我们创建的控制器或者模型都会被自动加载了。</p><p>由于修改了配置，因此需要执行 <code>composer dump-autoload</code> 重新生成自动加载文件。</p><blockquote><p>每次新创建用来保存类的文件夹时都要重新加载一下</p></blockquote><p>然后就可以打开浏览器，测试路由功能了！</p><p>最终文件目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   |-- config</span><br><span class="line">|   |-- controller</span><br><span class="line">|   |   `-- Home</span><br><span class="line">|   |       |-- IndexController.php</span><br><span class="line">|   |       `-- UserController.php</span><br><span class="line">|   |-- public</span><br><span class="line">|   `-- route</span><br><span class="line">|       `-- web.php</span><br><span class="line">|-- composer.json</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">|       |-- Controller</span><br><span class="line">|       |   `-- Controller.php</span><br><span class="line">|       `-- Route</span><br><span class="line">|           |-- Exception</span><br><span class="line">|           |   `-- RouteParamException.php</span><br><span class="line">|           |-- RequestMethod.php</span><br><span class="line">|           |-- Response</span><br><span class="line">|           |   |-- ActionNotFoundResponse.php</span><br><span class="line">|           |   |-- ClassNotFoundResponse.php</span><br><span class="line">|           |   |-- MethodErrorResponse.php</span><br><span class="line">|           |   |-- NotFoundResponse.php</span><br><span class="line">|           |   `-- RouteResponse.php</span><br><span class="line">|           |-- RouteParams.php</span><br><span class="line">|           `-- Router.php</span><br><span class="line">|-- http_server.php</span><br><span class="line">|-- test.php</span><br><span class="line">`-- vendor</span><br><span class="line">    |-- autoload.php</span><br><span class="line">    `-- composer</span><br><span class="line">        |-- ClassLoader.php</span><br><span class="line">        |-- LICENSE</span><br><span class="line">        |-- autoload_classmap.php</span><br><span class="line">        |-- autoload_namespaces.php</span><br><span class="line">        |-- autoload_psr4.php</span><br><span class="line">        |-- autoload_real.php</span><br><span class="line">        |-- autoload_static.php</span><br><span class="line">        `-- installed.json</span><br></pre></td></tr></table></figure><p>简单的路由功能这样就算完成了，但是现在还没办法实现路径参数，下文再补充。</p><blockquote><p>每次修改代码都记得要 Ctrl+C 结束 swoole 进程再重新启动，不然修改不会生效。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后是贴上完整的代码：</p><p>Router.php 文件是作为“解析&#x2F;分发”和“配置”路由的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Route\Exception\RouteParamException;</span><br><span class="line">use FireRabbitEngine\Module\Route\Response\NotFoundResponse;</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">&#123;</span><br><span class="line">    protected static $routes = [];</span><br><span class="line"></span><br><span class="line">    protected $namespace = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理路由</span><br><span class="line">     * @param $request</span><br><span class="line">     * @param $response</span><br><span class="line">     */</span><br><span class="line">    public function handle($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        $uri = $request-&gt;server[&#x27;request_uri&#x27;];</span><br><span class="line">        $route = $this-&gt;findRoute($uri);</span><br><span class="line"></span><br><span class="line">        if ($route == null) &#123;</span><br><span class="line">            (new NotFoundResponse)-&gt;response($request, $response, $route);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $route-&gt;createResponse($request, $response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 寻找路由</span><br><span class="line">     * @param $uri</span><br><span class="line">     * @return mixed|null</span><br><span class="line">     */</span><br><span class="line">    public function findRoute($request)</span><br><span class="line">    &#123;</span><br><span class="line">        $uri = $request-&gt;server[&#x27;request_uri&#x27;];</span><br><span class="line"></span><br><span class="line">        // 查找规则和方法都匹配的路由</span><br><span class="line">        foreach (self::$routes as $route) &#123;</span><br><span class="line">            if ($route-&gt;route == $uri) &#123;</span><br><span class="line">                return $route;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个 GET 请求路由</span><br><span class="line">     * @param $route</span><br><span class="line">     * @param $controller</span><br><span class="line">     * @throws RouteParamException</span><br><span class="line">     */</span><br><span class="line">    public function get($route, $controller)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;addRoute(RequestMethod::GET, $route, $controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个 POST 请求路由</span><br><span class="line">     * @param $route</span><br><span class="line">     * @param $controller</span><br><span class="line">     * @throws RouteParamException</span><br><span class="line">     */</span><br><span class="line">    public function post($route, $controller)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;addRoute(RequestMethod::POST, $route, $controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个任意请求皆可的路由</span><br><span class="line">     * @param $route</span><br><span class="line">     * @param $controller</span><br><span class="line">     * @throws RouteParamException</span><br><span class="line">     */</span><br><span class="line">    public function any($route, $controller)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;addRoute(RequestMethod::ANY, $route, $controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置配置参数外部调用方法</span><br><span class="line">     * @param $configs</span><br><span class="line">     * @return $this</span><br><span class="line">     */</span><br><span class="line">    public function setConfig($configs)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($configs as $key =&gt; $value) &#123;</span><br><span class="line">            $this-&gt;createConfig($key, $value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置参数</span><br><span class="line">     * @param $key</span><br><span class="line">     * @param $value</span><br><span class="line">     */</span><br><span class="line">    protected function createConfig($key, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($key) &#123;</span><br><span class="line">            case &#x27;namespace&#x27;:</span><br><span class="line">                $this-&gt;namespace = $value;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 路由分组</span><br><span class="line">     * @param $func</span><br><span class="line">     */</span><br><span class="line">    public function group($func)</span><br><span class="line">    &#123;</span><br><span class="line">        $func();</span><br><span class="line"></span><br><span class="line">        // 执行完成后将参数初始化</span><br><span class="line">        $this-&gt;namespace = &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将路由加入配置数组</span><br><span class="line">     * @param $method</span><br><span class="line">     * @param $route</span><br><span class="line">     * @param $controller</span><br><span class="line">     * @throws RouteParamException</span><br><span class="line">     */</span><br><span class="line">    protected function addRoute($method, $route, $controller)</span><br><span class="line">    &#123;</span><br><span class="line">        $param = new RouteParams();</span><br><span class="line"></span><br><span class="line">        $param-&gt;method = $method;</span><br><span class="line">        $param-&gt;route = $route;</span><br><span class="line"></span><br><span class="line">        // 格式为：控制器@方法名</span><br><span class="line">        $actions = explode(&#x27;@&#x27;, $controller);</span><br><span class="line"></span><br><span class="line">        // 如果不按照规则设置控制器和方法名则抛出异常</span><br><span class="line">        if (count($actions) != 2) &#123;</span><br><span class="line">            throw new RouteParamException(&#x27;控制器和方法名称错误，应该为：控制器名称@方法名称&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $param-&gt;controller = $actions[0];</span><br><span class="line">        $param-&gt;action = $actions[1];</span><br><span class="line">        $param-&gt;namespace = $this-&gt;namespace;</span><br><span class="line"></span><br><span class="line">        self::$routes[] = $param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RouteParam.php 是作为路由对象，在这里实例化控制器并且执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">use FireRabbitEngine\Module\Route\Response\ActionNotFoundResponse;</span><br><span class="line">use FireRabbitEngine\Module\Route\Response\MethodErrorResponse;</span><br><span class="line">use FireRabbitEngine\Module\Route\Response\ClassNotFoundResponse;</span><br><span class="line"></span><br><span class="line">class RouteParams</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 路由名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 路由匹配规则</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $route;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 命名空间</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $namespace;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 控制器名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $controller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用的控制器方法名称</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $action;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求方法</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    public $method;</span><br><span class="line"></span><br><span class="line">    public function createResponse($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        // 判断请求方法是否正确</span><br><span class="line">        if ($this-&gt;method != RequestMethod::ANY &amp;&amp; $request-&gt;server[&#x27;request_method&#x27;] != $this-&gt;method) &#123;</span><br><span class="line">            (new MethodErrorResponse())-&gt;response($request, $response, $this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 判断方法是否存在</span><br><span class="line">        $controllerName = $this-&gt;getFullControllerName();</span><br><span class="line">        if (!class_exists($controllerName)) &#123;</span><br><span class="line">            (new ClassNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $action = $this-&gt;action;</span><br><span class="line">        // 不存在方法则返回404</span><br><span class="line">        if (!method_exists($controllerName, $action)) &#123;</span><br><span class="line">            (new ActionNotFoundResponse())-&gt;response($request, $response, $this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 实例化类</span><br><span class="line">        $controllerObject = new $controllerName($request, $response, $this-&gt;name);</span><br><span class="line"></span><br><span class="line">        // ... 以后的中间件写在这里</span><br><span class="line"></span><br><span class="line">        // 执行方法</span><br><span class="line">        $controllerObject-&gt;$action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getFullControllerName()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;namespace . $this-&gt;controller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而 web.php 则是全局的路由配置文件，实现了用类配置路由，而不是用纯数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line"></span><br><span class="line">$router-&gt;setConfig([</span><br><span class="line">    &#x27;namespace&#x27; =&gt; &#x27;App\\Controller\\Home\\&#x27;,</span><br><span class="line">])-&gt;group(function () use ($router) &#123;</span><br><span class="line"></span><br><span class="line">    $router-&gt;get(&#x27;/&#x27;, &#x27;IndexController@index&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/login&#x27;, &#x27;IndexController@login&#x27;);</span><br><span class="line">    $router-&gt;get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;);</span><br><span class="line">    $router-&gt;post(&#x27;/user/loginSubmit&#x27;, &#x27;UserController@loginSubmit&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上，简单路由就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（三）类的自动加载</title>
      <link href="/2021/02/06/my-swoole-framework-3/"/>
      <url>/2021/02/06/my-swoole-framework-3/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blog</span><br><span class="line">|-- app</span><br><span class="line">|   `-- public</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">`-- http_server.php</span><br></pre></td></tr></table></figure><p>其中，根目录 blog 为项目根目录，app 文件夹是项目所在目录，</p><p>public 用来存放 web 的静态资源如图片、js 文件等。</p><p>firerabbit-engine 是框架目录，module 存放模块代码，</p><p>目前框架代码跟是项目代码放在一起的，</p><p>为了以后方便分离，所以把项目的代码放在 app 里面处理。</p><blockquote><p>文件夹的大小写规范自己定义即可</p></blockquote><h2 id="psr-4-自动加载"><a href="#psr-4-自动加载" class="headerlink" title="psr-4 自动加载"></a>psr-4 自动加载</h2><p>在根目录创建文件 <code>composer.json</code>，并输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;&#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;FireRabbitEngine\\Module\\&quot;: &quot;firerabbit-engine/module/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们指定了框架的命名空间以及将镜像源修改为阿里云。</p><p>接着使用命令 <code>composer install</code> 执行安装，</p><p>完成后出现 vendor 文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   `-- public</span><br><span class="line">|-- composer.json</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">|-- http_server.php</span><br><span class="line">`-- vendor</span><br><span class="line">    |-- autoload.php</span><br><span class="line">    `-- composer</span><br><span class="line">        |-- ClassLoader.php</span><br><span class="line">        |-- LICENSE</span><br><span class="line">        |-- autoload_classmap.php</span><br><span class="line">        |-- autoload_namespaces.php</span><br><span class="line">        |-- autoload_psr4.php</span><br><span class="line">        |-- autoload_real.php</span><br><span class="line">        |-- autoload_static.php</span><br><span class="line">        `-- installed.json</span><br></pre></td></tr></table></figure><p>我们第一步要实现路由功能，路由是一个模块，</p><p>因此在 modlue 下新建文件夹 Route，</p><p>接着在该目录新建文件 <code>Router.php</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace FireRabbitEngine\Module\Route;</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">&#123;</span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump(&#x27;ok&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>FireRabbitEngine 即框架的命名空间</p></blockquote><p>接着编辑 <code>http_server.php</code>，引入 composer 加载文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">$router = new \FireRabbitEngine\Module\Route\Router();</span><br><span class="line">$router-&gt;test();</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123;</span><br><span class="line">    $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>在终端输入 <code>php http_server.php</code>，看到打印出 ok 就说明自动加载没问题了。</p><blockquote><p>每次修改代码都要 Ctrl+C 关掉再重新启动，不然修改了代码也不会生效，因为 swoole 是常驻内存的，只在启动时加载一次</p></blockquote><p>完整的项目目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   `-- public</span><br><span class="line">|-- composer.json</span><br><span class="line">|-- firerabbit-engine</span><br><span class="line">|   `-- module</span><br><span class="line">|       `-- Route</span><br><span class="line">|           `-- Router.php</span><br><span class="line">|-- http_server.php</span><br><span class="line">`-- vendor</span><br><span class="line">    |-- autoload.php</span><br><span class="line">    `-- composer</span><br><span class="line">        |-- ClassLoader.php</span><br><span class="line">        |-- LICENSE</span><br><span class="line">        |-- autoload_classmap.php</span><br><span class="line">        |-- autoload_namespaces.php</span><br><span class="line">        |-- autoload_psr4.php</span><br><span class="line">        |-- autoload_real.php</span><br><span class="line">        |-- autoload_static.php</span><br><span class="line">        `-- installed.json</span><br></pre></td></tr></table></figure><p>我们需要同步到 Git 防止丢失代码，</p><p>因此需要设置 .gitignore 文件来忽略不需要上传的文件或者目录。</p><p>在终端或者直接右键创建文件都可以，.gitignore 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vendor</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure><blockquote><p>我用的是 PhpStorm 会产生 .idea 文件夹，但这个是不需要上传的，如果你用的是 vscode，要把 .vscode 文件夹也加进去</p></blockquote><p>然后就可以把项目同步到 Git 上面了。</p><p>如此一来类的自动加载就实现了，</p><p>下一步我们就可以开始编写路由模块了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（二）项目的规划和设计草案</title>
      <link href="/2021/02/06/my-swoole-framework-2/"/>
      <url>/2021/02/06/my-swoole-framework-2/</url>
      
        <content type="html"><![CDATA[<h2 id="项目的规划和设计草案"><a href="#项目的规划和设计草案" class="headerlink" title="项目的规划和设计草案"></a>项目的规划和设计草案</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第（一）章中我们已经实现了 hellow  world！</p><p>但是现在不用急着撸代码，</p><p>而是要把我们设计这款框架的想法捋顺。</p><h2 id="期望效果"><a href="#期望效果" class="headerlink" title="期望效果"></a>期望效果</h2><p>按照重要性给各项指标进行打分，其中星星越多代表重要性越高。</p><h3 id="开发舒适度：★★★★★"><a href="#开发舒适度：★★★★★" class="headerlink" title="开发舒适度：★★★★★"></a>开发舒适度：★★★★★</h3><p>这是最关键的一条！</p><p>使用了我们的框架，</p><p>开发者撸代码会变成愉♂悦的过程！</p><p>我给它起个口号：</p><blockquote><p>享受令人愉♂悦的开发过程。 — by FireRabbit-Engine 火兔引擎</p></blockquote><p>但是怎么个舒适法得有一个定义，不然就太宽泛了。</p><ul><li>能够帮助开发者快速排查错误以及调试的能力</li><li>在框架层面自动帮用户解决掉麻烦问题，比如 SQL 注入、用户权限、跨域问题、表单校验等等</li><li>指令式开发，开发者可以在控制台输入指令自动生成对应的文件，比如输入 <code>make:model</code> 就会生成一个数据库查询模型</li></ul><h3 id="高性能：★★★★★"><a href="#高性能：★★★★★" class="headerlink" title="高性能：★★★★★"></a>高性能：★★★★★</h3><p>我们既然选择了 swoole 扩展，</p><p>自然要体现出它应该具有的高性能特点，</p><p>高性能的指标是响应速度，期望效果是 1-30 ms。</p><p>（以接口的响应速度为判定指标） </p><blockquote><p>它要非常的快！不快怎么装 X 呢！</p></blockquote><h3 id="高并发：★★★★★"><a href="#高并发：★★★★★" class="headerlink" title="高并发：★★★★★"></a>高并发：★★★★★</h3><p>同样是 swoole 的特色，</p><p>我们的框架也应该支持强大的并发连接。</p><p>框架完成后我们会用 ab 测试来查看高并发情况下的性能。</p><h3 id="扩展性：★★★★★"><a href="#扩展性：★★★★★" class="headerlink" title="扩展性：★★★★★"></a>扩展性：★★★★★</h3><p>人没梦想跟咸鱼有什么区别！</p><p>万一框架火了呢！？</p><p>我们这套框架应该是能让开发者 DIY 的。</p><p>框架的扩展性要非常的强，</p><p>各个模块之间尽可能的解耦。</p><h3 id="安全性：★★★★★"><a href="#安全性：★★★★★" class="headerlink" title="安全性：★★★★★"></a>安全性：★★★★★</h3><p>手撸框架要十分注意的地方！</p><p>市面的框架基本上已经把安全隐患在框架层面解决了，</p><p>以至于我们完全忽视了本应该注意的漏洞。</p><p>就比如 SQL 注入，你用的框架封装好的 ORM 自动帮你处理了。</p><p>但是我们自己从零开始撸框架就不一样了，</p><p>我们要让这个框架使用起来非常安全。</p><h3 id="代码规范：★★★"><a href="#代码规范：★★★" class="headerlink" title="代码规范：★★★"></a>代码规范：★★★</h3><p>为了后期可维护，代码规范也是十分必要的，</p><p>毕竟老夫也不是什么大神，只能说在认知的范围内尽量吧……</p><p>如果后期觉得设计不合理，会推翻重做。</p><h3 id="小白化：★★★"><a href="#小白化：★★★" class="headerlink" title="小白化：★★★"></a>小白化：★★★</h3><p>让一个没学过 swoole 的人也能上手。</p><p>（其实我自己就是现学现卖）</p><p>我们再给它起个口号：</p><blockquote><p>有手就能撸。 — by FireRabbit-Engine 火兔引擎</p></blockquote><p>“会增删改查吗？”</p><p>“明天可以来上班了。” —— 根据本人亲身经历改编。</p><h3 id="半自动化：★★★"><a href="#半自动化：★★★" class="headerlink" title="半自动化：★★★"></a>半自动化：★★★</h3><p>谁说做开发就一定要手撸代码的？</p><p>要我说的话，</p><blockquote><p>开发的最高境界是“无码”</p></blockquote><p>其实是我开发游戏的时候得到的灵感，</p><p>比如关卡的设计，每个场景都要单独写一个吗？</p><p>那如果是几千个关卡的游戏呢？</p><p>只要一个配置文件就能搞定！</p><p>而我们只需要写一个关卡解释器，</p><p>将配置的参数实例化为游戏的场景。</p><p>所以我有一个预感，以后的开发者不需要写太多的代码，</p><p>只要配置文件就可以解决大部分的问题。</p><p>在开发这个框架的时候，我会把这个思想融入到设计层面。</p><blockquote><p>亲，我们这个框架高清无码。— by FireRabbit-Engine 火兔引擎</p></blockquote><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>框架是由模块构成的，</p><p>我们要把每个模块都拆分成独立的，以后还能拆分成单独的包。</p><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>swoole 已经是单一入口了，</p><p>所以直接用就行了。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>有一个专门用来读取配置文件的模块，</p><p>除了框架的配置还支持用户自定义配置。</p><p>不同的模块有不同的配置文件，全部单独区分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 文件目录 config/</span><br><span class="line">database.php  // 数据库配置</span><br><span class="line">cache.php     // 缓存配置</span><br><span class="line">sms.php       // 短信配置</span><br><span class="line">……            // 诸如此类</span><br></pre></td></tr></table></figure><h3 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h3><p>直接使用 composer 实现自动加载即可。</p><p>遵循 <code>psr-4</code> 加载规范。</p><h3 id="路由模块"><a href="#路由模块" class="headerlink" title="路由模块"></a>路由模块</h3><p>需要一个路由解析器来处理 swoole 收到的请求路径，</p><p>将请求分发到控制器和对应的方法，还有处理路径上的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 用户浏览一篇博客文章</span><br><span class="line">http://127.0.0.1/article/1</span><br><span class="line"></span><br><span class="line"># swoole 收到 nginx 转发的请求是这样的</span><br><span class="line">/article/1</span><br><span class="line"></span><br><span class="line"># 这个时候我们就需要定义一个解释器解析路由</span><br><span class="line">/article/1 是一个字符串，要将字符串按照某种规则匹配</span><br><span class="line"></span><br><span class="line"># 最终解析的结果为：</span><br><span class="line">/article/1 =&gt; 控制器是 article，方法是 show，参数是 1 </span><br><span class="line"></span><br><span class="line"># 实例化控制器</span><br><span class="line">$name = &#x27;ArticleController&#x27;; // 解析后得到的控制器名字</span><br><span class="line">$controller = new $name;</span><br><span class="line"></span><br><span class="line"># 执行对应的方法</span><br><span class="line">$method = &#x27;show&#x27;;</span><br><span class="line">$controller-&gt;$show;</span><br></pre></td></tr></table></figure><p>以上就是路由解析器的大概原理。</p><p>真正要实现是很复杂的，因为路由是各种各样奇奇怪怪的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 文章详情</span><br><span class="line">http://127.0.0.1/article/1</span><br><span class="line"></span><br><span class="line"># 编辑文章</span><br><span class="line">http://127.0.0.1/article/1/edit</span><br><span class="line"></span><br><span class="line"># 很长很长，看得出来哪些是路径参数吗？</span><br><span class="line">http://127.0.0.1/article/classify_1/list/12345/show</span><br><span class="line"></span><br><span class="line"># 注意！下面这种是 query 参数，要获取这种参数很简单</span><br><span class="line">http://127.0.0.1/article?id=1</span><br></pre></td></tr></table></figure><p>如果我们的网站不打算使用路径参数，</p><p>那就简单得多了，但是用 query 参数很不美观。</p><p>比如 TP 框架的这种路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># c 代表控制器，a 代表方法，id 是查询参数</span><br><span class="line">http://127.0.0.1?c=article&amp;a=show&amp;id=1</span><br><span class="line"></span><br><span class="line"># 美化后的路由（这才是我们想要的）</span><br><span class="line">http://127.0.0.1/article/1</span><br></pre></td></tr></table></figure><h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>这个就是面试的时候经常考的问题了，</p><p>就不再详细介绍了，</p><p>简单地说就是用户访问我们的网站，</p><p>我们要给它输出什么样的结果。</p><ul><li>请求要经过过滤器（中间件、数据&#x2F;权限验证）</li><li>响应返回的格式（content-type）</li></ul><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>对用户提交的表单字段验证。</p><p>如果每个表单都要这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 用户注册</span><br><span class="line">if(isset($_GET[&#x27;name&#x27;] &amp;&amp; strlen($_GET[&#x27;name&#x27;]) &lt; 4 || strlen($_GET[&#x27;name&#x27;]) &gt; 10) &#123;</span><br><span class="line">    echo &#x27;用户名不能为空，且长度为4~10&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 下面还有重名判断、邮箱、手机号码、密码长度……</span><br><span class="line"># 接着，用户修改密码，找回密码，更新账户资料</span><br><span class="line"># 以上，请再来一遍……</span><br></pre></td></tr></table></figure><p>一个框架没有表单处理模块，你离升仙也就不远了。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>通俗的将就是请求拦截器。</p><p>表单验证也是拦截请求，</p><p>但是在拦截的层面上不一样，</p><p>表单验证一般是在控制器里面拦截的，</p><p>而中间件是在还没进入到控制器的时候就开始拦截。</p><p>比如一个抢购活动在晚上 9 点开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$startTime = date(&#x27;Y-m-d 21:00:00&#x27;)</span><br><span class="line">$currentTime = date(&#x27;Y-m-d H:i:s&#x27;);</span><br><span class="line"></span><br><span class="line">if($currentTime &gt;=  $startTime ) &#123;</span><br><span class="line">    # 显示活动页</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    # 显示活动还没开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在控制器里面写上这样的代码来判断活动是否开始，</p><p>但是这种硬编码绝对会让你原地爆炸，</p><p>即使你自己觉得没啥，你同事绝对会想在月黑风高的时候把你弄死……</p><p>我们为什么不这样做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个“规则”，把它命名为：2021_12_12_active</span><br><span class="line">规则 2021_12_12_active : </span><br><span class="line">如果当前时间大于等于 2021-12-12 21:00:00 则返回 true，否则返回 false</span><br><span class="line"></span><br><span class="line"># 然后再修改路由解析器：</span><br><span class="line">用户访问：http://127.0.0.1/goods/1</span><br><span class="line">路由解析器解析出：控制器：goods，方法：show，参数：1</span><br><span class="line"></span><br><span class="line">它正准备实例化对象呢！</span><br><span class="line">这个时候，中间件站了出来，说：路由老哥，等一哈！</span><br><span class="line"></span><br><span class="line">路由老哥愣住了，停下来听中间件想说什么。</span><br><span class="line">中间件不慌不忙的解释道：这个路径被加上了“规则”，要验证之后才可以。</span><br><span class="line"></span><br><span class="line">而这个规则叫做：2021_12_12_active</span><br><span class="line">根据《小学生手册》里规定：</span><br><span class="line">第 2021_12_12_active 条：</span><br><span class="line">好孩子在 2021-12-12 这一天必须在晚上九点以后上传睡觉。</span><br><span class="line">在九点之前睡觉的都不是好孩子！不能让它们通过！</span><br><span class="line">这件事交给我来处理，你可以退下了。</span><br><span class="line"></span><br><span class="line">于是路由解释器就把执行权限交给了中间件。</span><br><span class="line">中间件就会查询时间是否符合要求，</span><br><span class="line">如果符合要求就让请求正常进行下去，</span><br><span class="line">不符合要求就返回异常的结果。</span><br></pre></td></tr></table></figure><p>中间件就是一套“规则”，你可能会问那跟表单验证有什么不同？</p><p>其实表单验证就是中间件的子集，除了表单验证之外，还有权限验证。</p><p>比如你可以规定一个请求不带 token 就不让它通过。</p><p>表单验证和权限验证虽然都属于中间件，</p><p>但我们还是会单独拆分出来，</p><p>因为他们在细节还是有些不同的，</p><p>而且我们还可以通过封装实现更加简单的操作。</p><blockquote><p>表单验证和权限验证均可以在控制器里面处理，如果是在控制器层面处理的话就不叫做中间件的，为了实现复用性，我们会把表单验证跟用户验证以中间件的形式实现</p></blockquote><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>不论是本地调试还是线上查询问题所在，</p><p>日志都是非常重要的，日志系统可以支持数据库和文件。</p><p>我们暂时只支持文件日志。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>需要一个专门的类来保存框架使用的各种常量。</p><p>比如返回的错误码之类的，redis 的键等等。</p><p>如果不统一管理常量的话，后期会变得非常麻烦。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将缓存的调用封装起来，</p><p>我们自定义一个 Cache 类，</p><p>外部只要调用暴露出来的接口即可。</p><p>而 Cache 内部则可以支持不同的缓存数据库，</p><p>包括 Redis 集群的调用等等。</p><p>目前仅考虑：Redis</p><h3 id="数据库（Model）"><a href="#数据库（Model）" class="headerlink" title="数据库（Model）"></a>数据库（Model）</h3><p>同缓存系统，</p><p>数据库模型直接暴露一个供外部调用的接口，</p><p>然后通过配置文件来自定义包括集群甚至是数据库类型等等配置。</p><p>数据库类型目前仅考虑：MySQL</p><p>模型文件主要是定义字段以及处理一些关联关系。</p><p>不将复杂的代码放到这里。</p><p>比较复杂的数据库逻辑可以再定义一个 Action 层来处理。</p><h3 id="模板引擎（View）"><a href="#模板引擎（View）" class="headerlink" title="模板引擎（View）"></a>模板引擎（View）</h3><p>为了支持搜索引擎的 SEO，</p><p>我们不采用前后端分离的设计，</p><p>当然也不能直接写 phtml（即 php 和 html 混合的代码）</p><p>第一次学 PHP 的时候，我们都接触过这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># index.php</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot;</span><br><span class="line">          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;?php echo &#x27;hello world&#x27;;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>phtml 文件把 php 的逻辑代码与 html 代码混合在一起，</p><p>如果是循环或者增加条件判断，简直不忍直视……</p><p>而使用模板引擎的情况下，我们只要传入参数，</p><p>然后模板渲染结果就可以了，</p><p>模板引擎当然也可以改成可配置的。</p><p>目前仅考虑：blade</p><h3 id="控制器（Controller）"><a href="#控制器（Controller）" class="headerlink" title="控制器（Controller）"></a>控制器（Controller）</h3><p>在我设计的这个框架里，</p><p>控制器不是用来处理业务逻辑的，</p><p>而是验证+分发请求+返回响应。</p><p>不过，验证可以完全交给中间件来处理，</p><p>这样控制器的代码就可以更加简洁。</p><p>期望效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function index() &#123;</span><br><span class="line">    // 获取参数</span><br><span class="line">    $params = $this-&gt;getParams();</span><br><span class="line">    // 将参数传递给 service，处理查询逻辑</span><br><span class="line">    $items = ArticleService::getInstance()-&gt;getList($params);</span><br><span class="line">    // 返回视图响应，并将参数传给视图渲染页面</span><br><span class="line">    $this-&gt;view(&#x27;home.index&#x27;, [&#x27;items&#x27; =&gt; $items]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有控制器的方法内的代码不超过 10 行。</p><h3 id="逻辑处理（Service）"><a href="#逻辑处理（Service）" class="headerlink" title="逻辑处理（Service）"></a>逻辑处理（Service）</h3><p>处理逻辑代码的地方，本质是一个类。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>按照原生开发的话，应该会使用 redis + 死循环来实现队列，</p><p>但是考虑到 swoole 自带了任务处理机制，</p><p>等我学习之后再具体考虑怎么实现。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>没有。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致就想到这么多，后期如果有需要再进行补充。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（一）框架概述</title>
      <link href="/2021/02/04/my-swoole-framework-1/"/>
      <url>/2021/02/04/my-swoole-framework-1/</url>
      
        <content type="html"><![CDATA[<h2 id="从入口文件开始说起"><a href="#从入口文件开始说起" class="headerlink" title="从入口文件开始说起"></a>从入口文件开始说起</h2><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p>简单地说框架就是封装好各种便利功能的工具，</p><p>同时还会“自动化”的处理复杂的事情，</p><p>通俗的说就是让程序员开开心心码代码的结构。</p><p>我们现在要撸的这套框架，应该满足以下需求：</p><ul><li>可以缩短开发时间</li><li>支持后期扩展</li></ul><p>不是仅仅封装一下类和方法就叫框架了，</p><p>它整体的结构应该让程序员使用起来非常舒服！</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>PHP 版本：7.2.31<br>Swoole 版本：4.5.2<br>PHP Redis 版本：5.1.1</p><p>这里我用的 redis 是 PHP 的扩展，</p><p>如果你不安装 redis 扩展也可以用 composer 引入。</p><h2 id="框架起名"><a href="#框架起名" class="headerlink" title="框架起名"></a>框架起名</h2><p>第一步是给框架起个好名字，</p><p>我把这个框架叫做“火兔引擎”，</p><p>创建目录：<code>/firerabbit-engine</code>。</p><p>这个目录名称和位置你可以随意设置，</p><p>之后用 nginx 指定就行了，最简单的就是放到 www 目录下。</p><h2 id="虚拟域名"><a href="#虚拟域名" class="headerlink" title="虚拟域名"></a>虚拟域名</h2><p>平时我们可能都是用 <code>127.0.0.1</code>，</p><p>但是本地的项目多了的话，就不能用单一的地址了。</p><p>我们可以设置一个虚拟域名，即修改本地的主机解析记录。</p><p>windows 系统和 mac os 都是修改 hosts 文件，</p><p>以 mac os 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>在最底下插入一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 firerabbit-engine.ht</span><br></pre></td></tr></table></figure><p><code>firerabbit-engine.ht</code> 是你设置的虚拟域名，</p><p>可以任意设置，但是最好不要是跟真正域名冲突的，</p><p>比如你设置了 <code>baidu.com</code>，</p><p>那你访问百度就会变成解析到自己本机了，</p><p>这个 <code>.ht</code> 后缀也是我虚构的。</p><p>测试的时候就可以在浏览器输入 <code>firerabbit-engine.ht</code> 访问博客地址。</p><h2 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello World！"></a>Hello World！</h2><p>现在项目是空的，一个文件也没有，</p><p>首先在项目目录下新建一个 <code>http_server.php</code>。</p><p>然后查看 Swoole 官方文档：<a href="https://wiki.swoole.com/#/start/start_http_server">Http 服务器</a></p><p>直接把示例代码抠下来复制到 <code>http_server.php</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$http = new Swoole\Http\Server(&#x27;0.0.0.0&#x27;, 9527);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123;</span><br><span class="line">    var_dump($request-&gt;server);</span><br><span class="line">    $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><blockquote><p>注意我这里把默认端口改成 9527 了。</p></blockquote><p>之后可以用 <code>127.0.0.1:9527</code> 进行访问。</p><p>如果你跟我一样是用 docker 的话，</p><p>记得要设置端口映射：<code>-p 9527:9527</code>，不然宿主机是访问不到的。</p><p>接着在项目的目录下，在控制台输出命令启动程序：<code>php http_server.php</code></p><p>你会看到光标卡住了，这说明程序已经运行了。</p><blockquote><p>swoole 本身就自带了 http 服务器的功能，因此不需要借助 nginx</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /www/firerabbit-engine/</span><br><span class="line">php http_server.php </span><br></pre></td></tr></table></figure><p>做完这一步就可以用 IP 地址+端口号的方式访问了，</p><p>打开浏览器，输入地址：<code>127.0.0.1:9527</code></p><p>可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Swoole. #7090</span><br></pre></td></tr></table></figure><p>后面的是随机数字所以每次刷新都不一样。</p><p>控制台也打印出了请求详情，</p><p>这样，第一步就成功了。</p><h2 id="Nginx-转发"><a href="#Nginx-转发" class="headerlink" title="Nginx 转发"></a>Nginx 转发</h2><p>虽然 swoole 自带了 http 服务器，</p><p>但是 swoole 处理 css、js 等静态文件却没有什么好的方法，</p><p>而 nginx 的强项就是处理静态文件，一拍即合，各展所长！</p><p>所以这里我们结合 nginx 处理静态文件，</p><p>静态文件 nginx 处理，动态文件 swoole 处理；</p><p>同时还可以利用上面的虚拟域名来访问网站。</p><p>nginx 增加一个配置文件 <code>firerabbit.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name firerabbit-engine.ht;</span><br><span class="line"></span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|css|js|ico|ttf|woff|woff2|svg|map)$ &#123;</span><br><span class="line">        root /www/firerabbit-engine/public;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;keep-alive&quot;;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        </span><br><span class="line">        if (!-e $request_filename)&#123;</span><br><span class="line">            proxy_pass http://php-fpm72:9527; # 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我是用 docker 搭建的 nginx 和 php 环境，</p><p>容器之间不能直接通过 IP 访问，而是要用容器名。</p><p>如果你不是用 docker 环境，php-fpm72 要改成 <code>127.0.0.1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://127.0.0.1:9527;</span><br></pre></td></tr></table></figure><p>然后执行命令：<code>nginx -s reload</code> 来平滑重启 nginx。</p><p>接着在浏览器输入上面设置的虚拟域名：<code>http://firerabbit-engine.ht/</code></p><p>可以看到同样的 hello world 页面。</p><p>通过 nginx 的转发，</p><p>所有静态文件如图片、css 文件等都会被转发到请求 public 这个目录，</p><p>不会发送到 swoole 那边，只有找不到文件才会转发给 swoole。</p><p>捋一捋程序的处理流程：</p><p>在浏览器输入域名的时候，用户的请求先经过 nginx 的正则判断，</p><p>如果是 jpg 之类的结尾，就去 public 这个目录下面找，</p><p>如果找不到文件了，再转发给 <code>http://php-fpm72:9527</code>。</p><p>这样 nginx 的配置也弄好了。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>一个典型的框架，包含以下几个特征：</p><ul><li>单一入口</li><li>MVC 结构（模型、视图、控制器分离）</li><li>自动加载（composer）</li></ul><p>单一入口这个很好理解，</p><p>swoole 默认即单一入口，</p><p>也就是全部请求都转发给 <code>http_server.php</code> 文件处理。</p><p>MVC 就是分离代码，让每个类的功能更加单一，</p><p>简单的说就是 PHP 写接口，前端人员写前端页面，</p><p>但是我们并不会真正的完全分离，因为博客是要做 SEO 的，</p><p>如果全部都用接口，搜索引擎就不会收录了。</p><p>我们的 MVC 结构会用模板引擎来实现代码解耦。</p><p>自动加载是我们这个框架的核心部分，</p><p>因为我们会依赖其他组件，同时我们自己的类也需要加上命名空间。</p><p>现代 PHP composer 自动加载几乎是必备的。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>捋一捋框架的整体运行流程：</p><p>swoole 收到 nginx 转发来的请求，</p><p>通过“解析器”将请求 uri 解析成对应的控制器和方法，</p><p>（解析器就是路由功能，解析器是一个类文件，自己要写的）</p><p>以及获取各种参数、cookie 等等，</p><p>将这些参数传递给 controller，</p><p>controller 负责处理业务逻辑。</p><p>虽然 MVC 框架已经很流行了，</p><p>但是我们这里不推荐在 controller 处理逻辑，</p><p>在这里写业务，后面这个文件就会变成几千行，不方便维护。</p><p>我们再增加一个 Service 层，将业务逻辑的代码移到 Service 去处理。</p><p>这样整个框架的流程大致可以捋顺了，如下图：</p><p><img src="https://i.loli.net/2021/02/04/INCJc6vlGMBYH8r.png" alt="流程1.png"></p><p>swoole 收到 nginx 转发的请求，</p><p>通过解析器（一个类文件），</p><p>将请求的 uri 解析成对应的路由和参数，</p><p>实例化路由的类并且调用对应的方法，并将参数传递给类的实例化对象，</p><p>类的实例化对象（controller）再调用 service 来处理逻辑。</p><p>（controller 的作用 与 nginx 类似，也是分发请求，但是它还有一个返回响应的功能）</p><p>controller 得到参数和 cookie 等，交给 service 处理，</p><p>service 再调用 model 或者其他的类库，返回处理结果，将值返回给  controller，</p><p>最后一步，controoler 收到返回的值，再返回对应类型的响应。</p><p>（响应的种类有很多，例如 json、html 等等，如：<code>content-type: text/html; charset=UTF-8</code>）</p><p>原本 controller 是处理逻辑代码的地方，</p><p>在这里我们把它变成分发请求了，</p><p>这是防止以后 controller 变得臃肿，</p><p>但实际上，</p><p>逻辑代码转移到 service 会让 service 变得臃肿……</p><p>（目前没有更好的方法了）</p><p>控制器的处理流程可以看图：</p><p><img src="https://i.loli.net/2021/02/04/cm8xCQ5aLjNYbrK.png" alt="流程2.png"></p><p>我个人比较喜欢这种方式，</p><p>最终我们写的控制器会是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class IndexController &#123;</span><br><span class="line">    public function index() &#123;</span><br><span class="line">        // 查询列表数据，为了方便调用，service全部做成单例的</span><br><span class="line">        $articles = ArticleService::getInstance()-&gt;getList();</span><br><span class="line">        // ... 这里返回视图</span><br><span class="line">        $this-&gt;view(&#x27;index&#x27;, [&#x27;articles&#x27; =&gt; $articles]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制器的代码会变得十分简洁。</p><p>控制器还有一个作用就是验证数据，</p><p>比如用户提交的表单，</p><p>如果输入的邮箱格式不正确就直接返回错误的响应，</p><p>数据验证就全部在 controller 处理了，而不是传到 service。</p><p>我把控制器的功能限制为：① 验证数据 ② 转发给 service 处理 ③ 返回结果</p><p>而 service 则处理数据库操作之类的业务逻辑。</p><p>controller 和 service 的功能变得十分单一，从而降低耦合性。</p><p>问题就是，控制器干净了，service 却脏了……</p><p>service 不仅要处理数据库，还要更新缓存之类的，想想就可怕。</p><p>后面我们可以考虑把数据库处理的逻辑转移到 model，</p><p>这样可以减少 service 臃肿度。</p><h2 id="第一阶段目标"><a href="#第一阶段目标" class="headerlink" title="第一阶段目标"></a>第一阶段目标</h2><p>现在思路已经很明确了，</p><p>但是很多细节部分我们还没有设计，</p><p>比如日志系统、缓存系统、数据库系统、配置参数文件、中间件……</p><p>下期统一进行规划，本篇文章就到这了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建自己的Swoole框架（序章）</title>
      <link href="/2021/02/04/my-swoole-framework-0/"/>
      <url>/2021/02/04/my-swoole-framework-0/</url>
      
        <content type="html"><![CDATA[<h2 id="开发目标及准备说明"><a href="#开发目标及准备说明" class="headerlink" title="开发目标及准备说明"></a>开发目标及准备说明</h2><p>这一篇不包含任何技术代码，如需要直接开始请阅读第（一）章。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>毕业三年，成为架构师！</p><p>这是我毕业时的梦想，结果没有实现。</p><p>现在重拾初心，从零设计一个属于自己的框架！</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>按照目前市面上的发展来看，</p><p>swoole 毫无疑问是目前 PHP 的天花板，</p><p>而自己在工作的时候做的都是流水线，几乎没机会接触到 swoole。</p><p>于是趁这个机会也学习一下。</p><p>这次设计的框架以开发博客系统作为案例，</p><p>我们不考虑它的适用性，正如标题所写的一样，</p><p>这是属于自己的框架，</p><p>而不是 Laravel 那样可以单独发布的 composer 包。</p><p>所以最终我们会完成一个单体博客应用，</p><p>如果你要把自己的框架做成发布到全网让别人使用你的框架，</p><p>可以了解一下 composer 的扩展包是怎么制作的。</p><p>只要这套框架做完了，</p><p>你自己改造成可以用 <code>composer require xxx/xxx</code> 那样引入的也完全没问题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="PHP-环境"><a href="#PHP-环境" class="headerlink" title="PHP 环境"></a>PHP 环境</h3><p>本人使用的是 docker 环境，</p><p>window 系统也可以用 wamp、xampp 等等，</p><p>只要搭好 PHP 环境并且安装了 swoole 扩展就行了。</p><p>windows 系统安装 swoole 扩展比较麻烦，</p><p>如果你不会安装，可以在 windows 系统安装 docker，</p><p>然后再在 docker 里面安装 php 环境。</p><h3 id="Swoole-扩展"><a href="#Swoole-扩展" class="headerlink" title="Swoole 扩展"></a>Swoole 扩展</h3><p>Swoole 官方网站：<a href="https://swoole.com/">swoole.com</a></p><p>swoole 其实是一个 php 扩展并不是框架，它跟 yaf 一样是基于内存常驻的。</p><p>swoole 依然还在保持着更新，yaf 却 N 年没更新了。</p><p>所以如果要学的话，强烈推荐 swoole 而不是 yaf。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>因为我们要做的是一个博客系统的单体应用。</p><p>Swoole 对静态文件的处理能力比较弱，</p><p>所以我们的目标是 swoole 做服务器，</p><p>静态文件交给 nginx 处理，</p><p>php 请求转发给 swoole。</p><blockquote><p>单体应用是相对于微服务来说的，通俗的讲即整个项目就只有一个文件夹，而微服务则是把各个模块拆出来，比如用户模块、订单模块诸如此类，还可以把全站的 api 接口拆分出来当成一个项目（前后端分离）</p></blockquote><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>免费的数据库，除了这个还有 Mango，</p><p>但是我没用过，根据你个人兴趣选择即可。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>免费的高性能包括键值对、哈希、集合列表等等处理器。</p><p>用来做缓存和队列任务，文章排行榜等等。</p><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p>php 的包管理工具，现在的项目还是纯手撸那也太 lower 了。</p><p>我们在开发框架的时候，会像 Laravel 那样依赖一些第三方的包。</p><p>感觉好像有点作弊？</p><p>用 composer 就跟直接拿别人开发好的一样，</p><p>不是说好手撸框架么？</p><p>不用担心，开发框架最核心的是编程思想，</p><p>具体怎么实现，我相信大家看着源码也能模仿出来。</p><p>如果你愿意从写 MySQL 数据连接开始，那也没问题!</p><p>如果你要从最底层的代码开始写，</p><p>那么我建议你将数据库处理、上传组件、缓存处理、队列任务等等，</p><p>把这些都做成单独的 composer 包，</p><p>然后再在框架里引入自己写的 composer 组件包，</p><p>像拼积木一样，看起来很酷对吧！</p><p>这样一个高度定制化的框架就实现了。</p><p>我还真的试过这么做，但是做一个 composer 包就放弃了……</p><p>因为……工作量增加了好几倍。</p><p>很不现实，你做的越细，工作量就越大，</p><p>而我们自己一个人维护不过来，</p><p>所以不推荐一开始就有那么大的野心，</p><p>本篇文章要完成的目标仅仅只是一个单体博客应用而已，</p><p>甚至都不会把框架单独拆分出来（业务逻辑代码也混合在框架里）。</p><p><strong>核心内容是开发框架的编程思想，而不是具体的实现。</strong></p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>用 PHPStorm 即可，当然也可以用微软的 VScode。</p><h2 id="最终目标"><a href="#最终目标" class="headerlink" title="最终目标"></a>最终目标</h2><p>在我们学习 PHP 的时候，</p><p>第一个开发的项目是什么？</p><p>我猜大部分人都是博客系统！</p><p>那么，三年前的我和三年后的我，</p><p>制作相同的一套系统会有什么差别呢？</p><p>用毕生（三年）的功力，来开发这套博客系统吧！</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> FireRabbitEngine </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC 系统打开网页速度缓慢问题的解决方法</title>
      <link href="/2021/01/16/mac-os-internet-slowly-resolved/"/>
      <url>/2021/01/16/mac-os-internet-slowly-resolved/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>MAC系统的浏览器打开某些网站特别慢，有的甚至打不开。比如百度云网盘链接打开很快，但是点击输入提取码却要卡半天；百度图片甚至直接打不开了；还有B站打开也要半天，严重浪费时间和影响效率。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="改变位置"><a href="#改变位置" class="headerlink" title="改变位置"></a>改变位置</h3><p>其实不是家里网络的问题，而是苹果系统迷之BUG！</p><p>首先点击左上角的苹果图标，然后选择“系统偏好设置”，接着选择“网络”。</p><p>（小技巧：按Command+空格键可以打开聚焦搜索，然后直接输入“网络”两个字，MAC系统就会显示出系统偏好设置里的网络了）</p><p>左侧默认有：</p><ul><li>Wi-Fi（已连接）</li><li>蓝牙 PAN</li><li>雷雳网桥</li></ul><p>这里我们不用修改。</p><p>看中间部分，默认值是“自动”，点击下拉框，然后选择“编辑位置”。</p><p>然后点击“+”号，输入新的位置：“家”，再点击完成。</p><p>接着我们可以发现，左侧的 Wi-Fi 的 IP 地址已经没了，并且提示你无法连接到网络。</p><p>只要你点击下方的“应用”，就会重新寻找 IP 地址。</p><p>现在已经大功告成了！再打开那些网页，你可以发现速度起飞了！</p><h3 id="改变-DNS"><a href="#改变-DNS" class="headerlink" title="改变 DNS"></a>改变 DNS</h3><p>如果上述方法依然无法提高访问速度，那就有可能是 DNS 地址在作怪。</p><p>我们知道，域名只是一个指向服务器 IP 地址的代号，把域名解析为 IP 地址需要 DNS 服务商为我们提供服务，因此 DNS 服务器也会影响打开网页的速度。</p><p>依然是系统偏好设置里的网络，点击左侧的 Wi-Fi，然后右下角的“高级”。</p><p>在顶部选项卡选择“DNS”，然后点击左下角的“+”号，添加如下地址：</p><ul><li>8.8.8.8</li><li>8.8.4.4</li></ul><p>以上任意一个即可，这两个是谷歌的 DNS 服务器。</p><p>当然我们国内的还有臭名昭著的 114：</p><ul><li>114.114.114.114</li></ul><p>你也可以修改为 114，但是并不推荐这么做。</p><p>因为它经常会在你打开的网页里加入一些奇奇怪怪的广告，最常见的就是手机访问网页时，右侧经常会出现一个红包领取的图标（并不是网站有这种东西，而是使用了 114 服务器解析后，它给这个网站加上的）</p><p>以前刚毕业的时候，曾经被这个奇怪的问题困扰了半天，还以为自己的网站是被被人黑了呢！</p><p>还有，当你访问的网站 404 时，114 会把网页改成它们的广告页，要知道互联网上 404 的页面有很多，光是广告费的收入就可想而知了。</p><p>虽说 114 又不是在做公益，没道理不牟利。</p><p>404 页面修改成广告倒是情有可原，但拦截别人的网站并在里面加入领取红包的广告，这样做就很不厚道了。</p><h3 id="关闭蓝牙"><a href="#关闭蓝牙" class="headerlink" title="关闭蓝牙"></a>关闭蓝牙</h3><p>据说苹果的蓝牙也会影响 Wi-Fi，你可以尝试关闭蓝牙，如果能提高网页访问速度，那说明蓝牙也会影响。</p><p>但是苹果系统又没有耳机接口，这样蓝牙耳机就用不了了……</p><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>如果你用了代理，那访问国内网站的速度肯定会变慢。</p><p>最好的方法就是改成 PAC 自动模式，这样软件就会自动判断是否需要开启代理了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MAC OS </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL为什么不使用 SELECT *(星号)查询？</title>
      <link href="/2020/06/25/mysql-why-not-use-select-star/"/>
      <url>/2020/06/25/mysql-why-not-use-select-star/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不论书上还是网上的技术论坛分享的 MySQL 查询优化方面的文章都不推荐使用 SELECT *，但是他们从未说过为什么不能这样用或者仅仅只是浅显的描述原因，但并不能让人觉得心服口服，那么——到底在 MySQL 为什么不用 SELECT * 来查询呢？</p><p>老娘很好奇！——「千反田」</p><p><img src="https://i.loli.net/2020/06/25/UADdHxXB8p9hewO.gif" alt="mysql"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实际上我标题党了！标题其实是一个伪命题。</p><p>抛开使用场景就提出命题全部都是无稽之谈！</p><p>比如一个 MySQL 的表 <code>users</code> 如下：</p><table><thead><tr><th>name</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>自增主键</td></tr><tr><td>name</td><td>varchar</td><td>用户昵称</td></tr><tr><td>email</td><td>varchar</td><td>注册邮箱</td></tr></tbody></table><p>现在需求是：产品需要查询全部的用户资料然后导出 Excel。</p><p>当然，我们肯定直接用 <code>SELECT * FROM users</code> 查询了。</p><p>你也可以用下面的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name,email FROM users;</span><br></pre></td></tr></table></figure><p>这两种方法是等价的，<code>*</code>（星号）的本质就是查询所有字段，并不是说使用星号就跟列出所有字段有什么不同的地方。</p><p>上述场景，两种方法的结果和过程完全一致。</p><h2 id="SELECT-的优点"><a href="#SELECT-的优点" class="headerlink" title="SELECT * 的优点"></a>SELECT * 的优点</h2><p>看到这里是不是颠覆常规的认知了？</p><p>众所周知，不论书上还是网上一致抵制 SELECT 星号查询。</p><p>为什么还能有优点呢？</p><p>抛开使用场景不谈而直接讨论命题的做法显然不可取。</p><p>以技术的角度来讨论这个问题，把不需要的字段查出来确实不好，为什么不好我们下文再介绍。</p><p>如果以项目经理的角度来说，<em><strong>SELECT 星号查询能大幅提升开发效率和减轻后续维护的时间</strong></em>。</p><p>这就涉及到「性能和开发效率的抉择」两者无法兼得。</p><p>为了提高查询效率，我们使用了 <code>SELECT 字段1,字段2,字段3</code> 进行查询，但如果后期我们修改表结构，表中新增了一个字段 4，那开发人员就得找到查询语句再补充一个字段 4，如果数据库模型使用了诸如 Laravel 的 <code>fillable</code> （可填充字段），你不仅要修改查询语句，还得修改模型。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    // 原本数据库只有两个字段 name 和 email</span><br><span class="line">    protected $fillable = [&quot;name&quot;, &quot;email&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 某个业务逻辑</span><br><span class="line">$users = User::select([&quot;name&quot;, &quot;email&quot;])-&gt;get();</span><br></pre></td></tr></table></figure><blockquote><p>虽然这个 fillable 跟查询没有关系，但是不设置 fillable 在插入数据字段就会屏蔽</p></blockquote><p>业务更新后，<code>users</code> 表新增了一个 <code>address</code> （住址）字段，业务需求不仅要显示出 <code>name</code> 和 <code>email</code> 现在还要把住址也显示出来。</p><p>于是，代码修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    // 添加新的字段 address</span><br><span class="line">    protected $fillable = [&quot;name&quot;, &quot;email&quot;, &quot;address&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询字段新增 address</span><br><span class="line">$users = User::select([&quot;name&quot;, &quot;email&quot;, &quot;address&quot;])-&gt;get();</span><br></pre></td></tr></table></figure><p>是不是很麻烦？因为添加一个新字段要修改两个地方的代码，开发效率大大降低了。</p><p>相反，如果直接使用星号查询呢？</p><p>Laravel 的 Model 中，与 <code>fillable</code> 相反的是 <code>guarded</code>（不可填充字段），将 <code>guarded</code> 的值设置为空数组代表所有字段（*）都可以填充（fillable）。</p><p>代码修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    // 所有字段都可以填充</span><br><span class="line">    protected $guarded = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不使用 select 方法查询即返回全部字段，也就是 SELECT * 查询</span><br><span class="line">$users = User::get();</span><br></pre></td></tr></table></figure><blockquote><p>guarded 也跟查询没有关系，它指代的是需要屏蔽哪些字段，与 fillable 相反</p></blockquote><p>现在即使添加了新的 <code>address</code> 字段，我们也不需要回去修改代码了。</p><p>所以，SELECT 星号的优点就是可以提高开发效率，而且这种开发效率的提升是极为显著的，试想一下如果一张表后期改了很多字段，不仅有新增字段还有删除的字段，如果使用 <code>SELECT 字段1,字段2</code> 的方法来查询，每次表结构更改就得重新审核一遍所有该表的查询语句，因为一旦忘记修改某处那就会报字段不存在的错误。</p><p>事情往往都有两面性，尽管 SELECT 星号查询会在一定程度上降低性能，但它却能提升开发效率，我们应该根据使用场景来决定具体用哪种方法，在需要高度优化的场景，我们自然不会使用低性能的 SELECT 星号，规则是死的，人是活的，场景不断变化，我们的查询语句也要跟随变化。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>上文提到使用 SELECT 星号查询会影响性能，这其实是一句很含糊的话，到底是什么性能？性能只是一种笼统的概念，网上大都没有深究具体哪些地方会受到影响，无非都是说查询的字段越多查询速度越慢，诸如此类。</p><p>老娘很好奇！！——「千反田」</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593061541376&di=9f36d3cb1049822e7147e83b9c27f75f&imgtype=0&src=http://img1.gtimg.com/comic/pics/hv1/4/68/2220/144372844.jpg" alt="mysql"></p><p>接下来就来详细的探讨 SELECT 星号影响的到底是哪些性能。</p><h3 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h3><p>我们知道 MySQL 的本质是存储在磁盘上的文件，因此查询操作就是一种读取文件的行为。</p><p>（当然还有一种是不需要读取文件的，后文介绍）</p><p>如果查询的字段越多，说明要读取的内容也就越多，因此会增大磁盘 IO 开销。</p><p>在对于 <code>TEXT</code>、<code>MEDIUMTEXT</code> 等更大长度的字段时，效果尤为明显。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>后端代码查询 MySQL 后将查询结果保存在变量中，变量会占用内存资源，字段越多变量占用的内存就越高，看下面的例子，展示了两种不同查询占用的内存情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查询语句</span><br><span class="line">select * from `users` limit 5000</span><br><span class="line"></span><br><span class="line"># PHP Laravel 框架测试内存使用情况</span><br><span class="line"></span><br><span class="line">// 获取查询前内存使用</span><br><span class="line">$startMemory = memory_get_usage();</span><br><span class="line">// 查询</span><br><span class="line">$users = User::limit(5000)-&gt;get();</span><br><span class="line">// 获取查询后内存使用</span><br><span class="line">$endMemory = memory_get_usage();</span><br><span class="line"></span><br><span class="line">echo &#x27;查询前：&#x27; . $startMemory . PHP_EOL;</span><br><span class="line">echo &#x27;查询后：&#x27; . $endMemory . PHP_EOL;</span><br><span class="line"></span><br><span class="line">## 输出结果</span><br><span class="line">查询前：15362584</span><br><span class="line">查询后：27977144</span><br></pre></td></tr></table></figure><p>如果只查询部分字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查询语句</span><br><span class="line">select id from `users` limit 5000</span><br><span class="line"></span><br><span class="line"># PHP Laravel 框架测试内存使用情况</span><br><span class="line"></span><br><span class="line">// 获取查询前内存使用</span><br><span class="line">$startMemory = memory_get_usage();</span><br><span class="line">// 查询</span><br><span class="line">$users = User::select([&#x27;id&#x27;])-&gt;limit(5000)-&gt;get();</span><br><span class="line">// 获取查询后内存使用</span><br><span class="line">$endMemory = memory_get_usage();</span><br><span class="line"></span><br><span class="line">echo &#x27;查询前：&#x27; . $startMemory . PHP_EOL;</span><br><span class="line">echo &#x27;查询后：&#x27; . $endMemory . PHP_EOL;</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">查询前：15363056</span><br><span class="line">查询后：21672336</span><br></pre></td></tr></table></figure><p>只查一个字段和查出全部字段内存占用差距非常大，尤其是在有 <code>text</code> 或者较大长度字段时，千万不要使用 SELECT 星号把无关的字段也包含到查询语句中，因为查找这些字段不仅没有意义还会徒增内存消耗。</p><h3 id="网络传输-x2F-带宽"><a href="#网络传输-x2F-带宽" class="headerlink" title="网络传输 &#x2F; 带宽"></a>网络传输 &#x2F; 带宽</h3><p>我们知道 MySQL 可以部署在与项目相同的服务器，也可以不在同一台服务器，当项目与 MySQL 不在同一台服务器时这种情况就会更加严重。</p><p>同理，如果使用了 <code>TEXT</code> 等大字段，要传输的内容也会变得更多。</p><p>从另一台部署了 MySQL 的服务器进行查询时，另一台服务器需要把数据传输给当前服务器，这中间是通过网络进行通信的，查询的数据越多返回的数据量也就越大。</p><p>数据传输量越大占用的网络资源就越多，这也是为什么前端要把 js 文件压缩成 min 减小体积的原因，只要传输的文件内容体积变小，传输花费的时间就越少，而大文件直到传输完成前网络连接不会断开，如果连接数一直增加最终可能超过服务器的承受能力导致后续连接直接未响应。</p><p>如果 MySQL 服务器是单独的，那么前面提到的缺点还会成倍的增加。</p><p>试想一下，MySQL 服务器中读取了多余字段（磁盘 IO &#x2F; 网络等性能消耗），然后再把数据传给项目所在服务器（多余字段导致内存增加），也就是说两台服务器都徒增压力。</p><h3 id="无法高效利用索引"><a href="#无法高效利用索引" class="headerlink" title="无法高效利用索引"></a>无法高效利用索引</h3><p>在本博客前一篇文章中提到对 MySQL 占用内存过高的优化技巧。</p><p>因为 MySQL 为了查询优化占缓存了许多数据到内存中，而如果我们能利用内存的数据，查询效率能得到质的飞跃。</p><p>其中之一就是索引。</p><p>MySQL 中存在一种概念叫做「覆盖查询」，当查询的字段全部都是索引时，这时 MySQL 可以直接从索引中返回数据而不需要再次去查询表。</p><p>示例，orders 表中存在索引字段：<code>user_id</code> 和 <code>goods_id</code>，直接查询这两个字段时，通过 explain 分析可以发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select user_id,goods_id from orders where user_id = 1 limit 10;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/25/LHKka4soi51XgEv.png" alt="image.png"></p><p><code>Extra</code> 字段返回的结果是：<code>Using index</code></p><p>这里说明查询结果用到了索引，「覆盖查询」的原理就是在 MySQL 创建表数据的时候，会对索引的数据创建单独的结构（注意：索引里面就包含了数据），因此查询索引字段直接从这个单独的结构里面就能拿到数据了，就不需要通过索引去定位行再从行中取记录。</p><p>如果我们把上述的查询语句修改一下，加入一个非索引字段 <code>price</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select user_id,goods_id,price from orders where user_id = 1 limit 10;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/25/oXf6P8J7qr1BSa5.png" alt="image.png"></p><p>可以发现，<code>Extra</code> 原本的 <code>Using index</code> 已经变成 <code>NULL</code> 了。</p><p>这是因为 price 不是索引字段，因此 MySQL 无法直接得到数据，必须定位到行才能拿到 price 字段，这种通过索引定位行再回到表中查询的过程叫做「回表查询」。</p><p>「覆盖查询」是从索引直接拿到数据，不需要「回表查询」，因而查询速度更快。</p><p>通过上面的分析，我们知道要实现「覆盖查询」的条件必须是：查询的字段全部都是索引。</p><p>显然我们不可能给每一张表的所有字段都加上索引，因此使用 SELECT 星号在字段比较多的表中无法实现「覆盖查询」。</p><h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><p>保持一颗「千反田的好奇心」，相信技术一定会有很大突破。</p><p><img src="https://i.loli.net/2020/06/25/NgM2rOeXHQiFPwI.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL新增用户、修改密码、设置权限</title>
      <link href="/2020/06/21/mysql-init-action/"/>
      <url>/2020/06/21/mysql-init-action/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次部署新项目都要重新设置 MySQL 的用户及权限，但这些基础命令又不经常用到，每次都要重新查找，于是整合了一下发成博文以便后续直接 <strong>复制粘贴</strong>。</p><p>网上搜索的大都是低版本 MySQL 或者根本就是错误的代码，不知道他们这样直接复制粘贴别人的代码但又没试过的是什么心态，简直浪费别人的时间。（尤其点明某 CSDN）</p><p>错误的范例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges *.* to &#x27;要创建的用户&#x27;@&#x27;localhost&#x27; identified by &#x27;自定义密码&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码在 MySQL 8 直接报错</p></blockquote><p>本文记录的命令以最新版的 MySQL 8 为基准。</p><h2 id="用户介绍"><a href="#用户介绍" class="headerlink" title="用户介绍"></a>用户介绍</h2><p>这一段科普 MySQL 用户知识，如需直接得到问题的解决答案可直接跳过。</p><p>MySQL 的所有用户均在 mysql 这个数据库里面保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user,host from users;</span><br><span class="line">ERROR 1146 (42S02): Table &#x27;mysql.users&#x27; doesn&#x27;t exist</span><br><span class="line">mysql&gt; select user,host from user;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| root             | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>其中，<code>authentication_string</code> 为加密后的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select user,host,authentication_string from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| root             | localhost |                                                                        |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，即使是 MySQL 系统创建的数据库同样适用 SQL 语句，你可以直接通过 <code>update</code> 命令修改字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set host=&quot;%&quot; where user=&quot;root&quot;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>上述命令是有效的，它的作用是把 <code>root</code> 用户的权限修改为 %（通配符），即除了 localhost（本地连接）之外，任何主机都可以通过该用户访问 MySQL。</p><p>当然这是不安全的，因为我们现在还没有给 root 用户设置密码，也就是说任何人都可以无密码访问到 MySQL。</p><p>虽然我们可以通过 <code>update</code> 直接修改 <code>authentication_string</code> 字段，但是这个字段是要经过加密的，不能直接修改成某个密码的值。</p><p>具体操作方法见下面的介绍。</p><h2 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h2><p>非本地连接时，最好不要使用 root 登录，而是创建一个新用户并且指定权限。</p><p>MySQL 创建新用户命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;用户名&#x27;@&#x27;权限&#x27; identified by &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure><p>其中，需要设置三个字段的值：</p><ul><li>用户名：即登录的用户名，如：root2</li><li>权限：可选值为 % 或者 localhost 或指定具体 IP，如果要通过第三方软件（如 Navicat）必须将这个值设置为 % 或者某个主机 IP，推荐使用 %，表示所有 IP，如果设置为 localhost（本地）表示只有这台服务器才能访问。</li><li>密码：设置登录的密码</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;huotu&#x27;@&#x27;%&#x27; identified by &#x27;huotublog&#x27;;</span><br></pre></td></tr></table></figure><p>上述代码表示创建一个具有远程登录权限的用户 huotu 且密码为 huotublog。</p><blockquote><p>刷新权限命令：flush privileges;</p></blockquote><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>如果需要修改用户的密码可以使用如下命令，不能直接使用 update 更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter user &#x27;huotu&#x27;@&#x27;%&#x27; identified by &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><p>修改完成后需要刷新权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>如果不设置权限，那么新增的用户就无法操作表。</p><p>在 MySQL 中所有用户都拥有某些数据库和表的某些权限，比如 root 用户具有最高权限，拥有操作所有数据库和表的能力。</p><p>一个用户的权限可以是一整个数据库，也可以对应许多个数据库，也可以是一个数据库中的某个表。</p><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;huotu&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>上述命令赋予 <code>huotu</code> 用户所有数据库的表所有操作（增删改查）。</p><p><code>with gran option</code> 表示该用户可给其它用户赋予权限，但不可能超过该用户已有的权限。</p><p><code>all privileges</code> 对应具体的权限，可换成 select,update,insert,delete,drop,create 等操作。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select,insert,update on *.* to &#x27;huotu&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>表示 <code>huotu</code> 只有对数据库中的表查询、插入和修改的权限，因此他无法进行删除操作。</p><p><code>*.*</code> 这里的 * 指的是通配符，第一个 * 的位置指定数据库，设置为 * 表示所有数据库，也可以指定某个数据库，比如：myblog.*。（myblog 是一个数据库，表示拥有 myblog 数据库对所有表的操作权限）</p><p>第二个 * 指的是数据库中的某个表，设置为 * 表示对数据库所有表都有权限，也可以指定具体的表：myblog.articles。</p><h2 id="查看授权信息"><a href="#查看授权信息" class="headerlink" title="查看授权信息"></a>查看授权信息</h2><p>查询某个用户的操作权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#x27;root&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h2 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h2><p>删除某个用户的全部权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke all privileges on *.* from &#x27;huotu&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>将用户数据删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#x27;huotu&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="疑点解析"><a href="#疑点解析" class="headerlink" title="疑点解析"></a>疑点解析</h2><p>上述所有命令基本都是 <code>&#39;huotu&#39;@&#39;%&#39;</code>，在看到这些命令的时候我在想后面的权限是有必要的吗？</p><p>因为已经有用户名了，附带权限不是多此一举？</p><p>其实只要测试一下就知道了，我们可以通过 <code>create</code> 命令创建一个 user 字段相同的用户，比如 root，但是权限不同，即 <code>%</code>，此时查询出来这两个同名的用户是并存的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select user,host,authentication_string from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| root             | %         | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257                              |</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| root             | localhost | *05F9DE4C759F49574C4400083F80107567B47C2E                              |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果不添加权限那这两个同名用户就无法区分了，也就是说 user 字段加上 host 字段组成唯一键，而不是 user 字段唯一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拆分你的代码</title>
      <link href="/2020/05/26/split-your-code-file/"/>
      <url>/2020/05/26/split-your-code-file/</url>
      
        <content type="html"><![CDATA[<h2 id="前文概要"><a href="#前文概要" class="headerlink" title="前文概要"></a>前文概要</h2><p>本文讲述的是如何把一个大文件拆分成许许多多小文件的方法。</p><p>所谓大文件其实没有一个明确定义，暂且规定一个文件如果超过 1000 行就算大文件吧！</p><p>当然也不用死脑筋，一看到代码行数多就得拆分，这完全要看情况，就好比玩游戏辅助的位置就一定得跟射手？如果脑袋不会转弯，对以后学习都很不利。死脑筋在一定程度上等同于“杠精”，本文介绍的是拆分文件的方法，而如何使用取决于一个聪明的孩子。</p><p>拆分文件的目的是解决混乱的逻辑，因为一个文件只要很大，极有可能是混杂了本来不应该出现的东西。拆分之后的小文件可能只有 100-200 行，相比一个 1000 多行的文件，哪个更容易让人看懂？</p><p>（题外话：在我看来辅助是决定游戏成败的关键因素，它的位置与打野一样重，出了辅助装的辅助不会抢经济，也就意味着这个位置可以支援任何一路，帮助中路快速清兵 Gank 上路，或者开局配合队友入侵对面野区，或者在上单被单杀后去守塔并且吃掉本来会被浪费的兵线，或者在打野队友被对面反蓝的时候去支援等等，辅助是很灵活的位置，但是一个死脑筋的人理解范畴就是辅助只有跟了射手才是辅助。）</p><h2 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h2><p>技术的演变过程都是朝着分离代码发展。</p><p>最早的 PHP 文件前后端代码混合在一起，相信大家最开始学 PHP 的时候都接触过这种代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// index.php 文件</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">// ...此处省略998行</span><br><span class="line">&lt;h1&gt;&lt;?php echo &quot;hello world!&quot; ?&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这种文件又被归为：<code>.phtml</code> 格式，意思是 PHP 代码与 HTML 混合的文件。</p><p>因为 PHP 代码可以嵌入在 HTML 文件中，所以 PHP 又被叫做嵌入式语言。</p><p>可以嵌入其他语言感觉很 Cool，但其实这种做法是非常不可取的，试想一下公司忽然来了一个不懂 HTML 的 PHP 实习生，看着混合着 HTML 和 PHP 代码的文件肯定一脸懵逼。</p><p>为了维护混合代码的项目需要掌握前端知识，后端开发无形中增加了学习成本。</p><blockquote><p>重点知识：HTML 代码与 PHP 代码混合在一起</p></blockquote><p>也就是上面提到的“出现不应该出现的东西”，HTML 代码应该只包含 HTML、JS、CSS 之类的前端方面文件，而用来处理业务逻辑的 PHP 文件里也不应该出现前端的东西。只要出现了本来不应该出现的东西就会导致维护成本增加。</p><h2 id="传统-MVC-模式"><a href="#传统-MVC-模式" class="headerlink" title="传统 MVC 模式"></a>传统 MVC 模式</h2><p>首先介绍一下传统 MVC 模式，</p><p>这是早期用来处理代码文件膨胀的解决方案：</p><p>将代码文件分成：</p><ul><li>Model（模型）处理数据库操作</li><li>View（视图）渲染 HTML 文件</li><li>Controller（控制器）处理请求和响应</li></ul><p>在一定程度上满足了早期的需求，模型文件专门处理数据库的增删改查，而控制器只要实例化模型对象就可以直接调用数据库操作方法，然后把数据传递给视图进行渲染。</p><p>每一步都变得更加专业化了。</p><blockquote><p>模板视图：包括 PHP 代码与 HTML 代码的特殊文件</p></blockquote><p>但 MVC 结构依然没有摆脱代码混合的问题，而是使用了稍微好一些的模板视图（例如：smart 模板、blade 模板）。</p><p>模板视图就是用来处理前端和 PHP 代码，用来最终渲染出 HTML 页面的文件。</p><p>以 Laravel 使用的 blade 模板为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// IndexController.php</span><br><span class="line">class IndexController &#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        // 查询数据库，取 ID=1 的 goods</span><br><span class="line">        $goods = Goods::where(&#x27;id&#x27;, 1)-&gt;first();</span><br><span class="line">        </span><br><span class="line">        return view(&#x27;index&#x27;, compact(&#x27;goods&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.blade.php</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">// ... 省略998行</span><br><span class="line">&#123;&#123; $goods-&gt;name &#125;&#125;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通过模板引擎编译后生成如下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">// ... 省略998行</span><br><span class="line">&lt;?php echo $goods-&gt;name; ?&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>也就是说我们现在不需要直接在 HTML 上面写代码，而是在模板文件（index.blade.php）上面写代码。</p><p>但这种方法治标不治本，虽然模板文件是 PHP 文件，但还是夹杂着 HTML。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>为了分离出 HTML 和 PHP 代码，人们研究出了通过接口调用实现前后端分离的方法。</p><p>这种技术叫做 Ajax，前端通过 JavaScript 发起 HTTP 请求，服务器返回查询的数据，前端再渲染数据。</p><p>整个过程实现了前后端代码的完全分离。</p><blockquote><p>现在我们后端开发人员已经从前端地狱中解放出来了！！</p></blockquote><h2 id="Service-模式"><a href="#Service-模式" class="headerlink" title="Service 模式"></a>Service 模式</h2><p>因为前后端分离，MVC 模式的 View（视图）已经不需要了，</p><p>取而代之的是新出现的 Service（服务）。</p><p>MVC 模式下，所有的业务逻辑都写在 Controller（控制器）上。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class GoodsController</span><br><span class="line">&#123;</span><br><span class="line">    public function index() &#123;</span><br><span class="line">        // 按发布时间倒序获取20条商品数据</span><br><span class="line">        $goods = Goods::orderByDesc(&#x27;created_at&#x27;)-&gt;limit(20)-&gt;get();</span><br><span class="line">        // 拼装接口返回数据</span><br><span class="line">        $items = [];</span><br><span class="line">        foreach($goods as $item) &#123;</span><br><span class="line">            $items[&#x27;data&#x27;][] = [</span><br><span class="line">                &#x27;id&#x27; =&gt; $item-&gt;id,</span><br><span class="line">                &#x27;title&#x27; =&gt; $item-&gt;title,</span><br><span class="line">                &#x27;time&#x27; =&gt; $item-&gt;created_at</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 返回接口响应</span><br><span class="line">        return api_response($items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把所有业务逻辑代码都写在控制器上会导致控制器文件逐渐膨胀。</p><p>控制器的作用是处理请求和响应，我们可以让它更加专业化一点，让它只负责处理请求然后给出响应。</p><p>至于逻辑处理，可以交给第三方：Service（服务）来处理。</p><p>所谓 Service 层只不过是再额外增加一个文件。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class GoodsService &#123;</span><br><span class="line">    </span><br><span class="line">    // 按发布时间倒序获取20条商品数据</span><br><span class="line">    public function getGoodsItems() &#123;</span><br><span class="line">       $goods = Goods::orderByDesc(&#x27;created_at&#x27;)-&gt;limit(20)-&gt;get();</span><br><span class="line">       // 拼装接口返回数据</span><br><span class="line">       $items = [];</span><br><span class="line">       foreach($goods as $item) &#123;</span><br><span class="line">           $items[&#x27;data&#x27;][] = [</span><br><span class="line">               &#x27;id&#x27; =&gt; $item-&gt;id,</span><br><span class="line">               &#x27;title&#x27; =&gt; $item-&gt;title,</span><br><span class="line">               &#x27;time&#x27; =&gt; $item-&gt;created_at</span><br><span class="line">           ];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return $goods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在控制器里只需要实例化出一个 GoodsService 对象，调用方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class GoodsController</span><br><span class="line">&#123;</span><br><span class="line">    public function index() &#123;</span><br><span class="line">        $service = new GoodsService();</span><br><span class="line">        $items = $service-&gt;getGoodsItems();</span><br><span class="line">        </span><br><span class="line">        // 返回接口响应</span><br><span class="line">        return api_response($items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器里面只负责处理请求和给出响应，把逻辑处理交给 Service 处理，这样 Controller 的代码几乎已经没有多少了，以后某个接口出问题可以立即找到对应的控制器方法，大大减少排查问题的时间。</p><p>（把业务逻辑写在控制器里是一个非常让人吐血的事情，作为接盘了不少项目的我深有体会）</p><h2 id="更多的划分方法"><a href="#更多的划分方法" class="headerlink" title="更多的划分方法"></a>更多的划分方法</h2><p>机智的你一定发现，即使增加了 Service 层，业务逻辑代码还是很多啊，把本来囤积在 Controller 的代码移到 Service 有什么意义？</p><p>意义之一就是让每个结构更加专业化，Controller 只处理请求和响应，因为 Controller 如果有太多代码的话，如果一个接口出问题了，你要在 IDE 上面拖动滚轮才能定位到你想要的那个方法上面，然后直接在 Controller 层排查问题。而且 Controller 层如果囤积了太多业务代码，还有其他小伙伴也在修改这个控制器就很容易发生代码冲突造成不必要的麻烦。</p><p>Goods（商品）的相关业务逻辑就交给 GoodsService 处理；User（用户）的业务逻辑就交给 UserService 处理，这样你要修改哪个模块的业务逻辑也很方便不是吗？</p><p>但还是没有解决 Service 层代码囤积问题。</p><p>这里凭经验之谈，其中一个方法就是数据库操作的逻辑移动到 Model 层里面去处理，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class UserModel extends Model &#123;</span><br><span class="line">    // 添加一名新用户</span><br><span class="line">    public function addUser($username) &#123;</span><br><span class="line">        // user 表增加一条新用户记录</span><br><span class="line">        $user = $this-&gt;create([</span><br><span class="line">            &#x27;username&#x27; =&gt; $username,</span><br><span class="line">        ]);</span><br><span class="line">        </span><br><span class="line">        // 为用户开通支付账户</span><br><span class="line">        UserAccountModel::create([</span><br><span class="line">            &#x27;user_id&#x27; =&gt; $user-&gt;id</span><br><span class="line">        ]);</span><br><span class="line">        </span><br><span class="line">        // ... 其他数据库相关操作</span><br><span class="line">        </span><br><span class="line">        // 返回新创建的 user 对象</span><br><span class="line">        return $user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 UserService 直接调用 Model 的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$data = request()-&gt;all();</span><br><span class="line">$model  = new UserModel();</span><br><span class="line">$user = $model-&gt;addUser($data);</span><br><span class="line">// ... 处理其他逻辑</span><br></pre></td></tr></table></figure><p>这样 Service 层的代码一部分就转移到了 Model 层里去了！</p><p>把所有数据库增删改查的逻辑全部转移到 Model 层，</p><p>而 Service 只要实例化对应的 Model，调用方法（负责处理整体的逻辑）。</p><p>这样 Service 层也可以变得更加专业化。</p><blockquote><p>Model：喵喵喵？把锅甩给我！？</p></blockquote><p>新的问题又来了，Model 层膨胀了！</p><p>OK，用同样的逻辑，我们再分出一个 Action（操作）层。</p><p>新建 Action 类，每一个操作对应一个类文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class UserAddAction &#123;</span><br><span class="line"></span><br><span class="line">    // 创建新用户</span><br><span class="line">    public function add($data) &#123;</span><br><span class="line">        $model = new UserModel();</span><br><span class="line">        $user = $model-&gt;create($data);</span><br><span class="line">        </span><br><span class="line">        return $user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UserAccountAddAction &#123;</span><br><span class="line"></span><br><span class="line">    // 开通用户支付账户</span><br><span class="line">    public function add(UserModel $user) &#123;</span><br><span class="line">        $model = new UserAccountModel();</span><br><span class="line">        $data = [</span><br><span class="line">            &#x27;user_id&#x27; =&gt; $user-&gt;id,</span><br><span class="line">            // ... 省略其他数据</span><br><span class="line">        ];</span><br><span class="line">        $account = $model-&gt;create($data);</span><br><span class="line">        </span><br><span class="line">        return $account;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 Model 里面只要实例化 Action，然后调用方法就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class UserModel extends Model &#123;</span><br><span class="line">    // 添加一名新用户</span><br><span class="line">    public function addUser($username) &#123;</span><br><span class="line">        // user 表增加一条新用户记录</span><br><span class="line">        $userAddAction = new UserAddAction();</span><br><span class="line">        $data = [</span><br><span class="line">            &#x27;username&#x27; =&gt; $username,</span><br><span class="line">            // .. 其他数据</span><br><span class="line">        ];</span><br><span class="line">        $user = $userAddAction-&gt;add($data);</span><br><span class="line">        </span><br><span class="line">        // 为用户开通支付账户</span><br><span class="line">        $userAccountAddAction = new UserAccountAddAction();</span><br><span class="line">        $data = [</span><br><span class="line">            &#x27;user_id&#x27; =&gt; $user-&gt;id,</span><br><span class="line">            // .. 其他数据</span><br><span class="line">        ];</span><br><span class="line">        $account = $userAccountAddAction-&gt;add($data);</span><br><span class="line">        </span><br><span class="line">        // ... 其他数据库相关操作</span><br><span class="line">        </span><br><span class="line">        // 返回新创建的 user 对象</span><br><span class="line">        return $user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 Action 只对应一个方法，这样 Action 就不会膨胀了。</p><p>业务调用关系如下：</p><blockquote><p>Controller -&gt; Service -&gt; Model -&gt; Action</p></blockquote><p>但代码拆分的缺点就是会让文件变得越来越多，每一个数据库操作就要写一个 Action，以后可能会出现上千个文件，而我们知道 PHP 程序运行时需要加载全部的文件，无疑会降低性能。</p><p>代码变得更好维护的成本是降低性能，代价未免太大了。</p><p>所以优化也要适度，回到标题，如何选择是要看情况进行灵活变通的。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构同样是为了拆分代码，</p><p>把一套系统的各个功能模块拆分成独立的模块，</p><p>每一个小模块都是一个新的项目。</p><p>例如一套系统有用户模块、商品模块、订单模块，</p><p>主项目负责处理请求，然后调用相应的模块，再将数据返回。</p><p>主服务器的作用类似于 Controller 层，</p><p>只负责处理请求和响应，但具体的实现都交给 Service（子模块）去处理。</p><p>把每一个功能都单独立项可以使项目更加专一化，原本一个项目包括了所有模块。</p><blockquote><p>“单体应用”模式</p></blockquote><p>单体应用只需要部署一套项目，项目里就已经包含了完整的模块。</p><p>所有开发人员都在一个项目上进行开发工作。</p><p>单体应用的缺点是随着业务增加会越来越难以维护（因为所有的代码都集中在一个地方）。</p><p>而所有人都在共同维护一套代码，每个人习惯不同，技术水平也不同，</p><p>代码质量参差不齐，新加入的小伙伴也不敢轻易修改老员工的代码。</p><p>（有时候虽然知道老员工写了一个可以直接调用的方法，但新员工依然会产生不信任感，总归不是自己写的代码，万一被原主人改了怎么办？完全不能放心调用。）</p><blockquote><p>单体应用排查 BUG 困难</p></blockquote><p>有时候新来的小伙伴为了找一个 BUG 可能要遍历用户模块、订单模块、商品模块……</p><p>几乎把所有的逻辑代码查了个遍。如果把每个模块都单独拆成小项目交给一个小团队去维护，大家各扫门前雪，用户模块出问题了就让负责用户模块的人去处理，这样大家互不影响，不会出现你删了别人代码，导致别人一脸懵逼的排查了一整天都没找到原因。</p><p>项目拆分成小项目，每个项目的运行速度就会变得更快，大大提高了系统性能。</p><blockquote><p>理想很美好！现实很残酷……</p></blockquote><p>到公司你还是要当打杂的角色，不可能让一个人只负责一个项目，</p><p>往往就是用了微服务架构，你一个人要负责全部的项目（工作量反而增加了）。</p><blockquote><p>不是技术负责人要压榨劳动力……而是他要为项目负责任。</p></blockquote><p>如果他招来的人跑路了，那负责这个模块的功能就没人维护了，所以当你加入微服务架构里，每个团队成员至少也要负责 2 个以上的项目，万一其中一个人跑路还有另一个可以顶替。</p><p>项目变多，单个项目维护成本降低，</p><p>但总体维护成本也会提高，尤其是架构师跑路，谁来接盘就是一个严重问题。</p><p>回到最开始的地方，我们最终还是没能解决接盘侠的问题……</p><p>总之，接盘侠是无可避免的要痛苦的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL占用内存过高优化记录</title>
      <link href="/2020/04/09/mysql-memory-optimize/"/>
      <url>/2020/04/09/mysql-memory-optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在腾讯云购买的 1 核 1G 主机，使用 Docker 搭建的 MySQL 内存占用竟然高达 34%！再加上 Docker 其他容器运行起来和系统本身程序占用的内存，总内存高达 80+%，由于其他程序使用了 Redis 作为缓存，1G 内存就剩下 10%+ 可用内存（100MB+），一不小心可能就会让服务器卡成渣甚至直接 GG。</p><p>由于服务器一天的访问量并不多，并发访问也不高，并不需要把 MySQL 优化的多好，只要能正常运行就够了，加上有 Redis 缓存这一层，几乎很少会跑到 MySQL 查询。 </p><p>所以综合起来，MySQL 压根不用担心它会挂掉，可以把默认的优化方案修改一下，以便把占用的内存释放出来。</p><p>优化后的结果如下图：</p><p><img src="https://ae01.alicdn.com/kf/H8de4ff5c012d438f96db914a35d0e207i.png" alt="MySQL优化内存"></p><h2 id="查询内存占用"><a href="#查询内存占用" class="headerlink" title="查询内存占用"></a>查询内存占用</h2><p>使用 <code>top</code> 命令查询当前程序的内存占用情况。</p><p>我们需要关注的部分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                          </span><br><span class="line"> 1751 root      20   0  740212  11140   1476 S  1.2  1.1 106:46.57 barad_agent                                                                                                      </span><br><span class="line"> 1750 root      20   0  164512   8648   1312 S  0.6  0.9  20:52.41 barad_agent                                                                                                      </span><br><span class="line">29245 root      20   0  155148   2380    660 S  0.6  0.2   0:24.18 sshd                                                                                                             </span><br><span class="line">31044 root      20   0  135552   6028   1468 S  0.6  0.6   0:11.02 YDService                                                                                                        </span><br><span class="line">    1 root      20   0   43656   2764   1364 S  0.0  0.3   2:19.11 systemd  </span><br></pre></td></tr></table></figure><ul><li><code>PID</code>：进程 ID</li><li><code> %CPU</code>：CPU 占用百分比</li><li><code>%MEM</code>：内存占用百分比</li><li><code>COMMAND</code>：程序命令名称</li></ul><p>如果发现某个不需要的进程占用了过高的内存或 CPU，可以直接使用 <code>kill &lt;PID&gt;</code> 杀掉进程。</p><p>进程杀掉程序就停了，我们不能直接杀掉 MySQL，具体解决思路见下一个步骤。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>MySQL 在启动的时候，会占用一部分的内存来作为缓冲区，这样做的原因是可以优化查询速度，我们可以发现只要查询过一次 MySQL，然后用相同的语句再次查询，第二次查询会比第一次更快，这其中就用到了 MySQL 自身的缓存系统。</p><p>MySQL 的缓存机制是当某一个连接访问某张表时，MySQL 会先检查访问的表是否在缓存区中，如果这张表已经在缓存区中打开，那就会直接访问缓存区从而加快查询速度，如果这张表不在缓存区，那就会从实际的数据库文件进行查询，然后再把这张表加入缓存区，以便后续查询加快速度。</p><p>由于这个机制我们的 MySQL 在运行过程占用的内存会逐渐增加，1G 的内存不适合用来做 MySQL 的优化，我们要做的就是去掉 MySQL 用来加快查询的各种机制。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改 MySQL 配置文件 <code>my.cnf</code>，找到 <code>[mysqld]</code> 下添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">// 此处省略其他配置，添加如下内容</span><br><span class="line">table_open_cache=200</span><br><span class="line">table_definition_cache=400</span><br><span class="line">performance_schema_max_table_instances=400</span><br><span class="line">performance_schema=off</span><br></pre></td></tr></table></figure><p>保存然后重启 MySQL，OK！内存已经降到 10%+ 了。</p><p>各个配置项的具体用途：</p><table><thead><tr><th>字段</th><th>用途</th></tr></thead><tbody><tr><td>table_open_cache</td><td>高速缓存的大小，每当访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，下次查询该表时首先从高速缓存区查询，如果表在缓存中则直接从缓存查询，从而大幅提高查询速度。</td></tr><tr><td>table_definition_cache</td><td>定义了内存中可打开的表结构数量。</td></tr><tr><td>performance_schema_max_table_instances</td><td>检测的表对象的最大数目。</td></tr><tr><td>performance_schema</td><td>主要用来收集 MySQL 性能参数，启用 performance_schema 之后，server 会持续不间断地监测。【罪魁祸首】</td></tr></tbody></table><p>通过调整前面 3 个配置项的值，占用内存均有 1~3% 程度的降低，罪魁祸首便是 <code>performance_schema</code>，将其设置为 off 之后，内存直接降低了 20%！</p><p>其详细介绍可参考 MySQL 官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html">MySQL Performance Schema</a></p><p>当然除了上面几个配置项之外，MySQL 仍有许多可以优化的配置项，但是现在既然已经实现了自己的目的，就暂时不进行扩展阅读了，以后如果需要更深入的优化，到时候再学也不迟（日均 IP 100+ 根本不用考虑什么优化嘛~）。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏菜单系统开发之栈的妙用</title>
      <link href="/2020/04/02/game-developer-stack/"/>
      <url>/2020/04/02/game-developer-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="菜单系统"><a href="#菜单系统" class="headerlink" title="菜单系统"></a>菜单系统</h2><p>菜单是所有游戏必不可少的一个系统。</p><p>在游戏场景中，按 X 键可以呼出菜单，在菜单中按上下键可以切换菜单选项，再按 Z 键可以选中菜单，然后进入子页面的操作，子页面的菜单中也有子菜单，子菜单的操作与父级菜单一致。当打开菜单的状态，再按 X 键会返回上一级的菜单，直到主菜单返回游戏场景。</p><p>演示效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/02/GGIL5j.gif" alt="名为怪物的游戏 - 游戏菜单"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现菜单系统，最关键的地方在于防止按键冲突。</p><p>主菜单有按键事件，子菜单中也有按键事件，因此在主菜单中选中了子菜单，就要解除主菜单的监听事件而绑定子菜单的监听事件，多级菜单同理，可以归纳为：打开菜单——解除上一级的监听事件——绑定当前菜单的监听事件。</p><p>游戏的例子可能让从未接触过游戏的开发者难以理解，那么再看下一个例子。</p><p><img src="https://s1.ax1x.com/2020/04/02/GGLnsI.png" alt="电商菜单"></p><p>上图为某电商首页的 UI，假如产品经理提出一个需求，在这个网页上按 X 键可以展开商品分类的菜单，然后通过键盘的按键可以选择二级菜单，选中一个分类再按 Z 键展开三级菜单，在展开菜单的情况下按 X 键会返回上一级菜单，你应该如何实现此功能？</p><p>如果使用正常的方法，用变量来判断打开了哪些菜单，然后再绑定对应的事件，你会发现很难实现无限级的菜单系统，而且业务代码会变得乱糟糟的。</p><p>比如情报页面有线索二级菜单，线索菜单又可以进入到线索列表三级菜单，而角色状态可能只有一个显示角色信息的 UI，只有切换角色的按钮，没有三级菜单。</p><p>每个主菜单的选项都可能是不同的，它们没有共同点，因此你无法使用继承的关系把相同的操作提取出来，每一个菜单都要单独判断，简直是 <code>if-else</code> 地狱，不难想象代码会乱成什么样子。</p><p>在这里我们可以用“栈”的特性来优雅的实现菜单系统。</p><blockquote><p>栈：一种先进后出的数据结构</p></blockquote><p>栈是一种先进先出的结构，与队列正好相反，而我们打开菜单，按 X 键也正好是逐级向上返回，符合了栈的特性——先打开的菜单最后关闭。</p><p>在这里核心点是 <strong>监听事件与解除监听</strong>，无需关心具体的业务逻辑。</p><blockquote><p>示例语言为 TypeScript，cocos creator 游戏引擎开发</p></blockquote><p>首先我们定义一个父类 <code>StackComponent</code> 这个父类是需要调用栈的组件必须继承的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 Scene_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default abstract class NewClass extends cc.Component &#123;</span><br><span class="line"></span><br><span class="line">    /** 添加监听按键 */</span><br><span class="line">    addListener() &#123;</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 移除监听按键 */</span><br><span class="line">    removeListener() &#123;</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract onKeyDown(event: cc.Event.EventKeyboard): void;</span><br><span class="line">    abstract onKeyUp(event: cc.Event.EventKeyboard): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>addListener</code> 方法添加按键监听，而 <code>removeListener</code> 方法则移除监听的事件，具体的按键事件进行了抽象，由子类来实现。</p><ul><li>onKeyDown：键盘按下的时候触发</li><li>onKeyUp：键盘弹起的时候触发</li></ul><p>接着定义一个栈结构，栈非常简单就可以实现，用一个数组来保存数据，用 <code>pop</code> 方法即可弹出最后一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 System_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line">import System_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class NewClass extends cc.Component &#123;</span><br><span class="line">    private _componentStacks: System_StackComponent[] = [];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空栈</span><br><span class="line">     */</span><br><span class="line">    flushStack() &#123;</span><br><span class="line">        this._componentStacks = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从栈取出最后一个元素</span><br><span class="line">     */</span><br><span class="line">    popStack() &#123;</span><br><span class="line">        var len = this._componentStacks.length;</span><br><span class="line">        if (len == 0) &#123;</span><br><span class="line">            cc.error(&#x27;栈已空，调用失败&#x27;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 弹出当前窗口</span><br><span class="line">        let pop = this._componentStacks.pop();</span><br><span class="line">        pop.removeListener();</span><br><span class="line">        // 最后一个元素添加监听</span><br><span class="line">        if (this._componentStacks.length != 0) &#123;</span><br><span class="line">            let last = this._componentStacks[this._componentStacks.length - 1];</span><br><span class="line">            last.addListener();</span><br><span class="line"></span><br><span class="line">            cc.log(&#x27;窗口出栈,剩余：&#x27; + this._componentStacks.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜单组件入栈</span><br><span class="line">     * @param  component </span><br><span class="line">     */</span><br><span class="line">    pushStack(component: System_StackComponent) &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">            cc.error(&#x27;这是一个空的元素&#x27;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 原来最后一个元素移除监听</span><br><span class="line">        let len = this._componentStacks.length;</span><br><span class="line">        if (len != 0) &#123;</span><br><span class="line">            let last = this._componentStacks[len - 1];</span><br><span class="line">            last.removeListener();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前元素添加监听</span><br><span class="line">        component.addListener();</span><br><span class="line"></span><br><span class="line">        this._componentStacks.push(component);</span><br><span class="line"></span><br><span class="line">        cc.log(&quot;入栈：&quot;, this._componentStacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>popStack</code> 方法弹出栈最顶层的元素，并且移除监听事件，同时监听新的顶层元素事件。</p><p><code>pushStack</code> 方法将新的菜单入栈，监听当前菜单事件并且移除原来菜单的事件。</p><p>栈中所有的元素都继承 <code>System_StackComponent</code> 栈组件，因此它们都具有 <code>addListener</code> 方法和 <code>removeListener</code> 方法。</p><p>接下来为了方便，我们把对象保存在 JavaScript 的系统对象 window 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window[&quot;__game&quot;][&quot;stack&quot;] = new System_Stack;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过 <code>__game.stack</code> 来调用栈的方法了。</p><p>主菜单脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line">import Scene_Menu_Item from &quot;./Scene_Menu_Item&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class Scene_Menu extends Scene_StackComponent &#123;</span><br><span class="line"></span><br><span class="line">    /** 关闭菜单 */</span><br><span class="line">    closeMenu() &#123;</span><br><span class="line">        // 弹出当前菜单事件</span><br><span class="line">        __game.stack.popStack();</span><br><span class="line">        // 销毁菜单节点（让菜单消失）</span><br><span class="line">        this.node.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 显示情报面板 */</span><br><span class="line">    showInformationPanel() &#123;</span><br><span class="line">        // 读取情报面板的预制资源</span><br><span class="line">        cc.loader.loadRes(&quot;/prefab/SceneInformation&quot;, (err, res) =&gt; &#123;</span><br><span class="line">            let clueNode = cc.instantiate(res);</span><br><span class="line">            let clue = clueNode.getComponent(&quot;Scene_Information&quot;);</span><br><span class="line">            // 把菜单脚本压入栈</span><br><span class="line">            __game.stack.pushStack(clue);</span><br><span class="line">            // 调用菜单脚本的初始化方法</span><br><span class="line">            clue.init();</span><br><span class="line">            // 把菜单节点添加到场景（显示菜单 UI）</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(clueNode);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 具体的监听事件</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        // 判断当前选项在“情报”菜单，如果此时按 Z 键则调用 showInformationPanel 方法显示情报页</span><br><span class="line">        // 判断按 X 键调用 closeMenu 方法关闭菜单</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        // 业务逻辑忽略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>closeMenu</code> 方法关闭当前菜单，并且弹出栈，在所有菜单关闭的时候都调用这个方法。</p><p><code>onKeyUp</code> 是键盘弹起事件，暂时不用理会。</p><p>在游戏场景加载中，为了能随时随地呼出菜单，我们再定义一个新的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// System_Menu.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line"></span><br><span class="line">import Scene_Menu from &quot;./Scene_Menu&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;./Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class System_Menu extends Scene_StackComponent &#123;</span><br><span class="line">    private _menuNode: cc.Node = null;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        __game.stack.pushStack(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听 X 键</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        switch (event.keyCode) &#123;</span><br><span class="line">            case cc.macro.KEY.x:</span><br><span class="line">                this.show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 显示菜单 */</span><br><span class="line">    show() &#123;</span><br><span class="line">        // 加载菜单预制资源并添加到场景</span><br><span class="line">        cc.loader.loadRes(&quot;/prefab/Menu&quot;, (err, res) =&gt; &#123;</span><br><span class="line">            let node = cc.instantiate(res);</span><br><span class="line">            let menu: Scene_Menu = node.getComponent(&quot;Scene_Menu&quot;);</span><br><span class="line">            // 将主菜单入栈</span><br><span class="line">            __game.stack.pushStack(menu);</span><br><span class="line">            this._menuNode = node;</span><br><span class="line">            // 添加到场景</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(node);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将这个类添加到 window 系统对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加到 window 对象</span><br><span class="line">window[&quot;__game&quot;][&quot;menu&quot;] = new System_Menu;</span><br><span class="line">// 执行初始化操作（入栈）</span><br><span class="line">__game.menu.init();</span><br></pre></td></tr></table></figure><p>如此一来，我们就可以随时随地通过全局的方法 <code>__game.menu.show()</code> 调出菜单了！</p><p>注意！<code>System_Menu</code> 脚本并没有出栈的操作，因为如果这个脚本出栈了，那就不能监听 X 呼出菜单的事件，保留最底层的监听以便随时呼出菜单。</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>由于菜单是一级一级往上打开，而关闭的时候是一级一级向下关闭，因此它符合栈的结构，当一个菜单节点入栈时，我们为它绑定监听事件，同时解除上一级菜单的监听事件；当一个菜单出栈时，我们就解除这个菜单的监听事件，然后再给栈新的顶层节点绑定监听事件，无论有多少级的菜单都能够用这种结构来实现，只要让它们继承 <code>StackComponent</code> 类即可实现栈的调用控制事件的监听与解除，比起用变量来判断打开了哪些菜单，是不是优雅得多呢？</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript使用对象必须知道的一件事</title>
      <link href="/2020/04/01/javascript-object-issue/"/>
      <url>/2020/04/01/javascript-object-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 中，对象即引用。</p><p>我们知道引用的特性：</p><p>将对象赋值给另一个变量，另一个变量的值如果改变，原对象的值也会改变。</p><p>引用即是内存地址的指向，将对象赋值给另一个变量，相当于另一个变量也指向了同一块内存地址，因此改变值时，原对象的值也会跟着变。通过下面的例子来了解一下引用的特性。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个json对象</span><br><span class="line">let json = &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">// 将json对象赋值给另一个变量</span><br><span class="line">let data = json;</span><br><span class="line">data.aa = &quot;no ok!&quot;;</span><br><span class="line">// 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>在控制面板上的输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们原本是希望把 json 变量的值赋值给另一个变量 data，本意是不希望修改 json 的值，但由于 JavaScript 中对象即引用的特性会导致原来的值发生改变。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用 <code>Object.assign(target, source)</code> 方法将 source 对象复制一份给 target 变量，类似 PHP 中的 clone，复制出来的变量会独立占据一片内存空间，而不是原对象的引用。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个json对象</span><br><span class="line">let json = &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">// 复制对象到data</span><br><span class="line">let data = &#123;&#125;;</span><br><span class="line">Obejct.assign(data, json);</span><br><span class="line">// 修改aa的值</span><br><span class="line">data.aa = &quot;no ok!&quot;;</span><br><span class="line">// 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;Im aa&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，原来的 json 对象的值没有改变。</p><p>在 TypeScript 中，不能直接使用 <code>Object.assign</code> 方法，而是要使用 <code>(&lt;any&gt;Object).assign</code>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个json对象</span><br><span class="line">let json = &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">// 复制对象到data</span><br><span class="line">let data = &#123;&#125;;</span><br><span class="line">(&lt;any&gt;Object).assign(data, json);</span><br></pre></td></tr></table></figure><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>由于 cocos creator 使用的是 JavaScript 和 TypeScript 开发，今天在制作游戏的事件系统，遇到一个神秘的 BUG，排查了好久一直没找到原因，突然想起来以前也遇到过同样的问题，为了涨点记性，特此记录。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux自定义别名——大幅提高工作效率！</title>
      <link href="/2020/03/31/linux-alias/"/>
      <url>/2020/03/31/linux-alias/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-系统命令"><a href="#Linux-系统命令" class="headerlink" title="Linux 系统命令"></a>Linux 系统命令</h2><p>在 <code>Linux</code> 系统中，诸如 <code>ls</code>、<code>top</code>、<code>ps</code> 此类为 <code>Linux</code> 系统内置的命令，我们希望通过自定义命令来作为某些复杂命令的组合，如自定义 <code>ll</code> 为 <code>ls -alF</code> 的简写，通过简写可以大幅缩短输入命令的时间，还可以避免输错命令，何乐而不为呢？</p><h2 id="自定义-Linux-命令-x2F-添加别名-Alias"><a href="#自定义-Linux-命令-x2F-添加别名-Alias" class="headerlink" title="自定义 Linux 命令 &#x2F; 添加别名 Alias"></a>自定义 Linux 命令 &#x2F; 添加别名 Alias</h2><p>自定义命令其实就是添加一个别名，执行如下命令创建别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure><p>在这个文件里输入需要创建的别名，例如 <code>ll</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br></pre></td></tr></table></figure><p>然后保存，再执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>现在，使用 <code>ll</code> 等价于输入 <code>ls -alF</code>。</p><p>可以将常用的命令组合简写，例如我们常用来查看进程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias psp=&#x27;ps -ef|grep&#x27;</span><br></pre></td></tr></table></figure><p>以后只需要输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 PHP 进程</span><br><span class="line">psp php</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">FireRabbitdeMacBook-Pro:~ firerabbit$ psp php</span><br><span class="line">  501 89356     1   0 二07下午 ??        29:02.94 /Applications/PhpStorm.app/Contents/MacOS/phpstorm</span><br><span class="line">  501 99412 99183   0  9:20下午 ttys005    0:00.00 grep php</span><br></pre></td></tr></table></figure><p>对于记不住命令的小金鱼们来说，利用好别名可以事半功倍哟！</p><h2 id="注意事项！"><a href="#注意事项！" class="headerlink" title="注意事项！"></a>注意事项！</h2><p>别名的使用只有定义者自己知道，因此不适合多人协作的工作。在日常的开发中（如在个人的 Mac），可以自定义一些常用的别名来提高自己工作的效率。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis添加密码验证</title>
      <link href="/2020/03/31/redis-add-permission/"/>
      <url>/2020/03/31/redis-add-permission/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要为-Redis-添加密码验证？"><a href="#为什么要为-Redis-添加密码验证？" class="headerlink" title="为什么要为 Redis 添加密码验证？"></a>为什么要为 Redis 添加密码验证？</h2><p>默认情况下，<code>redis</code> 不需要使用密码即可连接，而由于默认开放端口为 6379（用户一般不会去修改这个端口），导致基本信息完全暴露给试图攻击服务器者。</p><blockquote><p>IDCE.COM 建站之初未设置 redis 密码，结果被注入了挖矿病毒 %&gt;_&lt;%</p></blockquote><p>没有任何密码验证，意味着任何人都能访问到服务器的 Redis 服务，可能造成重要的信息泄露或者被访问者恶意删除造成严重后果！</p><p>总而言之，如果要使用 Redis 服务，那么最好为 <code>redis</code> 加上密码验证可以增加系统的安全性。</p><h2 id="开启-redis-密码验证"><a href="#开启-redis-密码验证" class="headerlink" title="开启 redis 密码验证"></a>开启 redis 密码验证</h2><p>以 <code>Linux</code> 系统为例，首先找到 <code>redis.conf</code> 配置文件，如果不知道文件在哪可以使用命令 <code>find / -name redis.conf</code> 找到。</p><p>添加 <code>requirepass</code> 字段，后面即你需要设置的密码，建议生成一个足够长的随机字符串来作为密码。</p><p><img src="https://i.loli.net/2019/08/29/l7msnYqtQeOiUNp.png" alt="image.png"></p><p>完成后保存，重启 <code>redis</code> 即可！</p><h2 id="Redis-cli-验证密码"><a href="#Redis-cli-验证密码" class="headerlink" title="Redis-cli 验证密码"></a>Redis-cli 验证密码</h2><p>在 <code>cli</code> 模式下，如果设置了密码需要验证之后才能执行 <code>redis</code> 操作，进入 <code>redis</code> 服务，然后执行 <code>auth 密码</code> 即可。</p><p><img src="https://i.loli.net/2019/08/29/VqJUpRx25HbELGA.png" alt="image.png"></p><h2 id="PHP-验证-Redis-密码"><a href="#PHP-验证-Redis-密码" class="headerlink" title="PHP 验证 Redis 密码"></a>PHP 验证 Redis 密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$redis = new Redis(); </span><br><span class="line">$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); //连接Redis</span><br><span class="line">$redis-&gt;auth(&#x27;123456&#x27;); //密码验证</span><br><span class="line">$redis-&gt;select(2);//选择数据库2</span><br><span class="line">$redis-&gt;set( &quot;testKey&quot; , &quot;Hello Redis&quot;); //设置测试key</span><br><span class="line">echo $redis-&gt;get(&quot;testKey&quot;);//输出value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker更换镜像源</title>
      <link href="/2020/03/31/docker-change-mirrors/"/>
      <url>/2020/03/31/docker-change-mirrors/</url>
      
        <content type="html"><![CDATA[<h2 id="国内镜像源"><a href="#国内镜像源" class="headerlink" title="国内镜像源"></a>国内镜像源</h2><h3 id="Docker-官方镜像中国区"><a href="#Docker-官方镜像中国区" class="headerlink" title="Docker 官方镜像中国区"></a>Docker 官方镜像中国区</h3><p><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></p><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>阿里的镜像异常麻烦，本着求真的角度，还是把这一部分补充了 %&gt;_&lt;%。</p><p>首先需要注册成为阿里开发者，前往：<a href="https://dev.aliyun.com/search.html">阿里云开发者中心</a>。</p><p>注册并登陆后，点击右上角的<strong>控制台</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141265-f297c080-ce39-11e9-92ca-1c89280fe717.png" alt="image"></p><p>想吐槽阿里云的界面设计，阿里云是一个超级聚合体……里面的服务实在太多，如果不写这样一个图文教程很难找到自己想要的功能，操作步骤如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141431-91242180-ce3a-11e9-87d2-6edc56597f8c.png" alt="image"></p><p>进入容器镜像服务，点击左侧菜单的<strong>镜像中心-镜像加速器</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141511-e5c79c80-ce3a-11e9-8fe4-037f95849052.png" alt="image"></p><p>根据阿里的提示操作即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://93m46zjd.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>这里的 <code>https://93m46zjd.mirror.aliyuncs.com</code> 是我的个人镜像源加速地址，建议自己申请一个。</p><h2 id="更换-Docker-镜像源"><a href="#更换-Docker-镜像源" class="headerlink" title="更换 Docker 镜像源"></a>更换 Docker 镜像源</h2><h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h3><p>Docker 使用 <code>daemon.json</code> 作为配置文件，如果没有的话则创建，编辑 <code>daemon.json</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加仓库地址（以中科大镜像源为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成并保存，重启 docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>作为一个学府，中科大还十分贴心的写了帮助文档：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">Docker 镜像使用帮助</a></p><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>Docker for Window 可以直接通过右键右下角小鲸鱼，选择 Settings，选择 Daemon 选项卡，在右下角的 Registry mirrors 添加对应的镜像源地址即可。</p><h3 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><p>如果你是下载了 Docker 桌面版的 Mac 系统用户，启动 Docker，选择右上角的小鲸鱼图标，选择菜单中的 <code>Preferences</code>：</p><p><img src="https://i.loli.net/2019/09/03/PeijKIqDGrZVgct.png" alt="image.png"></p><p>在选项卡中选择 Daemon，点击 <code>Registry mirrors</code> 下方的加号，输入需要添加的国内镜像源地址，完成后点击底部的 <code>Apply &amp; Restart</code> 应用配置并重启 Docker：</p><p><img src="https://user-images.githubusercontent.com/28209810/64140700-f4f91b00-ce37-11e9-8e02-e5c4d2b1682c.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统安装Pecl</title>
      <link href="/2020/03/31/mac-install-pecl/"/>
      <url>/2020/03/31/mac-install-pecl/</url>
      
        <content type="html"><![CDATA[<h2 id="PECL-简介"><a href="#PECL-简介" class="headerlink" title="PECL 简介"></a>PECL 简介</h2><p>PECL（The PHP Extension Community Library）是 PHP 扩展的存储库，为 PHP 所有的扩展提供提供托管和下载服务。</p><p>一些常用及优秀的 PHP 扩展均被收录在 PECL 中，如：yaf、swoole 等等，我们可以方便的使用 pecl 命令来安装这些扩展。</p><p>PECL 支持的扩展：<a href="http://pecl.php.net/">PECL All Packages</a></p><p>在 Mac 系统或 Linux 系统中可能没有默认安装 pear，因此无法使用 pecl 命令，本文将介绍如何安装 pear。</p><h2 id="PEAR-安装方法"><a href="#PEAR-安装方法" class="headerlink" title="PEAR 安装方法"></a>PEAR 安装方法</h2><p>官方文档：<a href="https://pear.php.net/manual/en/installation.getting.php">Getting and installing the PEAR package manager</a></p><h3 id="1、下载-PEAR"><a href="#1、下载-PEAR" class="headerlink" title="1、下载 PEAR"></a>1、下载 PEAR</h3><p>使用 curl 命令下载即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://pear.php.net/go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="2、-安装-PEAR"><a href="#2、-安装-PEAR" class="headerlink" title="2、 安装 PEAR"></a>2、 安装 PEAR</h3><p>下载完成后，执行下面命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo php -d detect_unicode=0 go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p>安装过程需要配置参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Below is a suggested file layout for your new PEAR installation.  To</span><br><span class="line">change individual locations, type the number in front of the</span><br><span class="line">directory.  Type &#x27;all&#x27; to change all of them or simply press Enter to</span><br><span class="line">accept these locations.</span><br><span class="line"></span><br><span class="line"> 1. Installation base ($prefix)                   : /usr</span><br><span class="line"> 2. Temporary directory for processing            : /tmp/pear/install</span><br><span class="line"> 3. Temporary directory for downloads             : /tmp/pear/install</span><br><span class="line"> 4. Binaries directory                            : /usr/bin</span><br><span class="line"> 5. PHP code directory ($php_dir)                 : /usr/share/pear</span><br><span class="line"> 6. Documentation directory                       : /usr/docs</span><br><span class="line"> 7. Data directory                                : /usr/data</span><br><span class="line"> 8. User-modifiable configuration files directory : /usr/cfg</span><br><span class="line"> 9. Public Web Files directory                    : /usr/www</span><br><span class="line">10. System manual pages directory                 : /usr/man</span><br><span class="line">11. Tests directory                               : /usr/tests</span><br><span class="line">12. Name of configuration file                    : /private/etc/pear.conf</span><br><span class="line"></span><br><span class="line">1-12, &#x27;all&#x27; or Enter to continue: </span><br></pre></td></tr></table></figure><p>修改安装时的根目录，输入 1，再输入 <code>/usr/local/pear</code>，回车；</p><p>修改命令的安装目录，输入 4，再输入 <code>/usr/local/bin</code>，回车；</p><p>其它选项使用默认即可，一路回车。</p><h3 id="4、测试是否安装成功"><a href="#4、测试是否安装成功" class="headerlink" title="4、测试是否安装成功"></a>4、测试是否安装成功</h3><p>输入命令 <code>pear version</code>，如果成功安装将会看到类似如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PEAR Version: 1.10.9</span><br><span class="line">PHP Version: 7.1.23</span><br><span class="line">Zend Engine Version: 3.1.0</span><br><span class="line">Running on: Darwin hongjiahuangdeMac-mini.local 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2/RELEASE_X86_64 x86_64</span><br></pre></td></tr></table></figure><p>接下来就可以使用 <code>pecl install &lt;扩展名称:版本号&gt;</code> 安装各种被 PECL 收录的扩展了。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis淘汰机制</title>
      <link href="/2020/03/31/redis-delete-policy/"/>
      <url>/2020/03/31/redis-delete-policy/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>redis 的配置文件为 <code>redis.conf</code>，当 redis 占用的内存达到配置的最大内存时，再使用 redis 增加新的值时会触发淘汰机制将占用的内存释放出来，以创建新的键值。</p><p>redis 允许占用的最大内存，约在 567 行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>找到 <code>maxmemory</code> 去掉前面的 <code>#</code> 井号， 将 <code>&lt;bytes&gt;</code>（单位：字节） 改为需要设置的最大内存值，一般而言，建议设置为服务器总内存的 50%~75%（需根据服务器情况确定），如果服务器其他进程占用较多内存的话，可以减少这个值。</p><p>当 redis 内存占用达到设置的最大值，触发的淘汰策略，约在 598 行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>去掉前面的 <code>#</code> 井号，后面即为淘汰的策略，淘汰策略有许多种，下面进行介绍。不过在此之前，我们可以理解一下 redis 如何淘汰掉键值。</p><p>我们通过给一个键值设置过期时间，来让它“自动过期”，但实际上，即使到了过期时间，这个键其实并没有立即被删除，而是当下次取这个键值的时候进行判断，如果这个键设置了过期时间，同时已经过了过期时间再进行删除，这是一种惰性的删除策略。</p><p>此外，除了这种被动删除的策略之外还有主动删除策略，例如定期扫描过期的键值，扫描也不可能将全部的键都扫秒一遍，而是通过某种随机算法获取某些键，判断键是否过期再决定是否删除。</p><p>为什么键设定了过期时间不能在到期后立即删除呢？因为从技术的角度上来考虑这是一件十分困难的事，如果要追踪一个键值的过期时间，可能需要启动一个进程来追踪并且在过期时“杀掉”这个键，这样使用 redis 的优势就全部没有了，反而要消耗更多的系统资源。</p><p>redis 过期的键太多而没有删除，会造成内存资源的浪费，反之，如果过于频繁的去检查过期的键，希望在第一时间释放出内存资源，频繁的检查也是十分耗费资源的事，因此两者之间必须存在一个平衡，这就需要依靠 redis 的淘汰策略。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>redis 有如下淘汰策略：</p><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧</p><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</p><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</p><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2020/03/31/redis-base/"/>
      <url>/2020/03/31/redis-base/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是由 ANSI C（标准C语言）写的键值对存储系统，由于是存储在内存中的，所以性能极高，但我们知道存储在内存中一旦电脑关闭就会丢失数据，Redis 还提供了数据持久化的功能，也就是说，Redis 的数据也可以保存在本地硬盘中。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>所谓原子操作指的是不可再分割的操作，要么都成功，要么都失败。</p><p>Redis 的操作结果一定是确定的，例如将商品库存存储在 Redis 中，此时由于高并发场景有 1000 个请求进入，判断减少库存，总库存为 999 个，那么第 1000 个请求会因为高并发的场景而判断失误吗？答案是不会。</p><p>同理，一些抽奖活动将奖品数量存储在 Redis 进行操作，不会出现奖品被人领光还能领到奖品的情况，当有面试官问你就这么告诉他。</p><p>以抽奖场景示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 读取数据库奖品余额</span><br><span class="line">$count = PrizeModel::getCount();</span><br><span class="line"></span><br><span class="line">// 判断是否还有可以领取的奖品</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    // 处理领奖逻辑，并且减少奖品数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，涉及到读后写的问题，在读取奖品余额后更新奖品数量，由于读写操作是分开的，可能因为请求的先后而产生不同结果；比如 A 进来领取奖品，奖品的库存是 1，此时 B 也进来领取奖品，这个时候他也判断了奖品库存是 1，这个时候奖品的数量只剩 1 个，却有两个人被判断为可以领取奖品，就出现奖品库存变为负数的情况。</p><p>导致问题的根本原因在于读操作与写操作是分离的，中间如果有其他的请求进来，那么读操作的结果就是不准确的，可以使用 Redis 的 <code>decr</code>（自减）来操作商品库存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis = new Redis();</span><br><span class="line">$count = $redis-&gt;decr(&#x27;prize&#x27;);</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    // 处理领奖逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 的 <code>decr</code> 命令将值减 1，并且返回了计算后的结果，实现了读写同步的操作，因此不会产生因为高并发场景读取了错误数据的情况。</p><p>这些都是依赖 Redis 的原子操作，之所以能够实现原子操作，是因为 <strong>Redis 是单线程</strong>。</p><p>假如对方问你，为什么单线程就是原子操作？</p><blockquote><p>扩展阅读：<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101">什么是线程</a></p></blockquote><p>操作系统调度任务以线程为基本单位，Redis 所有的指令都在一个线程中进行，不会扩展出额外的线程；多线程，比如 MySQL 启动的时候是一个进程，而执行增删改查操作就是一个新的线程。多线程指的是可以同时干很多件事，而单线程只能一件事一件事的干，做完一件事才做下一件事，从效率上来说多线程远远超出单线程，但单线程的优势是每一步的执行结果都是确定的，要么都成功，要么都失败。</p><p>实际上，Redis 虽然是单线程但效率也是非常高的，因为它完全基于内存操作。</p><h2 id="键"><a href="#键" class="headerlink" title="键"></a>键</h2><p>Redis 使用键值对的形式存储数据，键类似于变量名字，键是一个字符串，最大长度 512MB，与开发语言不同的是　Redis 中的键可以使用一些开发语言中不能作为命名的符合，如：冒号、横杠。</p><p>键名称太长，会占用更多的内存空间，此外，太长的键名也会多查找造成影响；名称太短，又会造成语义不清，所以在取键名的时候需要有规范。</p><p><strong>键的名称区分大小写</strong>，不建议大小写混用，要么全部大写，要么全部小写，取名“见名知意”为佳。</p><p>可以参考如下规则：</p><p>第一段为项目名称或者缩写形式（非必需），如：project 或 pro<br>第二段为表的名字，如：user<br>第三段为区分键的字段，如：MySQL 主键的列名，属性名<br>第四段为键的特征字段，可以作为查询依据，如：MySQL 中主键 ID 的值</p><p>键的各个字段通常用冒号隔开。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 根据 ID</span><br><span class="line">idce:users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">idce:users:name</span><br></pre></td></tr></table></figure><p>前缀增加项目名称的用途是：当一个 Redis 服务器部署了多个项目可以进行区分，如果是单个项目，则可以去掉项目名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">users:name</span><br></pre></td></tr></table></figure><p>在项目中，最好有一个统一管理键名称的地方，否则后期无法进行维护。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis 支持如下数据结构：</p><ul><li>String：字符串</li><li>Hash：哈希</li><li>List：列表</li><li>Set：集合</li><li>Sorted Set：有序集合</li></ul><h2 id="PHP-使用-Redis"><a href="#PHP-使用-Redis" class="headerlink" title="PHP 使用 Redis"></a>PHP 使用 Redis</h2><p>PHP 想要使用 Redis 需要安装 redis 相关的扩展：<a href="https://pecl.php.net/package/redis">PECL - REDIS 扩展下载</a>。</p><p>也可以不使用扩展，直接下载 predis：<a href="https://github.com/nrk/predis">Github - Predis 下载</a></p><p>将下载的包使用 <code>require</code> 命令引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./lib/predis-1.1/autoload.php&quot;;</span><br></pre></td></tr></table></figure><h2 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于其高性能的特性可以作为数据缓存，对于频繁查询但是不经常更新的数据可以将其缓存到 Redis 中，从而减少数据库查询压力，例如商品的库存、金额，需要注意的是当这些数据更新的时候也必须同步更新缓存数据。</p><p>此外，对于像微博的阅读量此类频繁更新的数据，也可以用缓存处理。方法是获取一条微博详情的时候，先判断是否有缓存，有的话先从缓存读取阅读量的数据，没有的话就从数据库读取，然后保存在 Redis 中；当用户访问时，直接在 Redis 操作访问量的增加，然后设置一个定时器程序，定期将缓存中的阅读量写入数据库，不过，这种类型的数据一般是比较不重要的，因为有可能会发生意外服务器重启导致数据丢失而没有正常写入数据库。</p><p>当某种数据需要频繁的查询或更新时可以使用 Redis 作为缓存。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>我们经常会收到亲朋好友要求帮忙给他们家的小盆友投票（一般是才艺表演之类的），根据点赞数进行排行，排在前几名的会有奖励之类的。排行榜的数据变化十分频繁，这个时候就可以使用 Redis 的有序集合结构来存储排行数据。</p><h3 id="分布式锁、本地锁"><a href="#分布式锁、本地锁" class="headerlink" title="分布式锁、本地锁"></a>分布式锁、本地锁</h3><p>Redis 中有一种命令 <code>setnx</code> 意为 <code>set if not exists</code>，即当不存在时设置数据，否则不进行操作，利用这种特性可以实现分布式锁。当成功设置的时候就执行后面的逻辑，如果未能成功设置代表之前已经执行过了，就不再走后面的逻辑。</p><p>锁的作用是防止重复动作，比如用户在点击领取奖励的时候，发现没有响应（网络延迟导致），结果用户以为自己没点下去就多点了几次，如果不做防止重复提交的处理，很有可能会造成领取到多次奖励的 BUG。</p><p>分布式就是多台机子间，而本地锁指的是本机，其原理类似，比如设置一个带有过期时间的 String 类型的缓存，如果这个键不为空则代表加过锁了。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中的列表结构由于读取头尾的速度非常快，因此适合作为消息队列的容器，将任务队列存储在 Redis 中可以大大提高程序的执行效率（与传统的数据库存储相比）。</p><h2 id="Redis-安全隐患"><a href="#Redis-安全隐患" class="headerlink" title="Redis 安全隐患"></a>Redis 安全隐患</h2><p>其中一个是未设置密码问题：<a href="https://idce.com/archive/PLlWREOZ?id=VDej">Redis 未设置密码导致服务器被安装挖矿病毒</a></p><p>此外，Redis 即使正常使用也可能存在安全隐患。</p><p>缓存分为过期缓存和不过期缓存，不过期缓存过多可能造成内存溢出，而过期缓存又可能带来新的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的是查询一个缓存中不存在的数据，比如我们设置了一个根据用户 ID 来获取用户信息的缓存，此时如果我们输入 -1 或者其他不存在的 ID，那么系统将会判断缓存不存在，接着就去数据库查询。</p><p>这种“绕过”缓存查询数据库的行为类似于直接穿透了 Redis。</p><p>如果有人利用了这一点编写程序大量查询不存在的用户 ID 就很可能造成数据库崩溃。</p><p>解决方法是即使不存在的用户 ID 也设置一个空的缓存的键值，不过此类键值需要设置一个较短的过期时间，否则也可能会被恶意查询造成内存溢出。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>雪崩指的是一种短期内产生的爆发性冲击，在 Redis 中，如果有许多缓存在同一时刻过期，就会造成大量的数据需要从数据库查询，面对冲击性涌入的查询，数据库很可能造成崩溃。</p><p>解决方法是尽可能的让缓存的过期时间不一样，热门数据的缓存时间更长一些，对于同类型的数据可以设置一个额外的随机时间来让同类型的数据也会在不同时刻过期。</p><p>除此之外，还可以设计多级缓存结构来防止缓存雪崩。</p><p>当第一层的缓存过期了，不从数据库读取，而是判断第二层缓存是否存在，如果有就直接取数据，如果没有再判断下一层缓存……以此类推。这样的结构称为多级缓存，多级缓存结构比较复杂，其中第一层缓存叫做一级缓存，第二层叫做二级缓存……多级缓存结构可以防止突发性的冲击造成数据库崩溃，不过这样系统的复杂性会变高，多级缓存需要有一个程序来定期维护下级缓存，一般由架构师进行设计。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿与缓存雪崩有些类似，不过不同的是缓存击穿指的是某个单一的键值过期，但是此时却有大量的流量涌入，造成所有的请求都直接到数据库那边，相当于在某个点凿出了一个洞，因此叫做“击穿”。</p><p>防止缓存击穿的方法：</p><p>方法（一）：后台增加一个定期任务刷新缓存的过期时间。</p><p>方法（二）：将缓存的过期时间也保存在值里面，当获取这个缓存数据的时候判断过期时间，在超过设置的阀值时更新这个缓存的过期时间。</p><p>方法（三）：可以使用缓存雪崩所说的多级缓存方法。</p><p>方法（四）：增加锁机制，当缓存过期查询数据库时，判断锁，只允许一个请求进来，其他请求都进入等待状态，进入的请求在查好数据后更新缓存，此时等待中的请求就可以获取到数据了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 还有许多应用，持续保持学习中……</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window环境下安装Docker的坑</title>
      <link href="/2020/03/31/window-install-docker-issue/"/>
      <url>/2020/03/31/window-install-docker-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近下载了 Docker for Window 搭建 Win10 系统的 PHP 环境，结果遇到了一大堆问题，网络上搜索答案极少，而且也很难找到能解决问题的方法，通过不断尝试和推测，踩了很多坑，也找到了填坑的办法，在此记录下来。</p><p>Docker for Window 下载地址：<a href="https://www.docker.com/products/docker-desktop">Docker 官方网站下载</a></p><h2 id="Docker-Hub-登录问题"><a href="#Docker-Hub-登录问题" class="headerlink" title="Docker Hub 登录问题"></a>Docker Hub 登录问题</h2><p>需要注册一个 Docker Hub 来进行登录，登录的帐号只能是 Docker ID，也就是注册时的用户名，而不是邮箱，此处需要注意，在使用 <code>docker login</code> 命令时经常会犯错而无法成功登录。</p><h2 id="Hyper-V-缺失问题"><a href="#Hyper-V-缺失问题" class="headerlink" title="Hyper-V 缺失问题"></a>Hyper-V 缺失问题</h2><p>Docker for Window 依赖 Hyper-V（微软的虚拟机系统），只有 Window 专业版才有这个功能，家庭版如果需要开启此功能就需要升级到专业版。</p><blockquote><p>查看电脑系统的方法：右键我的电脑，选择属性即可看到 Window 版本信息。</p></blockquote><p>家庭版也可以不升级，安装另一个 Docker 的产品——Docker Tool。</p><p>Docker Tool 不依赖 Hyper-V，而是 VirtualBox（也是一种虚拟机软件），如果安装了 Docker Tool，则会自动安装 VirtualBox。Docker Tool 的操作方法与 Docker for Window 不太一样，更复杂一些，虽然本人也尝试下载过，但是感觉十分不便，因此最后卸载了。（由于安装了 Docker Tool，这里又挖了一个新坑，后面进行介绍）</p><p>本人用的是 Win10 专业版系统，却发现没有 Hyper-V 这个选项，原来是因为下载了精简版的 ISO 作为装机镜像，一些装机系统那边下载的软件都是经过二次封装的，削减了一部分的功能，因此推荐用那些精简过的系统。</p><p>找了许多装机的 ISO 镜像，最后决定下载微软官方原版的 ISO 镜像（十分干净，不带第三方软件），然后重新安装了 Win10 专业版。</p><p>Window MSDN 镜像下载：<a href="https://msdn.itellyou.cn/">MSDN 我告诉你</a></p><p>选择左侧的系统，根据个人需求安装即可，不过据说对 Window 版本有一定的要求，太早的版本可能还是没有这个功能，建议至少 Win 8 以上(专业版)。</p><p>查看 Hyper-V 的方法是打开 <strong>控制面板</strong>，然后选择 <strong>程序</strong>，再选择 <strong>启用或关闭 Windows 功能</strong>。</p><p>重装后的系统已经可以看到 Hyper-V 这个选项了，如下图所示：</p><p><img src="https://i.loli.net/2019/10/20/uHBJOYP3Mtze6jc.png" alt="image.png"></p><p>勾选后选择确定，重新启动电脑。</p><h2 id="开启-Hyper-V-导致无法开机问题"><a href="#开启-Hyper-V-导致无法开机问题" class="headerlink" title="开启 Hyper-V 导致无法开机问题"></a>开启 Hyper-V 导致无法开机问题</h2><p>在开启 Hyper-V 的过程中，又遇到新的问题，如果将 Hyper-V 勾选起来点击确定，系统会安装软件然后提示重新启动，此时重新启动会导致电脑无法开机，一直在开始界面，并且提示“系统正在自动修复”。</p><p>只有进入到安全模式，将 Hyper-V 取消掉才能正常开机；又或者多次重启失败，系统自动恢复最后一次正确的配置。网上查了很多资料都没有找到解决方法，于是推测是因为相关的虚拟机服务没有启动导致的。</p><p>解决方法是进入服务管理，将 Hyper-V 的相关服务调整为“自动启动”，点击开始，选择运行（或者直接按 Win+R 快捷键），然后输入 <code>services.msc</code> 进入服务管理。</p><p><img src="https://i.loli.net/2019/10/20/75OeL1pd4x6QtzS.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/hkmugev9KtBzlZ3.png" alt="image.png"></p><p>然后打开 Hyper-V，再重启就可以了。</p><h2 id="Docker-命令被占用"><a href="#Docker-命令被占用" class="headerlink" title="Docker 命令被占用"></a>Docker 命令被占用</h2><p>在安装好了 Docker for Window 后，打开命令行使用 docker 命令，却提示如下的错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unable to resolve docker endpoint: open C:\Users\Administrator\.docker\machi....</span><br></pre></td></tr></table></figure><p>大致意思是找不到某个文件，而 <code>docker-machine</code> 是 Docker Tool 用到的东西，在翻找了许多资料后才发现原来是卸载时残留的环境变量导致的问题，Docker Tool 虽然卸载了，但是环境变量还在，这就导致了使用 docker 命令用的环境变量路径还是 Docker Tool 设置的路径，由于软件被卸载了，路径自然就找不到了。</p><p>解决方法是删掉残留的环境变量。</p><p>右键我的电脑，高级系统设置，环境变量。</p><p><img src="https://i.loli.net/2019/10/20/VLGM5XjYpJhZEeW.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/1HFzeVMgtSoLRb7.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/QYVrGO3k2M8By1D.png" alt="image.png"></p><p>然后在用户变量与系统变量中，找到 Docker 相关的变量全部删除，然后卸载掉 Docker for Window，重装一遍，即可解决（建议重启一次电脑）。</p><h2 id="磁盘共享"><a href="#磁盘共享" class="headerlink" title="磁盘共享"></a>磁盘共享</h2><p>Docker 恢复正常以后，本人使用的是自己封装的一套 docker-compose 系统，由于里面用到了容器卷，在 Window 系统中还存在磁盘共享问题。</p><p>在使用 <code>docker-compose up -d</code> 的时候遇到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot create container for service redis: b&#x27;Drive sharing failed for an unk...</span><br></pre></td></tr></table></figure><p>大致意思是说磁盘共享失败。</p><p>解决方法是打开 Docker for Window 的 Settings，右键右下角的小鲸鱼图标进入设置界面，在设置界面中选择 Shared Drives 选项卡，将需要共享的磁盘勾选起来，然后点击 Apply（应用）保存设置，这个过程可能需要输入 Window 系统的用户名和密码，如果没有设置密码则需要设置一个。</p><p><img src="https://i.loli.net/2019/10/20/RCuri4gzwynGNeH.png" alt="image.png"></p><h2 id="Docker-Compose-路径问题"><a href="#Docker-Compose-路径问题" class="headerlink" title="Docker-Compose 路径问题"></a>Docker-Compose 路径问题</h2><p>接着又遇到新的问题，执行 <code>docker-compose up -d</code> 弹出如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: for workspace_redis_1  Cannot start service redis: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;process_linux.go:430: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/etc/localtime\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27/merged/usr/share/zonStarting workspace_mysql_1 ... error </span><br></pre></td></tr></table></figure><p>这是由于我在 <code>docker-compose.yml</code> 文件中写了一个错误的路径，<code>/etc/localtime</code> 是 Linux 系统里面的路径，将它去掉就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">        build: redis/</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">          - ./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">          - ./var/logs/redis.log:/var/log/redis.log</span><br><span class="line">          - /etc/localtime:/etc/localtime</span><br><span class="line">        ports:</span><br><span class="line">          - &quot;6379:6379&quot;</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br></pre></td></tr></table></figure><p>去掉后就可以正常运行了。</p><h2 id="Vmware、Hyper-V-不兼容问题"><a href="#Vmware、Hyper-V-不兼容问题" class="headerlink" title="Vmware、Hyper-V 不兼容问题"></a>Vmware、Hyper-V 不兼容问题</h2><p>第一次因为 Hyper-V 缺失而无法安装时，曾经尝试过使用 Vmware 来安装虚拟机，想要在虚拟机里面装一个 MacOS 系统，结果也是一个大坑，默认情况下的 Vmware 不支持 MacOS，而需要安装一个补丁，结果折腾了半天也没搞定，MacOS 的镜像高达 7 个 G，还因为百度网盘暂停会导致重新开始……折腾得心累，于是放弃了。</p><p>Hyper-V 与 Vmware 是不兼容的，一山不容二虎，如果要使用其中的一种，需要卸载掉另外一种。否则可能会因为服务的问题导致软件不能正常启动。</p><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>在中途曾经放弃过安装 Docker 的念头，而是手动安装了 PHP、MySQL、Redis、Nginx 等环境，但是后面又发现许多 PHP 扩展在 Window 系统的安装都十分麻烦，比如 swoole 扩展还需要安装 cygwin，折腾的心累于是放弃了。</p><p>真是艰辛的过程~~~</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主键详解</title>
      <link href="/2020/03/31/mysql-primary-key/"/>
      <url>/2020/03/31/mysql-primary-key/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从书本上学到的 MySQL 主键知识十分有限，我们只是知道基础的理论。</p><p>在一次面试中，面试官提问：主键索引与普通索引有什么区别？</p><p>当场懵逼。</p><p>为了深入学习 MySQL 记录下此文。</p><h2 id="MySQL-主键（Primary-Key）"><a href="#MySQL-主键（Primary-Key）" class="headerlink" title="MySQL 主键（Primary Key）"></a>MySQL 主键（Primary Key）</h2><p>MySQL 中的键即某种约束，键具有索引的作用，通过约束条件可以使得数据更快的被查到。</p><p><strong>主键</strong> 是基本每张表都会用到的，一般类型为整型（integer、bigInteger）或者无符号整型（unsigned integer)并按照自然数的顺序自增。</p><p>主键是唯一的。</p><p>主键是一种索引，可以加快查询效率。</p><p>这是我们通常理解的主键，那么主键作为索引，又与普通索引有什么不同？为什么表需要主键？</p><h2 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h2><p>主键的字段名称一般设置为 ID，当这个 ID 与业务无关时，称为逻辑主键（即 ID 没有实际的意义），如果将用户名（name） 字段设置为主键，该字段是业务中会用到的字段，称为业务主键。</p><p>由于主键是业务中经常会用到的键，而业务又经常变更，因此不适合将业务字段作为主键，而是设置一个与业务毫无关系的（ID）字段作为主键。</p><p>如果将业务字段用来做主键，例如上面的例子中的 name，系统后台需要修改某个用户的 name 字段，意味着主键也跟着变更了。</p><p>如果存在以下场景：</p><p>用户个人空间的地址为：<code>http://domain.com/:name</code>，<code>:name</code> 是用户名（即数据库中的 name 字段）。</p><p>主键一旦变更，某些页面如个人空间也会跟着变更，假如我收藏了某个用户的空间到浏览器：<code>http://domain.com/user/xiaoming</code>，结果因为用户改名为：xiaohong，这个用户的空间地址就变成了：<code>http://domain.com/user/xiaohong</code>，那我收藏的地址就 404 了，除了这方面的原因，由于可以随意修改主键，也就导致你改了主键的值，其他人又改成之前用过的主键，会产生许多问题，如果某个人又将 xiaogang 的名字改成 xiaoming，那我收藏的地址就会变成原名为 xiaogang 的个人空间，业务变得十分混乱。</p><p>主键通常是不能变更的值，因此建议设置一个与业务毫无关系的字段作为主键的值，之所以要用整型是因为查询效率比字符串更高、所需空间更小，可以使用自增自动生成唯一的值。</p><p>其他类型如字符串作为主键，由于在插入数据时需要生成唯一字符串，同时还需要判断是否已存在该值，故在插入数据的时候效率也会降低。</p><p>除了将单个字段设置为主键，也可以将多个字段绑定在一起作为联合主键（也称复合主键）。</p><p>主键设计原则：</p><ul><li>主键的值 <strong>应该</strong> 无法被修改</li><li>主键的值 <strong>不应该</strong> 与业务有关</li><li>主键的值 <strong>建议</strong> 使用系统自动生成（如自增整型）</li><li><strong>建议</strong> 使用单个字段作为主键</li><li>每张表都 <strong>建议</strong> 设置主键</li></ul><h2 id="为什么表需要主键"><a href="#为什么表需要主键" class="headerlink" title="为什么表需要主键"></a>为什么表需要主键</h2><p>想一下如果没有主键，需要删改查除某条数据的时候会有多麻烦：“帮我删掉 name 为 xiaohong 的那条数据”，而 name 属性又没有设置唯一键，存在很多条同名数据，到底是删除哪条？</p><p>而当我们设置了 ID 作为主键，那我们就可以说：“删除 ID 为 6 的数据”、“帮我把 ID 为 6 的 name 字段改成 xiaohong”。</p><p>主键的其中一个作用即指向该行的数据，<strong>键具有约束作用</strong>，主键约束可以令数据具有唯一性，设置身份证为主键，那么这个主键就决定了一个人的个人资料，从千千万万个人当中，可以用身份证来指代唯一的一个人。</p><p>此外，主键索引可以提升查询效率，将一个字段设置为主键时，便会创建主键索引。</p><p>（下文介绍主键索引与普通索引区别）</p><h2 id="MySQL-主键与唯一键（Unique-Key）的区别"><a href="#MySQL-主键与唯一键（Unique-Key）的区别" class="headerlink" title="MySQL 主键与唯一键（Unique Key）的区别"></a>MySQL 主键与唯一键（Unique Key）的区别</h2><p>主键字段的值是唯一的，唯一键也要求字段值唯一，这两者的区别在于唯一键的值可以为 NULL，并且可以存在重复的 NULL 数据。</p><p>梳理如下：</p><p>唯一键的值 <strong>可以为空</strong>，且不能存在除空值以外重复的值。</p><p>主键的值必须 <strong>不为空</strong> 且不存在重复。</p><p>每张表中 <strong>只能</strong> 存在一个主键，可以存在 <strong>多个</strong> 唯一键。</p><p>从存在意义上来说，主键的作用是指代这一行的数据（如身份证代表一个人），而唯一键只是一种约束作用，用来约束这个字段在这张表不能存在相同值（如限制用户手机号码只能注册一个账号）。</p><h2 id="主键索引与普通索引（Normal-Index）的区别"><a href="#主键索引与普通索引（Normal-Index）的区别" class="headerlink" title="主键索引与普通索引（Normal Index）的区别"></a>主键索引与普通索引（Normal Index）的区别</h2><blockquote><p>扩展阅读：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p></blockquote><p>普通索引的作用只是加快查询效率，并且可以存在重复的值，而主键索引的值是唯一的，它也可以提高查询效率，普通索引的值可以为 NULL，查询一个存在 NULL 的普通索引会导致查询效率提升的作用失效，当一个列设置了索引，同时也应当将其设置为 NOT NULL。</p><p>主键索引与普通索引的结构也不同。</p><h3 id="聚簇索引和非聚簇索引（二级索引）"><a href="#聚簇索引和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引和非聚簇索引（二级索引）"></a>聚簇索引和非聚簇索引（二级索引）</h3><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</li></ul><p>Innodb 存储引擎中，数据表 table 由 table.frm、table.idb 组成。table.frm 保存表结构的定义，table.idb 保存的是数据和索引，这样的结构称为聚簇索引。</p><p>Myisam 存储引擎中，数据表 table 由 table.frm、table.myi、table.myd 组成。table.frm 保存表结构的定义，table.myi 保存索引，table.myd 保存数据。在用到索引时，先到 table.myi(索引树)中进行查找，取到数据所在 table.myd 的行位置，拿到数据。所以 Myisam 引擎的索引文件和数据文件是独立分开的，称之为非聚簇索引。</p><p>聚簇索引是按照数据存放的物理位置为顺序的，聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索更快。</p><p>在 Innodb 中，主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>在表结构中只存在一个聚簇索引（主键索引），除此之外都是非聚簇索引（普通索引）。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一种特殊情况可以不通过聚簇索引查询数据，那就是通过创建联合索引（多个字段作为索引），如果查询的数据在索引中可以直接获取到，那就不需要再到数据行进行查询了。</p><p>例如创建索引：idx_name_email</p><p>name 字段 和 email 字段是联合索引，当我们使用如下语句查询时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name where email = &quot;xxx@idce.com&quot;</span><br></pre></td></tr></table></figure><p>通过 email 来查询 name，由于它们是一组联合索引，因此可以直接从索引中拿到对应的数据。</p><p>覆盖索引查询数据只需要从索引中获得，而不需要到数据表中获取，因此可以极大的提高查询效率。</p><p>之所以能够从索引中得到数据，是因为索引的结构中保存了对应字段的值。</p><p>容易混淆的一个地方：上面介绍的聚簇索引才能保存数据，那为什么普通索引也能保存数据？</p><p>其实这里指的是表的数据，通过聚簇索引找到的数据是直接找到表对应行的一整行数据，而索引保存的数据是这个字段的值，因此可以通过索引得到对应字段的值。</p><p>面试官曾经问我的问题：索引会保存字段的值吗？</p><p>当时觉得不会，应该是保存对应行的所在地址才对。但其实是会保存的，因为只有保存了这个数据，查询索引字段才能快速进行数据对比从而筛选数据，如果能不回到表查询，则不回到表查询，回到表查询的效率比直接从索引拿数据低得多。</p><p>索引的结构，一侧是字段的值，另一侧是下一个数据的地址：</p><p><img src="https://i.loli.net/2019/11/26/hArR2ISmwPLzNCy.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx SSL证书配置问题</title>
      <link href="/2020/03/31/nginx-ssl-issue/"/>
      <url>/2020/03/31/nginx-ssl-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="SSL-问题"><a href="#SSL-问题" class="headerlink" title="SSL 问题"></a>SSL 问题</h2><p>Nginx 重启时，报错信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in /etc/nginx/conf.d/xxx.conf:57</span><br></pre></td></tr></table></figure><p>通常我们会在 server 有如下 Nginx 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssl on;</span><br><span class="line">ssl_certificate   /etc/nginx/ssl/xxx.com.pem;</span><br><span class="line">ssl_certificate_key /etc/nginx/ssl/xxx.com.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure><p>访问网页提示错误代码 <code>ERR_SSL_PROTOCOL_ERROR</code>。</p><p><img src="https://i.loli.net/2019/12/05/R3GCLPZ8tsbpzS2.png" alt="image.png"></p><p>原因在于 Nginx 升级到 1.15 版之后，SSL 的配置不再使用 <code>ssl on</code>，把这一句去掉就可以。</p><p>这时再执行：<code>nginx -s reload</code> 平滑重启 Nginx 就不会报错了。</p><h2 id="CURL-无法正常访问"><a href="#CURL-无法正常访问" class="headerlink" title="CURL 无法正常访问"></a>CURL 无法正常访问</h2><p>按照上面的步骤重启 Nginx 后，使用 curl 尝试连接到网站，结果依然报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (35) SSL received a record that exceeded the maximum permissible length.</span><br></pre></td></tr></table></figure><p>这其实也是升级后配置发生了变化，第一个步骤的提示信息已经给与了提示：<code>use the &quot;listen ... ssl&quot;</code>，再次编辑 <code>xxx.conf</code>，将 <code>listen 443</code> 修改为：<code>listen 443 ssl</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  idce.com;</span><br><span class="line">    // ...此处省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存，然后再执行重启，OK！</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHPStorm逼死强迫症患者解决方法</title>
      <link href="/2020/03/31/phpstorm-no-ext-tip-issue/"/>
      <url>/2020/03/31/phpstorm-no-ext-tip-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h2><p>在使用 JSON 函数的时候，会报如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext-json missing in composer.json</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/26/sYow5WKkvbRdXOV.png" alt="image.png"></p><p>花花绿绿看得猛男落泪，简直要逼死强迫症啊！</p><p>原因可能是因为使用了 Docker 或者其他的环境，由于扩展是安装在虚拟机上就导致本机无法正确识别 PHP 的扩展，并不是本机上没有安装这个扩展，代码没有问题也不会报错，就是看得难受。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>所幸，这里提供了两种方法可以根治此问题。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>针对缺失的扩展，在 <code>composer.json</code> 文件的 <code>require</code> 字段进行添加。</p><p>例如：<code>&quot;ext-json&quot;: &quot;*&quot;</code>：</p><p><img src="https://i.loli.net/2019/11/26/IH3GgJQB4XWpz8y.png" alt="image.png"></p><p>如果没有 <code>composer.json</code> 文件，在项目根目录下自行创建一个即可。</p><p>这种方法针对特定的扩展，除了 JSON 扩展，常见的还有 CURL 扩展也无法正常识别，用相同的方法即可解决，扩展不多的时候可以用这种方法，要是使用了诸多第三方扩展而 PHPStorm 无法识别，可以参考下面的方案二一次性解决问题。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>关闭 PHPStorm 缺失扩展提示。</p><p>打开左上角 <code>File-&gt;Settings</code> 搜 PHP，然后找到下方一行的 <code>Inspections</code>，在右侧搜索 <code>extension</code>，找到 <code>Extension is mission in composer.json</code> 取消勾选保存即可，见下图：</p><p><img src="https://i.loli.net/2019/11/26/bB9RVYwCf6DtmGL.png" alt="image.png"></p><p>以上方法任选一种即可。</p><p><img src="https://i.loli.net/2019/11/26/UZdEPz9Hg5MkXyt.png" alt="image.png"></p><p>猛的一顿操作之后——舒服多了！！</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-CLI 常用命令参数</title>
      <link href="/2020/03/15/php-cli-arguments/"/>
      <url>/2020/03/15/php-cli-arguments/</url>
      
        <content type="html"><![CDATA[<h2 id="运行-PHP-文件"><a href="#运行-PHP-文件" class="headerlink" title="运行 PHP 文件"></a>运行 PHP 文件</h2><p>可以直接使用 <code>php &lt;文件路径&gt;</code> 执行 PHP 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php /var/www/html/project/index.php;</span><br></pre></td></tr></table></figure><h2 id="进入命令行模式"><a href="#进入命令行模式" class="headerlink" title="进入命令行模式"></a>进入命令行模式</h2><p>使用命令 <code>php -a</code> 可以进入命令行模式，在这里可以直接运行 PHP 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; echo &quot;hello world&quot;;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="加载指定配置文件"><a href="#加载指定配置文件" class="headerlink" title="加载指定配置文件"></a>加载指定配置文件</h2><p>使用 <code>php -c</code> 可以加载指定的配置文件 <code>php.ini</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c /test/my_php.ini</span><br></pre></td></tr></table></figure><h2 id="显示当前配置文件路径"><a href="#显示当前配置文件路径" class="headerlink" title="显示当前配置文件路径"></a>显示当前配置文件路径</h2><p>使用命令 <code>php --ini</code> 查看当前加载的配置文件路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php --ini</span><br><span class="line">Configuration File (php.ini) Path: /usr/local/etc/php</span><br><span class="line">Loaded Configuration File:         /usr/local/etc/php/php.ini</span><br><span class="line">Scan for additional .ini files in: /usr/local/etc/php/conf.d</span><br><span class="line">Additional .ini files parsed:      /usr/local/etc/php/conf.d/docker-php-ext-bcmath.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-gd.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-gmp.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-opcache.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-redis.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-sockets.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-sodium.ini,</span><br><span class="line">/usr/local/etc/php/conf.d/docker-php-ext-swoole.ini</span><br></pre></td></tr></table></figure><h2 id="启动一个-WebServer"><a href="#启动一个-WebServer" class="headerlink" title="启动一个 WebServer"></a>启动一个 WebServer</h2><p>Web Server（网页服务）一般是由 Apache、Nginx 或是 Windows 系统的 IIS 提供。</p><p>从 <code>PHP 5.4.0</code> 起，也可以使用 cli 模式来启动 PHP 内置的 Web Server。</p><blockquote><p>这个内置的 Web 服务器主要用于本地开发使用，不可用于线上产品环境。</p></blockquote><p>使用命令 <code>php -S localhost:&lt;端口号&gt; [文件路径]</code> 来启动一个 WebServer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -S localhost:999</span><br><span class="line">[Sun Mar 15 04:25:52 2020] PHP 7.4.1 Development Server (http://localhost:999) started</span><br></pre></td></tr></table></figure><blockquote><p>localhost 等价于 127.0.0.1</p></blockquote><p>启动 PHP WebServer 时可以指定一个文件作为启动脚本（如框架的入口文件），在该文件注册所需要的插件及分发路由等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 test.php</span><br></pre></td></tr></table></figure><p>命令添加 <code>-t</code> 参数，将会以目录作为 WebServer 的启动目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 -t public/</span><br></pre></td></tr></table></figure><p>关掉命令行窗口或者按 <code>Ctrl + C</code> 即可退出 PHP WebServer。</p><h2 id="PHP-版本号"><a href="#PHP-版本号" class="headerlink" title="PHP 版本号"></a>PHP 版本号</h2><p>使用 <code>php -v</code> 命令可以查看 PHP 版本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -v</span><br><span class="line">PHP 7.4.1 (cli) (built: Dec 28 2019 20:56:41) ( NTS )</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br><span class="line">    with Zend OPcache v7.4.1, Copyright (c), by Zend Technologies</span><br></pre></td></tr></table></figure><h2 id="PHP-扩展"><a href="#PHP-扩展" class="headerlink" title="PHP 扩展"></a>PHP 扩展</h2><p>使用 <code>php -m</code> 命令可以查看 PHP 安装的扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -m</span><br><span class="line">[PHP Modules]</span><br><span class="line">bcmath</span><br><span class="line">Core</span><br><span class="line">ctype</span><br><span class="line">curl</span><br><span class="line">date</span><br><span class="line">dom</span><br><span class="line">fileinfo</span><br><span class="line">filter</span><br><span class="line">ftp</span><br><span class="line">gd</span><br></pre></td></tr></table></figure><h2 id="PHP-参数"><a href="#PHP-参数" class="headerlink" title="PHP 参数"></a>PHP 参数</h2><p>使用 <code>php -i</code> 命令可以查看 PHP &#x2F; 扩展的配置参数，等价于 <code>phpinfo</code>。</p><h2 id="语法查错"><a href="#语法查错" class="headerlink" title="语法查错"></a>语法查错</h2><p>可以用 <code>php -l &lt;文件路径&gt;</code> 来检测该 php 文件是否有语法错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -l index.php</span><br><span class="line">No syntax errors detected in index.php</span><br></pre></td></tr></table></figure><h2 id="执行一段代码"><a href="#执行一段代码" class="headerlink" title="执行一段代码"></a>执行一段代码</h2><p>使用 <code>php -r &quot;代码&quot;</code> 来执行一段 PHP 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php -r &quot;echo &#x27;ok&#x27;;&quot;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="查看扩展详情"><a href="#查看扩展详情" class="headerlink" title="查看扩展详情"></a>查看扩展详情</h2><p>使用命令 <code>php --ri &lt;扩展名称&gt;</code> 获取扩展配置详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php --ri swoole</span><br><span class="line"></span><br><span class="line">swoole</span><br><span class="line"></span><br><span class="line">Swoole =&gt; enabled</span><br><span class="line">Author =&gt; Swoole Team &lt;team@swoole.com&gt;</span><br><span class="line">Version =&gt; 4.4.14</span><br><span class="line">Built =&gt; Jan  6 2020 07:22:54</span><br><span class="line">coroutine =&gt; enabled</span><br><span class="line">epoll =&gt; enabled</span><br><span class="line">eventfd =&gt; enabled</span><br><span class="line">signalfd =&gt; enabled</span><br><span class="line">cpu_affinity =&gt; enabled</span><br><span class="line">spinlock =&gt; enabled</span><br><span class="line">rwlock =&gt; enabled</span><br><span class="line">openssl =&gt; OpenSSL 1.1.1d  10 Sep 2019</span><br><span class="line">http2 =&gt; enabled</span><br><span class="line">zlib =&gt; 1.2.11</span><br><span class="line">mutex_timedlock =&gt; enabled</span><br><span class="line">pthread_barrier =&gt; enabled</span><br><span class="line">futex =&gt; enabled</span><br><span class="line">mysqlnd =&gt; enabled</span><br><span class="line">async_redis =&gt; enabled</span><br><span class="line"></span><br><span class="line">Directive =&gt; Local Value =&gt; Master Value</span><br><span class="line">swoole.enable_coroutine =&gt; On =&gt; On</span><br><span class="line">swoole.enable_library =&gt; On =&gt; On</span><br><span class="line">swoole.enable_preemptive_scheduler =&gt; Off =&gt; Off</span><br><span class="line">swoole.display_errors =&gt; On =&gt; On</span><br><span class="line">swoole.use_shortname =&gt; On =&gt; On</span><br><span class="line">swoole.unixsock_buffer_size =&gt; 8388608 =&gt; 8388608</span><br></pre></td></tr></table></figure><h2 id="查看扩展提供的方法"><a href="#查看扩展提供的方法" class="headerlink" title="查看扩展提供的方法"></a>查看扩展提供的方法</h2><p>使用命令 <code>php --re &lt;扩展名称&gt;</code> 获取扩展的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php --re swoole</span><br></pre></td></tr></table></figure><h2 id="获取函数详情"><a href="#获取函数详情" class="headerlink" title="获取函数详情"></a>获取函数详情</h2><p>使用命令 <code>php --rf &lt;函数名称&gt;</code> 获取函数详情，可以用来检测函数是否存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:/var/www/html# php --rf array_columns</span><br><span class="line">Exception: Function array_columns() does not exist</span><br><span class="line">root@0139eebfa774:/var/www/html# php --rf array_column</span><br><span class="line">Function [ &lt;internal:standard&gt; function array_column ] &#123;</span><br><span class="line"></span><br><span class="line"> - Parameters [3] &#123;</span><br><span class="line">    Parameter #0 [ &lt;required&gt; $arg ]</span><br><span class="line">    Parameter #1 [ &lt;required&gt; $column_key ]</span><br><span class="line">    Parameter #2 [ &lt;optional&gt; $index_key ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trait - 优雅的复用方法</title>
      <link href="/2020/03/15/trait/"/>
      <url>/2020/03/15/trait/</url>
      
        <content type="html"><![CDATA[<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>为了解决单继承问题，从 PHP 5.4 开始新增了 <code>trait</code> 关键字来实现代码的复用。<code>trait</code> 定义的代码块在类的内部引入，类就能获得由 <code>trait</code> 定义的属性及方法。</p><p>通过定义一个 <code>SingletonTrait</code>，来实现单例模式的类共用代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trait SingletonTrait</span><br><span class="line">&#123;</span><br><span class="line">    protected static $instance = null;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() &#123;</span><br><span class="line">        if (null === self::$instance) &#123;</span><br><span class="line">            self::$instance = new static();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要引用 <code>Trait</code> 十分简单，只要在类的内部使用 <code>use</code> 关键字即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SomeService</span><br><span class="line">&#123;</span><br><span class="line">    use SingletonTrait;</span><br><span class="line"></span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;ok!&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$service = SomeService::getInstance();</span><br><span class="line">$service-&gt;test();</span><br></pre></td></tr></table></figure><p>通过引用 <code>SingletonTrait</code> 代码块 <code>SomeService</code> 直接获得了 <code>trait</code> 定义的方法及属性，通过 <code>trait</code> 引用实现复用单例模式方法，而不是直接复制粘贴同样的代码到每个单例的类中，让代码变得更加优雅！</p><blockquote><p>Trait 的实现原理是简单的把代码块拷贝到类</p></blockquote><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在类的继承关系中，如果父类的属性或方法使用了 <code>private</code> 声明，子类是无法调用的，但是在 Trait 中不同，因为 Trait 相当于把代码引入到类里面，也就是变成了类的一部分，因此当 Trait 声明了私有属性或方法，在类的内部是可以直接使用的。</p><p>Trait 定义的代码块同样可以使用 <code>static</code>、<code>abstract</code> 等修饰符。</p><h2 id="多个-Trait"><a href="#多个-Trait" class="headerlink" title="多个 Trait"></a>多个 Trait</h2><p>一个类可以引用多个 Trait，中间使用逗号隔开。</p><p>当引入的多个 Trait 里面存在同名方法时，需要通过两种方式来解决冲突，否则会报出致命异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Fatal error:  Trait method xxx has not been applied, because there are collisions with other trait methods on Test in xxx</span><br></pre></td></tr></table></figure><h3 id="insteadof"><a href="#insteadof" class="headerlink" title="insteadof"></a>insteadof</h3><p>使用 <code>insteadof</code> 关键字来让其中一个 Trait 的方法覆盖另一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;A:hello&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;A:world&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;B:hello&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;B:world&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A,B &#123;</span><br><span class="line">        // 使用 A trait 中的 hello 覆盖 B 的 hello</span><br><span class="line">        A:: hello insteadof B;</span><br><span class="line">        // 使用 B trait 中的 world 覆盖 A 的 world</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:hello</span><br><span class="line">B:world</span><br></pre></td></tr></table></figure><h3 id="as-方法重命名"><a href="#as-方法重命名" class="headerlink" title="as 方法重命名"></a>as 方法重命名</h3><p>如果需要保留两者的方法，可以使用 <code>as</code> 重命名，然后再用另一个的方法进行覆盖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;A:hello&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;A:world&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;B:hello&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;B:world&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A, B &#123;</span><br><span class="line">        // 将 A trait 中的方法重命名</span><br><span class="line">        A::hello as ahello;</span><br><span class="line">        A::world as aworld;</span><br><span class="line">        // 再使用 insteadof 关键字覆盖冲突的方法</span><br><span class="line">        B:: hello insteadof A;</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br><span class="line">$test-&gt;ahello();</span><br><span class="line">$test-&gt;aworld();</span><br></pre></td></tr></table></figure><p>注意，即使重命名了也需要使用 <code>insteadof</code> 覆盖原来的代码，不然同样会产生致命报错。</p><h2 id="Trait-嵌套"><a href="#Trait-嵌套" class="headerlink" title="Trait 嵌套"></a>Trait 嵌套</h2><p>Trait 里面也可以引用其他 Trait。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当 Trait 中定义的方法或属性与类或其父类相同时，其优先级如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类 &gt; trait &gt; 父类</span><br></pre></td></tr></table></figure><h2 id="Trait-的意义"><a href="#Trait-的意义" class="headerlink" title="Trait 的意义"></a>Trait 的意义</h2><p>Trait 能实现代码块的复用，但是继承（extends）、实现（implements）同样可以复用父类的方法或实现接口的方法，它们之间有什么区别呢？</p><p>我们知道面向对象编程里代码的关联性十分重要，例如继承关系即把子类的属性和方法进行了抽象，接口同样是把相同的东西抽象出来，然后在子类进行实现，这样有时候我们遇到像“水陆两栖动物”这种特殊的类型，既要让它继承水生动物的特性，又要让它继承陆生动物的特性，而 PHP 不支持多继承，要实现这种效果会变得十分麻烦。</p><p>而 Trait 定义的代码块，并没有严格意义上的关联性，仅仅只是为了复用代码块而被设计。Trait 的作用更像是一个功能块，不论是谁，只要让其他的类“嵌入”这个功能块就能让它具有对应的效果。</p><p>就好比 LOL 里的提莫，你可以出帽子、法穿棒等纯粹的 AP 装让它变成 AP 提莫，也可以出纳什之牙、飓风让提莫变成一个普攻型的 APC（远程输出单位），Trait 的作用类似于装备效果，任何人都可以出这件装备，只要装备了就能得到对应的能力。</p><p>在 Laravel 框架里，要实现“软删除”功能十分简单，只需要在数据库迁移中添加字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(&#x27;orders&#x27;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;bigIncrements(&#x27;id&#x27;);</span><br><span class="line">            // .. 省略其他字段</span><br><span class="line">            $table-&gt;softDeletes();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>然后在 Model 里直接引入 Trait：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line">use Illuminate\Database\Eloquent\SoftDeletes;</span><br><span class="line"></span><br><span class="line">class Order extends Model</span><br><span class="line">&#123;</span><br><span class="line">    use SoftDeletes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可让一个模型具有软删除的功能。</p><p>Laravel 还有许多地方存在此类的应用，通过这样的设计让代码更加优雅！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>凡是在开发过程中，只要意识到自己通过 Ctrl+C、Ctrl+V 复制了同一份的代码，就表明这个地方写的不够好，一定存在优化的空间。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2020/03/14/mini-server/"/>
      <url>/2020/03/14/mini-server/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微服务是一种服务架构模式，目标是架构师的话，当然不能放过这个知识点。</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>一般的项目架构有两种形式：单体应用和微服务。</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>单体应用就是用一套代码实现全部功能。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务就是把单体应用的代码按照功能拆分出来，形成多套独立的代码，通过某种方式让它们连接在一起，实现完整功能。</p><p>单体应用好比早期的网站开发，用 PHP 搭建的网站：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php echo &quot;hello world!&quot; ?&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>HTML 代码与 PHP 代码混合在一起。</p><p>而随着技术的发展，又推出了 MVC 模式，实现模型、视图、控制器的分离。</p><p>然而问题的本质依然没有改变，还不是要一个人去完成同样的工作？</p><p>技术从未停下发展的脚本，职业的分工越来越明确，开始出现专门写 HTML 和 JavaScript 的前端人员和专门写 PHP 代码的后端人员，前端人员通过一项技术“Ajax”调用后端人员写的接口，使他们看似分离但却紧紧的联系到一起，共同实现一个完整的项目。</p><p>这样的分工方式就叫做微服务。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>比如有一套系统，包括如下业务：</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3518914240,1325113277&fm=26&gp=0.jpg" alt="微服务架构"></p><p>把这些业务拆分出来，单独做成一套系统，然后以某种方式让独立的项目之前能够进行通信，这就完成了一套微服务架构。</p><h2 id="微服务通信模式"><a href="#微服务通信模式" class="headerlink" title="微服务通信模式"></a>微服务通信模式</h2><h3 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h3><h3 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h2 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h2><p>优点</p><ul><li>大型项目解耦，提高整体性能</li><li>每个服务都很小，开发人员可以聚焦自己负责的功能模块。</li><li>只需要极少的人来维护一套代码</li><li>可以用不同的语言开发</li></ul><p>缺点</p><ul><li>架构需要花费一定的精力，如果架构得不好，后期反而会变成麻烦</li><li>由于服务分散成很多个，因此难以快速定位错误</li><li>管理成本提高</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-FPM</title>
      <link href="/2020/03/14/php-fpm/"/>
      <url>/2020/03/14/php-fpm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学 PHP 的时候，搜索网上教程一顿操作配置了 LNMP（Linux + Nginx + MySQL + PHP）环境，在配置 Nginx 的时候听说了 PHP-FPM，然而却没有进行深究，只知道让 Nginx 转发就完事了。</p><p>为了进一步的学习 PHP，需要了解 PHP-FPM 是什么。</p><h2 id="CGI-通用网关接口"><a href="#CGI-通用网关接口" class="headerlink" title="CGI 通用网关接口"></a>CGI 通用网关接口</h2><p>通用网关接口（Common Gateway Interface，CGI）是一个为用户和 WEB 服务（如 Nginx）与其他应用（如 PHP）提供交互的程序。</p><p>早期的 WEB 应用只处理静态的页面，用户访问站点只要请求指定的 <code>.htm</code> 或 <code>.html</code> 文件，静态文件可以直接输出给浏览器，所以 Nginx 不需要做额外的处理。</p><p>随着互联网的发展，只有静态的页面已经不能满足人们的需求了。</p><p>Nginx 本身不处理文件，只是分发请求，比如用户请求 <code>/index.html</code>，它会去服务器寻找这个文件，找到了就输出给浏览器，没找到就返回 404。这里分发的是静态数据，但如果用户请求的是 <code>/index.php</code>，这是一个 PHP 文件，不能像 <code>.html</code> 文件一样直接返回给浏览器。</p><p>这个时候就犯难了，Nginx 应该如何处理非静态的文件呢？</p><p>为了解决如何处理非静态文件的问题，CGI 诞生了。</p><p>CGI 做的事情就是解析用户的请求，然后将请求的结果解析成 HTML 返回给浏览器，开发者可以使用任何语言处理 Web Server 发来的请求，生成动态的内容。</p><p>上面的例子，用户访问 <code>/index.php</code> 文件，由于 Nginx 无法处理这种格式的文件，于是将请求（包括参数等等）转发给 CGI 程序（可理解为语言解释器）进行处理，这里的 CGI 就是 PHP-CGI，PHP-CGI 可以解析 PHP 文件，<code>index.php</code> 文件在 PHP-CGI 程序进行解析和处理后才会输出给浏览器。</p><p><code>index.php</code> 文件就交给 PHP 程序去处理，<code>.jsp</code> 文件就让 Java 去处理，每种动态语言都有对应的 CGI，Nginx 只需要将请求转发给 CGI 就可以了，再通过 CGI 输出数据给浏览器。</p><h2 id="FastCGI-快速网关接口"><a href="#FastCGI-快速网关接口" class="headerlink" title="FastCGI 快速网关接口"></a>FastCGI 快速网关接口</h2><p>CGI 在高并发时存在性能问题，作为改进版的 FastCGI 便出现了。</p><p>快速网关接口（Fast Common Gateway Interface，FastCGI）是 CGI 的增强版。</p><h3 id="CGI-原理"><a href="#CGI-原理" class="headerlink" title="CGI 原理"></a>CGI 原理</h3><p>在接收到请求时，先 fork 出 CGI 进程，然后处理请求，处理完后结束这个进程，这就是 fork-and-execute 模式。</p><p>所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 进程，每个进程都会加载解析配置文件，初始化执行环境，那么当高并发请求时，会大量挤占系统的资源如内存，CPU 等，造成效能低下。</p><h3 id="FastCGI-原理"><a href="#FastCGI-原理" class="headerlink" title="FastCGI 原理"></a>FastCGI 原理</h3><p>FastCGI 进程管理器启动时会创建一个主（Master）进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接。</p><p>Web 服务器接收 HTTP 请求后，将 CGI 报文通过 UNIX 或 TCP Socket 进行通信，将环境变量和请求数据写入标准输入，转发到 CGI 解释器进程。</p><p>CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器。</p><p>CGI 解释器进程变为空闲状态，等待下一个 HTTP 请求的到来。</p><p>由于 FastCGI 模式在启动时便创建了很多个子进程，这些子进程常驻内存中，一旦接收到请求就可以立即进入工作状态，而传统的 CGI 模式，只有在接收到请求的时候才会去创建进程，重新读取配置文件等一系列初始化操作，毫无疑问性能会相差很多。</p><h2 id="PHP-FPM-FastCGI-进程管理器"><a href="#PHP-FPM-FastCGI-进程管理器" class="headerlink" title="PHP-FPM FastCGI 进程管理器"></a>PHP-FPM FastCGI 进程管理器</h2><p>PHP 的 FastCGI进程管理器（FastCGI Process Manager，PHP-FPM），PHP-FPM 即 FastCGI 的具体实现。</p><p>PHP 的解释器是 PHP-CGI，它本身只会解析请求返回结果，不能进行进程的调度，而 PHP-FPM（进程管理器）所做的事情便是管理进程。</p><p>PHP-FPM 包含了一个 <code>master</code> 进程和许多个 <code>worker</code> 进程，<code>worker</code> 进程的数量是可以动态调节的，创建和销毁全部由 <code>master</code> 进程来控制。</p><p><img src="https://user-images.githubusercontent.com/28209810/64397840-35090980-d095-11e9-959e-eda11f5cb000.png" alt="image"></p><p>其中，<code>master</code> 进程负责分发请求，首先 <code>master</code> 进程检测是否有可用的 <code>worker</code> 进程，如果没有则返回错误（502），然后将请求分发给空闲的 <code>worker</code> 进程处理，然后接取下一个请求，再将请求分发给空闲的 <code>worker</code>，如果 <code>worker</code> 进程处理请求超时则返回错误（504）。</p><p>这样的协作方式大大的提高了程序处理并发请求的性能，<code>worker</code> 进程的数量可以通过 <code>php.ini</code> 文件进行配置。</p><p>理论上进程越多，可以处理的请求也越多，但空闲的进程太多反而会造成内存的浪费。</p><h2 id="Nginx-与-PHP-FPM-通信"><a href="#Nginx-与-PHP-FPM-通信" class="headerlink" title="Nginx 与 PHP-FPM 通信"></a>Nginx 与 PHP-FPM 通信</h2><p>Nginx 与 PHP-FPM 的通信方式有两种：TCP SOCKET 和 Unix SOCKET。</p><p>TCP socket 的优点是可以跨服务器，Nginx 服务器不需要与 PHP-FPM 在同一台服务器上，由于跨服务器的特性，还可以实现分布式部署。</p><p>Unix socket 用于实现同一主机上的进程间通信，相较于 TCP socket，Unix socket 跳过了许多验证的步骤，因此 Unix socket 的效率比 TCP socket 要高，但是不稳定。</p><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>一个基于 TCP socket 的 PHP 站点 Nginx 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root /www/web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><p>Nginx 的 FastCGI 模块提供了 fastcgi_param 来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量，fastcgi_param 是一个文件，包含了 Nginx 中的变量映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">fastcgi_param  REQUEST_SCHEME     $scheme;</span><br><span class="line">fastcgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;</span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;</span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br></pre></td></tr></table></figure><p>除此之外，还有一个重要的指令 <code>fastcgi_pass</code>，这个指令用于指定 FPM 进程监听的地址，Nginx 会把所有的 PHP 请求翻译成 FastCGI 请求之后再发送到这个地址。</p><p>上面的 Nginx 配置文件中，我们配置了 <code>fastcgi_pass 127.0.0.1:9000;</code>，其含义是将请求转发到本机 9000 端口（PHP-FPM 进程）处理，这样的方式叫做 TCP socket。</p><p>TCP socket 的好处是可以将 Nginx 服务器与 FPM 服务器进行分离，因此可以实现分布式 PHP-FPM 架构：</p><p><img src="https://user-images.githubusercontent.com/28209810/64407389-c5a41180-d0b6-11e9-8d5f-5b5ef39a52ce.png" alt="image"></p><p>配置 <code>upstream</code> 来指定 PHP-FPM 服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upstream php-fpm &#123;</span><br><span class="line">    server 127.0.0.1:9000;</span><br><span class="line">    server 127.0.0.2:9000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root /www/web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass php-fpm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unix-socket"><a href="#Unix-socket" class="headerlink" title="Unix socket"></a>Unix socket</h3><p>基于 Unix socket 的 Nginx 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fasrcgi_pass /usr/run/php-fpm.sock</span><br></pre></td></tr></table></figure><p>PHP-FPM 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen = 127.0.0.1:9000</span><br><span class="line"># 或者</span><br><span class="line">listen = /var/run/php-fpm.sock</span><br></pre></td></tr></table></figure><blockquote><p>socket 的本质是一个文件，因此还存在权限问题，所以需要注意 Nginx 所在的用户组是否有该文件的操作权限。</p></blockquote><p>Unix socket 通信方式需要在本机生成 sock 文件，因此 Nginx 服务器与 PHP-FPM 必须在同一台机子。</p><p>关于两者的取舍，当并发量较小时（比如几百），可以选择 Unix socket 以提高处理效率，在并发量较大时，可以选择 TCP socket 以保持连接的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文读懂Nginx</title>
      <link href="/2020/03/10/nginx-introduction/"/>
      <url>/2020/03/10/nginx-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-是什么？"><a href="#Nginx-是什么？" class="headerlink" title="Nginx 是什么？"></a>Nginx 是什么？</h2><p>Nginx 是高性能 HTTP 和反向代理 WEB 服务器，还提供了邮件代理服务。</p><p>简而言之即<strong>分发服务器请求的软件</strong>。</p><p>访问一个网站的本质：</p><ul><li>在浏览器输入网址</li><li>DNS 服务商将网址解析成服务器 IP 地址</li><li>访问此 IP 的服务器</li><li>服务器收到请求，建立连接</li><li>服务器上的 Nginx 解析请求并转发给对应程序处理</li><li>程序处理请求</li><li>程序返回请求的结果（响应）</li></ul><p>在此过程，Nginx 负责分发请求给指定的程序处理。</p><p>Nginx 在分发请求的时候，会携带请求参数和请求头等其他信息，Nginx 自身无法处理请求，它只是将请求转发给对应程序处理，如果是 PHP 搭建的网站，则转发给 PHP-CGI，由 PHP-CGI 返回结果给客户端。</p><blockquote><p>PHP-CGI 是处理 PHP 文件的程序</p></blockquote><h2 id="Nginx-起源"><a href="#Nginx-起源" class="headerlink" title="Nginx 起源"></a>Nginx 起源</h2><p>Nginx 是伊戈尔·赛索耶夫为俄罗斯访问量第二的 rambler.ru 站点设计开发的。</p><p>第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。</p><p>从发布至今，凭借开源的力量，已经接近成熟与完善。</p><p>中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h2 id="URI-是什么？"><a href="#URI-是什么？" class="headerlink" title="URI 是什么？"></a>URI 是什么？</h2><p>在了解 Nginx 是如何分发请求之前需要先了解什么是 URI。</p><p>URI 统一资源标识符(Uniform Resource Identifier， URI)，它由三个部分组成：</p><ul><li>协议</li><li>主机</li><li>资源路径</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.huotuyouxi.com/img/1.jpg</span><br></pre></td></tr></table></figure><ul><li>https：协议</li><li>blog.huotuyouxi.com：主机</li><li>&#x2F;img&#x2F;1.jpg：资源路径</li></ul><p>上面也提到了，访问网址的本质是访问服务器上某个文件，示例的网址访问 blog.huotuyouxi.com 所在服务器上的 1.jpg 这个文件。</p><p>如果这样理解不能，换句话说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\games\Lol\Lol.exe</span><br></pre></td></tr></table></figure><p>访问服务器上的文件与访问本地 F 盘并无太大的差别，区别在于访问网址相当于访问远程服务器上的文件。</p><p>通俗的讲 URI 就是远程服务器文件的路径。</p><p>至于协议部分，协议即一种人为约定的规则，除了 http、https 协议，还有 ftp、sftp 等等各种协议，请求协议跟后文没有多大关系，有兴趣可以自行查阅当做扩展阅读。</p><h2 id="Nginx-如何分发请求？"><a href="#Nginx-如何分发请求？" class="headerlink" title="Nginx 如何分发请求？"></a>Nginx 如何分发请求？</h2><p>客户端请求 URI 对应的文件，Nginx 是如何处理的呢？</p><p>在分发请求之前，Nginx 首先需要解析请求。</p><p>假如我们把域名：blog.huotuyouxi.com 解析到 IP 为 xxx.xxx.xxx.xxx 的服务器上。</p><p>然后在该服务器上安装 Nginx，并且添加如下配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听 80 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    # 对应的域名</span><br><span class="line">    server_name  blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    # 项目根目录</span><br><span class="line">    root /www/blog/public;</span><br><span class="line"></span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log /var/log/nginx/blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log /var/log/nginx/blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 字符集</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    # 匹配 URI 以 / 开头（因为所有的 URI 都是以 / 开头，所以会匹配到所有请求）</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 尝试获取这几种文件</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 匹配后缀为 .php 的请求</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>小知识：80 是 http 默认端口，443 是 https 默认端口，访问域名时无需指定端口即可访问，使用其他端口时，就需要在域名后面加上 :端口号才能访问，例如：<a href="http://blog.huotuyouxi.com:81/">http://blog.huotuyouxi.com:81</a></p></blockquote><p><code>location</code> 是 Nginx 主要的模块之一，用来匹配 URI，满足条件时进入到模块内执行，我们在这个配置文件里设置了两个 <code>location</code> 模块匹配资源文件。</p><p>第一个 <code>location</code> 定制了规则 <code>/</code>，匹配以 <code>/</code> 开头的所有 URI，由于所有的 URI 都是以 &#x2F; 开头，所以会匹配到所有请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try_files</code> 按顺序检查文件是否存在，返回第一个找到的文件，至少需要两个参数，当前面的文件都找不到时，会内部重定向到最后一个参数：</p><ul><li>$uri</li><li>$uri&#x2F;</li><li>&#x2F;index.php?$query_string</li></ul><p><code>$uri</code> 指的是完全匹配的文件，<code>$uri/</code> 指的是文件夹，当前面两个都没有时，会访问 <code>/index.php</code>，而后面的 <code>?$query_string</code> 指的是携带请求参数，如果不携带参数，使用 <code>$_GET</code> 会获取不到任何参数。</p><p>访问目录是以配置的项目相对路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /www/blog/public;</span><br></pre></td></tr></table></figure><p>最后的值访问 <code>index.php</code> 即访问 <code>/www/blog/public/index.php</code>。</p><p>接着第二个 <code>location</code>，<code>~</code> 是一种标识符，用于正则匹配 URI，区分大小写，正则匹配规则为：<code>.php$</code> 也就是以 <code>.php</code> 结尾的文件，当满足条件时进入此模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri =404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意！反斜杠 \ 一定要存在，因为 .（点）也是正则表达式，需要加上反斜杠转义才能匹配 .php 后缀 </p></blockquote><p><code>location</code> 在配置文件里的前后顺序并不是匹配的顺序，<code>location</code> 匹配的规则及顺序后文介绍，在这个例子中 <code>/</code> 的匹配优先级低于 <code>~</code>，也就是先匹配 <code>.php</code> 后缀的文件，如果匹配不到再匹配 <code>/</code> 规则。</p><p>假如某个用户访问：blog.huotuyouxi.com&#x2F;php-fpm</p><p>此时，在 Nginx 中的处理流程是：</p><p>首先匹配到了 <code>server_name</code>：blog.huotuyouxi.com，进入当前配置文件进行处理。</p><p>接着解析 $uri（文件路径）即 <code>server_name</code> 后面的部分 <code>/php-fpm</code>，然后优先匹配规则 <code>~ .php</code>，发现它并没有 <code>.php</code> 结尾，接着往下级匹配 <code>/</code>，满足条件，进入到该模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    # 尝试获取这几种文件</span><br><span class="line">    try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try_files 会尝试获取 <code>/www/blog/public/php-fpm</code> 文件，发现没有，继续匹配第二个参数；<code>$uri/</code> 比之前的参数多加了一个 <code>/</code> 结尾，指的是文件夹，发现也没有 <code>/www/blog/public/php-fpm</code> 这个目录，前面两个参数都匹配完了，因此请求会变为内部重定向到最后一个参数 <code>index.php</code> 这个文件，然后重新开始匹配，此时正好匹配了规则 <code>.php</code> 结尾，进入 <code>location ~ .php</code> 模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri =404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到这个模块后，实际上是将请求转发给了 PHP-CGI 进行处理，前面几个字段暂时不用理会，只需要知道请求被转发给了 <code>fastcgi_pass</code> 这个字段，也就是 <code>127.0.0.1:9000</code>（PHP-FPM 本机端口），CGI 处理完请求后将结果返回给客户端。</p><p>以上就是 Nginx 解析和分发请求的过程。</p><h2 id="Nginx-匹配规则及优先级"><a href="#Nginx-匹配规则及优先级" class="headerlink" title="Nginx 匹配规则及优先级"></a>Nginx 匹配规则及优先级</h2><p>Nginx 配置文件中的 <code>location</code> 即匹配规则，匹配规则可以有任意个，按照优先级逐个匹配，匹配成功时停止往下匹配。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>Nginx 的 <code>location</code> 模块包含 4 种匹配标识符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标识符描述</span><br><span class="line">=精确匹配：当 $uri 完全匹配。</span><br><span class="line">~正则匹配：正则表达式匹配 $uri，区分大小写。</span><br><span class="line">~*正则匹配：正则表达式匹配 $uri，不区分大小写。</span><br><span class="line">^~非正则匹配：匹配到前缀最多的 $uri 后就结束，该模式匹配成功后，不会使用正则匹配。</span><br></pre></td></tr></table></figure><p>标识符置于 <code>location</code> 语句后面，标识符后面为匹配规则。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location [标识符] &lt;匹配规则&gt; &#123;</span><br><span class="line">    # 匹配成功时执行的代码块</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了标识符之外，可以不使用标识符进行前缀匹配（最长字符匹配）。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><blockquote><p><code>location</code> 的匹配优先级与 <code>location</code> 在配置文件的书写顺序无关</p></blockquote><p>Nginx <code>location</code> 匹配优先级为：</p><p>(location &#x3D;) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>,</del>* 正则顺序) &gt; (location 部分起始路径) &gt; (location &#x2F;)</p><p>换而言之，即：</p><p>（精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location 通配）</p><h3 id="“-x3D-”精准匹配"><a href="#“-x3D-”精准匹配" class="headerlink" title="“&#x3D;”精准匹配"></a>“&#x3D;”精准匹配</h3><p>使用精准匹配时，URI 必须完全相同才能匹配成功。</p><p>如下面的匹配规则，只有 URI 等于 <code>/php-fpm</code> 时才会触发成功，模块里的 <code>return 403;</code> 将会返回一个 <code>403 Forbidden</code> 提示信息，模拟我们不希望用户能直接访问的目录或文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /php-fpm &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 <code>server_name</code> 字段修改为 <code>localhost</code> 方便本地调试。</p><blockquote><p>修改 Nginx 配置需要重启或平滑重启使配置生效，平滑重启命令：nginx -s reload</p></blockquote><p>请求 URI：<code>127.0.0.1/php-fpm</code></p><p>可以使用 <code>curl</code> 命令来测试，即 <code>curl 127.0.0.1/php-fpm</code>，也可以直接打开浏览器输入这个地址查看结果。</p><p>返回结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm/1.jpg</code></p><p>匹配失败，<code>=</code> 号必须完全匹配。</p><h3 id="“-”正则匹配，区分大小写"><a href="#“-”正则匹配，区分大小写" class="headerlink" title="“~”正则匹配，区分大小写"></a>“~”正则匹配，区分大小写</h3><p><code>location</code> 后跟波浪线标识符 <code>~</code>，可以实现按照正则表达式规则进行匹配，<code>~</code> 波浪线标识符正则匹配时会区分大小写，下面的规则表示不希望用户访问所有后缀为 <code>.php</code> 的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>第二个请求里，最后一个字母 P 为大写，因此匹配失败。</p><p>在波浪线前面加上感叹号，形成 <code>!~</code> 标识符，表示<strong>不匹配</strong>正则表达式（区分大小写）的规则，也就是跟 <code>~</code> 的作用相反。</p><h3 id="“-”正则匹配，不区分大小写"><a href="#“-”正则匹配，不区分大小写" class="headerlink" title="“~*”正则匹配，不区分大小写"></a>“~*”正则匹配，不区分大小写</h3><p>波浪线后加上星号 <code>~*</code> 标识符将不区分大小写进行正则匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .php&#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>结果：403</p><p>由于使用了不区分大小写的规则，因此最后一个 P 改成大写也能匹配成功。</p><p>在波浪线前面加上感叹号，形成 <code>!~*</code> 标识符，表示<strong>不匹配</strong>正则表达式（不区分大小写）的规则，也就是跟 <code>~*</code> 的作用相反。</p><h3 id="“-”非正则匹配前缀"><a href="#“-”非正则匹配前缀" class="headerlink" title="“^~”非正则匹配前缀"></a>“^~”非正则匹配前缀</h3><p>“^~” 非正则匹配，后面的参数为匹配的路径，只要 URI 满足了这个前缀就匹配成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /encrpyt/ &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/encrpyt/</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt</code></p><p>匹配失败，<code>/encrpyt</code> 没有满足 <code>/encrpyt/</code>，缺少了后面的 <code>/</code>。</p><p>请求 URI：<code>127.0.0.1/encrpyt/1.jpg</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt/images/1.jpg</code></p><p>结果：403</p><p>也就是说，只要前缀满足了这个条件就匹配成功，上面的匹配规则含义是 <code>encrypt</code> 目录下所有的文件都禁止访问。</p><h3 id="不使用标识符"><a href="#不使用标识符" class="headerlink" title="不使用标识符"></a>不使用标识符</h3><p>不使用标识符即按照最长字符串匹配，优先匹配最长的字符串，只要完全匹配就停止继续往下匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /files/encrypt/ &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /post.php &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/post.php</code></p><p>首先会查找最长的字符串规则：<code>/files/encrypt/</code> 发现不匹配，接着匹配第二长的规则：<code>/post.php</code>，匹配成功，返回 403。</p><p>请求 URI：<code>127.0.0.1/files/encrypt/post.php</code></p><p>首先查找最长字符串规则：<code>/files/encrypt/</code> 前缀满足条件，匹配成功，停止往下匹配。</p><blockquote><p>注意！测试匹配规则时，如果你拷贝了上面完整的 Nginx 配置文件，.php 结尾是有 location ~ .php$ 规则的，记得删掉，否则会优先匹配到正则规则，建议测试时删除多余的所有规则，避免干扰结果，只建立一个对照组进行测试</p></blockquote><h2 id="Nginx-配置文件"><a href="#Nginx-配置文件" class="headerlink" title="Nginx 配置文件"></a>Nginx 配置文件</h2><p>Nginx 包括主配置文件与子配置文件，默认路径为：</p><ul><li>&#x2F;etc&#x2F;nginx&#x2F;nginx.conf（主配置）</li><li>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;（子配置目录）</li></ul><p>Nginx 提供了官方的中文文档可供查阅：<a href="https://www.nginx.cn/doc/index.html">Nginx - 官方中文文档</a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p>主配置文件可以让所有子配置文件共享通用的配置，可以定义 Nginx 基本参数等。</p><p>编辑主配置文件 <code>/etc/nginx/nginx.conf</code>，对应参数及作用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># Nginx 运行时的用户和用户组</span><br><span class="line">user  nginx;</span><br><span class="line"></span><br><span class="line"># Nginx 工作进程数，推荐设置为 CPU 核心数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 全局错误日志存储路径及类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log  /var/log/nginx/nginx_error.log warn;</span><br><span class="line"></span><br><span class="line"># 进程 PID 文件路径</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># 事件模块</span><br><span class="line">events &#123;</span><br><span class="line">    # 每个工作进程的最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 服务</span><br><span class="line">http &#123;</span><br><span class="line">    # 文件扩展名与文件类型映射表</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    </span><br><span class="line">    # 默认文件类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    # 日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    # 全局访问日志目录</span><br><span class="line">    access_log  /var/log/nginx/nginx_access.log  main;</span><br><span class="line">    </span><br><span class="line">    # 是否调用 sendfile 函数输出文件</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    # 此选项仅在使用 sendfile 的时候使用</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    # http 层面的连接超时时长（单位：秒），如一个网页打开 65 秒后服务器还没给出响应，则显示超时</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    # 是否开启 gzip 压缩，开启时可以压缩文件体积减少网络传输，使得网页打开更快，但是会消耗 CPU 资源</span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    # 读取子配置文件</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>events</code> 模块包含了 Nginx 处理连接的设置，常见的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">    # 设置网路连接序列化，防止惊群现象发生，默认为 on</span><br><span class="line">    accept_mutex on;</span><br><span class="line">    # 设置一个进程是否同时接受多个网络连接，默认为 off</span><br><span class="line">    multi_accept on;</span><br><span class="line">    # 事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class="line">    use epoll;</span><br><span class="line">    # 最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Events 模块的更多配置项：<a href="https://www.nginx.cn/doc/core/events.html">Nginx - 指令</a></p><p><code>log_format</code> 字段可以定义日志的输出格式，具体可设置的参数格式及说明如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>219.227.111.255</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>—</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18&#x2F;Jul&#x2F;2014:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET &#x2F;article-10000.html HTTP&#x2F;1.1”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.blog.huotuyouxi.com/">www.blog.huotuyouxi.com</a> 198.98.120.87</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>1547</td></tr><tr><td>$http_referer</td><td>url跳转来源</td><td><a href="https://www.google.com/">https://www.google.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户终端浏览器等信息</td><td>“Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.36.10.80:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.165</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr></tbody></table><p><code>server</code> 模块用于配置站点，可以在主配置文件添加，但是后期不方便维护，我们可以单独为每个站点编辑一份配置文件。</p><h3 id="子配置文件"><a href="#子配置文件" class="headerlink" title="子配置文件"></a>子配置文件</h3><p>子配置文件是一个包含 <code>server</code> 模块的配置文件，由自己来创建，推荐为每个站点单独创建一个配置文件。</p><p>命名规则一般是根据站点名称，如：<code>blog.huotuyouxi.com.conf</code>。</p><p>当然这个没有严格要求，也可以写成：<code>blog.conf</code>。</p><p>当子配置文件多的时候方便区分即可。</p><p>使用命令 <code>vim/etc/nginx/conf.d/blog.conf</code> 来创建博客的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    return 301 https://blog.huotuyouxi.com$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # https</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    root /www/blog;</span><br><span class="line">    index index.html;</span><br><span class="line">    </span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log /var/log/nginx/blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log /var/log/nginx/blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 以下为 SSL 相关配置</span><br><span class="line">    ssl_certificate   /etc/nginx/ssl/3527929_blog.huotuyouxi.com.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/3527929_blog.huotuyouxi.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件将默认的 http 80 端口重定向到了 https 的链接上。</p><p>编辑完成后运行：<code>nginx -s reload</code> 平滑重启即可使配置生效。</p><p>在子配置里可以单独设置访问日志和错误日志，让每个站点都有独立的日志记录文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 访问日志存储位置</span><br><span class="line">access_log /var/log/nginx/blog_access.log;</span><br><span class="line"></span><br><span class="line"># 错误日志存储位置</span><br><span class="line">error_log /var/log/nginx/blog_error.log;</span><br></pre></td></tr></table></figure><p>access_log：访问日志主要记录客户端的请求。客户端向 Nginx 服务器发起的每一次请求都记录在这里。客户端 IP，浏览器信息，referer，请求处理时间，请求 URL 等都可以在访问日志中得到。当然具体要记录哪些信息，你可以通过 log_format 指令定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; # 设置访问日志</span><br><span class="line">access_log off; # 关闭访问日志</span><br></pre></td></tr></table></figure><ul><li>path 指定日志的存放位置。</li><li>format 指定日志的格式。默认使用预定义的 combined。</li><li>buffer 用来指定日志写入时的缓存大小。默认是 64k。</li><li>gzip 日志写入前先进行压缩。压缩率可以指定，从 1 到 9 数值越大压缩比越高，同时压缩的速度也越慢。默认是 1。</li><li>flush 设置缓存的有效时间。如果超过 flush 指定的时间，缓存中的内容将被清空。</li><li>if 条件判断。如果指定的条件计算为 0 或空字符串，那么该请求不会写入日志。</li></ul><p>error_log：记录服务器和请求处理过程中的错误信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log path [level];</span><br></pre></td></tr></table></figure><ul><li>path：指定错误日志的存储位置</li><li>level：指定要记录的错误级别，只有发生错误的级别大于等于 level 的时候才会记录错误，可取值为：debug, info, notice, warn, error, crit, alert,emerg，默认值为 error。</li></ul><p>如果没有配置单独的日志文件，则会记录在全局日志里。</p><h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p>代理指的是中介服务。</p><p>分为正向代理与反向代理。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理可以理解成代购模式，例如你的朋友要去国外旅游，于是你拜托他帮忙购买你需要的商品，他从国外买好回来再交给你。</p><p>在这里你就是客户端，而你的朋友就是代理服务器。</p><p>这样直接由代理服务器去完成某件事的过程，叫做正向代理。</p><p>正向代理的应用例子——VPN：</p><p>由于国内无法访问到国外的某些网站，比如谷歌；但不是所有的国外服务器都被墙了，因此你可以买一台没有被墙的国外服务器，当你需要访问国外网站的时候，就让服务器去访问，然后再让服务器把结果转发给你。</p><p>正向代理的特征是你知道自己委托了谁去干这件事。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理与正向代理不同的地方在于：客户委托中介完成一件事，结果中介私底下把需求转交给了别人去干，客户不知道究竟是谁帮自己做完了需求，但是得到了自己想要的结果就够了。</p><p>好比游戏里面的公会，村民可以把自己的委托贴在公会告示板上，然后公会的看板娘会把委托的需求分配给适合的冒险者来完成。</p><p>反向代理的应用例子——负载均衡：</p><p>“负载”可以理解成负荷，用户访问一个非静态网站，程序需要读取数据库、渲染 HTML 页面、维持 TCP 连接等操作需要消耗 CPU、内存资源，会给服务器带来一定的负荷。</p><p>假如服务器可以承受的压力为 100N（物理学单位）</p><p>在某个瞬间，每有一名用户访问这个网站，会给服务器带来 5N 的压力，那么这个瞬间最大承载量就是 20 名用户，当服务器压力超过 100N 时就会崩溃。</p><p>要解决这个问题，可以进行硬件提升或者优化项目代码。</p><p>硬件提升可以提升服务器最大承受压力值，比如双核的服务器升级到 4 核，使服务器的最大承受压力从 100N 提升到 200N。</p><p>软件优化可以减少每个访客造成的压力，比如某些数据库 N+1 的问题严重影响了数据库的性能，造成数据库卡顿，优化了这个问题后，访客造成的压力值从 5N 降低到了 4N。</p><p>但是这两种方法提升都有一个临界点，比如硬件优化继续往上提升，服务器的价格就越来越贵，也不可能存在无限核心数的服务器；软件优化到一定程度后已经很难再找到优化的空间。</p><p>达到临界值后就无法再继续优化了，单机的性能已经达到了极致。</p><p>此时，如果能再买一台同样的服务器并且部署同一套项目，是不是可以使最大承载访客数翻倍呢？</p><p>确实可以，只要有两台服务器，那么它们的处理能力就会翻倍！</p><p>只要把一半的请求转发给另一台相同的服务器，平均分担压力。</p><p>但是应该怎么让请求分别进入到不同的服务器呢？</p><p>答案是通过 Nginx，利用上文介绍的反向代理功能。</p><p><img src="http://p3.pstatp.com/large/pgc-image/1534991903053fc12397bd0" alt="负载均衡"></p><p>这个过程称为“均衡”，负责维持均衡的那台服务器只负责分发请求，把请求转发给其他能完成功能的服务器处理，由其他服务器返回结果。</p><p>负责分发请求的服务器称为“均衡调度器”，Nginx 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream huotu-server &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">    server 192.168.0.16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://huotu-server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>upstream</code> 字段定义了代理服务器的 IP 地址，当访客进来的时候，Nginx 会按照某种规则将请求分发给其中一个服务器处理。</p><p><code>server</code> 模块里通过 <code>proxy_pass http://huotu-server;</code> 将匹配到规则的请求转发给代理服务器来处理。</p><p>当用户访问：blog.huotuyouxi.com</p><p>Nginx 会把请求转发给某台服务器处理，因此每次访问网站看到的返回 IP 可能都会不同。</p><h2 id="Nginx-模块"><a href="#Nginx-模块" class="headerlink" title="Nginx 模块"></a>Nginx 模块</h2><p>Nginx 发展迅速的原因除了开源之外，还可以使用官方提供的模块或用户自定义开发的模块，由于模块化使得 Nginx 的定制能力很强，可以使用第三方扩展模块让 Nginx 适应各种场景，有能力的大神也可以分享自己写好的模块让其他人直接使用，像这样可以自由 DIY 的软件，有谁会不喜欢呢？</p><p>例如，由淘宝的工程师清无（王晓哲）和春来（章亦春）所开发的 nginx_lua_module 可以将 Lua 语言嵌入到 Nginx 配置中，从而利用 Lua 极大增强了 Nginx 本身的编程能力，甚至可以不用配合其它脚本语言（如 PHP 或 Python 等），只靠 Nginx 本身就可以实现复杂业务的处理。</p><p>Nginx 本身支持多种模块，如 HTTP 模块、EVENT 模块和 MAIL 模块等。</p><p>前文提到，在 HTTP 请求中，Nginx 的工作仅仅只是分析请求然后转发给匹配规则的 <code>location</code> 去处理，<code>location</code> 模块中的内容才是真正干活的人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 匹配规则</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 实际的工作者</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已安装模块可以用命令：<code>nginx -V</code> 查看，输出结果类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) </span><br><span class="line">built with OpenSSL 1.1.0j  20 Nov 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&#x27;-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.15.12/debian/debuild-base/nginx-1.15.12=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#x27;</span><br></pre></td></tr></table></figure><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>Nginx 有许多可以自定义安装的模块，下面以 echo 为例。</p><p>echo 仓库地址：<a href="https://github.com/openresty/echo-nginx-module">Github - echo-nginx-module</a></p><p>安装 echo 模块 <code>echo-nginx-module</code> 可以使 Nginx 具有输出字符串的能力，这个功能可以用来简单的调试，如输出参数等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123; </span><br><span class="line">    return 200 &#x27;hello!&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /hello_echo &#123; </span><br><span class="line">    echo &quot;hello, echo!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方模块"><a href="#官方模块" class="headerlink" title="官方模块"></a>官方模块</h3><p>官方模块是 Nginx 官方提供的可扩展模块。</p><p>例如 Nginx 预制的模块 stub_status 可以用来查看 Nginx 的运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问后的输出页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 3 3 2 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1 </span><br></pre></td></tr></table></figure><p>更多 Nginx 官方模块以使用方法：<a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></p><p>如上面的 <code>stub_status</code>，可以通过查询手册：<a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html">ngx_http_stub_status_module</a> 来获取如何使用。</p><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>可以通过搜索 Github 寻找来自全世界开发者分享的模块：<a href="https://github.com/search?q=nginx+module">Github - Nginx 扩展模块</a></p><p>具体的使用方法可以参照作者写的 README 文档。</p><h2 id="Nginx-应用场景"><a href="#Nginx-应用场景" class="headerlink" title="Nginx 应用场景"></a>Nginx 应用场景</h2><p>最后再来总结一下，Nginx 具体的应用场景。</p><h3 id="HTTP-服务"><a href="#HTTP-服务" class="headerlink" title="HTTP 服务"></a>HTTP 服务</h3><p>Nginx 可以为站点提供 HTTP 服务。</p><p>利用 <code>location</code> 模块匹配 URI 规则，再将其分发到对应的程序进行处理。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Nginx 的反向代理服务，可以实现分发请求的功能。</p><p>具体方法是配置 <code>upstream</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        server 127.0.0.1:8000 weight=3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">        server 127.0.0.1:8003;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">        server_name www.domain.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://myproject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡有以下几种模式：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>轮询模式</td><td>Nginx 默认配置，当客户端访问服务的时候，请求按时间顺序逐一分配到不同的后端服务器，如果有某台服务器挂了，Nginx 会自动剔除</td></tr><tr><td>权重模式</td><td>可以为每个服务器配置不同的权重，权重值越高的越容易被分发到请求，当多台服务器性能存在差异时，可以让配置高的服务器分配更高的权重</td></tr><tr><td>IP 哈希</td><td>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。解决 Session 丢失的问题，保证每个用户访问到同一台服务器。</td></tr><tr><td>第三方插件</td><td>可以通过安装第三方插件实现更多的模式</td></tr></tbody></table><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>当自己网站的图片、视频等静态资源被其他人引用时，其他人访问了别人的网站，就会请求到我们服务器上的资源，给我们的服务器带来压力。</p><p>Nginx 可以验证来源网站 referers 来判断请求是否是本站点，如果是其他的站点则不让它们获取到图片资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    root html</span><br><span class="line">    valid_referers none blocked *.huotuyouxi.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDN-服务器"><a href="#CDN-服务器" class="headerlink" title="CDN 服务器"></a>CDN 服务器</h3><p>可以用 Nginx 搭建 CDN 服务器。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>Nginx 的 <code>ngx_http_limit_req_module</code> 模块可以限制访问频率和并发连接数。</p><p>HttpLimit zone：<a href="https://www.nginx.cn/doc/standard/httplimitzone.html">HttpLimit zone</a></p><p>HttpLimitReqest：<a href="https://www.nginx.cn/doc/standard/httplimitrequest.html">HttpLimitReqest</a></p><h3 id="黑-x2F-白名单"><a href="#黑-x2F-白名单" class="headerlink" title="黑&#x2F;白名单"></a>黑&#x2F;白名单</h3><p>可以禁止某些 IP 访问，或允许指定 IP 访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny 8.8.8.8;</span><br><span class="line">    allow 9.9.9.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>以 Ajax 方式访问非本站点的链接时，浏览器出于安全考虑会禁止访问，也就是跨域问题（HTTP 访问限制，CORS）。</p><p>在 Nginx 中只需要配置允许访问的来源类型即可解决跨域问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 允许访问的来源，* 指的是全部，可以是 IP 地址或者域名</span><br><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line"># 允许请求的类型</span><br><span class="line">add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line"># 允许请求的方法</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br></pre></td></tr></table></figure><h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>Nginx 提供了邮件代理服务，具体参照官方文档：<a href="https://www.nginx.cn/doc/mail/mailcore.html">Nginx - MailCore</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的反射</title>
      <link href="/2020/03/10/php-reflex/"/>
      <url>/2020/03/10/php-reflex/</url>
      
        <content type="html"><![CDATA[<h2 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h2><p>反射原本指的是一种光学现象，光在传播时照射在物体上会产生返回原物体的现象。在 PHP 中，反射的作用类似光的传播，PHP 可以通过反射机制拿到代码本身，也就是通过代码得到代码，反射一词十分形象。</p><p>通过反射机制可以获取类中的变量、方法名称甚至是注释等等，在正常的开发环境中几乎不会用到，一般都是在框架设计时使用，目的是增加框架的扩展性。</p><p>Laravel、Swoft 框架都用到了反射机制，Swoft 注解的实现原理就是使用反射机制来实现的。</p><p>一些 API 文档插件可以通过注释来编译生成 API 文档，其原理同样是使用了 PHP 的反射机制。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义一个类，类里面有常量、私有属性（private 声明的变量）、类的注释和方法的注释等等。</p><p>思考下面几个业务中几乎不会用到的问题：</p><p>如果我们要获取类里面的所有常量，应该怎么做？</p><p>如果我们要获取方法的注释，或者类的注释，应该怎么做？</p><p>如果我们要获得类的命名空间，又该怎么做？</p><p>此时习惯了做业务的我们肯定一脸懵逼，PHP 中的反射就是为了解决这一类的问题，通过反射提供的 API 可以拿到一个类的所有信息。</p><p>通过下面的代码举例，你马上就会弄懂什么是反射了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * 类的注释</span><br><span class="line"> */</span><br><span class="line">class User</span><br><span class="line">&#123;</span><br><span class="line">    const BOY = 1;</span><br><span class="line">    const GIRL = 2;</span><br><span class="line"></span><br><span class="line">    private $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name) &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     */</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#x27;hello!&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class = new ReflectionClass(&#x27;User&#x27;);  // 将类名User作为参数，即可建立User类的反射类</span><br><span class="line">$properties = $class-&gt;getProperties();  // 获取User类的所有属性，返回ReflectionProperty的数组</span><br><span class="line">$property = $class-&gt;getProperty(&#x27;name&#x27;); // 获取User类的属性ReflectionProperty</span><br><span class="line">$methods = $class-&gt;getMethods();   // 获取User类的所有方法，返回ReflectionMethod数组</span><br><span class="line">$method = $class-&gt;getMethod(&#x27;sayHello&#x27;);  // 获取User类的方法的ReflectionMethod</span><br><span class="line">$constants = $class-&gt;getConstants();   // 获取所有常量，返回常量定义数组</span><br><span class="line">$constant = $class-&gt;getConstant(&#x27;BOY&#x27;);   // 获取常量</span><br><span class="line">$namespace = $class-&gt;getNamespaceName();  // 获取类的命名空间</span><br><span class="line">$comment_class = $class-&gt;getDocComment();  // 获取User类的注释文档，即定义在类之前的注释</span><br><span class="line">$comment_method = $class-&gt;getMethod(&#x27;sayHello&#x27;)-&gt;getDocComment();  // 获取User类中方法的注释文档</span><br><span class="line"></span><br><span class="line">var_dump($comment_method);</span><br></pre></td></tr></table></figure><p>上面的代码会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(39) &quot;/**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     */&quot;</span><br></pre></td></tr></table></figure><h2 id="反射-API"><a href="#反射-API" class="headerlink" title="反射 API"></a>反射 API</h2><p>PHP 官方手册：<a href="https://www.php.net/reflection">https://www.php.net/reflection</a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>反射机制会打破类的封装性，日常业务也不需要获取代码的注释。</p><p>因此在日常开发中几乎不会直接用到，但是在框架或者插件的设计上却能发挥很大的作用。</p><h3 id="生成-API-文档"><a href="#生成-API-文档" class="headerlink" title="生成 API 文档"></a>生成 API 文档</h3><p>由于反射可以拿到类的属性、方法，就可以自动生成类的文档。</p><p>典型例子：<a href="https://apidocjs.com/">API DOC</a></p><p>通过在方法名称上添加注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @api &#123;get&#125; /user/:id Request User information</span><br><span class="line"> * @apiName GetUser</span><br><span class="line"> * @apiGroup User</span><br><span class="line"> *</span><br><span class="line"> * @apiParam &#123;Number&#125; id Users unique ID.</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccess &#123;String&#125; firstname Firstname of the User.</span><br><span class="line"> * @apiSuccess &#123;String&#125; lastname  Lastname of the User.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>然后运行编译程序就可以直接生成一个美观、排版整齐的 API 文档。</p><p><img src="https://apidocjs.com/img/example.png" alt="APIDOC"></p><p>一些 IDE 提示工具也利用反射获取类的注释，然后实现提示的功能，注释时需要根据一定的规范。</p><p>注释示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试方法</span><br><span class="line"> * @param $a</span><br><span class="line"> * @param $b</span><br><span class="line"> */</span><br><span class="line">function test($a,$b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量复刻文件"><a href="#批量复刻文件" class="headerlink" title="批量复刻文件"></a>批量复刻文件</h3><p>既然可以拿到类的所有成员，那么以类为母版，克隆出子类文件轻而易举，在一些框架或插件中经常用到。</p><p>Laravel 框架可以使用 <code>php artisan make:controller UserController</code> 命令创建一个控制器类的模板，还可以加上参数 <code>-r</code> 生成一个 RESTful 风格的 API 控制器类。</p><p>还有数据库迁移工具（Laravel 内置了此插件），可以通过命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php vendor/bin/phinx create MyMigration</span><br></pre></td></tr></table></figure><p>直接生成一个数据库迁移文件。</p><p>直接用命令的方式生成文件，可以少写很多重复的代码。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>先不需要知道依赖注入是什么，看下面的例子，Laravel 很普通的控制器类的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct(UserService $service)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service = $service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users = $this-&gt;service-&gt;getAllUsers();</span><br><span class="line">        </span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过构造函数赋予了属性 <code>$service</code>，但问题是——控制器类并没有被实例化！</p><p>一般情况下，我们需要这样把参数传给构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$service = new UserService();</span><br><span class="line">$user = new UserController($service);</span><br></pre></td></tr></table></figure><p>上面的例子并没有 <code>UserController</code> 的实例化操作，而且在 PHP 中参数前面加上类名称，只是起到变量类型限制的作用。</p><p>到底是哪里传来实例化的 <code>UserService</code> 呢？</p><p>其实是通过反射机制实现的，通过反射获取到了控制器类的构造方法，然后将这个控制器所需要<strong>依赖</strong>的类实例化后生成的对象<strong>注入</strong>到控制器里，所以这个叫做依赖注入。</p><p>依赖注入这个概念是从 Java 中传过来的，并非 Laravel 特有。</p><p>假设不使用反射机制注入依赖，那么我们的控制器是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service = new UserService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users = $this-&gt;service-&gt;getAllUsers();</span><br><span class="line"></span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯……？代码量好像差不多！</p><p>依赖注入是一种设计模式，运行的结果没有差别。</p><p>其实在学 Laravel 的时候，我发现了一个很奇怪的地方。</p><p>比如存在路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#x27;/users&#x27;, &#x27;UserController@index&#x27;)-&gt;name(&#x27;users.index&#x27;);</span><br><span class="line">Route::get(&#x27;/users/&#123;id&#125;&#x27;, &#x27;UserController@show&#x27;)-&gt;name(&#x27;users.show&#x27;);</span><br></pre></td></tr></table></figure><p>然后控制器的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function show(Request $request, $id)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request, $id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index 方法的第一个<code>Illuminate\Http\Request</code> 类型的参数，我们在路由中没有任何参数，既然不是通过匹配路由得到的参数，这个参数又是怎么来的呢？</p><p>更不可思议的是第二个路由的 show 方法，我们在声明路由的时候只指明了一个参数 <code>/users/&#123;id&#125;</code>，但我们现在却在方法中写了两个参数，又是怎么精确地匹配到 ID 值的？</p><p>其实同样是用了依赖注入的方法实现的，在学习了反射之后，它们的原理就大概知道了。</p><p>首先通过反射得到一个方法的参数，如果这个参数定义了某些类型，就将其实例化后再传递给该方法，在 Laravel 中有专门的解析类在处理这些参数。</p><h3 id="通过注释生成路由"><a href="#通过注释生成路由" class="headerlink" title="通过注释生成路由"></a>通过注释生成路由</h3><p>Swoft 框架把注释当做定义路由的方法，称为“注解”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use Swoft\Http\Message\Request;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\Controller;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\RequestMapping;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class Home</span><br><span class="line"> *</span><br><span class="line"> * @Controller(prefix=&quot;home&quot;)</span><br><span class="line"> */</span><br><span class="line">class Home</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 该方法路由地址为 /home/index</span><br><span class="line">     *</span><br><span class="line">     * @RequestMapping(route=&quot;/index&quot;, method=&quot;post&quot;)</span><br><span class="line">     *</span><br><span class="line">     * @param Request $request</span><br><span class="line">     */</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 PHP 的反射机制可以做一些奇奇怪怪的事，这也算是 Swoft 独特的风格吧。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的魔术方法</title>
      <link href="/2020/03/10/php-magic-methods/"/>
      <url>/2020/03/10/php-magic-methods/</url>
      
        <content type="html"><![CDATA[<h2 id="魔术方法是什么？"><a href="#魔术方法是什么？" class="headerlink" title="魔术方法是什么？"></a>魔术方法是什么？</h2><p>魔术方法是 PHP 类中特殊的方法，以双下划线 <code>__</code> 开头，具有特殊用途，比如我们常用的 <code>__construct</code> 构造函数就属于魔术方法，构造函数的作用是类实例化自动调用的方法。</p><p>魔术方法的名称都是系统预定义的，无法修改，我们在写 PHP 代码的时候，为了避免与系统预定义函数相同，不建议用双下划线 <code>__</code> 作为函数的前缀。</p><p>魔术方法的作用可以归纳为：<strong>对象在 xxx 的时候，应该实现的功能。</strong></p><p>比如，上述构造函数可以理解为：对象在“实例化”的时候，应该实现的功能。</p><p>除此之外，与构造函数相对的 <strong>析构函数</strong> <code>__destruct</code> 可以在对象被回收时自动调用。</p><p>如果有 Java 基础，你可以发现类默认有一种 <code>toString</code> 方法，可以把对象转化成字符串。其实 PHP 中也存在同样的魔术方法 <code>__toString</code>，当类的对象被当做字符串调用时会自动执行此方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;Just a dog.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>执行的结果会输出：Just a dog.</p><p>为什么在上述代码中，echo 可以输出一个对象呢？</p><p>这是因为我们设置了 <code>__toString</code> 方法，当对象被当做字符串调用时会自动触发 <code>__toString</code> 方法。</p><p>换而言之，<strong>魔术方法是一类由系统预定义了函数名称，在某些情况下被动触发的函数</strong>。</p><p>所有的魔术方法都不是用来主动调用的，如下错误示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 错误示范</span><br><span class="line">$obj = new MyClass();</span><br><span class="line">$obj-&gt;__construct();</span><br></pre></td></tr></table></figure><p>魔术方法也是类的方法，上述代码逻辑上没有问题而且可以运行且不会报错。不会报错不代表这么写没问题，魔术方法中<strong>不应该</strong>放入业务逻辑相关的代码。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>魔术方法大都用于框架且与设计模式关联紧密，日常业务除了构造方法之外几乎很少接触到其他魔术方法。<br>Laravel 框架将魔术方法用到了极致，被称为“优雅”的框架。</p><h2 id="PHP-中的魔术方法"><a href="#PHP-中的魔术方法" class="headerlink" title="PHP 中的魔术方法"></a>PHP 中的魔术方法</h2><p>下面介绍 PHP 常见的魔术方法以及应用场景和示例代码。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>俗称类的构造方法，当类被实例化为对象时自动调用。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Just a dog.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br></pre></td></tr></table></figure><p>输出：Just a dog.</p><blockquote><p>void __construct ([ mixed $args [, $… ]] )</p></blockquote><p>构造函数的几大特征：</p><ul><li>构造函数可以接受参数，能够在创建对象时赋值给对象属性</li><li>构造函数可以调用类方法或其他函数</li><li>构造函数可以调用其他类的构造函数</li><li>构造函数的权限可以被修改</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;This is animal.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 父类构造函数不会自动调用，需要手动进行调用</span><br><span class="line">        parent::__construct();</span><br><span class="line">        </span><br><span class="line">        // 对象赋值</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line"></span><br><span class="line">        // 调用类中的方法</span><br><span class="line">        $this-&gt;jump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function jump()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name . &#x27; jump.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog(&#x27;小白&#x27;);</span><br></pre></td></tr></table></figure><p>最后一条：<strong>构造函数的权限可以被修改。</strong></p><p>在设计模式中会用到，例如单例模式，为了防止子类被实例化，会将构造函数限制为 <code>private</code> 私有化。</p><p>一个比较标准的单例模式示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Singleton &#123;</span><br><span class="line">    // 私有属性，用于保存实例</span><br><span class="line">    private static $instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化，防止外部创建实例</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 公有方法，用于获取实例</span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        // 没有的话创建实例并返回，有的话直接返回</span><br><span class="line">        if(!(self::$instance instanceof self))&#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 克隆方法私有化，防止复制实例</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h3><p>俗称析构函数，当对象被回收时自动调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;The dog is dead.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">unset($dog);</span><br></pre></td></tr></table></figure><p>输出：The dog is dead.</p><blockquote><p>void __destruct ( void )</p></blockquote><p>析构函数的特征：</p><ul><li>析构函数不能接受参数</li><li>析构函数不能抛出异常</li></ul><p>由于析构函数在对象被回收时触发，因此如果抛出异常将无法被捕获，抛出异常情况下将报出致命错误。</p><p>和构造函数一样，父类的析构函数不会被隐式调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用： <code>parent::__destruct();</code></p><h3 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h3><p>当调用对象中不存在的属性时，自动触发该方法。</p><p>Laravel 框架里几乎随处可见，如 Model 对象调用表的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::find(1);</span><br><span class="line">echo $user-&gt;name;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs = [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：NULL</p><p>通常情况下，如果直接调用对象中不存在的属性会产生报错，但是设置了 <code>__get</code> 方法后，如果调用了不存在的属性则会转而调用这个方法处理。通常 <code>__get</code> 要结合 <code>__set</code> 一起使用。</p><h3 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h3><p>当设置对象中不存在的属性时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs = [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __set($name, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;attrs[$name] = $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;name = &#x27;小白&#x27;;</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：string(6) “小白”</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h3><p>当对象被当成字符串调用时，自动触发该方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;Dog name is &#x27; . $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog(&#x27;小黑&#x27;);</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>输出：Dog name is 小黑</p><p>这个魔术方法在调试的时候非常有用，可以把对象中的参数信息打印出来，记录到日志里。</p><h3 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h3><p>当对象调用了一个类中不存在的方法或者没有权限调用的方法时，自动触发。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function aPrivateMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Im private.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;fly(&#x27;666&#x27;);</span><br><span class="line">$dog-&gt;aPrivateMethod();</span><br></pre></td></tr></table></figure><p>第一个 fly 方法，不存在 Dog 类中；第二个 aPrivateMethod 是私有方法，不能直接被对象调用，因而触发了 <code>__call</code> 方法。</p><p>在 Laravel 中也可以看到许多 <code>__call</code> 应用的场景，还是 Model 类的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::whereName(&#x27;xiaobai&#x27;)-&gt;first();</span><br><span class="line">dd($user);</span><br></pre></td></tr></table></figure><p>这里的 where 后面接大驼峰方式的参数，相当于如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user = User::where(&#x27;name&#x27;, &#x27;xiaobai&#x27;)-&gt;first();</span><br></pre></td></tr></table></figure><p>通过 <code>__call</code> 方法实现简写的目的。</p><p><code>__call</code> 方法接收两个参数，第一个参数是调用方法的名称，第二个参数是调用方法时传入的参数，数组格式。</p><h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic"></a>__callStatic</h3><p>当对象调用了一个不存在的静态方法时，自动触发。</p><p><code>__callStatic</code> 与 <code>__call</code> 的作用基本相似，只不过 <code>__callStatic</code> 针对的是静态方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public static function __callStatic($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog::whatsYourProblem();</span><br></pre></td></tr></table></figure><p>这样的设计在 Laravel 框架中也能看到，依然是 Model 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users = User::all();</span><br><span class="line">$items = Item::where(&#x27;price&#x27;, &#x27;&gt;&#x27;, 100)-&gt;paginate(20);</span><br></pre></td></tr></table></figure><p>Laravel 中的 Model 并不是把方法真的当做静态方法，而是利用 <code>__callStatic</code> 让你产生“静态调用”的错觉。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h3><p>当尝试以调用方法的形式来调用一个对象时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __invoke($parm1, $parm2)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($parm1,$parm2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog(&#x27;小白&#x27;,&#x27;小黑&#x27;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">string(6) &quot;小黑&quot;</span><br></pre></td></tr></table></figure><p><code>__invoke</code> 可以接收自定义的任意参数，与函数的形参规则一致。</p><p>我们知道这种方法有点奇怪，谁也不会把一个对象当成方法来用吧？</p><p>让我们来康康 Laravel 框架是怎么利用 <code>__invoke</code> 让代码变得更“优雅”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1、指定路由及对应的方法</span><br><span class="line">Route::get(&#x27;/user&#x27;, &#x27;UserController@index&#x27;);</span><br><span class="line"></span><br><span class="line">// 2、不指定对应的方法，自动调用 __invoke</span><br><span class="line">Route::get(&#x27;/user/default&#x27;, &#x27;UserController&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    // 1、/user 调用 index 方法</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2、/user/default 没有指定方法，自动调用 __invoke</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不指定具体的方法时，Laravel 的路由会把对象当做方法来执行，从而调用 <code>__invoke</code> 方法，简化了路由部分的代码。</p><h3 id="clone"><a href="#clone" class="headerlink" title="__clone"></a>__clone</h3><p>当对象被克隆时，自动调用。</p><p>PHP 中存在一个关键词 clone 可以复制对象，并且复制出来的对象为独立的个体，与原对象不存在互相影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;new dog birth.&#x27; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = new Dog();</span><br><span class="line">$dog-&gt;name = &#x27;小白&#x27;;</span><br><span class="line"></span><br><span class="line">// 克隆出来的对象属性与原对象一模一样</span><br><span class="line">$cloneDog = clone $dog;</span><br><span class="line">var_dump($cloneDog-&gt;name);</span><br><span class="line"></span><br><span class="line">// 修改克隆对象的属性，不会影响原对象</span><br><span class="line">$cloneDog-&gt;name = &#x27;小黑&#x27;;</span><br><span class="line">var_dump($dog, $cloneDog);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new dog birth.</span><br><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">object(Dog)#1 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(6) &quot;小白&quot;</span><br><span class="line">&#125;</span><br><span class="line">object(Dog)#2 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(6) &quot;小黑&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，克隆出来的对象修改了属性，但是原来对象的属性保持不变，它们是互相独立的个体，也就是说并非引用关系，clone 会开辟一块新的内存来存储复制出来的新对象。</p><p><code>__clone</code> 方法在 clone 出新对象时自动调用。</p><p>clone 业务中用得比较少，应用场景能想到的一个是重构代码，我们需要增加一个新的接口来应对新的需求，但同时又不希望破坏旧接口的内部结构，也不希望直接在旧接口的代码上修改，此时可以使用 clone，既可以向下兼容作用，又能在旧接口上添加新功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class NewDogAction</span><br><span class="line">&#123;</span><br><span class="line">    // 新接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OldDogAction</span><br><span class="line">&#123;</span><br><span class="line">    // 旧版接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    // 动作类对象</span><br><span class="line">    private $action;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action = new OldDogAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action = new NewDogAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 clone 出来的时候，action 被替换成新的接口代码。</p><p>换成比较形象的例子：</p><p>鸣人使用多重影分身之术，可以看成是 clone 出很多个分身，但是这些分身并不能 100% 继承本体的能力，本体的能力可以看成上面的 <code>oldDogAction</code>，而分身的能力则是 <code>newDogAction</code>，分身除了 action 属性之外其他的地方与本体并无差异。</p><h2 id="更多的魔术方法"><a href="#更多的魔术方法" class="headerlink" title="更多的魔术方法"></a>更多的魔术方法</h2><p>如果有兴趣了解全部的魔术方法，请访问 <a href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP：魔术方法</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理工具 Supervisord</title>
      <link href="/2020/03/10/supervisord/"/>
      <url>/2020/03/10/supervisord/</url>
      
        <content type="html"><![CDATA[<h2 id="Supervisord-是什么？"><a href="#Supervisord-是什么？" class="headerlink" title="Supervisord 是什么？"></a>Supervisord 是什么？</h2><p>Supervisord 是一个进程管理工具，它可以用来执行一些需要在后台持续存在的进程（守护进程）的启动命令。</p><p>比如前端的 Nuxt 框架使用 SSR（服务端渲染），需要启动服务端的进程，会使用 pm2 来管理进程的启动。</p><p>Supervisord 同样是一种进程管理工具。</p><p>下文将演示 Supervisord 管理 Laravel 的队列任务进程。 </p><h2 id="安装-Supervisord"><a href="#安装-Supervisord" class="headerlink" title="安装 Supervisord"></a>安装 Supervisord</h2><p>以 Centos 为例，直接使用 yum 安装即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、安装 epel-release</span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"># 2、安装 supervisor</span><br><span class="line">yum install -y supervisor</span><br><span class="line"></span><br><span class="line"># 3、将 supervisor 设置为开机启动</span><br><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure><p>以上就安装完成了，但是还没有启动 supervisor，先不用着急启动。</p><h2 id="Supervisor-配置文件"><a href="#Supervisor-配置文件" class="headerlink" title="Supervisor 配置文件"></a>Supervisor 配置文件</h2><p>supervisor 的配置文件默认路径为：<code>/etc/supervisor/supervisord.conf</code>，使用 <code>vim</code> 命令编辑，大致可以看到如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/var/run/supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod=0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir=/var/log/supervisor            ; (&#x27;AUTO&#x27; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">&quot;/etc/supervisor/supervisord.conf&quot; 28L, 1178C                 8,1           Top</span><br><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/var/run/supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod=0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir=/var/log/supervisor            ; (&#x27;AUTO&#x27; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files = /etc/supervisor/conf.d/*.conf</span><br><span class="line">                                                                                                                                                                                          19,36         All</span><br></pre></td></tr></table></figure><p>如果不一样说明版本不同，通过下面的命令可以查看自己安装的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 版本</span><br><span class="line">supervisord -v</span><br><span class="line"></span><br><span class="line"># 我下载的版本是 3.3.5</span><br></pre></td></tr></table></figure><p>需要注意的地方只有最底下的一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisor/conf.d/*.conf</span><br></pre></td></tr></table></figure><p>在一些旧的版本这里会有差别，这里的意思是说包含了路径 <code>/etc/supervisor/conf.d</code> 文件夹里面所有后缀为 <code>.conf</code> 的文件，现在不需要改动这个文件。</p><p><code>/etc/supervisor/conf.d/</code> 文件夹下默认是空的，我们要自己创建新的配置文件。</p><p>使用命令：<code>vim /etc/supervisor/conf.d/my.conf</code>，编辑并保存如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:myprogram]</span><br><span class="line">process_name=%(program_name)s_%(process_num)02d</span><br><span class="line">command=/usr/local/bin/php /www/myproject/artisan queue:work --quiet --tries=3 --sleep=3</span><br><span class="line">directory=/www/myproject</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=www-data</span><br><span class="line">numprocs=1</span><br><span class="line">redirect_stderr=true</span><br></pre></td></tr></table></figure><p>这里我们启动了一个守护进程，用来执行 Laravel 的队列任务：<code>php artisan queue:work</code>。</p><p>配置项说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># program:&lt;进程名字&gt;</span><br><span class="line">[program:myprogram]</span><br><span class="line"></span><br><span class="line"># 进程的名字规则，按照下面的配置就可以了</span><br><span class="line">process_name=%(program_name)s_%(process_num)02d</span><br><span class="line"></span><br><span class="line"># 执行的命令 /usr/local/bin/php 是 PHP 二进制文件位置，相当于在 Laravel 下执行 php artisan 一样</span><br><span class="line">command=/usr/local/bin/php /www/myproject/artisan queue:work --quiet --tries=3 --sleep=3</span><br><span class="line"></span><br><span class="line"># 项目所在目录，注意这里一定要填，网上搜的教程很多都忽略了这个字段</span><br><span class="line">directory=/www/myproject</span><br><span class="line"></span><br><span class="line"># 是否在 supervisor 启动的时候自动启动进程</span><br><span class="line">autostart=true</span><br><span class="line"></span><br><span class="line"># 当进程在 running 状态下 exit 时，是否自动重启</span><br><span class="line">autorestart=true</span><br><span class="line"></span><br><span class="line"># 这里一定要填对，如果你是用 Laravel 执行队列任务，那跟我填的一样就可以，如果你执行其他任务，请填写所属的用户组，不然会有权限问题</span><br><span class="line">user=www-data</span><br><span class="line"></span><br><span class="line"># 启动多少个子进程，一般启动 1 个就够了</span><br><span class="line">numprocs=1</span><br><span class="line"></span><br><span class="line"># 设置为 true 时，将进程报错的输出内容写到 supervisor 的输出文件 stdout 里，建议为 true，这样报错了可以查错误信息</span><br><span class="line">redirect_stderr=true</span><br></pre></td></tr></table></figure><blockquote><p>注意把上面的 myproject 替换成自己项目的路径</p></blockquote><p>保存好配置文件后，就可以启动 supervisor 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种方法皆可启动 supervisor</span><br><span class="line"></span><br><span class="line"># 1、指定配置文件的方式启动 supervisor（推荐）</span><br><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line"></span><br><span class="line"># 2、服务的方式启动</span><br><span class="line">systemctl start supervisord</span><br></pre></td></tr></table></figure><p>执行成功的情况下，你会看到如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unlinking stale socket /var/run/supervisor.sock</span><br></pre></td></tr></table></figure><p>如果不是这个信息，说明你的配置文件有问题，检查一下 <code>command</code> 和 <code>directory</code> 路径是否填写正确，99% 启动不成功都是这两个字段填写不正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 进程</span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line"># 可以看到下面的输出结果</span><br><span class="line">myproject:myprogram                 RUNNING   pid 17, uptime 0:01:40</span><br></pre></td></tr></table></figure><p>显示为 <code>RUNNING</code> 则说明正常运行，如果不是这个状态就是配置文件出错了。</p><p>如果修改了配置文件，或者创建了新的配置文件，需要重载才能读取到新的配置，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重新读取配置文件</span><br><span class="line">supervisorctl reread</span><br><span class="line"></span><br><span class="line"># 更新运行状态</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h2 id="Laravel-队列任务无法写入-Log-日志问题"><a href="#Laravel-队列任务无法写入-Log-日志问题" class="headerlink" title="Laravel 队列任务无法写入 Log 日志问题"></a>Laravel 队列任务无法写入 Log 日志问题</h2><p>用 supervisor 执行队列任务时发现 Laravel 的日志系统 Log 竟然无法写入日志文件，查了下也没有任何报错信息，问题的原因是所在用户组没有权限。</p><p>也就是配置文件中的，user 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=www-data</span><br></pre></td></tr></table></figure><p>这里一定要填写运行程序的用户组，比如 PHP 的用户组是 <code>www-data</code>，如果你填的是 <code>root</code>，这样就没有权限操作日志文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Supervisord </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序猿提升自我修养的网站推荐</title>
      <link href="/2020/03/09/programmer-recommend-website/"/>
      <url>/2020/03/09/programmer-recommend-website/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为程序猿，阅读其他人分享的技术文章除了学习新的技术之外，对于提升自己的思维能力也有很大的帮助。比起自己摸爬滚打尝试出来所耗费的时间，也许别人一句简单的提醒就能使你豁然开朗。</p><p>当然，对于一些刚刚入坑的新人来说，也许依赖别人不是一个好的建议，自己摸索可以提升自学能力，作为新入道途的小司机来说，在听取别人的建议后，别忘了加入自己的思考。</p><p>对老司机老说，关键的学习能力和处理问题的能力已经在日常业务中得到锻炼，与其不断摸索不如听取建议以最快的速度解决问题。然后再细细回味其中的道理。</p><p>下面推荐一些自己平时经常去的论坛或社区，自己在早晨上班的时候都会花 30 分钟左右去阅（mo）读（yu）别人分享的文章，虽然不一定能学到什么，但这种无差别的阅读会成为你知识的积淀，说不定在哪一刻你突然听到同事谈到某个专业术语，你会惊奇的发现——这不是我早上读的那篇文章提到的东西吗！？</p><h2 id="前端人员"><a href="#前端人员" class="headerlink" title="前端人员"></a>前端人员</h2><p>前端人员不能满足于当个切图仔只会网页布局和 CSS 样式，JS 用的 JQuery 别的就不懂了。其实现在前后端的区分度已经不大了，从 nodeJS 出现以后，前端的格局就改变了，不要把自己的思维局限在“前端只是做网页样式”而已，如果你还保留这种思想，建议早点舍弃。前端学点后端的思维跟后端学点 HTML、CSS 都是很普通的事情。</p><p>除了 WEB 前端，安卓前端、IOS 前端同理。</p><p>下面的推荐顺序没有排名，纯粹是想到什么就写下来。</p><h3 id="掘金社区"><a href="#掘金社区" class="headerlink" title="掘金社区"></a>掘金社区</h3><p>前端技术有一个比较火的社区，而且里面也有许多大佬，这个社区叫做“掘金”：</p><p>传送门：<a href="https://juejin.im/">大佬之家 - 掘金社区</a></p><p>掘金社区会有大佬发布技术相关的文章，也会有人告诉你面试的技巧 <strong>（还能相亲）</strong> 。</p><p>但是里面有一个地方我建议不要点开，那就是“沸点”，要是沉迷在沸点就跟刷微博差不多了。</p><p>前不久还上线了“掘金小册”，可以将自己的知识进行变现。</p><p>掘金是一个前端大佬云集的地方。</p><h3 id="V2EX"><a href="#V2EX" class="headerlink" title="V2EX"></a>V2EX</h3><p>这也是一个神奇的社区，不过内容比较综合，各种东西都会有，偶尔还有大佬出现，也有人喜欢在这里刷帖摸鱼，鱼龙混杂的地方。</p><p>V2EX 可以让你发现许多黑科技，提升自己的姿势水平，偶尔会有人把自己异想天开的想法发到这里进行讨论，还有一些企业的黑幕（如暴力裁员等黑料）。</p><p>总之，在这里更多的是提升自己的阅历。</p><p>传送门：<a href="https://v2ex.com/">八卦与涨姿势的地方 - V2EX</a></p><p>这个社区的名字究竟是何义至今不明。</p><h3 id="思否-amp-stackOverFlow"><a href="#思否-amp-stackOverFlow" class="headerlink" title="思否 &amp; stackOverFlow"></a>思否 &amp; stackOverFlow</h3><p>思否是国内比较大的交流讨论社区，应该是致敬国外的 stackOverFlow，从 UI 看起来两者非常相似。</p><p>可以把思否当做国内版的 stackOverFlow。</p><p>先来介绍国外的 stackOverFlow。</p><p>传送门：<a href="https://stackoverflow.com/">解决问题的宝库 - stackOverFlow</a></p><p>根据个人阅读的帖子来看，这里主要是解决问题的帖子居多，很多时候你搜索某个报错信息，跳出来的就是这个网站的帖子，而且你经常可以从帖子里找到解决问题的方法。</p><p>所以，这个网站给我的感觉是一个可以帮助你快速查错和解决问题的平台。如果遇到开发上的难题或者不明的报错信息，可以到这个平台上搜索看看（对英文稍有要求），大多数情况下都可以找到解决问题的方法。</p><p>接着是我们国内的思否，个人非常喜欢这个社区，因为这边文章详情页的排版、字体、背景颜色十分协调，可以拥有十分良好的阅读体验。</p><p>传送门：<a href="https://segmentfault.com/">享受阅读的乐趣 - Segmentfault</a></p><p>这个社区同样也有许多解决问题的帖子，同时还有许多分享技术的帖子，也有人把这个平台当做了自己个人博客记录的地方。</p><p>思否上面提供了“视频课程”，价格上来看还算蛮便宜的，比起报培训班流水线式的作业，倒不如拿那些钱支持一些真正有技术的作者。</p><h2 id="后端人员"><a href="#后端人员" class="headerlink" title="后端人员"></a>后端人员</h2><p>其实前面介绍的几个也有后端的文章，后端开发也可以去逛逛。</p><p>因为我的本职是 PHP 开发，所以这里推荐的是偏向 PHP 的社区。</p><h3 id="Laravel-China"><a href="#Laravel-China" class="headerlink" title="Laravel - China"></a>Laravel - China</h3><p>现在更名为 LearnKu 了，PHP 较为出名的一个社区，也是 Laravel 框架最大的交流论坛之一。</p><p>传送门：<a href="https://learnku.com/">刻意学习，与日精进 - LearnKu</a></p><p>LearnKu 社区是 Summer 个人开发的 Laravel 技术论坛，如今已经扩展了更多的板块，不再局限于 Laravel 或是 PHP 语言，诸如 Python、Java 等语言也拥有独立的板块了。</p><p>LearnKu 里面比较有意思的一个地方是可以翻译国外的文档，然后留下你的大名，虽然本人的英文水平不咋样，但是也曾翻译过几篇文章的段落，成就感十足！</p><p>除此之外，个人感觉要学习 Laravel 框架的话，首选 LearnKu，因为这里有最全、最新的 Laravel 文档（并且阅读体验良好）。</p><p>LearnKu 的前身 Laravel - China 曾经是国内最早一批提供 Composer 国内镜像源的地方，个人感觉 Summer 在推动 Laravel 框架在国内的推广做出了十分巨大的贡献，如果没有翻译国外的文档和提供 Composer 国内镜像源，想要入门这个“优雅”的框架可不容易。</p><p>LearnKu 是集文档、技术分享、问题提问的综合社区，想要入门 Laravel 的萌新，选择 LearnKu 准没错！</p><p>LearnKu 这个名字听起来怪怪的，难道是 learn Kungfu 的缩写！？</p><h3 id="Laravel-学院"><a href="#Laravel-学院" class="headerlink" title="Laravel 学院"></a>Laravel 学院</h3><p>现在改名为学院君（感觉之前的名字更好）。</p><p>Laravel 学院也是学习 Laravel 的好去处，只不过这里比较偏向于查阅资料的地方，虽然提供了“问题”的板块，但是讨论的氛围还是偏向于冷清。</p><p>传送门：<a href="https://xueyuanjun.com/">优质的 Laravel 中文学习资料 - 学院君</a></p><p>Laravel 学院也为 Laravel 在国内的推广做出了重要贡献，在搜索 Laravel 相关问题的时候，经常能搜到 Laravel 学院的网站，而且从中找到解决问题的方法。</p><p>所以，个人感觉 Laravel 学院偏向于查资料与搜索问题。</p><p>本站点的起源本人尚不清楚，但是从文档的分享者来看居然全部都是同一个人——学院君。</p><p>只凭借网站本身的力量竟然能够整理出如此众多的文档，令人钦佩。</p><p>Laravel 学院除了文档之外，还有项目的实践教程，而且每一步都十分详细甚至还有配图，萌新想学不会都难！</p><h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p>一个略微神奇的网站，咋看之下是文人墨客记录生活情感的地方，然而程序猿却在这开辟出一片属于自己的天地。</p><p>传送门：<a href="https://www.jianshu.com/">众多教程 - 简书</a></p><p>简书上面记录得比较多的是一些软件的安装教程和使用方法。</p><p>目前开通了钻石系统，口号是：“能让创作变现”。</p><p>如果有技术大佬喜欢写文章的，可以到这个平台试试，分享技术还能赚点小钱，不亦乐乎！</p><p>简书有不少女性作家，说不定还有意外的邂逅（笑）。</p><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p>“你们以后找工作，如果面试官问你经常去看哪些网站，你就说 CSDN。”</p><p>这是我大学老师跟我们说的一句话。</p><p>但是现在，我去面试的时候是绝对不会提 CSDN 的。</p><p>因为它已经完全变质了，也许在我老师的那个年代这是一个大神聚集的社区，但如今在我看来，它只不过是一个盗版成灾的地方，而且百度给的权重还很高，CSDN 的搜索结果总是置于前几名。</p><p>这里把 CSDN 列举出来是为了点名批评的。</p><p>盗版文章是对原作者版权不尊重；其次，我们搜索问题是为了找到解决方法的，但是 CSDN 盗版的文章经常还存在重复，造成我们搜索结果里面有很多条都是 CSDN 的文章而且还不能解决问题，CSDN 出现在搜索结果里大大增加了我们解决问题的时间成本。</p><blockquote><p>小技巧：使用百度搜索时在关键词后面加上 -csdn 可以排除所有 CSDN 网站的结果</p></blockquote><p>CSDN 做的恶不仅仅只是盗版文章。</p><p>还有盗版资源。</p><p>相信大家都有这样的体验：在百度搜索一个资源时，跳出的是 CSDN 的下载地址，点进去发现还要积分。而这些资源大都是从其他技术分享者那里拿到的，转手就成为了谋取利益的手段。</p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer配置参数详解</title>
      <link href="/2020/03/08/composer-config/"/>
      <url>/2020/03/08/composer-config/</url>
      
        <content type="html"><![CDATA[<h2 id="composer-json"><a href="#composer-json" class="headerlink" title="composer.json"></a>composer.json</h2><p>Composer 使用配置文件 <code>composer.json</code> 来指明依赖关系或者包信息。</p><p>一个简单的 <code>composer.json</code> 配置文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;require-dev&quot;: &#123;</span><br><span class="line">    &quot;robmorgan/phinx&quot;: &quot;^0.10.8&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\Library\\&quot;: &quot;application/library&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发配置项"><a href="#开发配置项" class="headerlink" title="开发配置项"></a>开发配置项</h2><p>如果你不打算将自己的包开源，或者这个配置文件并不是一个库，而是你的项目依赖第三方包的配置文件，那么许多字段都是不需要用到的，以下是几个比较核心的配置字段。</p><h3 id="require-项目依赖关系"><a href="#require-项目依赖关系" class="headerlink" title="require : 项目依赖关系"></a>require : 项目依赖关系</h3><p>执行 <code>composer install</code> 或者 <code>composer update</code> 将会下载依赖的包。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们声明了我们需要下载安装的包 <code>phpmailer/phpmailer</code> 和对应的版本信息 <code>^6.0</code>。</p><p><code>require</code> 也可以用来指明 PHP 的版本信息。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">   &quot;php&quot;: &quot;&gt;=5.5.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它要求使用者的 PHP 版本至少是 5.5.0 以上的。</p><h3 id="require-dev-只在开发环境的依赖"><a href="#require-dev-只在开发环境的依赖" class="headerlink" title="require-dev : 只在开发环境的依赖"></a>require-dev : 只在开发环境的依赖</h3><p>有时候，我们可能需要一些帮助我们调试的第三方包，但是线上环境并不需要用到这些包，这个时候可以将它们放在 <code>require-dev</code> 中进行声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require-dev&quot;: &#123;</span><br><span class="line">    &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线上环境</strong>在执行 <code>composer install</code> 或者 <code>composer update</code> 的时候，<strong>需要添加 <code>--no-dev</code> 参数</strong>来跳过 <code>require-dev</code> 依赖的包。</p><p>如果直接使用 <code>composer install</code>，则 <code>require-dev</code> 依赖的包也会被安装。</p><h3 id="autoload-自动加载"><a href="#autoload-自动加载" class="headerlink" title="autoload : 自动加载"></a>autoload : 自动加载</h3><p>通过配置 <code>autoload</code> 可以实现类的自动加载。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\Library\\&quot;: &quot;application/library&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用了 <code>psr-4</code> 的自动加载规范来加载 <code>library</code> 中的类。</p><p>除了 <code>psr-4</code> 还有几种可选的类型：</p><ul><li>psr-0</li><li>classmap</li><li>files</li></ul><h3 id="repositories-仓库地址"><a href="#repositories-仓库地址" class="headerlink" title="repositories : 仓库地址"></a>repositories : 仓库地址</h3><p>声明依赖所在仓库的地址，默认情况下使用 Packagist 官方网站：<a href="https://packagist.org./">https://packagist.org。</a></p><p>国内镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 阿里</span><br><span class="line">https://mirrors.aliyun.com/composer</span><br><span class="line"></span><br><span class="line">// Composer 中文网</span><br><span class="line">https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><p>此外，还可以搭建自己的仓库地址。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mirrors.aliyun.com/composer/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>支持以下类型（type）的包资源库：</p><ul><li>composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和&#x2F;或 source 信息。这个 packages.json 文件是用一个 PHP 流加载的。你可以使用 options 参数来设定额外的流信息。</li><li>vcs: 从 git、svn 和 hg 取得资源。</li><li>pear: 从 pear 获取资源。</li><li>package: 如果你依赖于一个项目，它不提供任何对 composer 的支持，你就可以使用这种类型。你基本上就只需要内联一个 composer.json 对象。</li></ul><h2 id="开源项目配置项"><a href="#开源项目配置项" class="headerlink" title="开源项目配置项"></a>开源项目配置项</h2><p>如果你的包希望上传到 Packagist 提供给他人使用，需要提供包的基本信息，如作者、包的描述等等。</p><p>一个开源的项目，<a href="https://github.com/PHPMailer/PHPMailer/blob/master/composer.json">PHPMailer</a> 的配置文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;phpmailer/phpmailer&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;library&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;PHPMailer is a full-featured email creation and transfer class for PHP&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Marcus Bointon&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;phpmailer@synchromedia.co.uk&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Jim Jagielski&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;jimjag@gmail.com&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Andy Prevost&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;codeworxtech@users.sourceforge.net&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Brent R. Matzelle&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;php&quot;: &quot;&gt;=5.5.0&quot;,</span><br><span class="line">        &quot;ext-ctype&quot;: &quot;*&quot;,</span><br><span class="line">        &quot;ext-filter&quot;: &quot;*&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;require-dev&quot;: &#123;</span><br><span class="line">        &quot;friendsofphp/php-cs-fixer&quot;: &quot;^2.2&quot;,</span><br><span class="line">        &quot;phpdocumentor/phpdocumentor&quot;: &quot;2.*&quot;,</span><br><span class="line">        &quot;phpunit/phpunit&quot;: &quot;^4.8 || ^5.7&quot;,</span><br><span class="line">        &quot;zendframework/zend-serializer&quot;: &quot;2.7.*&quot;,</span><br><span class="line">        &quot;doctrine/annotations&quot;: &quot;1.2.*&quot;,</span><br><span class="line">        &quot;zendframework/zend-eventmanager&quot;: &quot;3.0.*&quot;,</span><br><span class="line">        &quot;zendframework/zend-i18n&quot;: &quot;2.7.3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;suggest&quot;: &#123;</span><br><span class="line">        &quot;psr/log&quot;: &quot;For optional PSR-3 debug logging&quot;,</span><br><span class="line">        &quot;league/oauth2-google&quot;: &quot;Needed for Google XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;hayageek/oauth2-yahoo&quot;: &quot;Needed for Yahoo XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;stevenmaguire/oauth2-microsoft&quot;: &quot;Needed for Microsoft XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;ext-mbstring&quot;: &quot;Needed to send email in multibyte encoding charset&quot;,</span><br><span class="line">        &quot;symfony/polyfill-mbstring&quot;: &quot;To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;PHPMailer\\PHPMailer\\&quot;: &quot;src/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;autoload-dev&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;PHPMailer\\Test\\&quot;: &quot;test/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;license&quot;: &quot;LGPL-2.1-only&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="name-包名"><a href="#name-包名" class="headerlink" title="name : 包名"></a>name : 包名</h3><p>包的名称，它包括供应商名称和项目名称，使用 &#x2F; 分隔，左边为供应商名称，右边为项目名称。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monolog/monolog</span><br><span class="line">igorw/event-source</span><br></pre></td></tr></table></figure><p>对于需要发布的包（库），这是必须填写的。</p><h3 id="description-描述"><a href="#description-描述" class="headerlink" title="description : 描述"></a>description : 描述</h3><p>一个包的简短描述，通常用来描述包的功能，最长只有一行。</p><p>对于需要发布的包（库），这是必须填写的。</p><h3 id="version-版本"><a href="#version-版本" class="headerlink" title="version : 版本"></a>version : 版本</h3><p>version 不是必须的，并且建议忽略。</p><p>它应该符合 ‘X.Y.Z’ 或者 ‘vX.Y.Z’ 的形式， -dev、-patch、-alpha、-beta 或 -RC 这些后缀是可选的。在后缀之后也可以再跟上一个数字。</p><p>示例：</p><ul><li>1.0.0</li><li>1.0.2</li><li>1.0.0-dev</li><li>1.0.0-alpha3</li><li>1.0.0-beta2</li><li>1.0.0-RC5</li></ul><h3 id="type-安装类型"><a href="#type-安装类型" class="headerlink" title="type : 安装类型"></a>type : 安装类型</h3><p>包的安装类型，默认为 library。</p><p>composer 原生支持以下4种类型：</p><ul><li>library: 这是默认类型，它会简单的将文件复制到 vendor 目录。</li><li>project: 这表示当前包是一个项目，而不是一个库。例：框架应用程序 Symfony standard edition，内容管理系统 SilverStripe installer 或者完全成熟的分布式应用程序。使用 IDE 创建一个新的工作区时，这可以为其提供项目列表的初始化。</li><li>metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。</li><li>composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。详细请查看 自定义安装类型。<br>仅在你需要一个自定义的安装逻辑时才使用它。建议忽略这个属性，采用默认的 library。</li></ul><h3 id="keywords-关键字"><a href="#keywords-关键字" class="headerlink" title="keywords : 关键字"></a>keywords : 关键字</h3><p><strong>非必选，但建议填写。</strong> 该包相关的关键词的数组，可用于搜索和过滤，相当于在 composer 中的 SEO，有助于让更多的人搜索到你的包。</p><h3 id="homepage-项目主页"><a href="#homepage-项目主页" class="headerlink" title="homepage : 项目主页"></a>homepage : 项目主页</h3><p>该项目网站的 URL 地址，可选。</p><h3 id="time-版本发布时间"><a href="#time-版本发布时间" class="headerlink" title="time : 版本发布时间"></a>time : 版本发布时间</h3><p>必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式，可选。</p><h3 id="license-许可协议"><a href="#license-许可协议" class="headerlink" title="license : 许可协议"></a>license : 许可协议</h3><p>包的许可协议，它可以是一个字符串或者字符串数组。</p><p>最常见的许可协议的推荐写法：</p><ul><li>Apache-2.0</li><li>BSD-2-Clause</li><li>BSD-3-Clause</li><li>BSD-4-Clause</li><li>GPL-2.0</li><li>GPL-2.0+</li><li>GPL-3.0</li><li>GPL-3.0+</li><li>LGPL-2.1</li><li>LGPL-2.1+</li><li>LGPL-3.0</li><li>LGPL-3.0+</li><li>MIT</li></ul><p>可选，但强烈建议提供此内容。</p><h3 id="authors-作者"><a href="#authors-作者" class="headerlink" title="authors : 作者"></a>authors : 作者</h3><p>包的作者，这是一个对象数组。</p><p>这个对象必须包含以下属性：</p><ul><li>name: 作者的姓名，通常使用真名。</li><li>email: 作者的 email 地址。</li><li>homepage: 作者主页的 URL 地址。</li><li>role: 该作者在此项目中担任的角色（例：开发人员 或 翻译）。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Nils Adermann&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;naderman@naderman.de&quot;,</span><br><span class="line">            &quot;homepage&quot;: &quot;http://www.naderman.de&quot;,</span><br><span class="line">            &quot;role&quot;: &quot;Developer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Jordi Boggiano&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;j.boggiano@seld.be&quot;,</span><br><span class="line">            &quot;homepage&quot;: &quot;http://seld.be&quot;,</span><br><span class="line">            &quot;role&quot;: &quot;Developer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选，但强烈建议提供此内容。</p><h3 id="support-支持信息"><a href="#support-支持信息" class="headerlink" title="support : 支持信息"></a>support : 支持信息</h3><p>获取项目支持的向相关信息对象。</p><p>这个对象必须包含以下属性：</p><ul><li>email: 项目支持 email 地址。</li><li>issues: 跟踪问题的 URL 地址。</li><li>forum: 论坛地址。</li><li>wiki: Wiki 地址。</li><li>irc: IRC 聊天频道地址，类似于 irc:&#x2F;&#x2F;server&#x2F;channel。</li><li>source: 网址浏览或下载源。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;support&quot;: &#123;</span><br><span class="line">        &quot;email&quot;: &quot;support@example.org&quot;,</span><br><span class="line">        &quot;irc&quot;: &quot;irc://irc.freenode.org/composer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选。</p><h3 id="minimum-stability-root-only"><a href="#minimum-stability-root-only" class="headerlink" title="minimum-stability (root-only)"></a>minimum-stability (root-only)</h3><p>这定义了通过稳定性过滤包的默认行为。默认为 stable（稳定）。因此如果你依赖于一个 dev（开发）包，你应该明确的进行定义。</p><p>对每个包的所有版本都会进行稳定性检查，而低于 minimum-stability 所设定的最低稳定性的版本，将在解决依赖关系时被忽略。对于个别包的特殊稳定性要求，可以在 require 或 require-dev 中设定。</p><p>可用的稳定性标识：dev、alpha、beta、RC、stable。</p><h3 id="prefer-stable-root-only"><a href="#prefer-stable-root-only" class="headerlink" title="prefer-stable (root-only)"></a>prefer-stable (root-only)</h3><p>当此选项被激活时，Composer 将优先使用更稳定的包版本。</p><p>使用 “prefer-stable”: true 来激活它。</p>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始开发自己的Composer包</title>
      <link href="/2020/03/08/composer-package/"/>
      <url>/2020/03/08/composer-package/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 <code>composer</code> 的时候，我们几乎都是在用其他人分享出来的包，久而久之，难免会产生开发自己包的想法，不仅可以加深对 <code>composer</code> 的理解程度，同时还可以把自己常用的功能封装起来，作为自己的“小金库”储备起来。</p><blockquote><p>使用 <code>composer</code> 开发依赖包是一项非常考验能力的事情，它涉及到一个微型系统的架构，阅读<strong>设计模式</strong>有助于帮助我们开发一个优秀的 <code>composer</code> 依赖包。</p></blockquote><h2 id="开发自己的第一个-Composer-包"><a href="#开发自己的第一个-Composer-包" class="headerlink" title="开发自己的第一个 Composer 包"></a>开发自己的第一个 Composer 包</h2><p><code>composer.json</code> 是 <code>composer</code> 的基础，文件夹目录下存在 <code>composer.json</code> 文件，那么这个文件夹就是一个<strong>资源包</strong>。</p><p>我们可以手动创建 <code>composer.json</code> 文件，不过，我们推荐使用 <code>composer init</code> 命令。</p><blockquote><p>composer init 命令帮助我们自动生成 composer.json，文件可以修改，不必担心按错了什么会产生不好的影响。</p></blockquote><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p><code>composer.json</code> 配置项的字段较多，后续步骤如果对配置文件的字段抱有疑问，可以返回此处查看：<a href="/composer-config">composer.json 详解</a>。</p><p>现在，不需要了解这些。</p><h3 id="创建包目录"><a href="#创建包目录" class="headerlink" title="创建包目录"></a>创建包目录</h3><p>我们的操作是在命令行界面操作的，如果是 Windows 系统，则需要进入 CMD 界面，进入到你的工作磁盘目录下，使用快捷键 <code>Shift + 鼠标右键</code>，在菜单栏中选择进入命令行（DOS 界面）。</p><p>首先，我们需要创建一个包的目录 <code>packagist</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Mac OS 系统</span><br><span class="line">mkdir packagist</span><br><span class="line"></span><br><span class="line"># Windows 系统(可以直接右键创建）</span><br><span class="line">md packagist</span><br><span class="line"></span><br><span class="line"># 创建完成后进入文件夹</span><br><span class="line">cd packagist</span><br></pre></td></tr></table></figure><h3 id="输入包的名字"><a href="#输入包的名字" class="headerlink" title="输入包的名字"></a>输入包的名字</h3><p>在 <code>packagist </code> 目录下，执行 <code>composer init</code>，<code>composer</code> 会提示我们设置配置参数信息，如下图：</p><p><img src="https://i.loli.net/2019/08/24/NSPn6GYuE83jcs1.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package name (&lt;vendor&gt;/&lt;name&gt;) [firerabbit/packagist]:</span><br></pre></td></tr></table></figure><p>提示让你输入包的名字，格式为 <code>&lt;vendor&gt;/&lt;name&gt;</code>，<code>vendor</code> 为服务商名字，个人开发可以使用自己在 GitHub 中使用的昵称，<code>name</code> 为包的名字，<code>&lt;vendor&gt;/&lt;name&gt;</code> 不能存在同名，这里设置的名字即后面使用 <code>composer require</code> 的名字。</p><p>中括号内的 <code>[firerabbit/packagist]</code> 是默认值，直接按回车的话就会使用这个名字。</p><h3 id="输入包的描述信息"><a href="#输入包的描述信息" class="headerlink" title="输入包的描述信息"></a>输入包的描述信息</h3><p>包名输入完成后，接下来需要设置 <code>Description</code> （描述）字段，这个字段是包的功能性描述，作为练习包就随便输入啦：</p><p><img src="https://i.loli.net/2019/08/24/y6EWBMhGbZ1V3Qt.png" alt="image.png"></p><h3 id="输入作者信息"><a href="#输入作者信息" class="headerlink" title="输入作者信息"></a>输入作者信息</h3><p>接下来设置 <code>Author</code> (作者信息)，格式为 <code>name example@email.com</code>，输入 n 可以跳过：</p><p><img src="https://i.loli.net/2019/08/24/V7UsaPQpm5LyKqu.png" alt="image.png"></p><h3 id="minimum-stability-最小稳定版本"><a href="#minimum-stability-最小稳定版本" class="headerlink" title="minimum-stability 最小稳定版本"></a>minimum-stability 最小稳定版本</h3><p>通过设置 <code>minimum-stability</code> 的值，来告诉 <code>Composer</code> 当前开发的项目的依赖要求的包的全局稳定性级别，它的值包括：dev、alpha、beta、RC、stable，stable 是默认值。</p><p><img src="https://i.loli.net/2019/08/24/IFecMfkGXYgWU9T.png" alt="image.png"></p><p>稳定性介绍：<a href="https://learnku.com/php/t/9929/understanding-composers-stability-stability-identity">理解 Composer 的稳定性（Stability）标识</a></p><p>我们直接按回车默认值即可。</p><h3 id="Package-Type-包类型"><a href="#Package-Type-包类型" class="headerlink" title="Package Type 包类型"></a>Package Type 包类型</h3><p>接下来设置包的类型：</p><p><img src="https://i.loli.net/2019/08/24/4PMEiWuaXIb2Zyd.png" alt="image.png"></p><p>composer 原生支持以下4种类型：</p><ul><li>library: 默认类型，它会简单的将文件复制到 vendor 目录。</li><li>project: 一个项目，而不是一个库。</li><li>metapackage: 空的包，包含依赖并且需要触发依赖的安装。</li><li>composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。</li></ul><p>这里我们直接按回车，采用默认的 library。</p><h3 id="License-许可协议"><a href="#License-许可协议" class="headerlink" title="License 许可协议"></a>License 许可协议</h3><p>接下来输入包的许可协议：</p><p><img src="https://i.loli.net/2019/08/24/UW2StviLwyIO9ef.png" alt="image.png"></p><p>包的许可协议，它可以是一个字符串或者字符串数组。</p><p>最常见的许可协议的推荐写法：</p><ul><li>Apache-2.0</li><li>BSD-2-Clause</li><li>BSD-3-Clause</li><li>BSD-4-Clause</li><li>GPL-2.0</li><li>GPL-2.0+</li><li>GPL-3.0</li><li>GPL-3.0+</li><li>LGPL-2.1</li><li>LGPL-2.1+</li><li>LGPL-3.0</li><li>LGPL-3.0+</li><li>MIT</li></ul><p>这里我们输入 MIT （开源许可协议）。</p><h3 id="定义依赖项"><a href="#定义依赖项" class="headerlink" title="定义依赖项"></a>定义依赖项</h3><p>接下来设置依赖项：</p><p><img src="https://i.loli.net/2019/08/24/6iHFcMvR8UK7o2O.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Define your dependencies.</span><br><span class="line"></span><br><span class="line">Would you like to define your dependencies (require) interactively [yes]?</span><br></pre></td></tr></table></figure><p>我们的练习项目不需要设置此项，输入 no。</p><h3 id="dev-依赖项"><a href="#dev-依赖项" class="headerlink" title="dev 依赖项"></a>dev 依赖项</h3><p>设置 dev 环境依赖项：</p><p><img src="https://i.loli.net/2019/08/24/LEelWoaq4dwNts2.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like to define your dev dependencies (require-dev) interactively [yes]?</span><br></pre></td></tr></table></figure><p>同上，输入 no。</p><h3 id="最后一步：确认信息"><a href="#最后一步：确认信息" class="headerlink" title="最后一步：确认信息"></a>最后一步：确认信息</h3><p>最后一步，确认包的信息：</p><p><img src="https://i.loli.net/2019/08/24/fDkiBObK9QXo1aJ.png" alt="image.png"></p><p>输入 yes，回车，然后查看当前目录即可看到 <code>composer.json</code> 文件。</p><p><code>composer init</code> 命令帮助你自动生成文件，实际上你可以直接在<strong>包的目录下</strong>创建 <code>composer.json</code>，并且输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;huotu/test&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个包。&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;火兔兔子&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上两种方式都是一样的。</p><h2 id="依赖包的基本结构"><a href="#依赖包的基本结构" class="headerlink" title="依赖包的基本结构"></a>依赖包的基本结构</h2><p>一个 <code>composer</code> 依赖包的基本结构，以我们上面的 <code>packagist</code> 为例：</p><ul><li>packagist<ul><li>src<ul><li>类文件</li><li>…</li></ul></li><li>tests<ul><li>单元测试文件</li><li>…</li></ul></li><li>README.md</li><li>composer.json</li><li>LICENSE</li></ul></li></ul><h3 id="src-文件夹"><a href="#src-文件夹" class="headerlink" title="src 文件夹"></a>src 文件夹</h3><p><code>src</code> 是包所在的路径，一般我们都会将其命名为 <code>src</code>（业界共识），不建议改成其他的名字。</p><p>开发包的工作就是在这个目录下进行的，你可以在这个目录下创建更多的文件夹来划分不同功能的类。</p><h3 id="tests-文件夹"><a href="#tests-文件夹" class="headerlink" title="tests 文件夹"></a>tests 文件夹</h3><p><code>tests</code> 文件夹用来存放单元测试的，如果你不写的话，这个文件夹可以不要。</p><h3 id="README-md-文件"><a href="#README-md-文件" class="headerlink" title="README.md 文件"></a>README.md 文件</h3><p><code>README.md</code> 是包描述的 Markdown 语法的介绍文档，在 GitHub 中将会自动解析这个文件并且展示出来，每一个包都<strong>应该</strong>要包含 <code>README.md</code> 文件，用来介绍这个包的基本信息和操作方法。</p><p>创建 <code>README.md</code> 文件的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Mac OS</span><br><span class="line">vim README.md</span><br><span class="line"></span><br><span class="line"># Windows 系统</span><br><span class="line">创建 README.txt，保存后改成 .md</span><br><span class="line">如需编辑，右键以文本文档打开即可</span><br></pre></td></tr></table></figure><h3 id="composer-json-文件"><a href="#composer-json-文件" class="headerlink" title="composer.json 文件"></a>composer.json 文件</h3><p>包的配置信息。</p><h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p>许可协议文本，文本格式。</p><p>练习项目中，我们只需要 <code>src</code> 和 <code>README.md</code> 即可。</p><p>推荐使用 <code>PHPstorm</code> 作为编辑工具，最后我们的包目录结构如图所示：</p><p><img src="https://i.loli.net/2019/08/24/he9UfyOz2W6Z5Qi.png" alt="image.png"></p><h2 id="配置自动加载规则"><a href="#配置自动加载规则" class="headerlink" title="配置自动加载规则"></a>配置自动加载规则</h2><p>为了防止命名空间冲突，开发的包需要配置自动加载，修改 <code>composer.json</code> 添加 <code>autoload</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;Huotu\\Test\\&quot;: &quot;src/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们采用 <code>psr-4</code> 的规范来自动加载包目录下 <code>src</code> 文件夹内的类文件，这里的 <code>&quot;Huotu\\Test\\&quot;</code> 是我们使用的命名空间，<code>\\</code> 不能写成 <code>\</code>，一般而言，命名空间以包的名字来命名。</p><p>完整的 <code>composer.json</code> 配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;huotu/test&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个包。&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;火兔兔子&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;&#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;Huotu\\Test\\&quot;: &quot;src/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建包的类文件"><a href="#创建包的类文件" class="headerlink" title="创建包的类文件"></a>创建包的类文件</h3><p>在 <code>src</code> 目录下创建 <code>Robot.php</code> 文件，我们希望写一个可以自动打招呼的机器人（类）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Huotu\Test;</span><br><span class="line"></span><br><span class="line">class Robot</span><br><span class="line">&#123;</span><br><span class="line">    public function sayHello($name) &#123;</span><br><span class="line">        echo &#x27;hello,&#x27; . $name . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了一个依赖包的开发，使用者只需要引入这个包就可以调用 <code>Robot</code> 的 <code>sayHello</code> 方法。</p><h2 id="测试包的功能"><a href="#测试包的功能" class="headerlink" title="测试包的功能"></a>测试包的功能</h2><p>我们现在已经写好了一个包，但是开发过程以及准备发布的时候，我们都需要对功能进行调试，你可以在目录下创建一个 <code>test.php</code>，然后运行 <code>php test.php</code> 来测试，不过这样总是不太方便的，尤其是某些有其他依赖的操作（如需要连接数据库、Redis）等等。最好的方法是将包文件放在一个真实的项目里进行测试，下面模拟创造一个 <code>project</code> 来作为我们实际的项目。</p><p>在 <code>packagist</code> 同级目录下，创建一个文件夹 <code>project</code>。</p><p>由于我们本地开发的包并未上传的 Packagist，无法通过 <code>composer require</code> 进行安装，因此我们必须手动配置加载目录，进入 project 文件夹，创建 <code>composer.json</code>：</p><ul><li>project<ul><li>composer.json</li></ul></li></ul><p>编辑 <code>composer.json</code>，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;Huotu\\Test\\&quot;: &quot;../packagist/src/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后，我们需要执行 <code>composer dump-autoload</code> 来生成自动加载文件。</p><blockquote><p>如果对依赖包添加了新的类或者删除了类，涉及到类文件数量、名称改变的，都需要重新执行 composer dump-autoload，否则无法读取到最新的类文件</p></blockquote><p>执行完成后，在当前目录下生成了 <code>vendor</code> 文件夹，这个文件夹里即包含了我们依赖包的自动加载信息。</p><p><img src="https://i.loli.net/2019/08/24/nCVmNxviFpfJUw5.png" alt="image.png"></p><p>接着一个文件用来测试结果 <code>test.php</code>：</p><ul><li>project<ul><li>composer.json</li><li>test.php</li><li>vendor<ul><li>composer<ul><li>…</li></ul></li><li>autoload.php</li></ul></li></ul></li></ul><p>输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">require &#x27;./vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">use Huotu\Test\Robot;</span><br><span class="line"></span><br><span class="line">$robot = new Robot();</span><br><span class="line">$robot-&gt;sayHello(&#x27;IDCE.COM&#x27;);</span><br></pre></td></tr></table></figure><p>终端中输入 <code>php test.php</code> 执行结果：</p><p><img src="https://i.loli.net/2019/08/24/BYavLTK2W9JDncZ.png" alt="image.png"></p><p>可以看到我们成功调用自己开发的包了！</p><p>必须将 <code>autoload</code> 引入才能实现自动加载，如果提示找不到类可能就是没有正确引入的关系或者 <code>composer.json</code> 配置的 <code>psr-4</code> 路径不正确。</p><h2 id="上传到-GitHub"><a href="#上传到-GitHub" class="headerlink" title="上传到 GitHub"></a>上传到 GitHub</h2><p>开发完成后，我们需要把包文件上传到 <a href="https://github.com/">GitHub</a>，如果没有账号则注册一个。</p><p>进入个人主页，在左侧的 Repositories（仓库）选择 New 创建一个新的仓库：</p><p><img src="https://i.loli.net/2019/08/24/ISdkXipUAeLfv2c.png" alt="image.png"></p><p>仓库信息，权限要选择 <code>public</code>（公开的），完成后点击 <code>Create repository</code>：</p><p><img src="https://i.loli.net/2019/08/24/FuyLgqBpdAH3W8R.png" alt="image.png"></p><p>创建好的项目：</p><p><img src="https://i.loli.net/2019/08/24/WZdpEtnvL3qCeVX.png" alt="image.png"></p><p>GitHub 十分友好的提示了上传文件的步骤，我们只需要执行以下几个步骤即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/huoshaotuzi/test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>返回 <code>packagist</code> 目录下，我们按照 GitHub 上提示的内容，执行 <code>git init</code>，并添加文件：</p><p><img src="https://i.loli.net/2019/08/24/B1vg4hK95lz2VkC.png" alt="image.png"></p><blockquote><p>注！由于 ide 产生的文件是必须添加 .gitigonre 排除的</p></blockquote><p>然后添加上传的仓库信息，并执行 <code>push</code> 推送到 GitHub 的仓库：</p><p><img src="https://i.loli.net/2019/08/24/FK5Gz1rpVluQLgn.png" alt="image.png"></p><p>返回 GitHub 仓库，刷新页面即可看到上传文件的信息：</p><p><img src="https://i.loli.net/2019/08/24/IbWEe8VnKwmZhCP.png" alt="image.png"></p><h2 id="上传到-Packagist"><a href="#上传到-Packagist" class="headerlink" title="上传到 Packagist"></a>上传到 Packagist</h2><p>如果希望自己的包被其他人安装，就需要将包上传到 Packagist 官网上。</p><p>Packagist 官网：<a href="https://packagist.org/">https://packagist.org/</a></p><p><img src="https://i.loli.net/2019/08/24/sX6AxhSyfEC9pVg.png" alt="image.png"></p><p>如果没有账号可以注册一个，或者直接使用 GitHub 登录（推荐）。</p><p>登录后，选择右上角的 <code>Submit</code>（提交）：</p><p><img src="https://i.loli.net/2019/08/24/8zhUPTDwsbOt5fa.png" alt="image.png"></p><p>在提交页面会提示你输入 GitHub 上仓库的地址：</p><p><img src="https://i.loli.net/2019/08/24/GQSMnub7JdOxWjH.png" alt="image.png"></p><p>输入刚才创建的仓库地址，点击 <code>Check</code>：</p><p><img src="https://i.loli.net/2019/08/24/qeuQ6oEsWdLl2cF.png" alt="image.png"></p><p>这边会提示一些同名的包，并且出现了 <code>Submit</code> 按钮，我们直接点击 <code>Submit</code>，此时会进入包页面，<code>update</code> 会进入转圈圈状态，表示正在同步包信息，稍等一会刷新页面即可看到包信息。</p><p>到目前为止，已经将包上传到 Packagist 官网了，但是我们还没有设置版本信息，需要返回到包目录下，给这个包打上标签。</p><p>输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m &quot;初始版本&quot;</span><br><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure><p>然后返回 Packagist 官网，点击 <code>update</code> 同步包信息，然后刷新页面就能看到刚刚提交的版本信息了。</p><p>现在，用户可以使用 <code>composer require</code> 命令下载你的包了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require huotu/test:1.0</span><br></pre></td></tr></table></figure><h2 id="自动同步版本更新"><a href="#自动同步版本更新" class="headerlink" title="自动同步版本更新"></a>自动同步版本更新</h2><p>每次更新包都需要手动点击 <code>update</code> 十分不便，实际上 GitHub 提供了钩子可以用来推送更新信息到 Packagist，默认情况下已经帮助我们打开了自动更新功能。</p><p>回到 GitHub 的仓库地址，选择 <code>Setting</code>，左侧菜单 <code>Webhook</code>，可以看到配置的推送信息：</p><p><img src="https://user-images.githubusercontent.com/28209810/63644830-3432b800-c724-11e9-98c1-8ee55b76825c.png" alt="webhook"></p><p>每当我们推送新的版本标签到 GitHub 时，Packagist 就会接收到一个 GitHub 的 Hook（钩子）发出的 POST 请求，这样 Packagist 上的包就会与 GitHub 上的同步了。</p><p>如果你不需要自动更新功能，可以点击右侧的 <code>Delete</code> 将其删除，删除后每次更新包都要前往 Packagist 点击 <code>Update</code> 手动进行更新。</p><p>开启自动更新情况下，每次 <code>push</code> 标签后都会自动同步到 Packagist，刷新页面即可看到最新提交的版本：</p><p><img src="https://user-images.githubusercontent.com/28209810/63644872-eff3e780-c724-11e9-9507-f722204a1422.png" alt="new version"></p><h2 id="依赖包编写小建议"><a href="#依赖包编写小建议" class="headerlink" title="依赖包编写小建议"></a>依赖包编写小建议</h2><p>开发依赖包需要要丰富的开发经验，可以多参考其他开源包，尤其是具有团队进行维护的，观察他们是如何区分目录和封装类的，可以学到很多知识。</p><p>推荐阅读：<a href="https://learnku.com/docs/php-design-patterns/2018">PHP 设计模式</a></p><p>编写依赖包能得到锻炼和成长的机会，开源自己的包也是一件十分具有成就感的事。</p><blockquote><p>分享，是最好的学习方式 —— IDCE.COM</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密登录原理及方法</title>
      <link href="/2020/03/07/ssh-no-password-method/"/>
      <url>/2020/03/07/ssh-no-password-method/</url>
      
        <content type="html"><![CDATA[<h2 id="SSH-命令"><a href="#SSH-命令" class="headerlink" title="SSH 命令"></a>SSH 命令</h2><p>使用 <code>ssh 用户名@服务器IP</code> 可以连接到服务器，这样做的缺点是每次都要输入密码，一方面是不安全，另一方面是麻烦。</p><h2 id="SSH-免密登录服务器"><a href="#SSH-免密登录服务器" class="headerlink" title="SSH 免密登录服务器"></a>SSH 免密登录服务器</h2><p>在本地主机上使用 <code>ssh-keygen -t rsa</code> 生成密匙对，这里的 <code>-t rsa</code> 指的是用 <code>rsa</code> 加密方式生成密匙：</p><p><img src="https://i.loli.net/2019/08/31/wpMU4vaBQfOoej8.png" alt="image.png"></p><p>第一步，输入密匙存放目录，使用默认路径直接按回车即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>第二步，输入密码，建议直接回车使用空密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p>如果输入了密码则需要再输入一次确认密码。这里的密码不是指远程登录主机的密码，而是使用密匙时的密码，既然我们是希望免密登录了，自然不希望再输入任何密码，因此此处填空即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---[RSA 2048]----+</span><br><span class="line">|    ..    .      |</span><br><span class="line">|    o. . . o     |</span><br><span class="line">|   o...+* +      |</span><br><span class="line">|    .o+*+O       |</span><br><span class="line">|    . =+So+o     |</span><br><span class="line">| . . . @.*B.     |</span><br><span class="line">|  o . . Eoo.     |</span><br><span class="line">|   o   * ..      |</span><br><span class="line">|    ..o o.       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>上面会生成 <code>randomart image</code> 图案，这个图案是根据密匙生成的，因此每个人看到的都不同。</p><blockquote><p>趣味小科普：为什么要生成这种图案呢？这是由于密匙对是一个很长的随机字符串，比起加密的字符串人们更容易接受图片，可以说是很贴心了</p></blockquote><p>生成的密匙包含一对，<strong>公钥和私匙</strong>（<strong>其实叫做私钥</strong>，但感觉这样比较有意思所以就这么写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure><p>我们根据路径可以找到文件所在位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_8_centos ~]# cd /root/.ssh</span><br><span class="line">[root@VM_0_8_centos .ssh]# ls</span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p>这两个密匙文件分别是：</p><ul><li>id_rsa 生成的私钥文件</li><li>id_rsa.pub 生成的公钥文件</li></ul><p>另外一个 <code>authorized_keys</code> 是保存远程免密登录公钥的文件，主要通过这个文件记录多台机器的公钥，我们要做的就是把本机的公钥发送到服务器主机的这个文件里。</p><p>接着，把公钥发到需要登录的服务器主机上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub 服务器IP地址:/root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>接着会要求你输入一次密码，输入完成后就可以实现免密登录了。</p><p>在本机上执行 <code>ssh 用户名@服务器IP</code>，不再需要输入密码验证。</p><h2 id="SSH-添加别名"><a href="#SSH-添加别名" class="headerlink" title="SSH 添加别名"></a>SSH 添加别名</h2><p>网络上的教程一般到上一步就结束了，在这里传授一个小技巧可以事半功倍。</p><p>虽然我们现在跳过了输入密码这个步骤，但是每次都要输入 IP 也是很蛋疼的一件事，<strong>我们甚至想要不输入 IP 就能登录到远程服务器</strong> ？</p><p>这也能做到！</p><p>在本地进入 <code>.ssh</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 进入 .ssh 目录</span><br><span class="line">FireRabbitdeMacBook-Pro:.ssh firerabbit$ cd ~/.ssh</span><br></pre></td></tr></table></figure><p>使用 <code>vim config</code> 编辑文件并且输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host dev</span><br><span class="line">HostName 127.0.0.1</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure><p>这里的 <code>dev</code> 是我们给远程主机起的别名，<code>127.0.0.1</code> 是远程主机的地址，请替换成你的服务器 IP，<code>User</code> 即登录的用户名，<code>Port</code> 为服务器访问端口，如果修改了端口在这里也要修改。</p><p>现在我们的目录应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FireRabbitdeMacBook-Pro:.ssh firerabbit$ ls</span><br><span class="line">configid_rsaid_rsa.pubknown_hosts</span><br></pre></td></tr></table></figure><p><code>known_hosts</code> 是连接过的主机记录，可以随意删除。</p><p>接着在命令行输入：<code>ssh dev</code> 即可连接到服务器！</p><blockquote><p>阅读至此，恭喜你！Linux Exp + 1</p></blockquote><h2 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h2><p>如果出现如下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssh-copy-id: ERROR: ssh: Could not resolve hostname xxx:/root/.ssh/authorized_keys: nodename nor servname provided, or not known</span><br></pre></td></tr></table></figure><p>网上查了下，大都是说 hosts 文件的问题。</p><p>可以尝试修改 <code>/etc/hosts</code> 看看是否有如下行，如果没有则添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br></pre></td></tr></table></figure><p>经过本人尝试结果无效，可用别的方法。</p><p>那就是——手动上传！！！</p><p>编辑本地主机的密匙文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>把密匙内容全部拷贝下来。</p><p>接着先用 <code>ssh root@远程主机IP</code> 用密码登录进去，然后在远程主机中 <code>vim /root/.ssh/authorized_keys</code>。</p><p>把复制的密钥直接粘贴下来就可以啦！</p><h2 id="免密登录原理"><a href="#免密登录原理" class="headerlink" title="免密登录原理"></a>免密登录原理</h2><p>网上的教程一般都是直接贴出代码和操作步骤，但这样我们根本不清楚它的原理是什么。</p><p>我们希望能像侦探一样追根究底，查清楚它的原理是什么。</p><blockquote><p>真正理解后的知识才能永远刻入你的脑海里</p></blockquote><p>上面的步骤，我们在本机生成一个密匙对，一共包含两个文件，一个是公钥，一个是私匙，公钥是发送到服务器主机的，私匙是留在本地的。</p><p>这样包含一对公钥私匙的加密叫做“<strong>非对称加密</strong>”。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在了解非对称加密之前需要先了解对称加密，所有新事物的出现必然伴随着某种需求。</p><p>小红和小明私底下正在交往，但又不希望被别人发现，于是他们约定了一种加密算法，每个字母向后移动一位，如 a 往后移一位是 b，b 往后移一位是 c……z往后移是 a。</p><p>那么，<code>ni hao</code> 就变成了 <code>oj ibp</code>。</p><p>由于双方约定好了同样的加密算法，所以小红发给小明消息时，就可以按照约定好的算法进行解密。</p><p>于是他们大胆的在班级群里用加密后的消息进行聊天，其他同学一脸茫然的看着不明觉厉的消息。</p><p>但是此时，<strong>名侦探小刚</strong>破解了他们约定好的加密算法，并且截获了（截获很简单，毕竟他们公然秀恩爱）他们互通的消息，此时小红和小明的聊天记录就被小刚一清二楚的知道了！</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>聊天记录被小刚公开后，小明和小红十分尴尬，于是机智的小明想出了一种方法，把前面约定的加密算法做了一些小的改进，小明告诉小红，我发给你一个密匙串，你用这个给消息进行加密（某种加密算法），你发给我消息后，<strong>我再用我这边的密匙进行解密，我发给你的密匙和我本地的密匙是不同的，只有我本地的密匙才能解密你加密过的内容。</strong></p><blockquote><p>问题又来了……现在只有小明破解小红的消息，小明用公钥加密消息发给小红，小红是解密不了的；如果需要双向沟通的话，自然是用同样的方法，小红也给小明一个密匙，小红本地存有另外一个用来解密的密匙。但是 Linux 免密登录是本机免密登录到服务器，属于单向的沟通，如果你希望服务器也能免密登录本机（一般不会有这种需求），就在服务器用同样的方法生成密匙，把密匙发生到本机就可以了。</p></blockquote><p>接下来的日子，小刚也无法破解他们的聊天记录，恼羞成怒的小刚带着三名小弟放学后去堵小红，逼迫小红把小明给她的加密密匙交出来，小红无奈之下将密匙交出，然而，即使拿到密匙，小刚依然无法破解小红的密码，因为，<strong>还需要小明手里的密匙才能解密小红的消息</strong>。</p><p>非对称加密的存在就是为了避免加密算法被第三者知道，导致密码泄露。上面的故事中小明交给小红的加密串叫做<strong>公钥</strong>，公钥可以让任何第三者知道，公钥加密过的密码只有小明手里的加密串——<strong>私匙</strong>才能解密，对于加密和解密使用不同的加密策略，叫做<strong>非对称加密</strong>。</p><h3 id="使用公钥实现免密登录"><a href="#使用公钥实现免密登录" class="headerlink" title="使用公钥实现免密登录"></a>使用公钥实现免密登录</h3><p>我们通过 <code>ssh-keygen -t rsa</code> 生成了公钥和私匙对，接着我们把公钥发送到服务器上，当连接的时候，服务端会发送一个用公钥加密的字符串过来，本地再使用私匙进行解密，实现了登录验证，从而不需要输入密码就能进行登录。</p><p>用盗来的一张图解释：</p><p><img src="https://i.loli.net/2019/08/31/pk2cFyIrHoVAJYE.png" alt="image.png"></p><h2 id="RSA-非对称加密算法"><a href="#RSA-非对称加密算法" class="headerlink" title="RSA 非对称加密算法"></a>RSA 非对称加密算法</h2><p>参考：<a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fromtitle=RSA&fromid=210678&fr=aladdin">百度百科 - RSA</a></p><p>只做兴趣了解，不需要掌握原理，因为我们的研究方向不是这个。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Gitlab</title>
      <link href="/2020/03/07/centos-install-gitlab/"/>
      <url>/2020/03/07/centos-install-gitlab/</url>
      
        <content type="html"><![CDATA[<h2 id="1、安准基础依赖"><a href="#1、安准基础依赖" class="headerlink" title="1、安准基础依赖"></a>1、安准基础依赖</h2><p>安装 Gitlab 所需依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br></pre></td></tr></table></figure><p>启动 ssh 服务并设置开机启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo systemctl enable sshd</span><br></pre></td></tr></table></figure><h2 id="2、安装邮件服务"><a href="#2、安装邮件服务" class="headerlink" title="2、安装邮件服务"></a>2、安装邮件服务</h2><p>Postfix 是一个邮件服务器，GitLab 发送邮件需要用到。</p><p>安装 postfix：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y postfix</span><br></pre></td></tr></table></figure><p>启动 postfix 并设置为开机启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start postfix</span><br><span class="line">sudo systemctl enable postfix</span><br></pre></td></tr></table></figure><h2 id="3、开放-ssh-以及-http-服务（80-端口）"><a href="#3、开放-ssh-以及-http-服务（80-端口）" class="headerlink" title="3、开放 ssh 以及 http 服务（80 端口）"></a>3、开放 ssh 以及 http 服务（80 端口）</h2><p>查看防火墙是否启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>以下为我的服务器上的防火墙状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-86c0 ~]# systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:firewalld(1)</span><br></pre></td></tr></table></figure><p>如果看到 Active: inactive (dead)，表示防火墙没有启动，执行下面的命令启动防火墙并且设置为开机启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p>此时，在查看防火墙状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-86c0 ~]# systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 一 2019-09-02 17:56:23 CST; 2s ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 26477 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─26477 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br></pre></td></tr></table></figure><p><code>Active: active (running)</code> 表示防火墙正常运行。</p><p>开放 ssh、http 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-service=ssh --permanent</span><br><span class="line">sudo firewall-cmd --add-service=http --permanent</span><br></pre></td></tr></table></figure><blockquote><p>只有防火墙开启状态才能执行上述命令，否则会报 FirewallD is not running 错误</p></blockquote><p>重新加载防火墙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="4、安装-Gitlab"><a href="#4、安装-Gitlab" class="headerlink" title="4、安装 Gitlab"></a>4、安装 Gitlab</h2><p>我们使用 Gitlab 的社区版：gitlab-ce，如果需要使用商业版，则安装：gitlab-ee。</p><h3 id="4-1、添加-Gitlab-社区版资源包"><a href="#4-1、添加-Gitlab-社区版资源包" class="headerlink" title="4.1、添加 Gitlab 社区版资源包"></a>4.1、添加 Gitlab 社区版资源包</h3><p>默认情况下 yum 源没有 gitlab-ce 软件包，需要手动下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><h3 id="4-2、使用-yum-安装-gitlab-ce"><a href="#4-2、使用-yum-安装-gitlab-ce" class="headerlink" title="4.2、使用 yum 安装 gitlab-ce"></a>4.2、使用 yum 安装 gitlab-ce</h3><p>在这里强烈推荐阅读：<a href="https://idce.com/document/VO4j">Centos 系统更新 yum 源为国内镜像源</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gitlab-ce</span><br></pre></td></tr></table></figure><p>软件包的安装大小足足有 1.4 G，更换镜像后只需要数十秒就下载完了。</p><p><img src="https://i.loli.net/2019/09/02/eAobTa7M8LyECUn.png" alt="image.png"></p><p>安装成功后可以看到一个类似“狐狸头像”的图案：</p><p><img src="https://i.loli.net/2019/09/02/PcAFUhG7LDm4TfJ.png" alt="image.png"></p><h3 id="4-3、配置-Gitlab-访问地址"><a href="#4-3、配置-Gitlab-访问地址" class="headerlink" title="4.3、配置 Gitlab 访问地址"></a>4.3、配置 Gitlab 访问地址</h3><p>Gitlab 安装完成后，配置文件所在路径为 <code>/etc/gitlab/gitlab.rb</code>，编辑配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure><p>将 <code>external_url</code> 字段修改为你的域名信息，如果没有域名可以改成 <code>IP:端口</code> 的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## GitLab configuration settings</span><br><span class="line">##! This file is generated during initial installation and **is not** modified</span><br><span class="line">##! during upgrades.</span><br><span class="line">##! Check out the latest version of this file to know about the different</span><br><span class="line">##! settings that can be configured by this file, which may be found at:</span><br><span class="line">##! https://gitlab.com/gitlab-org/omnibus-gitlab/raw/master/files/gitlab-config-template/gitlab.rb.template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## GitLab URL</span><br><span class="line">##! URL on which GitLab will be reachable.</span><br><span class="line">##! For more details on configuring external_url see:</span><br><span class="line">##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab</span><br><span class="line">external_url &#x27;http://gitlab.example.com&#x27;</span><br></pre></td></tr></table></figure><h3 id="4-4、启动-Gitlab"><a href="#4-4、启动-Gitlab" class="headerlink" title="4.4、启动 Gitlab"></a>4.4、启动 Gitlab</h3><p>重新载入配置并启动 Gitlab（如果修改了配置文件需要再运行此命令）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>翻车现场：</p><p><img src="https://i.loli.net/2019/09/02/6kpd51B8TZqHyGD.png" alt="image.png"></p><p>报错原文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Running handlers:</span><br><span class="line">There was an error running gitlab-ctl reconfigure:</span><br><span class="line"></span><br><span class="line">Multiple failures occurred:</span><br><span class="line">* Chef::Exceptions::MultipleFailures occurred in chef run: Multiple failures occurred:</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: ruby_block[restart_log_service] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 69) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: ruby_block[reload_log_service] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 77) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (/opt/gitlab/embedded/cookbooks/cache/cookbooks/runit/libraries/provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line"></span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 408) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: service[gitaly] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: runit_service[gitaly] (gitaly::enable line 75) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: service[gitlab-workhorse] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br></pre></td></tr></table></figure><p>%&gt;_&lt;%</p><p>原来是我的测试机内存（1G）不够！</p><blockquote><p>穷人没有资格安装 Gitlab （╯‵□′）╯︵┴─┴ </p></blockquote><h3 id="4-5、访问-Gitlab"><a href="#4-5、访问-Gitlab" class="headerlink" title="4.5、访问 Gitlab"></a>4.5、访问 Gitlab</h3><p>如果不出意外，输入 <code>external_url</code> 配置的地址，即可看到 Gitlab 页面。</p><p>第一次登陆 Gitlab 时需要设置 root 密码，然后就可以愉快的创建项目了。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再战！Docker 安装 Gitlab</title>
      <link href="/2020/03/07/docker-install-gitlab/"/>
      <url>/2020/03/07/docker-install-gitlab/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次因为服务器配置太低翻车了，现在重新挑战一次。</p><h2 id="Gitlab-硬件要求"><a href="#Gitlab-硬件要求" class="headerlink" title="Gitlab 硬件要求"></a>Gitlab 硬件要求</h2><p>Gitlab 十分吃机器的配置，Gitlab 官方推荐 2核 4G，最低建议 1 核 2G，再低的话可能会像我上次那样直接翻车或者运行起来十分卡顿。</p><p>由于是个人学习，就不打算将其部署到线上的服务器上了，这一次我采用在本地安装的方式搭建 Gitlab。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>拉取 Gitlab 官方最新版本镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>由于镜像较大，建议换成国内镜像提高下载速度。</p><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>下载完成后，再执行 <code>run</code> 启动容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname localhost \</span><br><span class="line">    --publish 4443:443 --publish 999:80 --publish 22:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume ~/docker/gitlab/config:/etc/gitlab \</span><br><span class="line">    --volume ~/docker/gitlab/logs:/var/log/gitlab \</span><br><span class="line">    --volume ~/docker/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><code>run</code> 参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--detach：让容器在后台运行</span><br><span class="line">--hostname：主机地址，本地使用 localhost，可以换成域名</span><br><span class="line">--publish：宿主机的端口映射到容器的端口，由于我本地已经有其他容器使用了 443 和 80 端口，因此我改成了 4443 和 999 端口。</span><br><span class="line">--name：自定义容器的名称</span><br><span class="line">--restart：容器重启策略，在退出时容器应该如何重启或不应该重启，always 始终重启 </span><br><span class="line">--volume：宿主机映射到容器的卷，用来做容器数据的持久化，这里我将卷的目录设置为 ~/docker/gitlab</span><br></pre></td></tr></table></figure><p><code>run</code> 命令执行后，可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/docker/gitlab</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以看到自动生成了以下几个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configdatalogs</span><br></pre></td></tr></table></figure><p>这些文件就是宿主机与容器之间通过卷映射的文件（容器数据持久化）。</p><p>执行 <code>docker ps</code> 可以看到容器运行状态：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143262-d0a23c00-ce41-11e9-81d3-4b727313dacf.png" alt="image"></p><h3 id="Gitlab-初始化"><a href="#Gitlab-初始化" class="headerlink" title="Gitlab 初始化"></a>Gitlab 初始化</h3><p>容器启动后，需要稍等几分钟，然后再访问 <code>127.0.0.1:999</code>，如果直接访问的话可能 Gitlab 还未完全启动，这个时候是访问不了的。</p><p>第一次访问时，需要设置管理员（root 用户）密码：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143324-10692380-ce42-11e9-98a9-f7372dc57b02.png" alt="image"></p><p>初始化密码设置完成后，返回到登录页面，使用账户 root 以及刚才设置的密码进行登录：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143342-31317900-ce42-11e9-98df-6ea83f67a14a.png" alt="image"></p><p>登录成功后，就可以操作界面啦！</p><p><img src="https://user-images.githubusercontent.com/28209810/64143494-dba99c00-ce42-11e9-864a-861c4a2adacc.png" alt="image"></p><h3 id="添加-SSH-key"><a href="#添加-SSH-key" class="headerlink" title="添加 SSH key"></a>添加 SSH key</h3><p>在开始使用之前，需要添加 <code>ssh key</code> 才能拉取或者推送到仓库，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>查看是否生成过 <code>ssh key</code>，如果当前目录下没有文件，则需要创建新的 <code>ssh key</code>，执行以下命令生成 <code>ssh key</code>，<code>-C</code> 参数后面是你的邮箱地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>完成后在当前目录下会生成 <code>ssh key</code>，包含两个文件，这是一对密匙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id_rsaid_rsa.pub</span><br></pre></td></tr></table></figure><p>其中，<code>id_rsa.pub</code> 是公钥，我们需要的就是这个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的密匙字符串复制下来（注意是把所有的内容都复制下来，包括邮箱）。</p><p><img src="https://user-images.githubusercontent.com/28209810/64162429-dca5f200-ce71-11e9-8812-5d3a965ea569.png" alt="image"></p><p>接着返回 Gitlab，点击左上角个人头像，选择 <code>Settings</code>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64161700-a320b700-ce70-11e9-8444-2370d88bff56.png" alt="image"></p><p>选择左侧菜单 <code>SSH Keys</code>，将你的 <code>ssh key</code> 黏贴到方框内，然后点击 <code>Add key</code> 即可：</p><p><img src="https://user-images.githubusercontent.com/28209810/64162574-27276e80-ce72-11e9-95e6-e2e23ca57098.png" alt="image"></p><p>接下来就可以愉快的开始使用 Gitlab 啦！</p><h2 id="为什么安装后的-Gitlab-可以直接访问？"><a href="#为什么安装后的-Gitlab-可以直接访问？" class="headerlink" title="为什么安装后的 Gitlab 可以直接访问？"></a>为什么安装后的 Gitlab 可以直接访问？</h2><p>这是由于 Gitlab 内置了 nginx 服务器，所以才能在安装完成后通过地址进行访问。</p><p>完结撒花～ ҉٩(<em>´︶&#96;</em>)۶҉ ??</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab + Satis 搭建私有 Composer 仓库</title>
      <link href="/2020/03/07/install-gitlab-satis-composer/"/>
      <url>/2020/03/07/install-gitlab-satis-composer/</url>
      
        <content type="html"><![CDATA[<h2 id="Satis-介绍"><a href="#Satis-介绍" class="headerlink" title="Satis 介绍"></a>Satis 介绍</h2><p>Satis 是开源的静态 Composer 仓库生成器，可用于托管公司私有包的元数据。</p><p>环境要求：PHP &gt;&#x3D; 7.2</p><h2 id="安装-Gitlab"><a href="#安装-Gitlab" class="headerlink" title="安装 Gitlab"></a>安装 Gitlab</h2><p>Centos 搭建 Gitlab：<a href="/centos-install-gitlab">Centos 系统安装 Gitlab</a><br>Docker 搭建 Gitlab：<a href="/docker-install-gitlab">再战！Docker 安装 Gitlab</a></p><h2 id="上传-Composer-包"><a href="#上传-Composer-包" class="headerlink" title="上传 Composer 包"></a>上传 Composer 包</h2><p>Composer 包开发教程：<a href="/composer-package">从零开始开发自己的 Composer 包</a></p><p>在 Gitlab 新建一个仓库，把自己开发完成的包上传到这个仓库，上传完成后的仓库如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/64165187-204f2a80-ce77-11e9-9532-fbe4a9239a37.png" alt="image"></p><p>包的配置文件 <code>composer.json</code> 如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/64166482-c7cd5c80-ce79-11e9-8b25-7719a08c156e.png" alt="image"></p><p>包的名字叫做：<code>huotu/test</code>，我们后面需要用到。</p><p>这个仓库的地址就是我们私有包的地址，接下来拿这个包作为演示。</p><h2 id="安装-Satis"><a href="#安装-Satis" class="headerlink" title="安装 Satis"></a>安装 Satis</h2><p>可以使用两种方式安装 Satis。</p><h3 id="1、Composer-安装"><a href="#1、Composer-安装" class="headerlink" title="1、Composer 安装"></a>1、Composer 安装</h3><p>可以直接使用 <code>composer</code> 命令安装 Satis： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project composer/satis --stability=dev --keep-vcs</span><br></pre></td></tr></table></figure><h3 id="2、从-GitHub-下载"><a href="#2、从-GitHub-下载" class="headerlink" title="2、从 GitHub 下载"></a>2、从 GitHub 下载</h3><p>使用 <code>git clone</code> 将 Satis 下载到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/composer/satis.git</span><br></pre></td></tr></table></figure><h2 id="添加-Satis-配置文件"><a href="#添加-Satis-配置文件" class="headerlink" title="添加 Satis 配置文件"></a>添加 Satis 配置文件</h2><p>在下载好的 satis 目录下，创建 <code>satis.json</code> 配置文件，一个示例的配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http://packages.example.org&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https://github.com/mycompany/privaterepo&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://svn.example.org/private/repo&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https://github.com/mycompany/privaterepo2&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;company/package&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;company/package2&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;company/package3&quot;: &quot;2.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name：仓库的名字，将会展示在页面上</li><li>homepage：satis 访问地址</li><li>repositories：包所在的地址</li><li>require：获取指定的包</li><li>require-all：如果为 true 表示获取所有包</li></ul><p>根据自己的情况进行配置，这里我们拿刚刚上传到 Gitlab 的包演示，配置如下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http://satis.com&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>http://satis.com</code> 为 satis 访问页面地址，<code>http://gitlab.com/huotu/test</code> 为私有包所在地址。</p><h2 id="Composer-配置"><a href="#Composer-配置" class="headerlink" title="Composer 配置"></a>Composer 配置</h2><p>由于我们使用 <code>http</code>，在这里需要修改设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g secure-http false</span><br></pre></td></tr></table></figure><h2 id="生成-Satis-索引页面"><a href="#生成-Satis-索引页面" class="headerlink" title="生成 Satis 索引页面"></a>生成 Satis 索引页面</h2><p>在 satis 目录下执行命令 <code>composer install</code> 安装所需依赖，然后再执行如下命令生成 satis 页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">php bin/satis build &lt;configuration file&gt; &lt;build dir&gt;</span><br><span class="line"></span><br><span class="line"># 示例 ：</span><br><span class="line">php bin/satis build satis.json public/</span><br><span class="line"></span><br><span class="line"># 跳过 Gitlab 密码验证</span><br><span class="line">php bin/satis build -n satis.json public/</span><br></pre></td></tr></table></figure><p>执行完命令后，在当前目录生成了 public 文件夹，接着配置 nginx，将域名指向这个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name satis.com;</span><br><span class="line">    root /www/satis/public;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 nginx，不出意外就可以通过域名访问 satis 了！</p><blockquote><p>使用域名记得添加解析到服务器</p></blockquote><p>访问 <code>http://satis.com</code>（这个是你配置的域名）：</p><p><img src="https://user-images.githubusercontent.com/28209810/64164278-8044d180-ce75-11e9-8b1a-9e81d905418c.png" alt="image"></p><h2 id="Composer-使用私有仓库"><a href="#Composer-使用私有仓库" class="headerlink" title="Composer 使用私有仓库"></a>Composer 使用私有仓库</h2><p>我们现在完成了 Satis + Gitlab 的全部安装，接下来我们的项目就可以使用自己搭建的私有 Composer 源了。</p><p>新建一个 test 文件夹，在 test 目录下创建 <code>compsoer.json</code>，编辑 <code>composer.json</code> 添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;huotu/test&quot;: &quot;*&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;repositories&quot;: [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http://satis.com&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存，然后在当前目录下执行 <code>composer install</code>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64166283-58576d00-ce79-11e9-9cf3-233193e4963e.png" alt="image"></p><p>成功把自己私有仓库的包下载下来了。</p><p>如果有多个包，则添加多个仓库地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http://satis.com&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test2&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://gitlab.com/huotu/test3&quot; &#125;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存包资源"><a href="#缓存包资源" class="headerlink" title="缓存包资源"></a>缓存包资源</h2><p>可以把所需要的包都缓存在本地 Satis 上，这样可以避免每次都需要从仓库中 clone，在 <code>satis.json</code> 添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;archive&quot;: &#123;</span><br><span class="line">        &quot;directory&quot;: &quot;dist&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;tar&quot;,</span><br><span class="line">        &quot;prefix-url&quot;: &quot;http://satis.com&quot;,</span><br><span class="line">        &quot;skip-dev&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>archive</code> 参数：</p><ul><li>directory: 表示生成的压缩包存放的目录，会在我们 build 时的目录中</li><li>format: 压缩包格式，zip（默认） tar</li><li>prefix-url: 下载链接的前缀的 Url, 默认从 homepage 中取</li><li>skip-dev: 默认为 false，是否跳过开发分支</li><li>absolute-directory: 可选，包文件存储到绝对路径的目录</li><li>whitelist: 可选，如果设置为包名称列表，则只会转储这些包的 dist 文件</li><li>blacklist: 可选，如果设置为包名称列表，则不会转储这些包的 dist 文件</li><li>checksum: 可选，默认情况下为 true，禁用时（false）不会为 dist 文件提供 sha1 校验 启用后，所有下载（包括来自 GitHub 和 BitBucket 的下载） 将替换为本地版本。</li></ul><p>添加 <code>archive</code> 后，配置的包信息就会下载到本地 Satis 目录下 dist 文件夹中，从 Satis 下载依赖时将从这个文件夹获取资源。</p><h2 id="定期更新-Satis"><a href="#定期更新-Satis" class="headerlink" title="定期更新 Satis"></a>定期更新 Satis</h2><p>需要定期执行 <code>php bin/satis build satis.json public/</code> 命令来生成最新的 Composer 包信息，可以将此命令作为定期任务执行，或是增加一个钩子 push 来更新 Satis。</p>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> composer </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的抽奖是否应该有保底机制？</title>
      <link href="/2020/03/07/game-draw-card-mechanism/"/>
      <url>/2020/03/07/game-draw-card-mechanism/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏中的抽奖机制是几乎所有游戏都要面临的问题，在一定程度上来说，抽奖机制可以决定游戏的命运。</p><p>当一个打算弃坑的玩家，想在最后抽个爽，结果却出了许多氪金大佬都没有的神宠！在游戏广播下，世界频道异口同声的喊起“狗托”，豹子头“零充”玩家心情自然不言而喻，十有八九会享受万众羡慕的眼神继续愉快的玩耍。</p><p>反之，一个氪金大佬怒抽 100 连，砸了 N 个 648 结果还不出货，正气急败坏，却看楼上那位零氪玩家的广播 <strong>XXX 玩家抽到 XXX</strong>，试问氪金大佬此时作何感想？</p><p>当然，上面的情景仅为 YY，实际上可能并没有那么夸张，举例只是为了说明在某些特定情况下可以决定玩家是否继续玩下去。</p><h2 id="游戏中的抽奖机制"><a href="#游戏中的抽奖机制" class="headerlink" title="游戏中的抽奖机制"></a>游戏中的抽奖机制</h2><p>游戏中的抽奖机制经过不断演变，发展为两种比较常见的形式：<strong>无保底机制</strong> 与 <strong>保底机制</strong>。</p><h3 id="无保底机制"><a href="#无保底机制" class="headerlink" title="无保底机制"></a>无保底机制</h3><p>如字面意思，无论抽几次，概率都是一样。</p><p>这种模型会造成某些玩家运气好，尤其是零元党在抽到好东西的时候很喜欢在 <strong>贴吧秀</strong>，对包括零氪、土豪玩家造成暴击伤害，“脸帝”是玩家公敌。</p><p>无保底机制的弊端会造成游戏过于依赖运气成分。</p><p>脸黑玩家可能永远抽不到，土豪玩家可能连砸 N 个 648 依然得不到。</p><p>站在游戏开发者的角度，希望绝大多数玩家可以体验到游戏绝大多数内容，而不是单纯的靠运气决定，这个时候就可以依靠俗话说的“努力就会有回报”。</p><h3 id="保底机制"><a href="#保底机制" class="headerlink" title="保底机制"></a>保底机制</h3><p>玩家通过抽奖，达到一定次数就能得到最好的奖励，这就是保底奖励。</p><p>保底奖励又有两种形式。</p><h4 id="积分兑换"><a href="#积分兑换" class="headerlink" title="积分兑换"></a>积分兑换</h4><p>第一种是以累计 <strong>“积分”</strong> 的形式，玩家可以用积分在商店兑换到最好的奖励。</p><p>这种方式的好处是，玩家可以 <strong>明确的知道</strong> 抽几次一定可以拿到大奖，虽然可能会损失几分惊喜的感觉，但是会让玩家心里感到踏实。即使失败也不会有太大的负面影响，因为失败也会累计积分作为补偿。</p><h4 id="幸运值"><a href="#幸运值" class="headerlink" title="幸运值"></a>幸运值</h4><p>第二种是通过抽奖累计 <strong>“幸运值”</strong>，每次抽奖都可以使下次抽到大奖的几率提高，幸运值达到满时必定抽到。比如王者荣耀的水晶&#x2F;积分抽奖，玩家可以通过日常获得的钻石去抽奖，即使没抽到也可以积累幸运值，慢慢积累直到抽到水晶然后兑换韩信这个英雄。有些游戏的强化系统也采用这种形式，每次强化失败，下一次强化的成功几率就会提高。</p><p>这种方式的好处是可以让玩家 <strong>保持对于抽奖的期待</strong>，因为概率不断提高，玩家的内心就会觉得可能下一次就中了，而且有保底满幸运值必中的结果，玩家对于失败的感觉就很淡然了，现在的抽奖已经变为 <strong>“可以让我省多少钱”</strong>，越早抽到，玩家反而会觉得赚到了。</p><h2 id="游戏的抽奖该不该保底？"><a href="#游戏的抽奖该不该保底？" class="headerlink" title="游戏的抽奖该不该保底？"></a>游戏的抽奖该不该保底？</h2><p>回到标题，让我们思考下面几个问题：</p><ul><li><p>游戏的抽奖该不该保底？</p></li><li><p>开发商会因为保底而亏损吗？</p></li><li><p>保底抽奖机制到底对哪种类型的玩家更有好处？</p></li></ul><p><strong>1、个人的看法是游戏抽奖以保底机制更好</strong></p><p>我是一个游戏开发者，我希望玩家可以体验到游戏的更多内容（毕竟是我亲自设计的），故意吊玩家的胃口，让某些神宠只让个别人拥有，固然可以提高玩家对神宠的追求，但如果一个永远无法达成的目标，只会让玩家失望，累积越来越多的失望最终就会失去玩家。</p><p><strong>2、不会因为保底抽奖而亏损</strong><br>首先保底机制可以减少玩家的流失，这是其一；其二，保底机制也让土豪玩家更有动力去充钱，以上面的积分模型为例，土豪玩家如果想要得到所有最好的奖励，“最坏”的结果已经可以通过计算明确知道了，当人知道最坏结果时，对失败的承担能力就会越强，而且土豪也可以通过计算推出自己 <strong>应该充多少钱</strong> 才能拿到所有的奖励，土豪并不差钱，但是土豪并不想被 <strong>概率</strong> 忽悠。</p><p>策划也可以通过 <strong>临界值</strong> 来诱使玩家进行充值，这个方法十分见效，我自己就上过很多次当。</p><p>下面是我被网易坑的血泪史（┭┮﹏┭┮）：</p><p>网易新出的游戏百闻牌，里面故意设计红玉和蓝玉兑换机制，让玩家误以为充值的就是红玉，其实充值的是蓝玉，需要再兑换成红玉才能抽奖。</p><p>（<strong>这种欺骗玩家或者诱导玩家错觉的行为极其不可取！</strong>）</p><p>抽奖处显示抽 10 次就可以得到妖刀姬，我就充了 30（计算得出只要充 30 就可以抽 10 次奖），结果发现充值的是蓝玉，兑换之后只有 5 次抽奖机会（真是神坑！）</p><p>好吧，现在已经抽了 5 次，再抽 5 次才能抽到，那我是抽还是不抽呢？这里还涉及到沉默成本，后文介绍。</p><p>当然是选择继续抽，而且这次还充了 68，原因是首充有额外赠送。</p><p>落入策划步步设计的深坑 ┭┮﹏┭┮</p><p>然后又抽了 5 次才拿到妖刀姬。</p><p>这里，由于我之前已经累积了 5 次，只要再抽 5 次就可以拿到大奖，因此我会有驱动力去继续抽下去，如果是在临界值，这个动力就会更强，例如：299&#x2F;300 的时候，只需要再一次就可以抽到！</p><p>接下来谈一谈 <strong>沉默成本</strong>。</p><p>沉默成本是经济学里面的概念（我大学也是学过经济学的2333）。</p><p>比如你投一只股票，当天亏损了 5 万，你会卖掉还是等明天看看？</p><p>很多人都会留着看看，因为这样白白亏损很不甘心。</p><p>但实际上，你亏损的 5 万已经成为了事实，已经无法改变，不应该影响下一步的决策。</p><p>就像上面我充了 30，结果发现只抽了 5 次，但此时我损失 30 块钱已经是板上钉钉子的事了，但是我的心里面就会想：“我已经充了 30，再充 30 就可以拿到想要的了，不能让之前充的白白浪费”。</p><p>这里就是沉默成本在作怪。</p><p>实际上，沉默成本也是决定游戏命运至关重要的要素，如果一个策划可以让玩家在游戏里投入更多的时间，那玩家就会越来越难以失去这个游戏，甚至以为是“情怀”什么的，比如魔兽玩家经常会说，“那不是游戏，而是我逝去的青春”，可以说是沉默成本非常形象的说明了。</p><p><strong>3、保底机制更利于氪金玩家</strong><br>由于保底机制，只要无限氪金 <strong>必然可以得到一切</strong>，也就造成了有钱可以为所欲为的情况，难道开发商不希望土豪充更多的钱吗？所以，开发商是绝对不会亏的，这一点可以保证。</p><p>由于氪金玩家可以不断充钱得到所有的奖励，如果不是保底机制呢？氪金玩家投入将是无底洞，无论投入多少钱，也许永远都得不到想要的一只英雄或者宠物。</p><p>其次，对于零氪玩家来说也是极好的，只是提升的程度没有土豪玩家那么大而已。</p><p>保底机制对“脸帝”来说是最大的威胁，由于保底，这样他们根本 <strong>秀不起来</strong>，他们由于脸好得到的神宠已经是人手可得的普通宠物了，晒这样的宠物已经无法满足他们日渐膨胀的虚荣心。</p><p>作为贴吧 13 级的大水比，已经见惯了秀脸贴。</p><p>“萌新求问 XXX 有用吗？”</p><h2 id="抽奖中的暗箱操作"><a href="#抽奖中的暗箱操作" class="headerlink" title="抽奖中的暗箱操作"></a>抽奖中的暗箱操作</h2><p>之前看了一期游戏抽奖的视频，介绍了游戏抽奖中的各种暗箱操作。</p><p>其中之一是最坑的，下面用一个故事来说明。</p><p>隔壁老王有一颗价值 1 万的钻石，他想了一个办法，可以让这颗钻石赚到更多钱。</p><p>他做了 300 个空盒子，接着把钻石放在其中一个盒子，其他 299 个盒子都放一颗与钻石等重的碎玻璃，然后他开始在大街上摆摊吆喝：300 个盒子里有一颗价值 1 万的钻石，其他都是玻璃，每个盒子卖 50 块，买盒子的人不能说出自己开到什么东西。</p><p>众人听到，纷纷想以 50 博 1 万，结果所有的盒子都卖出去了，老王共得 1.5 万，比直接出售钻石还多赚了 5000。</p><p>在这里有一个很坑的点，假设第一个买盒子的人开到钻石，那后面 299 个人必定无法开到钻石，也就是必定亏损的，但是由于 <strong>“不能说出自己开到什么”</strong> 导致后面来买盒子的人仍然抱有期待，因而继续购买盒子。</p><p>在一些游戏中，由于玩家并不能知道游戏的抽奖机制是什么，因此就会有策划想出这种“歪点子”，有些游戏里的大奖每天只会发放一份（或者固定份数），而后续的玩家永远抽不到。</p><p>除此之外，还有另一种暗箱操作——奖池机制。</p><p>这种方式的特点是全服玩家共享一个奖池，上面的例子也可以归为此类，只不过奖池机制有些不同。</p><p>奖池是彩票或者棋牌游戏中的概念，所有玩家一起打牌，每轮都要下赌资，赌资全部汇集到奖池中，直到某个玩家开牌，牌面最大的玩家得到所有奖池的钱。</p><p>游戏抽奖机制也存在这种情况，所有玩家都在一个奖池里抽奖，玩家的每次抽奖相当于 <strong>“投入赌资”</strong>，只有抽奖次数达到一定水平时才会出现大奖，大奖被一个玩家得到以后，奖池清空，开启下一轮的奖池，以此类推。</p><p>所以在某些游戏中，垫子之类的说法存在一定道理，一个服务器里面抽奖的玩家越多，抽到大奖的几率就越高，在鬼区没人抽奖的情况下，甚至有可能抽奖几率为负数。</p><h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>在这里写一下个人的想法。</p><p>假如作为开发商，自然希望玩家能多充钱，因为开发商开发游戏的目的很明确就是为了赚钱。</p><p>作为游戏制作者，我希望玩家可以体验到更多的游戏内容，而不是靠运气和财富差距造成严重游戏体验偏差。至于钱，目前并没有太大的想法，现在只是单纯的因为喜欢游戏而做游戏，也许以后会为了钱设计坑玩家的套路，但是赚到钱（维持生计）的同时，一定会并行开发一款自己真正想做的游戏（单机游戏）。</p><p>作为玩家，希望策划别坑！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴子都能学会的hexo博客安装教程</title>
      <link href="/2020/03/01/easy-to-start-hexo/"/>
      <url>/2020/03/01/easy-to-start-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h2><p>hexo 是一款开源博客项目。</p><p>即使是小白借助 hexo 也能轻松搭建属于自己的博客。</p><p>根据下面的教程，你能学会搭建个人博客，并且其他人可以通过外网访问到你的博客！</p><p>hexo 官网：<a href="https://hexo.io/">https://hexo.io/</a></p><p>官方中文文档：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><p>【FAQ】</p><p>需要买服务器和域名吗？</p><p>通过 Github Pages 可以白嫖域名和服务器，所以不用买。</p><p>当然，如果你的钱包预算足够，买一款心仪的域名和自己的服务器那就更完美了！</p><p>话不多说，接下来直接进入教学篇。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本教程主要基于 Linux 系统，如果是 Window 系统也不用急，只是增加一个配置环境变量的步骤，机智的你一定懂得怎么做！</p><p>代码编辑器：<a href="https://code.visualstudio.com/">VS Code</a></p><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>hexo 依赖于 node，首先需要安装 node 环境。</p><h3 id="1、安装-Nodejs"><a href="#1、安装-Nodejs" class="headerlink" title="1、安装 Nodejs"></a>1、安装 Nodejs</h3><p><strong>Windows 系统</strong></p><p>nodejs 官网下载：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><p>如果确实是小白，建议下载 Windows 安装包 (.msi)，msi 安装包会自动配置环境变量，真正实现小白式操作。</p><p><strong>Linux 系统</strong></p><p>Linux 版本众多，在这里只介绍 Centos 的安装方法。</p><p>第一步：安装 node 相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ openssl-devel epel-release</span><br></pre></td></tr></table></figure><p>第二步：安装 nodejs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><p>安装完成后，在控制台输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果可以看得到版本信息说明安装成功。</p><p>安装完 node 之后，即可使用 npm 命令，由于 npm 的源是国外网站，速度会很慢，为了节省时间我们可以更换淘宝提供的镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用 <code>cnpm</code> 命令了，在后续的操作用 cnpm 来代替 npm。</p><h3 id="2、安装-Git"><a href="#2、安装-Git" class="headerlink" title="2、安装 Git"></a>2、安装 Git</h3><p>Git 是代码托管工具，整个过程 Git 的戏份很少，不懂的小白也不用担心，安装好就对了！</p><ul><li>Windows：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>.</li><li>Mac：使用 Homebrew, MacPorts 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：sudo apt-get install -y git-core</li><li>Linux (Fedora, Red Hat, CentOS)：sudo yum install -y git-core</li></ul><blockquote><p>Mac 用户请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。</p></blockquote><h3 id="3、安装-hexo"><a href="#3、安装-hexo" class="headerlink" title="3、安装 hexo"></a>3、安装 hexo</h3><p>使用 cnpm 命令一键安装 hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，在控制台输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo</span><br></pre></td></tr></table></figure><p>如果看得到如下信息说明安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  help     Get help on a command.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages in the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#x27;hexo help [command]&#x27; for the detailed information</span><br><span class="line">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure><h2 id="搭建博客！"><a href="#搭建博客！" class="headerlink" title="搭建博客！"></a>搭建博客！</h2><p>现在开始搭建博客项目，运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个 blog 是文件夹的名字，你可以随意取，在这里我把它取名 blog。</p><p>执行完这个命令会自动在当前目录下创建一个 blog 文件夹，使用命令 <code>cd blog</code> 进入这个文件夹，接着再执行 <code>cnpm install</code>。</p><p>安装完成后，文件夹的目录如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>需要注意两个主要的配置文件：</p><h3 id="1、-config-yml"><a href="#1、-config-yml" class="headerlink" title="1、_config.yml"></a>1、_config.yml</h3><p>网站的配置信息，比如网站的名字什么的，都在这里进行配置。</p><h3 id="2、package-json"><a href="#2、package-json" class="headerlink" title="2、package.json"></a>2、package.json</h3><p>网站依赖的包（小白不用管这个东西），默认已经帮你配置好常用的包了。</p><p>以上，你的博客已经搭建完啦！</p><h2 id="访问博客！"><a href="#访问博客！" class="headerlink" title="访问博客！"></a>访问博客！</h2><p>什么鬼！？这就搭建完了？？</p><p>yes，我们打开控制台，在博客目录下执行命令启动博客：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619193-9a0c6a80-5bb3-11ea-88af-f8ea2b22b051.png" alt="启动hexo博客"></p><p>然后打开浏览器，输入 <code>http://localhost:4000</code> 或 <code>127.0.0.1:4000</code>。</p><p>你就可以看到搭建好的博客啦！</p><p>如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619228-6716a680-5bb4-11ea-99c2-d121aba9338f.png" alt="hexo博客"></p><h2 id="写下第一篇博文！"><a href="#写下第一篇博文！" class="headerlink" title="写下第一篇博文！"></a>写下第一篇博文！</h2><p>好吧，其实你的第一篇博客已经被系统写好了，也就是你在上图看到的标题为 Hello World 的博文。</p><p>接下来我们要手动创建第一篇博客！</p><p>使用命令 <code>hexo n &lt;博文标题&gt;</code> 来创建一篇新的博文。</p><p>控制台下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的第一篇博客&quot;</span><br></pre></td></tr></table></figure><p>执行完命令后，可以看到生成了一个 .md 格式的文件 <code>/blog/source/_posts/我的第一篇博客.md</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619292-13588d00-5bb5-11ea-9ff2-4833965a8456.png" alt="image"></p><p>这个文件就是我们的博文内容，进入 <code>/blog/source/_posts/</code> 然后打开 <code>我的第一篇博客.md</code>， 可以看到默认内容类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2020-03-01 10:49:10</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开头的部分不要动，在结尾部分写自己想写的文章即可，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2020-03-01 10:49:10</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 兔子的日记</span><br><span class="line"></span><br><span class="line">今天的天气真好！</span><br></pre></td></tr></table></figure><p>如果你用的是 Markdown 还能看到预览效果！</p><p>Markdown 编辑器推荐：<a href="http://note.youdao.com/semdl/markdown.html">有道云笔记</a></p><p>（你可以在其他地方编辑好文章，然后复制过来）</p><p>我用的是 PHPstorm，预览效果如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619349-c5905480-5bb5-11ea-89d2-d2abf88cdef4.png" alt="hexo第一篇博文"></p><p>文章内容已经写好了，接下来要生成静态页面，按 <code>Ctrl+C</code> 把刚才启动的博客关掉：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619390-2ae44580-5bb6-11ea-8835-12430e945e21.png" alt="关闭hexo服务"></p><p>然后依次运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清空数据库，如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619432-8d3d4600-5bb6-11ea-9985-a56c65a7cf48.png" alt="hexo clean"></p><p>接着输入 <code>hexo g</code> 重新编译生成静态页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619447-c4135c00-5bb6-11ea-827b-28be7914d84c.png" alt="hexo 生成博文"></p><p>最后，再启动 hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>浏览器输入：<code>127.0.0.1:4000</code> 就可以看到自己刚才写的那篇文章了。</p><p>如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619492-5451a100-5bb7-11ea-9af3-c25af149898f.png" alt="hexo第一篇博文"></p><p>至此，hexo 的基本操作已经 OK 了。</p><p>再来总结一下怎么发一篇博文。</p><p>1、执行 <code>hexo n &lt;标题&gt;</code> 创建博文文件</p><p>2、在 Markdown 编辑器完成博文书写，把内容复制到上面生成的博文文件里</p><p>3、执行 <code>hexo clean</code> 清空数据</p><p>4、执行 <code>hexo g</code> 重新编译生成静态文件</p><p>此外，本地调试用 <code>hexo s</code> 开启本地服务，在浏览器输入 <code>127.0.0.1:4000</code> 访问博客项目。</p><p>要记住这些步骤和命令对小白来说十分吃力，这是很正常的事情。</p><p>如果忘记了怎么操作，回头多看几遍本博文，熟能生巧！</p><h2 id="自定义主题！"><a href="#自定义主题！" class="headerlink" title="自定义主题！"></a>自定义主题！</h2><p>默认博客页面太丑，想换一个怎么办？</p><p>网上找到其他人分享的主题：<a href="https://github.com/zhvala/hexo-material-x-black">https://github.com/zhvala/hexo-material-x-black</a></p><p>然后把它下载下来，点击右侧 Clone or download：</p><p>下载下来并且解压，把解压后的文件复制到博客项目的 themes 目录下。</p><p>或者直接 clone 到 themes 目录下并且命名为 material-x：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x</span><br></pre></td></tr></table></figure><p>主题文件都很大，等下载完成就可以了。</p><p>主题下载下来以后，目录结构如下：</p><p><img src="https://s2.ax1x.com/2020/03/01/3g86hV.png" alt="3g86hV.png"></p><p>themes 下面的文件夹都是主题。</p><p>接着编辑 .config.yml，拉到底部，修改 theme 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: material-x</span><br></pre></td></tr></table></figure><p>theme 默认是 landscape，改成刚刚下载的主题 material-x（即文件夹的名字）。</p><p>然后安装主题所需的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts</span><br></pre></td></tr></table></figure><p>接着执行下面几个命令（如果之前启动了博客项目，记得按 Ctrl+C 先关掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:4000</code>，可以发现主题已经被更换成新的了。</p><p>在 Github 上还有更多主题可以选择：<a href="https://github.com/search?q=hexo+theme&type=Repositories">点击此处获取更多主题</a></p><h2 id="发布博客！"><a href="#发布博客！" class="headerlink" title="发布博客！"></a>发布博客！</h2><p>上面的步骤只能在自己的电脑打开博客项目，现在我们要把博客发到外网去，让别人来参观你的博客！</p><p>— 小剧场 —</p><p>你是想要节操，还是想白嫖域名和服务器？</p><p>我是想要节操还把域名和服务器嫖了！</p><p>嫖不成。</p><p>啪一声，你把 300 块大洋拍在桌子上。</p><p>这个能不能换来节操？</p><p>能，但是钱包空了。</p><p>啪一声，你把节操拍在桌子上，300 块大洋收回兜里。</p><p>嫖谁的？</p><p>GitHub 的！</p><p>就那个全球最大同性交流社区？</p><p>正是。</p><p>敢问君为何方神圣？</p><p>GitHub 基佬是也。</p><p>— 小剧场（完） —</p><p>没错，我们要白嫖 GitHub 提供的免费域名和空间——GitHub Pages！</p><p>GitHub Pages 提供了免费的服务可以让我们部署博客项目。</p><p>Github：<a href="https://github.com/">https://github.com/</a></p><p>注册一个账户并登陆。</p><p>接着点击左侧 Repositories 旁边的按钮 New 创建一个新的仓库，如图：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619699-608b2d80-5bba-11ea-8bff-2570abd32650.png" alt="image"></p><p>仓库的配置有两点需要注意，如果你没按照下面的要求，你的博客就访问不了：</p><p>1、仓库名称必须为：你的 GitHub 用户名.github.io，比如我的 Github 用户名是 huoshaotuzi，那么仓库的名字就是：huoshaotuzi.github.io</p><p>2、仓库必须为 Public 公开权限，如果选择 Private，就不能白嫖了，这也是上面的小剧场所说的出卖节操的原因，一旦公开权限，你的仓库 <strong>任何人都能访问</strong>，你的仓库设置成 Public，相当于你光着屁股暴露在 Github 几百万基佬面前，知道啥意思了吧？</p><p>创建好仓库后，可以看到如下的仓库信息：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619801-8107b780-5bbb-11ea-9b9b-77f1eb0b4078.png" alt="image"><br>（xxoo 是随便取的名字，不要问 xxoo 是什么意思，问了也不会告诉你。）</p><p>在这里把 SSH 后面的仓库地址复制下来，后面会用到。</p><p>接着返回到你博客的目录下，执行命令安装 git 插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>安装完成后，编辑根目录下的 _config.yml，拉到最底部，deploy 后面添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/huoshaotuzi/xxoo.git（填你自己的）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里的 repo 填入上面说的仓库地址：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619912-0fc90400-5bbd-11ea-9636-1d7bbc7310ce.png" alt="image"></p><p>保存配置文件后，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行命令后开始自动编译并且上传到 GitHub 仓库，然后会提示要输入 Github 的账号跟密码。</p><p>为了避免每次上传都要重复输入账号密码，你可以输入下面的命令记住密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>上传成功后，返回仓库就能看到上传好的代码。</p><p>然后就可以通过仓库名称访问到你的博客了！</p><p>我的仓库名称是：huoshaotuzi.github.io</p><p>在浏览器输入：huoshaotuzi.github.io</p><p>刚刚部署上去的时候，需要等几分钟才能看到博客，不然会出现 404 或者其他问题。</p><p>白嫖党只能使用 GitHub 提供的域名，接下来给大家介绍如何指定域名进行访问。</p><p>比如我的网站是：<a href="https://blog.huotuyouxi.com/">blog.huotuyouxi.com</a></p><p>这是怎么实现的呢?</p><h2 id="指定域名！"><a href="#指定域名！" class="headerlink" title="指定域名！"></a>指定域名！</h2><p>首先，你得有一个域名。</p><p>万网阿里云、百度云、腾讯云、京东云、华为云、国外的 GoDaddy……诸如此类域名服务提供商，任选一家即可。</p><p>建议购买 .com 后缀的域名，域名的名称就按照你自己喜欢的挑选了。</p><p>比如张三：zhangsan.com</p><p>皮卡丘博客：pikachublog.com</p><p>简单好记的域名，这个没什么要求的，选你喜欢的就好。</p><p>域名买好之后，在仓库主页的菜单栏，选择 Settings：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619981-0be9b180-5bbe-11ea-8b71-1a5cc2f906df.png" alt="image"></p><p>拉到下面，直到看到 GitHub Pages，然后点击 Choose a theme 选择一个主题：</p><p><img src="https://ae01.alicdn.com/kf/Hb6adf75de5bb405396b8991dcab4ccf2d.png" alt="image"></p><p>主题按照你喜欢的随便选一个就好：</p><p><img src="https://ae01.alicdn.com/kf/Hdad8baba745a4a5698426e9b386d9606a.png" alt="image"></p><p>比如选第一个，然后点击右下角 Select theme。</p><p>接着返回 Github Pages 配置域名：</p><p><img src="https://ae01.alicdn.com/kf/Ha7c7c267f4594459854b89d8782cf9366.png" alt="image"></p><p>在 Custom domain 栏处填写你购买的域名，然后点击 Save。</p><p>如果需要启用 https 域名，把 Enforce HTTPS 勾选即可，刚部署时需要等待几分钟 Enforce HTTPS 才会显示可选，并且勾选完成后也需要等待几分钟，Github 会为你免费提供 SSL 证书。</p><p>然后打开你购买域名的网站，例如阿里云，登录后打开右上角控制台-点击左上角展开菜单-选择域名：</p><p><img src="https://ae01.alicdn.com/kf/H59ae77f519c645c486feacd4c8e68ff8d.png" alt="image"></p><p>在域名右侧选择解析：</p><p><img src="https://ae01.alicdn.com/kf/H0f6fb6011e264e39a694159c9deac969C.png" alt="域名解析"></p><p>点击“添加记录”，记录类型 CNAME，主机记录 @，记录值填你自己仓库的名字：</p><p><img src="https://ae01.alicdn.com/kf/Hfa26d74adaf24408aba88ef049091802E.png"></p><p>如果你希望可以用 www 访问，那就再添加一条记录，主机记录填 www，其他跟上面的一样：</p><p><img src="https://ae01.alicdn.com/kf/H638380f92dbf4ff0bd97f57117e225fcv.png"></p><p>完成这一步你就可以通过购买的域名访问到博客了！</p><h2 id="指定服务器！"><a href="#指定服务器！" class="headerlink" title="指定服务器！"></a>指定服务器！</h2><p>不想出卖节操，就买台服务器自己安装环境，这样可以保证代码不被其他基佬看到。</p><h3 id="1、域名和服务器的选择"><a href="#1、域名和服务器的选择" class="headerlink" title="1、域名和服务器的选择"></a>1、域名和服务器的选择</h3><p>选服务器可是很有讲究的，看你网站的受众，如果是面向海外用户，就选国外的服务器；如果面向国内用户，那就买国内的服务器。服务器放在哪很大程度上会影响你网站的打开速度。</p><p>再者，如果你选国内服务器，还需要注意域名备案的问题。</p><p>想要搭建博客，最好提前买个域名进行备案。</p><p>没有备案的域名只能选择国外主机。</p><p>只建议购买：com、cn、net 这三个老牌域名。</p><p>非主流域名即使能备案，搜索引擎也很难收录，所以不推荐。</p><p>有条件或者嫌备案麻烦的，可以购买香港或者台湾地区的服务器，靠近大陆，延迟相对低一点，域名即买即用。</p><h3 id="2、服务器环境"><a href="#2、服务器环境" class="headerlink" title="2、服务器环境"></a>2、服务器环境</h3><p>服务器推荐 Centos 系统，如果是小白也可以选 Windows Server。</p><p>要让网站解析到服务器，首先需要安装 Web 服务器，老牌的 Web 服务器软件有 Apache，Windows 的 IIS。</p><p>这两个本人几乎没用过，就不在这里介绍了。</p><p>推荐使用 Nginx。</p><p>以 Centos 为例，安装十分简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装完成后，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure><p>按下 i 键插入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按 Esc，输入 <code>wq!</code> 保存。</p><p>接着重启 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>在这里，<code>server_name</code> 是你的域名。</p><p><code>root</code> 是你的博客项目路径，可以下载 FileZilla 把博客上传到服务器，或者直接使用 <code>git clone</code> 下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www</span><br><span class="line">git clone &lt;你的博客仓库地址&gt;</span><br></pre></td></tr></table></figure><p>然后你在哪买的域名，就登录到控制台把域名解析到服务器的公网 IP。</p><p>解析的方法在上面已经有介绍了，这里不再重复。</p><p>3、更新博客内容</p><p>前面的文章介绍了如何编写和更新博客：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>更新博客内容并且推送到 Github 上面，你就可以回到服务器上，然后执行 <code>git pull</code> 把最新的博客内容拉取下来，实现博客的更新。</p><p>其中，<code>hexo g</code> 和 <code>hexo d</code> 两个命令可以简写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的可以去了解一下 Git 自动构建，延伸的内容太多了，本文写不下</p></blockquote><h3 id="4、博客代码备份"><a href="#4、博客代码备份" class="headerlink" title="4、博客代码备份"></a>4、博客代码备份</h3><p>使用 <code>hexo d</code> 上传到 Github 的只是编译后的静态文件，博客的代码并没有上传到仓库里。</p><p>这样一旦你的博客代码丢失，你就无法继续更新了。</p><p>为了避免这种情况，我们要把博客代码也上传到仓库里，最好是上传到同一个仓库。</p><p>回到本地的博客项目，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b develop</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure><p>这两个步骤，第一个是切换到新的分支 <code>develop</code>（名字可以随便取），然后把新的分支推送到远程仓库。</p><p>如此一来，你的博客代码也被保存至仓库里。</p><p>前往 Github 查看，点击 Branch 即可看到新的分支：</p><p><img src="https://s2.ax1x.com/2020/03/01/3g2BzF.png" alt="git 分支"></p><p>还记得最早我们在 _config.yml 设置的 Github 仓库地址吗？</p><p><img src="https://s2.ax1x.com/2020/03/01/3g2gd1.png" alt="hexo github 配置"></p><p>这里我们把静态文件的分支设置成 master，因此我们可以专注于在 develop 分支上写博文，然后用 <code>hexo d -g</code> 进行推送，不需要进行分支切换，十分方便！</p><p>把博客代码上传到远程仓库，即使你在另一台电脑上面也可以把项目克隆下来，然后执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p>切换到 develop 分支上去写博文。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>借助 hexo 可以快速搭建属于自己的博客，平时学习到新东西的时候就可以记录下来，养成良好的习惯有助于学习成果的积累。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL占用内存过高优化记录</title>
      <link href="/mysql-memory-optimize/"/>
      <url>/mysql-memory-optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在腾讯云购买的 1 核 1G 主机，使用 Docker 搭建的 MySQL 内存占用竟然高达 34%！再加上 Docker 其他容器运行起来和系统本身程序占用的内存，总内存高达 80+%，由于其他程序使用了 Redis 作为缓存，1G 内存就剩下 10%+ 可用内存（100MB+），一不小心可能就会让服务器卡成渣甚至直接 GG。</p><p>由于服务器一天的访问量并不多，并发访问也不高，并不需要把 MySQL 优化的多好，只要能正常运行就够了，加上有 Redis 缓存这一层，几乎很少会跑到 MySQL 查询。 </p><p>所以综合起来，MySQL 压根不用担心它会挂掉，可以把默认的优化方案修改一下，以便把占用的内存释放出来。</p><p>优化后的结果如下图：</p><p><img src="https://ae01.alicdn.com/kf/H8de4ff5c012d438f96db914a35d0e207i.png" alt="MySQL优化内存"></p><h2 id="查询内存占用"><a href="#查询内存占用" class="headerlink" title="查询内存占用"></a>查询内存占用</h2><p>使用 <code>top</code> 命令查询当前程序的内存占用情况。</p><p>我们需要关注的部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                          </span><br><span class="line"> 1751 root      20   0  740212  11140   1476 S  1.2  1.1 106:46.57 barad_agent                                                                                                      </span><br><span class="line"> 1750 root      20   0  164512   8648   1312 S  0.6  0.9  20:52.41 barad_agent                                                                                                      </span><br><span class="line">29245 root      20   0  155148   2380    660 S  0.6  0.2   0:24.18 sshd                                                                                                             </span><br><span class="line">31044 root      20   0  135552   6028   1468 S  0.6  0.6   0:11.02 YDService                                                                                                        </span><br><span class="line">    1 root      20   0   43656   2764   1364 S  0.0  0.3   2:19.11 systemd</span><br></pre></td></tr></table></figure><ul><li><code>PID</code>：进程 ID</li><li><code>%CPU</code>：CPU 占用百分比</li><li><code>%MEM</code>：内存占用百分比</li><li><code>COMMAND</code>：程序命令名称</li></ul><p>如果发现某个不需要的进程占用了过高的内存或 CPU，可以直接使用 <code>kill &lt;PID&gt;</code> 杀掉进程。</p><p>进程杀掉程序就停了，我们不能直接杀掉 MySQL，具体解决思路见下一个步骤。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>MySQL 在启动的时候，会占用一部分的内存来作为缓冲区，这样做的原因是可以优化查询速度，我们可以发现只要查询过一次 MySQL，然后用相同的语句再次查询，第二次查询会比第一次更快，这其中就用到了 MySQL 自身的缓存系统。</p><p>MySQL 的缓存机制是当某一个连接访问某张表时，MySQL 会先检查访问的表是否在缓存区中，如果这张表已经在缓存区中打开，那就会直接访问缓存区从而加快查询速度，如果这张表不在缓存区，那就会从实际的数据库文件进行查询，然后再把这张表加入缓存区，以便后续查询加快速度。</p><p>由于这个机制我们的 MySQL 在运行过程占用的内存会逐渐增加，1G 的内存不适合用来做 MySQL 的优化，我们要做的就是去掉 MySQL 用来加快查询的各种机制。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改 MySQL 配置文件 <code>my.cnf</code>，找到 <code>[mysqld]</code> 下添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">&#x2F;&#x2F; 此处省略其他配置，添加如下内容</span><br><span class="line">table_open_cache&#x3D;200</span><br><span class="line">table_definition_cache&#x3D;400</span><br><span class="line">performance_schema_max_table_instances&#x3D;400</span><br><span class="line">performance_schema&#x3D;off</span><br></pre></td></tr></table></figure><p>保存然后重启 MySQL，OK！内存已经降到 10%+ 了。</p><p>各个配置项的具体用途：</p><table><thead><tr><th>字段</th><th>用途</th></tr></thead><tbody><tr><td>table_open_cache</td><td>高速缓存的大小，每当访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，下次查询该表时首先从高速缓存区查询，如果表在缓存中则直接从缓存查询，从而大幅提高查询速度。</td></tr><tr><td>table_definition_cache</td><td>定义了内存中可打开的表结构数量。</td></tr><tr><td>performance_schema_max_table_instances</td><td>检测的表对象的最大数目。</td></tr><tr><td>performance_schema</td><td>主要用来收集 MySQL 性能参数，启用 performance_schema 之后，server 会持续不间断地监测。【罪魁祸首】</td></tr></tbody></table><p>通过调整前面 3 个配置项的值，占用内存均有 1~3% 程度的降低，罪魁祸首便是 <code>performance_schema</code>，将其设置为 off 之后，内存直接降低了 20%！</p><p>其详细介绍可参考 MySQL 官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><p>当然除了上面几个配置项之外，MySQL 仍有许多可以优化的配置项，但是现在既然已经实现了自己的目的，就暂时不进行扩展阅读了，以后如果需要更深入的优化，到时候再学也不迟（日均 IP 100+ 根本不用考虑什么优化嘛~）。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏菜单系统开发之栈的妙用</title>
      <link href="/game-developer-stack/"/>
      <url>/game-developer-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="菜单系统"><a href="#菜单系统" class="headerlink" title="菜单系统"></a>菜单系统</h2><p>菜单是所有游戏必不可少的一个系统。</p><p>在游戏场景中，按 X 键可以呼出菜单，在菜单中按上下键可以切换菜单选项，再按 Z 键可以选中菜单，然后进入子页面的操作，子页面的菜单中也有子菜单，子菜单的操作与父级菜单一致。当打开菜单的状态，再按 X 键会返回上一级的菜单，直到主菜单返回游戏场景。</p><p>演示效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/02/GGIL5j.gif" alt="名为怪物的游戏 - 游戏菜单"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现菜单系统，最关键的地方在于防止按键冲突。</p><p>主菜单有按键事件，子菜单中也有按键事件，因此在主菜单中选中了子菜单，就要解除主菜单的监听事件而绑定子菜单的监听事件，多级菜单同理，可以归纳为：打开菜单——解除上一级的监听事件——绑定当前菜单的监听事件。</p><p>游戏的例子可能让从未接触过游戏的开发者难以理解，那么再看下一个例子。</p><p><img src="https://s1.ax1x.com/2020/04/02/GGLnsI.png" alt="电商菜单"></p><p>上图为某电商首页的 UI，假如产品经理提出一个需求，在这个网页上按 X 键可以展开商品分类的菜单，然后通过键盘的按键可以选择二级菜单，选中一个分类再按 Z 键展开三级菜单，在展开菜单的情况下按 X 键会返回上一级菜单，你应该如何实现此功能？</p><p>如果使用正常的方法，用变量来判断打开了哪些菜单，然后再绑定对应的事件，你会发现很难实现无限级的菜单系统，而且业务代码会变得乱糟糟的。</p><p>比如情报页面有线索二级菜单，线索菜单又可以进入到线索列表三级菜单，而角色状态可能只有一个显示角色信息的 UI，只有切换角色的按钮，没有三级菜单。</p><p>每个主菜单的选项都可能是不同的，它们没有共同点，因此你无法使用继承的关系把相同的操作提取出来，每一个菜单都要单独判断，简直是 <code>if-else</code> 地狱，不难想象代码会乱成什么样子。</p><p>在这里我们可以用“栈”的特性来优雅的实现菜单系统。</p><blockquote><p>栈：一种先进后出的数据结构</p></blockquote><p>栈是一种先进先出的结构，与队列正好相反，而我们打开菜单，按 X 键也正好是逐级向上返回，符合了栈的特性——先打开的菜单最后关闭。</p><p>在这里核心点是 <strong>监听事件与解除监听</strong>，无需关心具体的业务逻辑。</p><blockquote><p>示例语言为 TypeScript，cocos creator 游戏引擎开发</p></blockquote><p>首先我们定义一个父类 <code>StackComponent</code> 这个父类是需要调用栈的组件必须继承的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件名 Scene_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default abstract class NewClass extends cc.Component &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 添加监听按键 *&#x2F;</span><br><span class="line">    addListener() &#123;</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 移除监听按键 *&#x2F;</span><br><span class="line">    removeListener() &#123;</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);</span><br><span class="line">        cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract onKeyDown(event: cc.Event.EventKeyboard): void;</span><br><span class="line">    abstract onKeyUp(event: cc.Event.EventKeyboard): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addListener</code> 方法添加按键监听，而 <code>removeListener</code> 方法则移除监听的事件，具体的按键事件进行了抽象，由子类来实现。</p><ul><li>onKeyDown：键盘按下的时候触发</li><li>onKeyUp：键盘弹起的时候触发</li></ul><p>接着定义一个栈结构，栈非常简单就可以实现，用一个数组来保存数据，用 <code>pop</code> 方法即可弹出最后一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件名 System_StackComponent.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line">import System_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class NewClass extends cc.Component &#123;</span><br><span class="line">    private _componentStacks: System_StackComponent[] &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空栈</span><br><span class="line">     *&#x2F;</span><br><span class="line">    flushStack() &#123;</span><br><span class="line">        this._componentStacks &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从栈取出最后一个元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    popStack() &#123;</span><br><span class="line">        var len &#x3D; this._componentStacks.length;</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            cc.error(&#39;栈已空，调用失败&#39;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 弹出当前窗口</span><br><span class="line">        let pop &#x3D; this._componentStacks.pop();</span><br><span class="line">        pop.removeListener();</span><br><span class="line">        &#x2F;&#x2F; 最后一个元素添加监听</span><br><span class="line">        if (this._componentStacks.length !&#x3D; 0) &#123;</span><br><span class="line">            let last &#x3D; this._componentStacks[this._componentStacks.length - 1];</span><br><span class="line">            last.addListener();</span><br><span class="line"></span><br><span class="line">            cc.log(&#39;窗口出栈,剩余：&#39; + this._componentStacks.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 菜单组件入栈</span><br><span class="line">     * @param  component </span><br><span class="line">     *&#x2F;</span><br><span class="line">    pushStack(component: System_StackComponent) &#123;</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">            cc.error(&#39;这是一个空的元素&#39;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 原来最后一个元素移除监听</span><br><span class="line">        let len &#x3D; this._componentStacks.length;</span><br><span class="line">        if (len !&#x3D; 0) &#123;</span><br><span class="line">            let last &#x3D; this._componentStacks[len - 1];</span><br><span class="line">            last.removeListener();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前元素添加监听</span><br><span class="line">        component.addListener();</span><br><span class="line"></span><br><span class="line">        this._componentStacks.push(component);</span><br><span class="line"></span><br><span class="line">        cc.log(&quot;入栈：&quot;, this._componentStacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popStack</code> 方法弹出栈最顶层的元素，并且移除监听事件，同时监听新的顶层元素事件。</p><p><code>pushStack</code> 方法将新的菜单入栈，监听当前菜单事件并且移除原来菜单的事件。</p><p>栈中所有的元素都继承 <code>System_StackComponent</code> 栈组件，因此它们都具有 <code>addListener</code> 方法和 <code>removeListener</code> 方法。</p><p>接下来为了方便，我们把对象保存在 JavaScript 的系统对象 window 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window[&quot;__game&quot;][&quot;stack&quot;] &#x3D; new System_Stack;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过 <code>__game.stack</code> 来调用栈的方法了。</p><p>主菜单脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line">import Scene_Menu_Item from &quot;.&#x2F;Scene_Menu_Item&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class Scene_Menu extends Scene_StackComponent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 关闭菜单 *&#x2F;</span><br><span class="line">    closeMenu() &#123;</span><br><span class="line">        &#x2F;&#x2F; 弹出当前菜单事件</span><br><span class="line">        __game.stack.popStack();</span><br><span class="line">        &#x2F;&#x2F; 销毁菜单节点（让菜单消失）</span><br><span class="line">        this.node.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 显示情报面板 *&#x2F;</span><br><span class="line">    showInformationPanel() &#123;</span><br><span class="line">        &#x2F;&#x2F; 读取情报面板的预制资源</span><br><span class="line">        cc.loader.loadRes(&quot;&#x2F;prefab&#x2F;SceneInformation&quot;, (err, res) &#x3D;&gt; &#123;</span><br><span class="line">            let clueNode &#x3D; cc.instantiate(res);</span><br><span class="line">            let clue &#x3D; clueNode.getComponent(&quot;Scene_Information&quot;);</span><br><span class="line">            &#x2F;&#x2F; 把菜单脚本压入栈</span><br><span class="line">            __game.stack.pushStack(clue);</span><br><span class="line">            &#x2F;&#x2F; 调用菜单脚本的初始化方法</span><br><span class="line">            clue.init();</span><br><span class="line">            &#x2F;&#x2F; 把菜单节点添加到场景（显示菜单 UI）</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(clueNode);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 具体的监听事件</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断当前选项在“情报”菜单，如果此时按 Z 键则调用 showInformationPanel 方法显示情报页</span><br><span class="line">        &#x2F;&#x2F; 判断按 X 键调用 closeMenu 方法关闭菜单</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        &#x2F;&#x2F; 业务逻辑忽略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>closeMenu</code> 方法关闭当前菜单，并且弹出栈，在所有菜单关闭的时候都调用这个方法。</p><p><code>onKeyUp</code> 是键盘弹起事件，暂时不用理会。</p><p>在游戏场景加载中，为了能随时随地呼出菜单，我们再定义一个新的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; System_Menu.ts</span><br><span class="line"></span><br><span class="line">const &#123; ccclass, property &#125; &#x3D; cc._decorator;</span><br><span class="line"></span><br><span class="line">import Scene_Menu from &quot;.&#x2F;Scene_Menu&quot;;</span><br><span class="line">import Scene_StackComponent from &quot;.&#x2F;Scene_StackComponent&quot;;</span><br><span class="line"></span><br><span class="line">@ccclass</span><br><span class="line">export default class System_Menu extends Scene_StackComponent &#123;</span><br><span class="line">    private _menuNode: cc.Node &#x3D; null;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        __game.stack.pushStack(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 监听 X 键</span><br><span class="line">    onKeyDown(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">        switch (event.keyCode) &#123;</span><br><span class="line">            case cc.macro.KEY.x:</span><br><span class="line">                this.show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onKeyUp(event: cc.Event.EventKeyboard) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 显示菜单 *&#x2F;</span><br><span class="line">    show() &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载菜单预制资源并添加到场景</span><br><span class="line">        cc.loader.loadRes(&quot;&#x2F;prefab&#x2F;Menu&quot;, (err, res) &#x3D;&gt; &#123;</span><br><span class="line">            let node &#x3D; cc.instantiate(res);</span><br><span class="line">            let menu: Scene_Menu &#x3D; node.getComponent(&quot;Scene_Menu&quot;);</span><br><span class="line">            &#x2F;&#x2F; 将主菜单入栈</span><br><span class="line">            __game.stack.pushStack(menu);</span><br><span class="line">            this._menuNode &#x3D; node;</span><br><span class="line">            &#x2F;&#x2F; 添加到场景</span><br><span class="line">            cc.find(&quot;Scene&quot;).addChild(node);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将这个类添加到 window 系统对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加到 window 对象</span><br><span class="line">window[&quot;__game&quot;][&quot;menu&quot;] &#x3D; new System_Menu;</span><br><span class="line">&#x2F;&#x2F; 执行初始化操作（入栈）</span><br><span class="line">__game.menu.init();</span><br></pre></td></tr></table></figure><p>如此一来，我们就可以随时随地通过全局的方法 <code>__game.menu.show()</code> 调出菜单了！</p><p>注意！<code>System_Menu</code> 脚本并没有出栈的操作，因为如果这个脚本出栈了，那就不能监听 X 呼出菜单的事件，保留最底层的监听以便随时呼出菜单。</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>由于菜单是一级一级往上打开，而关闭的时候是一级一级向下关闭，因此它符合栈的结构，当一个菜单节点入栈时，我们为它绑定监听事件，同时解除上一级菜单的监听事件；当一个菜单出栈时，我们就解除这个菜单的监听事件，然后再给栈新的顶层节点绑定监听事件，无论有多少级的菜单都能够用这种结构来实现，只要让它们继承 <code>StackComponent</code> 类即可实现栈的调用控制事件的监听与解除，比起用变量来判断打开了哪些菜单，是不是优雅得多呢？</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript使用对象必须知道的一件事</title>
      <link href="/javascript-object-issue/"/>
      <url>/javascript-object-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 中，对象即引用。</p><p>我们知道引用的特性：</p><p>将对象赋值给另一个变量，另一个变量的值如果改变，原对象的值也会改变。</p><p>引用即是内存地址的指向，将对象赋值给另一个变量，相当于另一个变量也指向了同一块内存地址，因此改变值时，原对象的值也会跟着变。通过下面的例子来了解一下引用的特性。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 将json对象赋值给另一个变量</span><br><span class="line">let data &#x3D; json;</span><br><span class="line">data.aa &#x3D; &quot;no ok!&quot;;</span><br><span class="line">&#x2F;&#x2F; 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>在控制面板上的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们原本是希望把 json 变量的值赋值给另一个变量 data，本意是不希望修改 json 的值，但由于 JavaScript 中对象即引用的特性会导致原来的值发生改变。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用 <code>Object.assign(target, source)</code> 方法将 source 对象复制一份给 target 变量，类似 PHP 中的 clone，复制出来的变量会独立占据一片内存空间，而不是原对象的引用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 复制对象到data</span><br><span class="line">let data &#x3D; &#123;&#125;;</span><br><span class="line">Obejct.assign(data, json);</span><br><span class="line">&#x2F;&#x2F; 修改aa的值</span><br><span class="line">data.aa &#x3D; &quot;no ok!&quot;;</span><br><span class="line">&#x2F;&#x2F; 输出两个对象</span><br><span class="line">console.log(json, data);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object &#123; aa: &quot;Im aa&quot;, bb: &quot;Im bb&quot; &#125; Object &#123; aa: &quot;no ok!&quot;, bb: &quot;Im bb&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，原来的 json 对象的值没有改变。</p><p>在 TypeScript 中，不能直接使用 <code>Object.assign</code> 方法，而是要使用 <code>(&lt;any&gt;Object).assign</code>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个json对象</span><br><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &quot;aa&quot;: &quot;Im aa&quot;,</span><br><span class="line">    &quot;bb&quot;: &quot;Im bb&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 复制对象到data</span><br><span class="line">let data &#x3D; &#123;&#125;;</span><br><span class="line">(&lt;any&gt;Object).assign(data, json);</span><br></pre></td></tr></table></figure><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>由于 cocos creator 使用的是 JavaScript 和 TypeScript 开发，今天在制作游戏的事件系统，遇到一个神秘的 BUG，排查了好久一直没找到原因，突然想起来以前也遇到过同样的问题，为了涨点记性，特此记录。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux自定义别名——大幅提高工作效率！</title>
      <link href="/linux-alias/"/>
      <url>/linux-alias/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-系统命令"><a href="#Linux-系统命令" class="headerlink" title="Linux 系统命令"></a>Linux 系统命令</h2><p>在 <code>Linux</code> 系统中，诸如 <code>ls</code>、<code>top</code>、<code>ps</code> 此类为 <code>Linux</code> 系统内置的命令，我们希望通过自定义命令来作为某些复杂命令的组合，如自定义 <code>ll</code> 为 <code>ls -alF</code> 的简写，通过简写可以大幅缩短输入命令的时间，还可以避免输错命令，何乐而不为呢？</p><h2 id="自定义-Linux-命令-添加别名-Alias"><a href="#自定义-Linux-命令-添加别名-Alias" class="headerlink" title="自定义 Linux 命令 / 添加别名 Alias"></a>自定义 Linux 命令 / 添加别名 Alias</h2><p>自定义命令其实就是添加一个别名，执行如下命令创建别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure><p>在这个文件里输入需要创建的别名，例如 <code>ll</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll&#x3D;&#39;ls -alF&#39;</span><br></pre></td></tr></table></figure><p>然后保存，再执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>现在，使用 <code>ll</code> 等价于输入 <code>ls -alF</code>。</p><p>可以将常用的命令组合简写，例如我们常用来查看进程的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias psp&#x3D;&#39;ps -ef|grep&#39;</span><br></pre></td></tr></table></figure><p>以后只需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 PHP 进程</span><br><span class="line">psp php</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">FireRabbitdeMacBook-Pro:~ firerabbit$ psp php</span><br><span class="line">  501 89356     1   0 二07下午 ??        29:02.94 &#x2F;Applications&#x2F;PhpStorm.app&#x2F;Contents&#x2F;MacOS&#x2F;phpstorm</span><br><span class="line">  501 99412 99183   0  9:20下午 ttys005    0:00.00 grep php</span><br></pre></td></tr></table></figure><p>对于记不住命令的小金鱼们来说，利用好别名可以事半功倍哟！</p><h2 id="注意事项！"><a href="#注意事项！" class="headerlink" title="注意事项！"></a>注意事项！</h2><p>别名的使用只有定义者自己知道，因此不适合多人协作的工作。在日常的开发中（如在个人的 Mac），可以自定义一些常用的别名来提高自己工作的效率。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis添加密码验证</title>
      <link href="/redis-add-permission/"/>
      <url>/redis-add-permission/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要为-Redis-添加密码验证？"><a href="#为什么要为-Redis-添加密码验证？" class="headerlink" title="为什么要为 Redis 添加密码验证？"></a>为什么要为 Redis 添加密码验证？</h2><p>默认情况下，<code>redis</code> 不需要使用密码即可连接，而由于默认开放端口为 6379（用户一般不会去修改这个端口），导致基本信息完全暴露给试图攻击服务器者。</p><blockquote><p>IDCE.COM 建站之初未设置 redis 密码，结果被注入了挖矿病毒 %&gt;_&lt;%</p></blockquote><p>没有任何密码验证，意味着任何人都能访问到服务器的 Redis 服务，可能造成重要的信息泄露或者被访问者恶意删除造成严重后果！</p><p>总而言之，如果要使用 Redis 服务，那么最好为 <code>redis</code> 加上密码验证可以增加系统的安全性。</p><h2 id="开启-redis-密码验证"><a href="#开启-redis-密码验证" class="headerlink" title="开启 redis 密码验证"></a>开启 redis 密码验证</h2><p>以 <code>Linux</code> 系统为例，首先找到 <code>redis.conf</code> 配置文件，如果不知道文件在哪可以使用命令 <code>find / -name redis.conf</code> 找到。</p><p>添加 <code>requirepass</code> 字段，后面即你需要设置的密码，建议生成一个足够长的随机字符串来作为密码。</p><p><img src="https://i.loli.net/2019/08/29/l7msnYqtQeOiUNp.png" alt="image.png"></p><p>完成后保存，重启 <code>redis</code> 即可！</p><h2 id="Redis-cli-验证密码"><a href="#Redis-cli-验证密码" class="headerlink" title="Redis-cli 验证密码"></a>Redis-cli 验证密码</h2><p>在 <code>cli</code> 模式下，如果设置了密码需要验证之后才能执行 <code>redis</code> 操作，进入 <code>redis</code> 服务，然后执行 <code>auth 密码</code> 即可。</p><p><img src="https://i.loli.net/2019/08/29/VqJUpRx25HbELGA.png" alt="image.png"></p><h2 id="PHP-验证-Redis-密码"><a href="#PHP-验证-Redis-密码" class="headerlink" title="PHP 验证 Redis 密码"></a>PHP 验证 Redis 密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$redis &#x3D; new Redis(); </span><br><span class="line">$redis-&gt;connect(&#39;127.0.0.1&#39;, 6379); &#x2F;&#x2F;连接Redis</span><br><span class="line">$redis-&gt;auth(&#39;123456&#39;); &#x2F;&#x2F;密码验证</span><br><span class="line">$redis-&gt;select(2);&#x2F;&#x2F;选择数据库2</span><br><span class="line">$redis-&gt;set( &quot;testKey&quot; , &quot;Hello Redis&quot;); &#x2F;&#x2F;设置测试key</span><br><span class="line">echo $redis-&gt;get(&quot;testKey&quot;);&#x2F;&#x2F;输出value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker更换镜像源</title>
      <link href="/docker-change-mirrors/"/>
      <url>/docker-change-mirrors/</url>
      
        <content type="html"><![CDATA[<h2 id="国内镜像源"><a href="#国内镜像源" class="headerlink" title="国内镜像源"></a>国内镜像源</h2><h3 id="Docker-官方镜像中国区"><a href="#Docker-官方镜像中国区" class="headerlink" title="Docker 官方镜像中国区"></a>Docker 官方镜像中国区</h3><p><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>阿里的镜像异常麻烦，本着求真的角度，还是把这一部分补充了 %&gt;_&lt;%。</p><p>首先需要注册成为阿里开发者，前往：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云开发者中心</a>。</p><p>注册并登陆后，点击右上角的<strong>控制台</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141265-f297c080-ce39-11e9-92ca-1c89280fe717.png" alt="image"></p><p>想吐槽阿里云的界面设计，阿里云是一个超级聚合体……里面的服务实在太多，如果不写这样一个图文教程很难找到自己想要的功能，操作步骤如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141431-91242180-ce3a-11e9-87d2-6edc56597f8c.png" alt="image"></p><p>进入容器镜像服务，点击左侧菜单的<strong>镜像中心-镜像加速器</strong>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64141511-e5c79c80-ce3a-11e9-8fe4-037f95849052.png" alt="image"></p><p>根据阿里的提示操作即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;93m46zjd.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>这里的 <code>https://93m46zjd.mirror.aliyuncs.com</code> 是我的个人镜像源加速地址，建议自己申请一个。</p><h2 id="更换-Docker-镜像源"><a href="#更换-Docker-镜像源" class="headerlink" title="更换 Docker 镜像源"></a>更换 Docker 镜像源</h2><h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h3><p>Docker 使用 <code>daemon.json</code> 作为配置文件，如果没有的话则创建，编辑 <code>daemon.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p>添加仓库地址（以中科大镜像源为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成并保存，重启 docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>作为一个学府，中科大还十分贴心的写了帮助文档：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">Docker 镜像使用帮助</a></p><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>Docker for Window 可以直接通过右键右下角小鲸鱼，选择 Settings，选择 Daemon 选项卡，在右下角的 Registry mirrors 添加对应的镜像源地址即可。</p><h3 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><p>如果你是下载了 Docker 桌面版的 Mac 系统用户，启动 Docker，选择右上角的小鲸鱼图标，选择菜单中的 <code>Preferences</code>：</p><p><img src="https://i.loli.net/2019/09/03/PeijKIqDGrZVgct.png" alt="image.png"></p><p>在选项卡中选择 Daemon，点击 <code>Registry mirrors</code> 下方的加号，输入需要添加的国内镜像源地址，完成后点击底部的 <code>Apply &amp; Restart</code> 应用配置并重启 Docker：</p><p><img src="https://user-images.githubusercontent.com/28209810/64140700-f4f91b00-ce37-11e9-8e02-e5c4d2b1682c.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统安装Pecl</title>
      <link href="/mac-install-pecl/"/>
      <url>/mac-install-pecl/</url>
      
        <content type="html"><![CDATA[<h2 id="PECL-简介"><a href="#PECL-简介" class="headerlink" title="PECL 简介"></a>PECL 简介</h2><p>PECL（The PHP Extension Community Library）是 PHP 扩展的存储库，为 PHP 所有的扩展提供提供托管和下载服务。</p><p>一些常用及优秀的 PHP 扩展均被收录在 PECL 中，如：yaf、swoole 等等，我们可以方便的使用 pecl 命令来安装这些扩展。</p><p>PECL 支持的扩展：<a href="http://pecl.php.net/" target="_blank" rel="noopener">PECL All Packages</a></p><p>在 Mac 系统或 Linux 系统中可能没有默认安装 pear，因此无法使用 pecl 命令，本文将介绍如何安装 pear。</p><h2 id="PEAR-安装方法"><a href="#PEAR-安装方法" class="headerlink" title="PEAR 安装方法"></a>PEAR 安装方法</h2><p>官方文档：<a href="https://pear.php.net/manual/en/installation.getting.php" target="_blank" rel="noopener">Getting and installing the PEAR package manager</a></p><h3 id="1、下载-PEAR"><a href="#1、下载-PEAR" class="headerlink" title="1、下载 PEAR"></a>1、下载 PEAR</h3><p>使用 curl 命令下载即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;pear.php.net&#x2F;go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="2、-安装-PEAR"><a href="#2、-安装-PEAR" class="headerlink" title="2、 安装 PEAR"></a>2、 安装 PEAR</h3><p>下载完成后，执行下面命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo php -d detect_unicode&#x3D;0 go-pear.phar</span><br></pre></td></tr></table></figure><h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p>安装过程需要配置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Below is a suggested file layout for your new PEAR installation.  To</span><br><span class="line">change individual locations, type the number in front of the</span><br><span class="line">directory.  Type &#39;all&#39; to change all of them or simply press Enter to</span><br><span class="line">accept these locations.</span><br><span class="line"></span><br><span class="line"> 1. Installation base ($prefix)                   : &#x2F;usr</span><br><span class="line"> 2. Temporary directory for processing            : &#x2F;tmp&#x2F;pear&#x2F;install</span><br><span class="line"> 3. Temporary directory for downloads             : &#x2F;tmp&#x2F;pear&#x2F;install</span><br><span class="line"> 4. Binaries directory                            : &#x2F;usr&#x2F;bin</span><br><span class="line"> 5. PHP code directory ($php_dir)                 : &#x2F;usr&#x2F;share&#x2F;pear</span><br><span class="line"> 6. Documentation directory                       : &#x2F;usr&#x2F;docs</span><br><span class="line"> 7. Data directory                                : &#x2F;usr&#x2F;data</span><br><span class="line"> 8. User-modifiable configuration files directory : &#x2F;usr&#x2F;cfg</span><br><span class="line"> 9. Public Web Files directory                    : &#x2F;usr&#x2F;www</span><br><span class="line">10. System manual pages directory                 : &#x2F;usr&#x2F;man</span><br><span class="line">11. Tests directory                               : &#x2F;usr&#x2F;tests</span><br><span class="line">12. Name of configuration file                    : &#x2F;private&#x2F;etc&#x2F;pear.conf</span><br><span class="line"></span><br><span class="line">1-12, &#39;all&#39; or Enter to continue:</span><br></pre></td></tr></table></figure><p>修改安装时的根目录，输入 1，再输入 <code>/usr/local/pear</code>，回车；</p><p>修改命令的安装目录，输入 4，再输入 <code>/usr/local/bin</code>，回车；</p><p>其它选项使用默认即可，一路回车。</p><h3 id="4、测试是否安装成功"><a href="#4、测试是否安装成功" class="headerlink" title="4、测试是否安装成功"></a>4、测试是否安装成功</h3><p>输入命令 <code>pear version</code>，如果成功安装将会看到类似如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PEAR Version: 1.10.9</span><br><span class="line">PHP Version: 7.1.23</span><br><span class="line">Zend Engine Version: 3.1.0</span><br><span class="line">Running on: Darwin hongjiahuangdeMac-mini.local 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2&#x2F;RELEASE_X86_64 x86_64</span><br></pre></td></tr></table></figure><p>接下来就可以使用 <code>pecl install &lt;扩展名称:版本号&gt;</code> 安装各种被 PECL 收录的扩展了。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis淘汰机制</title>
      <link href="/redis-delete-policy/"/>
      <url>/redis-delete-policy/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>redis 的配置文件为 <code>redis.conf</code>，当 redis 占用的内存达到配置的最大内存时，再使用 redis 增加新的值时会触发淘汰机制将占用的内存释放出来，以创建新的键值。</p><p>redis 允许占用的最大内存，约在 567 行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>找到 <code>maxmemory</code> 去掉前面的 <code>#</code> 井号， 将 <code>&lt;bytes&gt;</code>（单位：字节） 改为需要设置的最大内存值，一般而言，建议设置为服务器总内存的 50%~75%（需根据服务器情况确定），如果服务器其他进程占用较多内存的话，可以减少这个值。</p><p>当 redis 内存占用达到设置的最大值，触发的淘汰策略，约在 598 行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>去掉前面的 <code>#</code> 井号，后面即为淘汰的策略，淘汰策略有许多种，下面进行介绍。不过在此之前，我们可以理解一下 redis 如何淘汰掉键值。</p><p>我们通过给一个键值设置过期时间，来让它“自动过期”，但实际上，即使到了过期时间，这个键其实并没有立即被删除，而是当下次取这个键值的时候进行判断，如果这个键设置了过期时间，同时已经过了过期时间再进行删除，这是一种惰性的删除策略。</p><p>此外，除了这种被动删除的策略之外还有主动删除策略，例如定期扫描过期的键值，扫描也不可能将全部的键都扫秒一遍，而是通过某种随机算法获取某些键，判断键是否过期再决定是否删除。</p><p>为什么键设定了过期时间不能在到期后立即删除呢？因为从技术的角度上来考虑这是一件十分困难的事，如果要追踪一个键值的过期时间，可能需要启动一个进程来追踪并且在过期时“杀掉”这个键，这样使用 redis 的优势就全部没有了，反而要消耗更多的系统资源。</p><p>redis 过期的键太多而没有删除，会造成内存资源的浪费，反之，如果过于频繁的去检查过期的键，希望在第一时间释放出内存资源，频繁的检查也是十分耗费资源的事，因此两者之间必须存在一个平衡，这就需要依靠 redis 的淘汰策略。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>redis 有如下淘汰策略：</p><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧</p><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</p><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</p><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/redis-base/"/>
      <url>/redis-base/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是由 ANSI C（标准C语言）写的键值对存储系统，由于是存储在内存中的，所以性能极高，但我们知道存储在内存中一旦电脑关闭就会丢失数据，Redis 还提供了数据持久化的功能，也就是说，Redis 的数据也可以保存在本地硬盘中。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>所谓原子操作指的是不可再分割的操作，要么都成功，要么都失败。</p><p>Redis 的操作结果一定是确定的，例如将商品库存存储在 Redis 中，此时由于高并发场景有 1000 个请求进入，判断减少库存，总库存为 999 个，那么第 1000 个请求会因为高并发的场景而判断失误吗？答案是不会。</p><p>同理，一些抽奖活动将奖品数量存储在 Redis 进行操作，不会出现奖品被人领光还能领到奖品的情况，当有面试官问你就这么告诉他。</p><p>以抽奖场景示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取数据库奖品余额</span><br><span class="line">$count &#x3D; PrizeModel::getCount();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否还有可以领取的奖品</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理领奖逻辑，并且减少奖品数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，涉及到读后写的问题，在读取奖品余额后更新奖品数量，由于读写操作是分开的，可能因为请求的先后而产生不同结果；比如 A 进来领取奖品，奖品的库存是 1，此时 B 也进来领取奖品，这个时候他也判断了奖品库存是 1，这个时候奖品的数量只剩 1 个，却有两个人被判断为可以领取奖品，就出现奖品库存变为负数的情况。</p><p>导致问题的根本原因在于读操作与写操作是分离的，中间如果有其他的请求进来，那么读操作的结果就是不准确的，可以使用 Redis 的 <code>decr</code>（自减）来操作商品库存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis &#x3D; new Redis();</span><br><span class="line">$count &#x3D; $redis-&gt;decr(&#39;prize&#39;);</span><br><span class="line">if($count &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理领奖逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 的 <code>decr</code> 命令将值减 1，并且返回了计算后的结果，实现了读写同步的操作，因此不会产生因为高并发场景读取了错误数据的情况。</p><p>这些都是依赖 Redis 的原子操作，之所以能够实现原子操作，是因为 <strong>Redis 是单线程</strong>。</p><p>假如对方问你，为什么单线程就是原子操作？</p><blockquote><p>扩展阅读：<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101" target="_blank" rel="noopener">什么是线程</a></p></blockquote><p>操作系统调度任务以线程为基本单位，Redis 所有的指令都在一个线程中进行，不会扩展出额外的线程；多线程，比如 MySQL 启动的时候是一个进程，而执行增删改查操作就是一个新的线程。多线程指的是可以同时干很多件事，而单线程只能一件事一件事的干，做完一件事才做下一件事，从效率上来说多线程远远超出单线程，但单线程的优势是每一步的执行结果都是确定的，要么都成功，要么都失败。</p><p>实际上，Redis 虽然是单线程但效率也是非常高的，因为它完全基于内存操作。</p><h2 id="键"><a href="#键" class="headerlink" title="键"></a>键</h2><p>Redis 使用键值对的形式存储数据，键类似于变量名字，键是一个字符串，最大长度 512MB，与开发语言不同的是　Redis 中的键可以使用一些开发语言中不能作为命名的符合，如：冒号、横杠。</p><p>键名称太长，会占用更多的内存空间，此外，太长的键名也会多查找造成影响；名称太短，又会造成语义不清，所以在取键名的时候需要有规范。</p><p><strong>键的名称区分大小写</strong>，不建议大小写混用，要么全部大写，要么全部小写，取名“见名知意”为佳。</p><p>可以参考如下规则：</p><p>第一段为项目名称或者缩写形式（非必需），如：project 或 pro<br>第二段为表的名字，如：user<br>第三段为区分键的字段，如：MySQL 主键的列名，属性名<br>第四段为键的特征字段，可以作为查询依据，如：MySQL 中主键 ID 的值</p><p>键的各个字段通常用冒号隔开。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 根据 ID</span><br><span class="line">idce:users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">idce:users:name</span><br></pre></td></tr></table></figure><p>前缀增加项目名称的用途是：当一个 Redis 服务器部署了多个项目可以进行区分，如果是单个项目，则可以去掉项目名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:id:1</span><br><span class="line"></span><br><span class="line"># 根据属性名 name</span><br><span class="line">users:name</span><br></pre></td></tr></table></figure><p>在项目中，最好有一个统一管理键名称的地方，否则后期无法进行维护。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis 支持如下数据结构：</p><ul><li>String：字符串</li><li>Hash：哈希</li><li>List：列表</li><li>Set：集合</li><li>Sorted Set：有序集合</li></ul><h2 id="PHP-使用-Redis"><a href="#PHP-使用-Redis" class="headerlink" title="PHP 使用 Redis"></a>PHP 使用 Redis</h2><p>PHP 想要使用 Redis 需要安装 redis 相关的扩展：<a href="https://pecl.php.net/package/redis" target="_blank" rel="noopener">PECL - REDIS 扩展下载</a>。</p><p>也可以不使用扩展，直接下载 predis：<a href="https://github.com/nrk/predis" target="_blank" rel="noopener">Github - Predis 下载</a></p><p>将下载的包使用 <code>require</code> 命令引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &quot;.&#x2F;lib&#x2F;predis-1.1&#x2F;autoload.php&quot;;</span><br></pre></td></tr></table></figure><h2 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于其高性能的特性可以作为数据缓存，对于频繁查询但是不经常更新的数据可以将其缓存到 Redis 中，从而减少数据库查询压力，例如商品的库存、金额，需要注意的是当这些数据更新的时候也必须同步更新缓存数据。</p><p>此外，对于像微博的阅读量此类频繁更新的数据，也可以用缓存处理。方法是获取一条微博详情的时候，先判断是否有缓存，有的话先从缓存读取阅读量的数据，没有的话就从数据库读取，然后保存在 Redis 中；当用户访问时，直接在 Redis 操作访问量的增加，然后设置一个定时器程序，定期将缓存中的阅读量写入数据库，不过，这种类型的数据一般是比较不重要的，因为有可能会发生意外服务器重启导致数据丢失而没有正常写入数据库。</p><p>当某种数据需要频繁的查询或更新时可以使用 Redis 作为缓存。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>我们经常会收到亲朋好友要求帮忙给他们家的小盆友投票（一般是才艺表演之类的），根据点赞数进行排行，排在前几名的会有奖励之类的。排行榜的数据变化十分频繁，这个时候就可以使用 Redis 的有序集合结构来存储排行数据。</p><h3 id="分布式锁、本地锁"><a href="#分布式锁、本地锁" class="headerlink" title="分布式锁、本地锁"></a>分布式锁、本地锁</h3><p>Redis 中有一种命令 <code>setnx</code> 意为 <code>set if not exists</code>，即当不存在时设置数据，否则不进行操作，利用这种特性可以实现分布式锁。当成功设置的时候就执行后面的逻辑，如果未能成功设置代表之前已经执行过了，就不再走后面的逻辑。</p><p>锁的作用是防止重复动作，比如用户在点击领取奖励的时候，发现没有响应（网络延迟导致），结果用户以为自己没点下去就多点了几次，如果不做防止重复提交的处理，很有可能会造成领取到多次奖励的 BUG。</p><p>分布式就是多台机子间，而本地锁指的是本机，其原理类似，比如设置一个带有过期时间的 String 类型的缓存，如果这个键不为空则代表加过锁了。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中的列表结构由于读取头尾的速度非常快，因此适合作为消息队列的容器，将任务队列存储在 Redis 中可以大大提高程序的执行效率（与传统的数据库存储相比）。</p><h2 id="Redis-安全隐患"><a href="#Redis-安全隐患" class="headerlink" title="Redis 安全隐患"></a>Redis 安全隐患</h2><p>其中一个是未设置密码问题：<a href="https://idce.com/archive/PLlWREOZ?id=VDej" target="_blank" rel="noopener">Redis 未设置密码导致服务器被安装挖矿病毒</a></p><p>此外，Redis 即使正常使用也可能存在安全隐患。</p><p>缓存分为过期缓存和不过期缓存，不过期缓存过多可能造成内存溢出，而过期缓存又可能带来新的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的是查询一个缓存中不存在的数据，比如我们设置了一个根据用户 ID 来获取用户信息的缓存，此时如果我们输入 -1 或者其他不存在的 ID，那么系统将会判断缓存不存在，接着就去数据库查询。</p><p>这种“绕过”缓存查询数据库的行为类似于直接穿透了 Redis。</p><p>如果有人利用了这一点编写程序大量查询不存在的用户 ID 就很可能造成数据库崩溃。</p><p>解决方法是即使不存在的用户 ID 也设置一个空的缓存的键值，不过此类键值需要设置一个较短的过期时间，否则也可能会被恶意查询造成内存溢出。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>雪崩指的是一种短期内产生的爆发性冲击，在 Redis 中，如果有许多缓存在同一时刻过期，就会造成大量的数据需要从数据库查询，面对冲击性涌入的查询，数据库很可能造成崩溃。</p><p>解决方法是尽可能的让缓存的过期时间不一样，热门数据的缓存时间更长一些，对于同类型的数据可以设置一个额外的随机时间来让同类型的数据也会在不同时刻过期。</p><p>除此之外，还可以设计多级缓存结构来防止缓存雪崩。</p><p>当第一层的缓存过期了，不从数据库读取，而是判断第二层缓存是否存在，如果有就直接取数据，如果没有再判断下一层缓存……以此类推。这样的结构称为多级缓存，多级缓存结构比较复杂，其中第一层缓存叫做一级缓存，第二层叫做二级缓存……多级缓存结构可以防止突发性的冲击造成数据库崩溃，不过这样系统的复杂性会变高，多级缓存需要有一个程序来定期维护下级缓存，一般由架构师进行设计。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿与缓存雪崩有些类似，不过不同的是缓存击穿指的是某个单一的键值过期，但是此时却有大量的流量涌入，造成所有的请求都直接到数据库那边，相当于在某个点凿出了一个洞，因此叫做“击穿”。</p><p>防止缓存击穿的方法：</p><p>方法（一）：后台增加一个定期任务刷新缓存的过期时间。</p><p>方法（二）：将缓存的过期时间也保存在值里面，当获取这个缓存数据的时候判断过期时间，在超过设置的阀值时更新这个缓存的过期时间。</p><p>方法（三）：可以使用缓存雪崩所说的多级缓存方法。</p><p>方法（四）：增加锁机制，当缓存过期查询数据库时，判断锁，只允许一个请求进来，其他请求都进入等待状态，进入的请求在查好数据后更新缓存，此时等待中的请求就可以获取到数据了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 还有许多应用，持续保持学习中……</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window环境下安装Docker的坑</title>
      <link href="/window-install-docker-issue/"/>
      <url>/window-install-docker-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近下载了 Docker for Window 搭建 Win10 系统的 PHP 环境，结果遇到了一大堆问题，网络上搜索答案极少，而且也很难找到能解决问题的方法，通过不断尝试和推测，踩了很多坑，也找到了填坑的办法，在此记录下来。</p><p>Docker for Window 下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker 官方网站下载</a></p><h2 id="Docker-Hub-登录问题"><a href="#Docker-Hub-登录问题" class="headerlink" title="Docker Hub 登录问题"></a>Docker Hub 登录问题</h2><p>需要注册一个 Docker Hub 来进行登录，登录的帐号只能是 Docker ID，也就是注册时的用户名，而不是邮箱，此处需要注意，在使用 <code>docker login</code> 命令时经常会犯错而无法成功登录。</p><h2 id="Hyper-V-缺失问题"><a href="#Hyper-V-缺失问题" class="headerlink" title="Hyper-V 缺失问题"></a>Hyper-V 缺失问题</h2><p>Docker for Window 依赖 Hyper-V（微软的虚拟机系统），只有 Window 专业版才有这个功能，家庭版如果需要开启此功能就需要升级到专业版。</p><blockquote><p>查看电脑系统的方法：右键我的电脑，选择属性即可看到 Window 版本信息。</p></blockquote><p>家庭版也可以不升级，安装另一个 Docker 的产品——Docker Tool。</p><p>Docker Tool 不依赖 Hyper-V，而是 VirtualBox（也是一种虚拟机软件），如果安装了 Docker Tool，则会自动安装 VirtualBox。Docker Tool 的操作方法与 Docker for Window 不太一样，更复杂一些，虽然本人也尝试下载过，但是感觉十分不便，因此最后卸载了。（由于安装了 Docker Tool，这里又挖了一个新坑，后面进行介绍）</p><p>本人用的是 Win10 专业版系统，却发现没有 Hyper-V 这个选项，原来是因为下载了精简版的 ISO 作为装机镜像，一些装机系统那边下载的软件都是经过二次封装的，削减了一部分的功能，因此推荐用那些精简过的系统。</p><p>找了许多装机的 ISO 镜像，最后决定下载微软官方原版的 ISO 镜像（十分干净，不带第三方软件），然后重新安装了 Win10 专业版。</p><p>Window MSDN 镜像下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN 我告诉你</a></p><p>选择左侧的系统，根据个人需求安装即可，不过据说对 Window 版本有一定的要求，太早的版本可能还是没有这个功能，建议至少 Win 8 以上(专业版)。</p><p>查看 Hyper-V 的方法是打开 <strong>控制面板</strong>，然后选择 <strong>程序</strong>，再选择 <strong>启用或关闭 Windows 功能</strong>。</p><p>重装后的系统已经可以看到 Hyper-V 这个选项了，如下图所示：</p><p><img src="https://i.loli.net/2019/10/20/uHBJOYP3Mtze6jc.png" alt="image.png"></p><p>勾选后选择确定，重新启动电脑。</p><h2 id="开启-Hyper-V-导致无法开机问题"><a href="#开启-Hyper-V-导致无法开机问题" class="headerlink" title="开启 Hyper-V 导致无法开机问题"></a>开启 Hyper-V 导致无法开机问题</h2><p>在开启 Hyper-V 的过程中，又遇到新的问题，如果将 Hyper-V 勾选起来点击确定，系统会安装软件然后提示重新启动，此时重新启动会导致电脑无法开机，一直在开始界面，并且提示“系统正在自动修复”。</p><p>只有进入到安全模式，将 Hyper-V 取消掉才能正常开机；又或者多次重启失败，系统自动恢复最后一次正确的配置。网上查了很多资料都没有找到解决方法，于是推测是因为相关的虚拟机服务没有启动导致的。</p><p>解决方法是进入服务管理，将 Hyper-V 的相关服务调整为“自动启动”，点击开始，选择运行（或者直接按 Win+R 快捷键），然后输入 <code>services.msc</code> 进入服务管理。</p><p><img src="https://i.loli.net/2019/10/20/75OeL1pd4x6QtzS.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/hkmugev9KtBzlZ3.png" alt="image.png"></p><p>然后打开 Hyper-V，再重启就可以了。</p><h2 id="Docker-命令被占用"><a href="#Docker-命令被占用" class="headerlink" title="Docker 命令被占用"></a>Docker 命令被占用</h2><p>在安装好了 Docker for Window 后，打开命令行使用 docker 命令，却提示如下的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unable to resolve docker endpoint: open C:\Users\Administrator\.docker\machi....</span><br></pre></td></tr></table></figure><p>大致意思是找不到某个文件，而 <code>docker-machine</code> 是 Docker Tool 用到的东西，在翻找了许多资料后才发现原来是卸载时残留的环境变量导致的问题，Docker Tool 虽然卸载了，但是环境变量还在，这就导致了使用 docker 命令用的环境变量路径还是 Docker Tool 设置的路径，由于软件被卸载了，路径自然就找不到了。</p><p>解决方法是删掉残留的环境变量。</p><p>右键我的电脑，高级系统设置，环境变量。</p><p><img src="https://i.loli.net/2019/10/20/VLGM5XjYpJhZEeW.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/1HFzeVMgtSoLRb7.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/10/20/QYVrGO3k2M8By1D.png" alt="image.png"></p><p>然后在用户变量与系统变量中，找到 Docker 相关的变量全部删除，然后卸载掉 Docker for Window，重装一遍，即可解决（建议重启一次电脑）。</p><h2 id="磁盘共享"><a href="#磁盘共享" class="headerlink" title="磁盘共享"></a>磁盘共享</h2><p>Docker 恢复正常以后，本人使用的是自己封装的一套 docker-compose 系统，由于里面用到了容器卷，在 Window 系统中还存在磁盘共享问题。</p><p>在使用 <code>docker-compose up -d</code> 的时候遇到如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot create container for service redis: b&#39;Drive sharing failed for an unk...</span><br></pre></td></tr></table></figure><p>大致意思是说磁盘共享失败。</p><p>解决方法是打开 Docker for Window 的 Settings，右键右下角的小鲸鱼图标进入设置界面，在设置界面中选择 Shared Drives 选项卡，将需要共享的磁盘勾选起来，然后点击 Apply（应用）保存设置，这个过程可能需要输入 Window 系统的用户名和密码，如果没有设置密码则需要设置一个。</p><p><img src="https://i.loli.net/2019/10/20/RCuri4gzwynGNeH.png" alt="image.png"></p><h2 id="Docker-Compose-路径问题"><a href="#Docker-Compose-路径问题" class="headerlink" title="Docker-Compose 路径问题"></a>Docker-Compose 路径问题</h2><p>接着又遇到新的问题，执行 <code>docker-compose up -d</code> 弹出如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: for workspace_redis_1  Cannot start service redis: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;process_linux.go:430: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;&#x2F;etc&#x2F;localtime\\\&quot; to rootfs \\\&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27&#x2F;merged\\\&quot; at \\\&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c6e01c3620bbec9f7dc46bc22dbda8a9cdbf050746f17af60e665fb2191f5d27&#x2F;merged&#x2F;usr&#x2F;share&#x2F;zonStarting workspace_mysql_1 ... error</span><br></pre></td></tr></table></figure><p>这是由于我在 <code>docker-compose.yml</code> 文件中写了一个错误的路径，<code>/etc/localtime</code> 是 Linux 系统里面的路径，将它去掉就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">        build: redis&#x2F;</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">          - .&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">          - .&#x2F;var&#x2F;logs&#x2F;redis.log:&#x2F;var&#x2F;log&#x2F;redis.log</span><br><span class="line">          - &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime</span><br><span class="line">        ports:</span><br><span class="line">          - &quot;6379:6379&quot;</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br></pre></td></tr></table></figure><p>去掉后就可以正常运行了。</p><h2 id="Vmware、Hyper-V-不兼容问题"><a href="#Vmware、Hyper-V-不兼容问题" class="headerlink" title="Vmware、Hyper-V 不兼容问题"></a>Vmware、Hyper-V 不兼容问题</h2><p>第一次因为 Hyper-V 缺失而无法安装时，曾经尝试过使用 Vmware 来安装虚拟机，想要在虚拟机里面装一个 MacOS 系统，结果也是一个大坑，默认情况下的 Vmware 不支持 MacOS，而需要安装一个补丁，结果折腾了半天也没搞定，MacOS 的镜像高达 7 个 G，还因为百度网盘暂停会导致重新开始……折腾得心累，于是放弃了。</p><p>Hyper-V 与 Vmware 是不兼容的，一山不容二虎，如果要使用其中的一种，需要卸载掉另外一种。否则可能会因为服务的问题导致软件不能正常启动。</p><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>在中途曾经放弃过安装 Docker 的念头，而是手动安装了 PHP、MySQL、Redis、Nginx 等环境，但是后面又发现许多 PHP 扩展在 Window 系统的安装都十分麻烦，比如 swoole 扩展还需要安装 cygwin，折腾的心累于是放弃了。</p><p>真是艰辛的过程<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主键详解</title>
      <link href="/mysql-primary-key/"/>
      <url>/mysql-primary-key/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从书本上学到的 MySQL 主键知识十分有限，我们只是知道基础的理论。</p><p>在一次面试中，面试官提问：主键索引与普通索引有什么区别？</p><p>当场懵逼。</p><p>为了深入学习 MySQL 记录下此文。</p><h2 id="MySQL-主键（Primary-Key）"><a href="#MySQL-主键（Primary-Key）" class="headerlink" title="MySQL 主键（Primary Key）"></a>MySQL 主键（Primary Key）</h2><p>MySQL 中的键即某种约束，键具有索引的作用，通过约束条件可以使得数据更快的被查到。</p><p><strong>主键</strong> 是基本每张表都会用到的，一般类型为整型（integer、bigInteger）或者无符号整型（unsigned integer)并按照自然数的顺序自增。</p><p>主键是唯一的。</p><p>主键是一种索引，可以加快查询效率。</p><p>这是我们通常理解的主键，那么主键作为索引，又与普通索引有什么不同？为什么表需要主键？</p><h2 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h2><p>主键的字段名称一般设置为 ID，当这个 ID 与业务无关时，称为逻辑主键（即 ID 没有实际的意义），如果将用户名（name） 字段设置为主键，该字段是业务中会用到的字段，称为业务主键。</p><p>由于主键是业务中经常会用到的键，而业务又经常变更，因此不适合将业务字段作为主键，而是设置一个与业务毫无关系的（ID）字段作为主键。</p><p>如果将业务字段用来做主键，例如上面的例子中的 name，系统后台需要修改某个用户的 name 字段，意味着主键也跟着变更了。</p><p>如果存在以下场景：</p><p>用户个人空间的地址为：<code>http://domain.com/:name</code>，<code>:name</code> 是用户名（即数据库中的 name 字段）。</p><p>主键一旦变更，某些页面如个人空间也会跟着变更，假如我收藏了某个用户的空间到浏览器：<code>http://domain.com/user/xiaoming</code>，结果因为用户改名为：xiaohong，这个用户的空间地址就变成了：<code>http://domain.com/user/xiaohong</code>，那我收藏的地址就 404 了，除了这方面的原因，由于可以随意修改主键，也就导致你改了主键的值，其他人又改成之前用过的主键，会产生许多问题，如果某个人又将 xiaogang 的名字改成 xiaoming，那我收藏的地址就会变成原名为 xiaogang 的个人空间，业务变得十分混乱。</p><p>主键通常是不能变更的值，因此建议设置一个与业务毫无关系的字段作为主键的值，之所以要用整型是因为查询效率比字符串更高、所需空间更小，可以使用自增自动生成唯一的值。</p><p>其他类型如字符串作为主键，由于在插入数据时需要生成唯一字符串，同时还需要判断是否已存在该值，故在插入数据的时候效率也会降低。</p><p>除了将单个字段设置为主键，也可以将多个字段绑定在一起作为联合主键（也称复合主键）。</p><p>主键设计原则：</p><ul><li>主键的值 <strong>应该</strong> 无法被修改</li><li>主键的值 <strong>不应该</strong> 与业务有关</li><li>主键的值 <strong>建议</strong> 使用系统自动生成（如自增整型）</li><li><strong>建议</strong> 使用单个字段作为主键</li><li>每张表都 <strong>建议</strong> 设置主键</li></ul><h2 id="为什么表需要主键"><a href="#为什么表需要主键" class="headerlink" title="为什么表需要主键"></a>为什么表需要主键</h2><p>想一下如果没有主键，需要删改查除某条数据的时候会有多麻烦：“帮我删掉 name 为 xiaohong 的那条数据”，而 name 属性又没有设置唯一键，存在很多条同名数据，到底是删除哪条？</p><p>而当我们设置了 ID 作为主键，那我们就可以说：“删除 ID 为 6 的数据”、“帮我把 ID 为 6 的 name 字段改成 xiaohong”。</p><p>主键的其中一个作用即指向该行的数据，<strong>键具有约束作用</strong>，主键约束可以令数据具有唯一性，设置身份证为主键，那么这个主键就决定了一个人的个人资料，从千千万万个人当中，可以用身份证来指代唯一的一个人。</p><p>此外，主键索引可以提升查询效率，将一个字段设置为主键时，便会创建主键索引。</p><p>（下文介绍主键索引与普通索引区别）</p><h2 id="MySQL-主键与唯一键（Unique-Key）的区别"><a href="#MySQL-主键与唯一键（Unique-Key）的区别" class="headerlink" title="MySQL 主键与唯一键（Unique Key）的区别"></a>MySQL 主键与唯一键（Unique Key）的区别</h2><p>主键字段的值是唯一的，唯一键也要求字段值唯一，这两者的区别在于唯一键的值可以为 NULL，并且可以存在重复的 NULL 数据。</p><p>梳理如下：</p><p>唯一键的值 <strong>可以为空</strong>，且不能存在除空值以外重复的值。</p><p>主键的值必须 <strong>不为空</strong> 且不存在重复。</p><p>每张表中 <strong>只能</strong> 存在一个主键，可以存在 <strong>多个</strong> 唯一键。</p><p>从存在意义上来说，主键的作用是指代这一行的数据（如身份证代表一个人），而唯一键只是一种约束作用，用来约束这个字段在这张表不能存在相同值（如限制用户手机号码只能注册一个账号）。</p><h2 id="主键索引与普通索引（Normal-Index）的区别"><a href="#主键索引与普通索引（Normal-Index）的区别" class="headerlink" title="主键索引与普通索引（Normal Index）的区别"></a>主键索引与普通索引（Normal Index）的区别</h2><blockquote><p>扩展阅读：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p></blockquote><p>普通索引的作用只是加快查询效率，并且可以存在重复的值，而主键索引的值是唯一的，它也可以提高查询效率，普通索引的值可以为 NULL，查询一个存在 NULL 的普通索引会导致查询效率提升的作用失效，当一个列设置了索引，同时也应当将其设置为 NOT NULL。</p><p>主键索引与普通索引的结构也不同。</p><h3 id="聚簇索引和非聚簇索引（二级索引）"><a href="#聚簇索引和非聚簇索引（二级索引）" class="headerlink" title="聚簇索引和非聚簇索引（二级索引）"></a>聚簇索引和非聚簇索引（二级索引）</h3><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</li></ul><p>Innodb 存储引擎中，数据表 table 由 table.frm、table.idb 组成。table.frm 保存表结构的定义，table.idb 保存的是数据和索引，这样的结构称为聚簇索引。</p><p>Myisam 存储引擎中，数据表 table 由 table.frm、table.myi、table.myd 组成。table.frm 保存表结构的定义，table.myi 保存索引，table.myd 保存数据。在用到索引时，先到 table.myi(索引树)中进行查找，取到数据所在 table.myd 的行位置，拿到数据。所以 Myisam 引擎的索引文件和数据文件是独立分开的，称之为非聚簇索引。</p><p>聚簇索引是按照数据存放的物理位置为顺序的，聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索更快。</p><p>在 Innodb 中，主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>在表结构中只存在一个聚簇索引（主键索引），除此之外都是非聚簇索引（普通索引）。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一种特殊情况可以不通过聚簇索引查询数据，那就是通过创建联合索引（多个字段作为索引），如果查询的数据在索引中可以直接获取到，那就不需要再到数据行进行查询了。</p><p>例如创建索引：idx_name_email</p><p>name 字段 和 email 字段是联合索引，当我们使用如下语句查询时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name where email &#x3D; &quot;xxx@idce.com&quot;</span><br></pre></td></tr></table></figure><p>通过 email 来查询 name，由于它们是一组联合索引，因此可以直接从索引中拿到对应的数据。</p><p>覆盖索引查询数据只需要从索引中获得，而不需要到数据表中获取，因此可以极大的提高查询效率。</p><p>之所以能够从索引中得到数据，是因为索引的结构中保存了对应字段的值。</p><p>容易混淆的一个地方：上面介绍的聚簇索引才能保存数据，那为什么普通索引也能保存数据？</p><p>其实这里指的是表的数据，通过聚簇索引找到的数据是直接找到表对应行的一整行数据，而索引保存的数据是这个字段的值，因此可以通过索引得到对应字段的值。</p><p>面试官曾经问我的问题：索引会保存字段的值吗？</p><p>当时觉得不会，应该是保存对应行的所在地址才对。但其实是会保存的，因为只有保存了这个数据，查询索引字段才能快速进行数据对比从而筛选数据，如果能不回到表查询，则不回到表查询，回到表查询的效率比直接从索引拿数据低得多。</p><p>索引的结构，一侧是字段的值，另一侧是下一个数据的地址：</p><p><img src="https://i.loli.net/2019/11/26/hArR2ISmwPLzNCy.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx SSL证书配置问题</title>
      <link href="/nginx-ssl-issue/"/>
      <url>/nginx-ssl-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="SSL-问题"><a href="#SSL-问题" class="headerlink" title="SSL 问题"></a>SSL 问题</h2><p>Nginx 重启时，报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;xxx.conf:57</span><br></pre></td></tr></table></figure><p>通常我们会在 server 有如下 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssl on;</span><br><span class="line">ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;xxx.com.pem;</span><br><span class="line">ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;xxx.com.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure><p>访问网页提示错误代码 <code>ERR_SSL_PROTOCOL_ERROR</code>。</p><p><img src="https://i.loli.net/2019/12/05/R3GCLPZ8tsbpzS2.png" alt="image.png"></p><p>原因在于 Nginx 升级到 1.15 版之后，SSL 的配置不再使用 <code>ssl on</code>，把这一句去掉就可以。</p><p>这时再执行：<code>nginx -s reload</code> 平滑重启 Nginx 就不会报错了。</p><h2 id="CURL-无法正常访问"><a href="#CURL-无法正常访问" class="headerlink" title="CURL 无法正常访问"></a>CURL 无法正常访问</h2><p>按照上面的步骤重启 Nginx 后，使用 curl 尝试连接到网站，结果依然报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (35) SSL received a record that exceeded the maximum permissible length.</span><br></pre></td></tr></table></figure><p>这其实也是升级后配置发生了变化，第一个步骤的提示信息已经给与了提示：<code>use the &quot;listen ... ssl&quot;</code>，再次编辑 <code>xxx.conf</code>，将 <code>listen 443</code> 修改为：<code>listen 443 ssl</code>：</p><pre><code>server {    listen       443 ssl;    server_name  idce.com;    // ...此处省略}</code></pre><p>保存，然后再执行重启，OK！</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHPStorm逼死强迫症患者解决方法</title>
      <link href="/phpstorm-no-ext-tip-issue/"/>
      <url>/phpstorm-no-ext-tip-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h2><p>在使用 JSON 函数的时候，会报如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext-json missing in composer.json</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/26/sYow5WKkvbRdXOV.png" alt="image.png"></p><p>花花绿绿看得猛男落泪，简直要逼死强迫症啊！</p><p>原因可能是因为使用了 Docker 或者其他的环境，由于扩展是安装在虚拟机上就导致本机无法正确识别 PHP 的扩展，并不是本机上没有安装这个扩展，代码没有问题也不会报错，就是看得难受。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>所幸，这里提供了两种方法可以根治此问题。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>针对缺失的扩展，在 <code>composer.json</code> 文件的 <code>require</code> 字段进行添加。</p><p>例如：<code>&quot;ext-json&quot;: &quot;*&quot;</code>：</p><p><img src="https://i.loli.net/2019/11/26/IH3GgJQB4XWpz8y.png" alt="image.png"></p><p>如果没有 <code>composer.json</code> 文件，在项目根目录下自行创建一个即可。</p><p>这种方法针对特定的扩展，除了 JSON 扩展，常见的还有 CURL 扩展也无法正常识别，用相同的方法即可解决，扩展不多的时候可以用这种方法，要是使用了诸多第三方扩展而 PHPStorm 无法识别，可以参考下面的方案二一次性解决问题。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>关闭 PHPStorm 缺失扩展提示。</p><p>打开左上角 <code>File-&gt;Settings</code> 搜 PHP，然后找到下方一行的 <code>Inspections</code>，在右侧搜索 <code>extension</code>，找到 <code>Extension is mission in composer.json</code> 取消勾选保存即可，见下图：</p><p><img src="https://i.loli.net/2019/11/26/bB9RVYwCf6DtmGL.png" alt="image.png"></p><p>以上方法任选一种即可。</p><p><img src="https://i.loli.net/2019/11/26/UZdEPz9Hg5MkXyt.png" alt="image.png"></p><p>猛的一顿操作之后——舒服多了！！</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-CLI 常用命令参数</title>
      <link href="/php-cli-arguments/"/>
      <url>/php-cli-arguments/</url>
      
        <content type="html"><![CDATA[<h2 id="运行-PHP-文件"><a href="#运行-PHP-文件" class="headerlink" title="运行 PHP 文件"></a>运行 PHP 文件</h2><p>可以直接使用 <code>php &lt;文件路径&gt;</code> 执行 PHP 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php &#x2F;var&#x2F;www&#x2F;html&#x2F;project&#x2F;index.php;</span><br></pre></td></tr></table></figure><h2 id="进入命令行模式"><a href="#进入命令行模式" class="headerlink" title="进入命令行模式"></a>进入命令行模式</h2><p>使用命令 <code>php -a</code> 可以进入命令行模式，在这里可以直接运行 PHP 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; echo &quot;hello world&quot;;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="加载指定配置文件"><a href="#加载指定配置文件" class="headerlink" title="加载指定配置文件"></a>加载指定配置文件</h2><p>使用 <code>php -c</code> 可以加载指定的配置文件 <code>php.ini</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c &#x2F;test&#x2F;my_php.ini</span><br></pre></td></tr></table></figure><h2 id="显示当前配置文件路径"><a href="#显示当前配置文件路径" class="headerlink" title="显示当前配置文件路径"></a>显示当前配置文件路径</h2><p>使用命令 <code>php --ini</code> 查看当前加载的配置文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --ini</span><br><span class="line">Configuration File (php.ini) Path: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php</span><br><span class="line">Loaded Configuration File:         &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini</span><br><span class="line">Scan for additional .ini files in: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d</span><br><span class="line">Additional .ini files parsed:      &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-bcmath.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-gd.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-gmp.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-mysqli.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-opcache.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-pdo_mysql.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-redis.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-sockets.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-sodium.ini,</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-swoole.ini</span><br></pre></td></tr></table></figure><h2 id="启动一个-WebServer"><a href="#启动一个-WebServer" class="headerlink" title="启动一个 WebServer"></a>启动一个 WebServer</h2><p>Web Server（网页服务）一般是由 Apache、Nginx 或是 Windows 系统的 IIS 提供。</p><p>从 <code>PHP 5.4.0</code> 起，也可以使用 cli 模式来启动 PHP 内置的 Web Server。</p><blockquote><p>这个内置的 Web 服务器主要用于本地开发使用，不可用于线上产品环境。</p></blockquote><p>使用命令 <code>php -S localhost:&lt;端口号&gt; [文件路径]</code> 来启动一个 WebServer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -S localhost:999</span><br><span class="line">[Sun Mar 15 04:25:52 2020] PHP 7.4.1 Development Server (http:&#x2F;&#x2F;localhost:999) started</span><br></pre></td></tr></table></figure><blockquote><p>localhost 等价于 127.0.0.1</p></blockquote><p>启动 PHP WebServer 时可以指定一个文件作为启动脚本（如框架的入口文件），在该文件注册所需要的插件及分发路由等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 test.php</span><br></pre></td></tr></table></figure><p>命令添加 <code>-t</code> 参数，将会以目录作为 WebServer 的启动目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 127.0.0.1:666 -t public&#x2F;</span><br></pre></td></tr></table></figure><p>关掉命令行窗口或者按 <code>Ctrl + C</code> 即可退出 PHP WebServer。</p><h2 id="PHP-版本号"><a href="#PHP-版本号" class="headerlink" title="PHP 版本号"></a>PHP 版本号</h2><p>使用 <code>php -v</code> 命令可以查看 PHP 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -v</span><br><span class="line">PHP 7.4.1 (cli) (built: Dec 28 2019 20:56:41) ( NTS )</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br><span class="line">    with Zend OPcache v7.4.1, Copyright (c), by Zend Technologies</span><br></pre></td></tr></table></figure><h2 id="PHP-扩展"><a href="#PHP-扩展" class="headerlink" title="PHP 扩展"></a>PHP 扩展</h2><p>使用 <code>php -m</code> 命令可以查看 PHP 安装的扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -m</span><br><span class="line">[PHP Modules]</span><br><span class="line">bcmath</span><br><span class="line">Core</span><br><span class="line">ctype</span><br><span class="line">curl</span><br><span class="line">date</span><br><span class="line">dom</span><br><span class="line">fileinfo</span><br><span class="line">filter</span><br><span class="line">ftp</span><br><span class="line">gd</span><br></pre></td></tr></table></figure><h2 id="PHP-参数"><a href="#PHP-参数" class="headerlink" title="PHP 参数"></a>PHP 参数</h2><p>使用 <code>php -i</code> 命令可以查看 PHP / 扩展的配置参数，等价于 <code>phpinfo</code>。</p><h2 id="语法查错"><a href="#语法查错" class="headerlink" title="语法查错"></a>语法查错</h2><p>可以用 <code>php -l &lt;文件路径&gt;</code> 来检测该 php 文件是否有语法错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -l index.php</span><br><span class="line">No syntax errors detected in index.php</span><br></pre></td></tr></table></figure><h2 id="执行一段代码"><a href="#执行一段代码" class="headerlink" title="执行一段代码"></a>执行一段代码</h2><p>使用 <code>php -r &quot;代码&quot;</code> 来执行一段 PHP 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php -r &quot;echo &#39;ok&#39;;&quot;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="查看扩展详情"><a href="#查看扩展详情" class="headerlink" title="查看扩展详情"></a>查看扩展详情</h2><p>使用命令 <code>php --ri &lt;扩展名称&gt;</code> 获取扩展配置详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --ri swoole</span><br><span class="line"></span><br><span class="line">swoole</span><br><span class="line"></span><br><span class="line">Swoole &#x3D;&gt; enabled</span><br><span class="line">Author &#x3D;&gt; Swoole Team &lt;team@swoole.com&gt;</span><br><span class="line">Version &#x3D;&gt; 4.4.14</span><br><span class="line">Built &#x3D;&gt; Jan  6 2020 07:22:54</span><br><span class="line">coroutine &#x3D;&gt; enabled</span><br><span class="line">epoll &#x3D;&gt; enabled</span><br><span class="line">eventfd &#x3D;&gt; enabled</span><br><span class="line">signalfd &#x3D;&gt; enabled</span><br><span class="line">cpu_affinity &#x3D;&gt; enabled</span><br><span class="line">spinlock &#x3D;&gt; enabled</span><br><span class="line">rwlock &#x3D;&gt; enabled</span><br><span class="line">openssl &#x3D;&gt; OpenSSL 1.1.1d  10 Sep 2019</span><br><span class="line">http2 &#x3D;&gt; enabled</span><br><span class="line">zlib &#x3D;&gt; 1.2.11</span><br><span class="line">mutex_timedlock &#x3D;&gt; enabled</span><br><span class="line">pthread_barrier &#x3D;&gt; enabled</span><br><span class="line">futex &#x3D;&gt; enabled</span><br><span class="line">mysqlnd &#x3D;&gt; enabled</span><br><span class="line">async_redis &#x3D;&gt; enabled</span><br><span class="line"></span><br><span class="line">Directive &#x3D;&gt; Local Value &#x3D;&gt; Master Value</span><br><span class="line">swoole.enable_coroutine &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.enable_library &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.enable_preemptive_scheduler &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">swoole.display_errors &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.use_shortname &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">swoole.unixsock_buffer_size &#x3D;&gt; 8388608 &#x3D;&gt; 8388608</span><br></pre></td></tr></table></figure><h2 id="查看扩展提供的方法"><a href="#查看扩展提供的方法" class="headerlink" title="查看扩展提供的方法"></a>查看扩展提供的方法</h2><p>使用命令 <code>php --re &lt;扩展名称&gt;</code> 获取扩展的所有方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php --re swoole</span><br></pre></td></tr></table></figure><h2 id="获取函数详情"><a href="#获取函数详情" class="headerlink" title="获取函数详情"></a>获取函数详情</h2><p>使用命令 <code>php --rf &lt;函数名称&gt;</code> 获取函数详情，可以用来检测函数是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --rf array_columns</span><br><span class="line">Exception: Function array_columns() does not exist</span><br><span class="line">root@0139eebfa774:&#x2F;var&#x2F;www&#x2F;html# php --rf array_column</span><br><span class="line">Function [ &lt;internal:standard&gt; function array_column ] &#123;</span><br><span class="line"></span><br><span class="line"> - Parameters [3] &#123;</span><br><span class="line">    Parameter #0 [ &lt;required&gt; $arg ]</span><br><span class="line">    Parameter #1 [ &lt;required&gt; $column_key ]</span><br><span class="line">    Parameter #2 [ &lt;optional&gt; $index_key ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trait - 优雅的复用方法</title>
      <link href="/trait/"/>
      <url>/trait/</url>
      
        <content type="html"><![CDATA[<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>为了解决单继承问题，从 PHP 5.4 开始新增了 <code>trait</code> 关键字来实现代码的复用。<code>trait</code> 定义的代码块在类的内部引入，类就能获得由 <code>trait</code> 定义的属性及方法。</p><p>通过定义一个 <code>SingletonTrait</code>，来实现单例模式的类共用代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trait SingletonTrait</span><br><span class="line">&#123;</span><br><span class="line">    protected static $instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() &#123;</span><br><span class="line">        if (null &#x3D;&#x3D;&#x3D; self::$instance) &#123;</span><br><span class="line">            self::$instance &#x3D; new static();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要引用 <code>Trait</code> 十分简单，只要在类的内部使用 <code>use</code> 关键字即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SomeService</span><br><span class="line">&#123;</span><br><span class="line">    use SingletonTrait;</span><br><span class="line"></span><br><span class="line">    public function test()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;ok!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$service &#x3D; SomeService::getInstance();</span><br><span class="line">$service-&gt;test();</span><br></pre></td></tr></table></figure><p>通过引用 <code>SingletonTrait</code> 代码块 <code>SomeService</code> 直接获得了 <code>trait</code> 定义的方法及属性，通过 <code>trait</code> 引用实现复用单例模式方法，而不是直接复制粘贴同样的代码到每个单例的类中，让代码变得更加优雅！</p><blockquote><p>Trait 的实现原理是简单的把代码块拷贝到类</p></blockquote><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在类的继承关系中，如果父类的属性或方法使用了 <code>private</code> 声明，子类是无法调用的，但是在 Trait 中不同，因为 Trait 相当于把代码引入到类里面，也就是变成了类的一部分，因此当 Trait 声明了私有属性或方法，在类的内部是可以直接使用的。</p><p>Trait 定义的代码块同样可以使用 <code>static</code>、<code>abstract</code> 等修饰符。</p><h2 id="多个-Trait"><a href="#多个-Trait" class="headerlink" title="多个 Trait"></a>多个 Trait</h2><p>一个类可以引用多个 Trait，中间使用逗号隔开。</p><p>当引入的多个 Trait 里面存在同名方法时，需要通过两种方式来解决冲突，否则会报出致命异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Fatal error:  Trait method xxx has not been applied, because there are collisions with other trait methods on Test in xxx</span><br></pre></td></tr></table></figure><h3 id="insteadof"><a href="#insteadof" class="headerlink" title="insteadof"></a>insteadof</h3><p>使用 <code>insteadof</code> 关键字来让其中一个 Trait 的方法覆盖另一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A,B &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用 A trait 中的 hello 覆盖 B 的 hello</span><br><span class="line">        A:: hello insteadof B;</span><br><span class="line">        &#x2F;&#x2F; 使用 B trait 中的 world 覆盖 A 的 world</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test &#x3D; new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:hello</span><br><span class="line">B:world</span><br></pre></td></tr></table></figure><h3 id="as-方法重命名"><a href="#as-方法重命名" class="headerlink" title="as 方法重命名"></a>as 方法重命名</h3><p>如果需要保留两者的方法，可以使用 <code>as</code> 重命名，然后再用另一个的方法进行覆盖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">trait A</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;A:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B</span><br><span class="line">&#123;</span><br><span class="line">    public function hello()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:hello&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function world()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;B:world&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    use A, B &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 A trait 中的方法重命名</span><br><span class="line">        A::hello as ahello;</span><br><span class="line">        A::world as aworld;</span><br><span class="line">        &#x2F;&#x2F; 再使用 insteadof 关键字覆盖冲突的方法</span><br><span class="line">        B:: hello insteadof A;</span><br><span class="line">        B:: world insteadof A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test &#x3D; new Test();</span><br><span class="line">$test-&gt;hello();</span><br><span class="line">$test-&gt;world();</span><br><span class="line">$test-&gt;ahello();</span><br><span class="line">$test-&gt;aworld();</span><br></pre></td></tr></table></figure><p>注意，即使重命名了也需要使用 <code>insteadof</code> 覆盖原来的代码，不然同样会产生致命报错。</p><h2 id="Trait-嵌套"><a href="#Trait-嵌套" class="headerlink" title="Trait 嵌套"></a>Trait 嵌套</h2><p>Trait 里面也可以引用其他 Trait。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当 Trait 中定义的方法或属性与类或其父类相同时，其优先级如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类 &gt; trait &gt; 父类</span><br></pre></td></tr></table></figure><h2 id="Trait-的意义"><a href="#Trait-的意义" class="headerlink" title="Trait 的意义"></a>Trait 的意义</h2><p>Trait 能实现代码块的复用，但是继承（extends）、实现（implements）同样可以复用父类的方法或实现接口的方法，它们之间有什么区别呢？</p><p>我们知道面向对象编程里代码的关联性十分重要，例如继承关系即把子类的属性和方法进行了抽象，接口同样是把相同的东西抽象出来，然后在子类进行实现，这样有时候我们遇到像“水陆两栖动物”这种特殊的类型，既要让它继承水生动物的特性，又要让它继承陆生动物的特性，而 PHP 不支持多继承，要实现这种效果会变得十分麻烦。</p><p>而 Trait 定义的代码块，并没有严格意义上的关联性，仅仅只是为了复用代码块而被设计。Trait 的作用更像是一个功能块，不论是谁，只要让其他的类“嵌入”这个功能块就能让它具有对应的效果。</p><p>就好比 LOL 里的提莫，你可以出帽子、法穿棒等纯粹的 AP 装让它变成 AP 提莫，也可以出纳什之牙、飓风让提莫变成一个普攻型的 APC（远程输出单位），Trait 的作用类似于装备效果，任何人都可以出这件装备，只要装备了就能得到对应的能力。</p><p>在 Laravel 框架里，要实现“软删除”功能十分简单，只需要在数据库迁移中添加字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(&#39;orders&#39;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;bigIncrements(&#39;id&#39;);</span><br><span class="line">            &#x2F;&#x2F; .. 省略其他字段</span><br><span class="line">            $table-&gt;softDeletes();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>然后在 Model 里直接引入 Trait：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Model;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line">use Illuminate\Database\Eloquent\SoftDeletes;</span><br><span class="line"></span><br><span class="line">class Order extends Model</span><br><span class="line">&#123;</span><br><span class="line">    use SoftDeletes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可让一个模型具有软删除的功能。</p><p>Laravel 还有许多地方存在此类的应用，通过这样的设计让代码更加优雅！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>凡是在开发过程中，只要意识到自己通过 Ctrl+C、Ctrl+V 复制了同一份的代码，就表明这个地方写的不够好，一定存在优化的空间。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/mini-server/"/>
      <url>/mini-server/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微服务是一种服务架构模式，目标是架构师的话，当然不能放过这个知识点。</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>一般的项目架构有两种形式：单体应用和微服务。</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>单体应用就是用一套代码实现全部功能。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务就是把单体应用的代码按照功能拆分出来，形成多套独立的代码，通过某种方式让它们连接在一起，实现完整功能。</p><p>单体应用好比早期的网站开发，用 PHP 搭建的网站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php echo &quot;hello world!&quot; ?&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>HTML 代码与 PHP 代码混合在一起。</p><p>而随着技术的发展，又推出了 MVC 模式，实现模型、视图、控制器的分离。</p><p>然而问题的本质依然没有改变，还不是要一个人去完成同样的工作？</p><p>技术从未停下发展的脚本，职业的分工越来越明确，开始出现专门写 HTML 和 JavaScript 的前端人员和专门写 PHP 代码的后端人员，前端人员通过一项技术“Ajax”调用后端人员写的接口，使他们看似分离但却紧紧的联系到一起，共同实现一个完整的项目。</p><p>这样的分工方式就叫做微服务。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>比如有一套系统，包括如下业务：</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3518914240,1325113277&fm=26&gp=0.jpg" alt="微服务架构"></p><p>把这些业务拆分出来，单独做成一套系统，然后以某种方式让独立的项目之前能够进行通信，这就完成了一套微服务架构。</p><h2 id="微服务通信模式"><a href="#微服务通信模式" class="headerlink" title="微服务通信模式"></a>微服务通信模式</h2><h3 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h3><h3 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h2 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h2><p>优点</p><ul><li>大型项目解耦，提高整体性能</li><li>每个服务都很小，开发人员可以聚焦自己负责的功能模块。</li><li>只需要极少的人来维护一套代码</li><li>可以用不同的语言开发</li></ul><p>缺点</p><ul><li>架构需要花费一定的精力，如果架构得不好，后期反而会变成麻烦</li><li>由于服务分散成很多个，因此难以快速定位错误</li><li>管理成本提高</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-FPM</title>
      <link href="/php-fpm/"/>
      <url>/php-fpm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学 PHP 的时候，搜索网上教程一顿操作配置了 LNMP（Linux + Nginx + MySQL + PHP）环境，在配置 Nginx 的时候听说了 PHP-FPM，然而却没有进行深究，只知道让 Nginx 转发就完事了。</p><p>为了进一步的学习 PHP，需要了解 PHP-FPM 是什么。</p><h2 id="CGI-通用网关接口"><a href="#CGI-通用网关接口" class="headerlink" title="CGI 通用网关接口"></a>CGI 通用网关接口</h2><p>通用网关接口（Common Gateway Interface，CGI）是一个为用户和 WEB 服务（如 Nginx）与其他应用（如 PHP）提供交互的程序。</p><p>早期的 WEB 应用只处理静态的页面，用户访问站点只要请求指定的 <code>.htm</code> 或 <code>.html</code> 文件，静态文件可以直接输出给浏览器，所以 Nginx 不需要做额外的处理。</p><p>随着互联网的发展，只有静态的页面已经不能满足人们的需求了。</p><p>Nginx 本身不处理文件，只是分发请求，比如用户请求 <code>/index.html</code>，它会去服务器寻找这个文件，找到了就输出给浏览器，没找到就返回 404。这里分发的是静态数据，但如果用户请求的是 <code>/index.php</code>，这是一个 PHP 文件，不能像 <code>.html</code> 文件一样直接返回给浏览器。</p><p>这个时候就犯难了，Nginx 应该如何处理非静态的文件呢？</p><p>为了解决如何处理非静态文件的问题，CGI 诞生了。</p><p>CGI 做的事情就是解析用户的请求，然后将请求的结果解析成 HTML 返回给浏览器，开发者可以使用任何语言处理 Web Server 发来的请求，生成动态的内容。</p><p>上面的例子，用户访问 <code>/index.php</code> 文件，由于 Nginx 无法处理这种格式的文件，于是将请求（包括参数等等）转发给 CGI 程序（可理解为语言解释器）进行处理，这里的 CGI 就是 PHP-CGI，PHP-CGI 可以解析 PHP 文件，<code>index.php</code> 文件在 PHP-CGI 程序进行解析和处理后才会输出给浏览器。</p><p><code>index.php</code> 文件就交给 PHP 程序去处理，<code>.jsp</code> 文件就让 Java 去处理，每种动态语言都有对应的 CGI，Nginx 只需要将请求转发给 CGI 就可以了，再通过 CGI 输出数据给浏览器。</p><h2 id="FastCGI-快速网关接口"><a href="#FastCGI-快速网关接口" class="headerlink" title="FastCGI 快速网关接口"></a>FastCGI 快速网关接口</h2><p>CGI 在高并发时存在性能问题，作为改进版的 FastCGI 便出现了。</p><p>快速网关接口（Fast Common Gateway Interface，FastCGI）是 CGI 的增强版。</p><h3 id="CGI-原理"><a href="#CGI-原理" class="headerlink" title="CGI 原理"></a>CGI 原理</h3><p>在接收到请求时，先 fork 出 CGI 进程，然后处理请求，处理完后结束这个进程，这就是 fork-and-execute 模式。</p><p>所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 进程，每个进程都会加载解析配置文件，初始化执行环境，那么当高并发请求时，会大量挤占系统的资源如内存，CPU 等，造成效能低下。</p><h3 id="FastCGI-原理"><a href="#FastCGI-原理" class="headerlink" title="FastCGI 原理"></a>FastCGI 原理</h3><p>FastCGI 进程管理器启动时会创建一个主（Master）进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接。</p><p>Web 服务器接收 HTTP 请求后，将 CGI 报文通过 UNIX 或 TCP Socket 进行通信，将环境变量和请求数据写入标准输入，转发到 CGI 解释器进程。</p><p>CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器。</p><p>CGI 解释器进程变为空闲状态，等待下一个 HTTP 请求的到来。</p><p>由于 FastCGI 模式在启动时便创建了很多个子进程，这些子进程常驻内存中，一旦接收到请求就可以立即进入工作状态，而传统的 CGI 模式，只有在接收到请求的时候才会去创建进程，重新读取配置文件等一系列初始化操作，毫无疑问性能会相差很多。</p><h2 id="PHP-FPM-FastCGI-进程管理器"><a href="#PHP-FPM-FastCGI-进程管理器" class="headerlink" title="PHP-FPM FastCGI 进程管理器"></a>PHP-FPM FastCGI 进程管理器</h2><p>PHP 的 FastCGI进程管理器（FastCGI Process Manager，PHP-FPM），PHP-FPM 即 FastCGI 的具体实现。</p><p>PHP 的解释器是 PHP-CGI，它本身只会解析请求返回结果，不能进行进程的调度，而 PHP-FPM（进程管理器）所做的事情便是管理进程。</p><p>PHP-FPM 包含了一个 <code>master</code> 进程和许多个 <code>worker</code> 进程，<code>worker</code> 进程的数量是可以动态调节的，创建和销毁全部由 <code>master</code> 进程来控制。</p><p><img src="https://user-images.githubusercontent.com/28209810/64397840-35090980-d095-11e9-959e-eda11f5cb000.png" alt="image"></p><p>其中，<code>master</code> 进程负责分发请求，首先 <code>master</code> 进程检测是否有可用的 <code>worker</code> 进程，如果没有则返回错误（502），然后将请求分发给空闲的 <code>worker</code> 进程处理，然后接取下一个请求，再将请求分发给空闲的 <code>worker</code>，如果 <code>worker</code> 进程处理请求超时则返回错误（504）。</p><p>这样的协作方式大大的提高了程序处理并发请求的性能，<code>worker</code> 进程的数量可以通过 <code>php.ini</code> 文件进行配置。</p><p>理论上进程越多，可以处理的请求也越多，但空闲的进程太多反而会造成内存的浪费。</p><h2 id="Nginx-与-PHP-FPM-通信"><a href="#Nginx-与-PHP-FPM-通信" class="headerlink" title="Nginx 与 PHP-FPM 通信"></a>Nginx 与 PHP-FPM 通信</h2><p>Nginx 与 PHP-FPM 的通信方式有两种：TCP SOCKET 和 Unix SOCKET。</p><p>TCP socket 的优点是可以跨服务器，Nginx 服务器不需要与 PHP-FPM 在同一台服务器上，由于跨服务器的特性，还可以实现分布式部署。</p><p>Unix socket 用于实现同一主机上的进程间通信，相较于 TCP socket，Unix socket 跳过了许多验证的步骤，因此 Unix socket 的效率比 TCP socket 要高，但是不稳定。</p><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>一个基于 TCP socket 的 PHP 站点 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root &#x2F;www&#x2F;web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><p>Nginx 的 FastCGI 模块提供了 fastcgi_param 来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量，fastcgi_param 是一个文件，包含了 Nginx 中的变量映射关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">fastcgi_param  REQUEST_SCHEME     $scheme;</span><br><span class="line">fastcgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI&#x2F;1.1;</span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx&#x2F;$nginx_version;</span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br></pre></td></tr></table></figure><p>除此之外，还有一个重要的指令 <code>fastcgi_pass</code>，这个指令用于指定 FPM 进程监听的地址，Nginx 会把所有的 PHP 请求翻译成 FastCGI 请求之后再发送到这个地址。</p><p>上面的 Nginx 配置文件中，我们配置了 <code>fastcgi_pass 127.0.0.1:9000;</code>，其含义是将请求转发到本机 9000 端口（PHP-FPM 进程）处理，这样的方式叫做 TCP socket。</p><p>TCP socket 的好处是可以将 Nginx 服务器与 FPM 服务器进行分离，因此可以实现分布式 PHP-FPM 架构：</p><p><img src="https://user-images.githubusercontent.com/28209810/64407389-c5a41180-d0b6-11e9-8d5f-5b5ef39a52ce.png" alt="image"></p><p>配置 <code>upstream</code> 来指定 PHP-FPM 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upstream php-fpm &#123;</span><br><span class="line">    server 127.0.0.1:9000;</span><br><span class="line">    server 127.0.0.2:9000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root &#x2F;www&#x2F;web;</span><br><span class="line">    index index.html index.php;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass php-fpm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unix-socket"><a href="#Unix-socket" class="headerlink" title="Unix socket"></a>Unix socket</h3><p>基于 Unix socket 的 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fasrcgi_pass &#x2F;usr&#x2F;run&#x2F;php-fpm.sock</span><br></pre></td></tr></table></figure><p>PHP-FPM 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line"># 或者</span><br><span class="line">listen &#x3D; &#x2F;var&#x2F;run&#x2F;php-fpm.sock</span><br></pre></td></tr></table></figure><blockquote><p>socket 的本质是一个文件，因此还存在权限问题，所以需要注意 Nginx 所在的用户组是否有该文件的操作权限。</p></blockquote><p>Unix socket 通信方式需要在本机生成 sock 文件，因此 Nginx 服务器与 PHP-FPM 必须在同一台机子。</p><p>关于两者的取舍，当并发量较小时（比如几百），可以选择 Unix socket 以提高处理效率，在并发量较大时，可以选择 TCP socket 以保持连接的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文读懂Nginx</title>
      <link href="/nginx-introduction/"/>
      <url>/nginx-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-是什么？"><a href="#Nginx-是什么？" class="headerlink" title="Nginx 是什么？"></a>Nginx 是什么？</h2><p>Nginx 是高性能 HTTP 和反向代理 WEB 服务器，还提供了邮件代理服务。</p><p>简而言之即<strong>分发服务器请求的软件</strong>。</p><p>访问一个网站的本质：</p><ul><li>在浏览器输入网址</li><li>DNS 服务商将网址解析成服务器 IP 地址</li><li>访问此 IP 的服务器</li><li>服务器收到请求，建立连接</li><li>服务器上的 Nginx 解析请求并转发给对应程序处理</li><li>程序处理请求</li><li>程序返回请求的结果（响应）</li></ul><p>在此过程，Nginx 负责分发请求给指定的程序处理。</p><p>Nginx 在分发请求的时候，会携带请求参数和请求头等其他信息，Nginx 自身无法处理请求，它只是将请求转发给对应程序处理，如果是 PHP 搭建的网站，则转发给 PHP-CGI，由 PHP-CGI 返回结果给客户端。</p><blockquote><p>PHP-CGI 是处理 PHP 文件的程序</p></blockquote><h2 id="Nginx-起源"><a href="#Nginx-起源" class="headerlink" title="Nginx 起源"></a>Nginx 起源</h2><p>Nginx 是伊戈尔·赛索耶夫为俄罗斯访问量第二的 rambler.ru 站点设计开发的。</p><p>第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。</p><p>从发布至今，凭借开源的力量，已经接近成熟与完善。</p><p>中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h2 id="URI-是什么？"><a href="#URI-是什么？" class="headerlink" title="URI 是什么？"></a>URI 是什么？</h2><p>在了解 Nginx 是如何分发请求之前需要先了解什么是 URI。</p><p>URI 统一资源标识符(Uniform Resource Identifier， URI)，它由三个部分组成：</p><ul><li>协议</li><li>主机</li><li>资源路径</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.huotuyouxi.com&#x2F;img&#x2F;1.jpg</span><br></pre></td></tr></table></figure><ul><li>https：协议</li><li>blog.huotuyouxi.com：主机</li><li>/img/1.jpg：资源路径</li></ul><p>上面也提到了，访问网址的本质是访问服务器上某个文件，示例的网址访问 blog.huotuyouxi.com 所在服务器上的 1.jpg 这个文件。</p><p>如果这样理解不能，换句话说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\games\Lol\Lol.exe</span><br></pre></td></tr></table></figure><p>访问服务器上的文件与访问本地 F 盘并无太大的差别，区别在于访问网址相当于访问远程服务器上的文件。</p><p>通俗的讲 URI 就是远程服务器文件的路径。</p><p>至于协议部分，协议即一种人为约定的规则，除了 http、https 协议，还有 ftp、sftp 等等各种协议，请求协议跟后文没有多大关系，有兴趣可以自行查阅当做扩展阅读。</p><h2 id="Nginx-如何分发请求？"><a href="#Nginx-如何分发请求？" class="headerlink" title="Nginx 如何分发请求？"></a>Nginx 如何分发请求？</h2><p>客户端请求 URI 对应的文件，Nginx 是如何处理的呢？</p><p>在分发请求之前，Nginx 首先需要解析请求。</p><p>假如我们把域名：blog.huotuyouxi.com 解析到 IP 为 xxx.xxx.xxx.xxx 的服务器上。</p><p>然后在该服务器上安装 Nginx，并且添加如下配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听 80 端口</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    # 对应的域名</span><br><span class="line">    server_name  blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    # 项目根目录</span><br><span class="line">    root &#x2F;www&#x2F;blog&#x2F;public;</span><br><span class="line"></span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 字符集</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    # 匹配 URI 以 &#x2F; 开头（因为所有的 URI 都是以 &#x2F; 开头，所以会匹配到所有请求）</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 尝试获取这几种文件</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 匹配后缀为 .php 的请求</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>小知识：80 是 http 默认端口，443 是 https 默认端口，访问域名时无需指定端口即可访问，使用其他端口时，就需要在域名后面加上 :端口号才能访问，例如：<a href="http://blog.huotuyouxi.com:81" target="_blank" rel="noopener">http://blog.huotuyouxi.com:81</a></p></blockquote><p><code>location</code> 是 Nginx 主要的模块之一，用来匹配 URI，满足条件时进入到模块内执行，我们在这个配置文件里设置了两个 <code>location</code> 模块匹配资源文件。</p><p>第一个 <code>location</code> 定制了规则 <code>/</code>，匹配以 <code>/</code> 开头的所有 URI，由于所有的 URI 都是以 / 开头，所以会匹配到所有请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try_files</code> 按顺序检查文件是否存在，返回第一个找到的文件，至少需要两个参数，当前面的文件都找不到时，会内部重定向到最后一个参数：</p><ul><li>$uri</li><li>$uri/</li><li>/index.php?$query_string</li></ul><p><code>$uri</code> 指的是完全匹配的文件，<code>$uri/</code> 指的是文件夹，当前面两个都没有时，会访问 <code>/index.php</code>，而后面的 <code>?$query_string</code> 指的是携带请求参数，如果不携带参数，使用 <code>$_GET</code> 会获取不到任何参数。</p><p>访问目录是以配置的项目相对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root &#x2F;www&#x2F;blog&#x2F;public;</span><br></pre></td></tr></table></figure><p>最后的值访问 <code>index.php</code> 即访问 <code>/www/blog/public/index.php</code>。</p><p>接着第二个 <code>location</code>，<code>~</code> 是一种标识符，用于正则匹配 URI，区分大小写，正则匹配规则为：<code>.php$</code> 也就是以 <code>.php</code> 结尾的文件，当满足条件时进入此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri &#x3D;404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意！反斜杠 \ 一定要存在，因为 .（点）也是正则表达式，需要加上反斜杠转义才能匹配 .php 后缀 </p></blockquote><p><code>location</code> 在配置文件里的前后顺序并不是匹配的顺序，<code>location</code> 匹配的规则及顺序后文介绍，在这个例子中 <code>/</code> 的匹配优先级低于 <code>~</code>，也就是先匹配 <code>.php</code> 后缀的文件，如果匹配不到再匹配 <code>/</code> 规则。</p><p>假如某个用户访问：blog.huotuyouxi.com/php-fpm</p><p>此时，在 Nginx 中的处理流程是：</p><p>首先匹配到了 <code>server_name</code>：blog.huotuyouxi.com，进入当前配置文件进行处理。</p><p>接着解析 $uri（文件路径）即 <code>server_name</code> 后面的部分 <code>/php-fpm</code>，然后优先匹配规则 <code>~ .php</code>，发现它并没有 <code>.php</code> 结尾，接着往下级匹配 <code>/</code>，满足条件，进入到该模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    # 尝试获取这几种文件</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try_files 会尝试获取 <code>/www/blog/public/php-fpm</code> 文件，发现没有，继续匹配第二个参数；<code>$uri/</code> 比之前的参数多加了一个 <code>/</code> 结尾，指的是文件夹，发现也没有 <code>/www/blog/public/php-fpm</code> 这个目录，前面两个参数都匹配完了，因此请求会变为内部重定向到最后一个参数 <code>index.php</code> 这个文件，然后重新开始匹配，此时正好匹配了规则 <code>.php</code> 结尾，进入 <code>location ~ .php</code> 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    try_files $uri &#x3D;404;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到这个模块后，实际上是将请求转发给了 PHP-CGI 进行处理，前面几个字段暂时不用理会，只需要知道请求被转发给了 <code>fastcgi_pass</code> 这个字段，也就是 <code>127.0.0.1:9000</code>（PHP-FPM 本机端口），CGI 处理完请求后将结果返回给客户端。</p><p>以上就是 Nginx 解析和分发请求的过程。</p><h2 id="Nginx-匹配规则及优先级"><a href="#Nginx-匹配规则及优先级" class="headerlink" title="Nginx 匹配规则及优先级"></a>Nginx 匹配规则及优先级</h2><p>Nginx 配置文件中的 <code>location</code> 即匹配规则，匹配规则可以有任意个，按照优先级逐个匹配，匹配成功时停止往下匹配。</p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>Nginx 的 <code>location</code> 模块包含 4 种匹配标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标识符描述</span><br><span class="line">&#x3D;精确匹配：当 $uri 完全匹配。</span><br><span class="line">~正则匹配：正则表达式匹配 $uri，区分大小写。</span><br><span class="line">~*正则匹配：正则表达式匹配 $uri，不区分大小写。</span><br><span class="line">^~非正则匹配：匹配到前缀最多的 $uri 后就结束，该模式匹配成功后，不会使用正则匹配。</span><br></pre></td></tr></table></figure><p>标识符置于 <code>location</code> 语句后面，标识符后面为匹配规则。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location [标识符] &lt;匹配规则&gt; &#123;</span><br><span class="line">    # 匹配成功时执行的代码块</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了标识符之外，可以不使用标识符进行前缀匹配（最长字符匹配）。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><blockquote><p><code>location</code> 的匹配优先级与 <code>location</code> 在配置文件的书写顺序无关</p></blockquote><p>Nginx <code>location</code> 匹配优先级为：</p><p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>,</del>* 正则顺序) &gt; (location 部分起始路径) &gt; (location /)</p><p>换而言之，即：</p><p>（精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location 通配）</p><h3 id="“-”精准匹配"><a href="#“-”精准匹配" class="headerlink" title="“=”精准匹配"></a>“=”精准匹配</h3><p>使用精准匹配时，URI 必须完全相同才能匹配成功。</p><p>如下面的匹配规则，只有 URI 等于 <code>/php-fpm</code> 时才会触发成功，模块里的 <code>return 403;</code> 将会返回一个 <code>403 Forbidden</code> 提示信息，模拟我们不希望用户能直接访问的目录或文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F;php-fpm &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 <code>server_name</code> 字段修改为 <code>localhost</code> 方便本地调试。</p><blockquote><p>修改 Nginx 配置需要重启或平滑重启使配置生效，平滑重启命令：nginx -s reload</p></blockquote><p>请求 URI：<code>127.0.0.1/php-fpm</code></p><p>可以使用 <code>curl</code> 命令来测试，即 <code>curl 127.0.0.1/php-fpm</code>，也可以直接打开浏览器输入这个地址查看结果。</p><p>返回结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm/1.jpg</code></p><p>匹配失败，<code>=</code> 号必须完全匹配。</p><h3 id="“-”正则匹配，区分大小写"><a href="#“-”正则匹配，区分大小写" class="headerlink" title="“~”正则匹配，区分大小写"></a>“~”正则匹配，区分大小写</h3><p><code>location</code> 后跟波浪线标识符 <code>~</code>，可以实现按照正则表达式规则进行匹配，<code>~</code> 波浪线标识符正则匹配时会区分大小写，下面的规则表示不希望用户访问所有后缀为 <code>.php</code> 的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>第二个请求里，最后一个字母 P 为大写，因此匹配失败。</p><p>在波浪线前面加上感叹号，形成 <code>!~</code> 标识符，表示<strong>不匹配</strong>正则表达式（区分大小写）的规则，也就是跟 <code>~</code> 的作用相反。</p><h3 id="“-”正则匹配，不区分大小写"><a href="#“-”正则匹配，不区分大小写" class="headerlink" title="“~*”正则匹配，不区分大小写"></a>“~*”正则匹配，不区分大小写</h3><p>波浪线后加上星号 <code>~*</code> 标识符将不区分大小写进行正则匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .php&#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/php-fpm.php</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/php-fpm.phP</code></p><p>结果：403</p><p>由于使用了不区分大小写的规则，因此最后一个 P 改成大写也能匹配成功。</p><p>在波浪线前面加上感叹号，形成 <code>!~*</code> 标识符，表示<strong>不匹配</strong>正则表达式（不区分大小写）的规则，也就是跟 <code>~*</code> 的作用相反。</p><h3 id="“-”非正则匹配前缀"><a href="#“-”非正则匹配前缀" class="headerlink" title="“^~”非正则匹配前缀"></a>“^~”非正则匹配前缀</h3><p>“^~” 非正则匹配，后面的参数为匹配的路径，只要 URI 满足了这个前缀就匹配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F;encrpyt&#x2F; &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/encrpyt/</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt</code></p><p>匹配失败，<code>/encrpyt</code> 没有满足 <code>/encrpyt/</code>，缺少了后面的 <code>/</code>。</p><p>请求 URI：<code>127.0.0.1/encrpyt/1.jpg</code></p><p>结果：403</p><p>请求 URI：<code>127.0.0.1/encrpyt/images/1.jpg</code></p><p>结果：403</p><p>也就是说，只要前缀满足了这个条件就匹配成功，上面的匹配规则含义是 <code>encrypt</code> 目录下所有的文件都禁止访问。</p><h3 id="不使用标识符"><a href="#不使用标识符" class="headerlink" title="不使用标识符"></a>不使用标识符</h3><p>不使用标识符即按照最长字符串匹配，优先匹配最长的字符串，只要完全匹配就停止继续往下匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;files&#x2F;encrypt&#x2F; &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;post.php &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 URI：<code>127.0.0.1/post.php</code></p><p>首先会查找最长的字符串规则：<code>/files/encrypt/</code> 发现不匹配，接着匹配第二长的规则：<code>/post.php</code>，匹配成功，返回 403。</p><p>请求 URI：<code>127.0.0.1/files/encrypt/post.php</code></p><p>首先查找最长字符串规则：<code>/files/encrypt/</code> 前缀满足条件，匹配成功，停止往下匹配。</p><blockquote><p>注意！测试匹配规则时，如果你拷贝了上面完整的 Nginx 配置文件，.php 结尾是有 location ~ .php$ 规则的，记得删掉，否则会优先匹配到正则规则，建议测试时删除多余的所有规则，避免干扰结果，只建立一个对照组进行测试</p></blockquote><h2 id="Nginx-配置文件"><a href="#Nginx-配置文件" class="headerlink" title="Nginx 配置文件"></a>Nginx 配置文件</h2><p>Nginx 包括主配置文件与子配置文件，默认路径为：</p><ul><li>/etc/nginx/nginx.conf（主配置）</li><li>/etc/nginx/conf.d/（子配置目录）</li></ul><p>Nginx 提供了官方的中文文档可供查阅：<a href="https://www.nginx.cn/doc/index.html" target="_blank" rel="noopener">Nginx - 官方中文文档</a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p>主配置文件可以让所有子配置文件共享通用的配置，可以定义 Nginx 基本参数等。</p><p>编辑主配置文件 <code>/etc/nginx/nginx.conf</code>，对应参数及作用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># Nginx 运行时的用户和用户组</span><br><span class="line">user  nginx;</span><br><span class="line"></span><br><span class="line"># Nginx 工作进程数，推荐设置为 CPU 核心数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 全局错误日志存储路径及类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;nginx_error.log warn;</span><br><span class="line"></span><br><span class="line"># 进程 PID 文件路径</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"># 事件模块</span><br><span class="line">events &#123;</span><br><span class="line">    # 每个工作进程的最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 服务</span><br><span class="line">http &#123;</span><br><span class="line">    # 文件扩展名与文件类型映射表</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    </span><br><span class="line">    # 默认文件类型</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"> </span><br><span class="line">    # 日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    # 全局访问日志目录</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;nginx_access.log  main;</span><br><span class="line">    </span><br><span class="line">    # 是否调用 sendfile 函数输出文件</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    # 此选项仅在使用 sendfile 的时候使用</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    # http 层面的连接超时时长（单位：秒），如一个网页打开 65 秒后服务器还没给出响应，则显示超时</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    # 是否开启 gzip 压缩，开启时可以压缩文件体积减少网络传输，使得网页打开更快，但是会消耗 CPU 资源</span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    # 读取子配置文件</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>events</code> 模块包含了 Nginx 处理连接的设置，常见的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">    # 设置网路连接序列化，防止惊群现象发生，默认为 on</span><br><span class="line">    accept_mutex on;</span><br><span class="line">    # 设置一个进程是否同时接受多个网络连接，默认为 off</span><br><span class="line">    multi_accept on;</span><br><span class="line">    # 事件驱动模型，select|poll|kqueue|epoll|resig|&#x2F;dev&#x2F;poll|eventport</span><br><span class="line">    use epoll;</span><br><span class="line">    # 最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Events 模块的更多配置项：<a href="https://www.nginx.cn/doc/core/events.html" target="_blank" rel="noopener">Nginx - 指令</a></p><p><code>log_format</code> 字段可以定义日志的输出格式，具体可设置的参数格式及说明如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>219.227.111.255</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>—</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18/Jul/2014:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET /article-10000.html HTTP/1.1”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.blog.huotuyouxi.com" target="_blank" rel="noopener">www.blog.huotuyouxi.com</a> 198.98.120.87</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>1547</td></tr><tr><td>$http_referer</td><td>url跳转来源</td><td><a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户终端浏览器等信息</td><td>“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.36.10.80:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.165</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr></tbody></table><p><code>server</code> 模块用于配置站点，可以在主配置文件添加，但是后期不方便维护，我们可以单独为每个站点编辑一份配置文件。</p><h3 id="子配置文件"><a href="#子配置文件" class="headerlink" title="子配置文件"></a>子配置文件</h3><p>子配置文件是一个包含 <code>server</code> 模块的配置文件，由自己来创建，推荐为每个站点单独创建一个配置文件。</p><p>命名规则一般是根据站点名称，如：<code>blog.huotuyouxi.com.conf</code>。</p><p>当然这个没有严格要求，也可以写成：<code>blog.conf</code>。</p><p>当子配置文件多的时候方便区分即可。</p><p>使用命令 <code>vim/etc/nginx/conf.d/blog.conf</code> 来创建博客的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    return 301 https:&#x2F;&#x2F;blog.huotuyouxi.com$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # https</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    root &#x2F;www&#x2F;blog;</span><br><span class="line">    index index.html;</span><br><span class="line">    </span><br><span class="line">    # 访问日志存储位置</span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line">    </span><br><span class="line">    # 错误日志存储位置</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br><span class="line"></span><br><span class="line">    # 以下为 SSL 相关配置</span><br><span class="line">    ssl_certificate   &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;3527929_blog.huotuyouxi.com.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;3527929_blog.huotuyouxi.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件将默认的 http 80 端口重定向到了 https 的链接上。</p><p>编辑完成后运行：<code>nginx -s reload</code> 平滑重启即可使配置生效。</p><p>在子配置里可以单独设置访问日志和错误日志，让每个站点都有独立的日志记录文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 访问日志存储位置</span><br><span class="line">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_access.log;</span><br><span class="line"></span><br><span class="line"># 错误日志存储位置</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog_error.log;</span><br></pre></td></tr></table></figure><p>access_log：访问日志主要记录客户端的请求。客户端向 Nginx 服务器发起的每一次请求都记录在这里。客户端 IP，浏览器信息，referer，请求处理时间，请求 URL 等都可以在访问日志中得到。当然具体要记录哪些信息，你可以通过 log_format 指令定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]]; # 设置访问日志</span><br><span class="line">access_log off; # 关闭访问日志</span><br></pre></td></tr></table></figure><ul><li>path 指定日志的存放位置。</li><li>format 指定日志的格式。默认使用预定义的 combined。</li><li>buffer 用来指定日志写入时的缓存大小。默认是 64k。</li><li>gzip 日志写入前先进行压缩。压缩率可以指定，从 1 到 9 数值越大压缩比越高，同时压缩的速度也越慢。默认是 1。</li><li>flush 设置缓存的有效时间。如果超过 flush 指定的时间，缓存中的内容将被清空。</li><li>if 条件判断。如果指定的条件计算为 0 或空字符串，那么该请求不会写入日志。</li></ul><p>error_log：记录服务器和请求处理过程中的错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log path [level];</span><br></pre></td></tr></table></figure><ul><li>path：指定错误日志的存储位置</li><li>level：指定要记录的错误级别，只有发生错误的级别大于等于 level 的时候才会记录错误，可取值为：debug, info, notice, warn, error, crit, alert,emerg，默认值为 error。</li></ul><p>如果没有配置单独的日志文件，则会记录在全局日志里。</p><h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p>代理指的是中介服务。</p><p>分为正向代理与反向代理。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理可以理解成代购模式，例如你的朋友要去国外旅游，于是你拜托他帮忙购买你需要的商品，他从国外买好回来再交给你。</p><p>在这里你就是客户端，而你的朋友就是代理服务器。</p><p>这样直接由代理服务器去完成某件事的过程，叫做正向代理。</p><p>正向代理的应用例子——VPN：</p><p>由于国内无法访问到国外的某些网站，比如谷歌；但不是所有的国外服务器都被墙了，因此你可以买一台没有被墙的国外服务器，当你需要访问国外网站的时候，就让服务器去访问，然后再让服务器把结果转发给你。</p><p>正向代理的特征是你知道自己委托了谁去干这件事。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理与正向代理不同的地方在于：客户委托中介完成一件事，结果中介私底下把需求转交给了别人去干，客户不知道究竟是谁帮自己做完了需求，但是得到了自己想要的结果就够了。</p><p>好比游戏里面的公会，村民可以把自己的委托贴在公会告示板上，然后公会的看板娘会把委托的需求分配给适合的冒险者来完成。</p><p>反向代理的应用例子——负载均衡：</p><p>“负载”可以理解成负荷，用户访问一个非静态网站，程序需要读取数据库、渲染 HTML 页面、维持 TCP 连接等操作需要消耗 CPU、内存资源，会给服务器带来一定的负荷。</p><p>假如服务器可以承受的压力为 100N（物理学单位）</p><p>在某个瞬间，每有一名用户访问这个网站，会给服务器带来 5N 的压力，那么这个瞬间最大承载量就是 20 名用户，当服务器压力超过 100N 时就会崩溃。</p><p>要解决这个问题，可以进行硬件提升或者优化项目代码。</p><p>硬件提升可以提升服务器最大承受压力值，比如双核的服务器升级到 4 核，使服务器的最大承受压力从 100N 提升到 200N。</p><p>软件优化可以减少每个访客造成的压力，比如某些数据库 N+1 的问题严重影响了数据库的性能，造成数据库卡顿，优化了这个问题后，访客造成的压力值从 5N 降低到了 4N。</p><p>但是这两种方法提升都有一个临界点，比如硬件优化继续往上提升，服务器的价格就越来越贵，也不可能存在无限核心数的服务器；软件优化到一定程度后已经很难再找到优化的空间。</p><p>达到临界值后就无法再继续优化了，单机的性能已经达到了极致。</p><p>此时，如果能再买一台同样的服务器并且部署同一套项目，是不是可以使最大承载访客数翻倍呢？</p><p>确实可以，只要有两台服务器，那么它们的处理能力就会翻倍！</p><p>只要把一半的请求转发给另一台相同的服务器，平均分担压力。</p><p>但是应该怎么让请求分别进入到不同的服务器呢？</p><p>答案是通过 Nginx，利用上文介绍的反向代理功能。</p><p><img src="http://p3.pstatp.com/large/pgc-image/1534991903053fc12397bd0" alt="负载均衡"></p><p>这个过程称为“均衡”，负责维持均衡的那台服务器只负责分发请求，把请求转发给其他能完成功能的服务器处理，由其他服务器返回结果。</p><p>负责分发请求的服务器称为“均衡调度器”，Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream huotu-server &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">    server 192.168.0.16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;huotu-server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>upstream</code> 字段定义了代理服务器的 IP 地址，当访客进来的时候，Nginx 会按照某种规则将请求分发给其中一个服务器处理。</p><p><code>server</code> 模块里通过 <code>proxy_pass http://huotu-server;</code> 将匹配到规则的请求转发给代理服务器来处理。</p><p>当用户访问：blog.huotuyouxi.com</p><p>Nginx 会把请求转发给某台服务器处理，因此每次访问网站看到的返回 IP 可能都会不同。</p><h2 id="Nginx-模块"><a href="#Nginx-模块" class="headerlink" title="Nginx 模块"></a>Nginx 模块</h2><p>Nginx 发展迅速的原因除了开源之外，还可以使用官方提供的模块或用户自定义开发的模块，由于模块化使得 Nginx 的定制能力很强，可以使用第三方扩展模块让 Nginx 适应各种场景，有能力的大神也可以分享自己写好的模块让其他人直接使用，像这样可以自由 DIY 的软件，有谁会不喜欢呢？</p><p>例如，由淘宝的工程师清无（王晓哲）和春来（章亦春）所开发的 nginx_lua_module 可以将 Lua 语言嵌入到 Nginx 配置中，从而利用 Lua 极大增强了 Nginx 本身的编程能力，甚至可以不用配合其它脚本语言（如 PHP 或 Python 等），只靠 Nginx 本身就可以实现复杂业务的处理。</p><p>Nginx 本身支持多种模块，如 HTTP 模块、EVENT 模块和 MAIL 模块等。</p><p>前文提到，在 HTTP 请求中，Nginx 的工作仅仅只是分析请求然后转发给匹配规则的 <code>location</code> 去处理，<code>location</code> 模块中的内容才是真正干活的人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 匹配规则</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 实际的工作者</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已安装模块可以用命令：<code>nginx -V</code> 查看，输出结果类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) </span><br><span class="line">built with OpenSSL 1.1.0j  20 Nov 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-g -O2 -fdebug-prefix-map&#x3D;&#x2F;data&#x2F;builder&#x2F;debuild&#x2F;nginx-1.15.12&#x2F;debian&#x2F;debuild-base&#x2F;nginx-1.15.12&#x3D;. -fstack-protector-strong -Wformat -Werror&#x3D;format-security -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fPIC&#39; --with-ld-opt&#x3D;&#39;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#39;</span><br></pre></td></tr></table></figure><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>Nginx 有许多可以自定义安装的模块，下面以 echo 为例。</p><p>echo 仓库地址：<a href="https://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">Github - echo-nginx-module</a></p><p>安装 echo 模块 <code>echo-nginx-module</code> 可以使 Nginx 具有输出字符串的能力，这个功能可以用来简单的调试，如输出参数等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;hello &#123; </span><br><span class="line">    return 200 &#39;hello!&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;hello_echo &#123; </span><br><span class="line">    echo &quot;hello, echo!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方模块"><a href="#官方模块" class="headerlink" title="官方模块"></a>官方模块</h3><p>官方模块是 Nginx 官方提供的可扩展模块。</p><p>例如 Nginx 预制的模块 stub_status 可以用来查看 Nginx 的运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line">    stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问后的输出页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 3 3 2 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure><p>更多 Nginx 官方模块以使用方法：<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a></p><p>如上面的 <code>stub_status</code>，可以通过查询手册：<a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html" target="_blank" rel="noopener">ngx_http_stub_status_module</a> 来获取如何使用。</p><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>可以通过搜索 Github 寻找来自全世界开发者分享的模块：<a href="https://github.com/search?q=nginx+module" target="_blank" rel="noopener">Github - Nginx 扩展模块</a></p><p>具体的使用方法可以参照作者写的 README 文档。</p><h2 id="Nginx-应用场景"><a href="#Nginx-应用场景" class="headerlink" title="Nginx 应用场景"></a>Nginx 应用场景</h2><p>最后再来总结一下，Nginx 具体的应用场景。</p><h3 id="HTTP-服务"><a href="#HTTP-服务" class="headerlink" title="HTTP 服务"></a>HTTP 服务</h3><p>Nginx 可以为站点提供 HTTP 服务。</p><p>利用 <code>location</code> 模块匹配 URI 规则，再将其分发到对应的程序进行处理。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Nginx 的反向代理服务，可以实现分发请求的功能。</p><p>具体方法是配置 <code>upstream</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        server 127.0.0.1:8000 weight&#x3D;3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">        server 127.0.0.1:8003;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">        server_name www.domain.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;myproject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡有以下几种模式：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>轮询模式</td><td>Nginx 默认配置，当客户端访问服务的时候，请求按时间顺序逐一分配到不同的后端服务器，如果有某台服务器挂了，Nginx 会自动剔除</td></tr><tr><td>权重模式</td><td>可以为每个服务器配置不同的权重，权重值越高的越容易被分发到请求，当多台服务器性能存在差异时，可以让配置高的服务器分配更高的权重</td></tr><tr><td>IP 哈希</td><td>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。解决 Session 丢失的问题，保证每个用户访问到同一台服务器。</td></tr><tr><td>第三方插件</td><td>可以通过安装第三方插件实现更多的模式</td></tr></tbody></table><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>当自己网站的图片、视频等静态资源被其他人引用时，其他人访问了别人的网站，就会请求到我们服务器上的资源，给我们的服务器带来压力。</p><p>Nginx 可以验证来源网站 referers 来判断请求是否是本站点，如果是其他的站点则不让它们获取到图片资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    root html</span><br><span class="line">    valid_referers none blocked *.huotuyouxi.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDN-服务器"><a href="#CDN-服务器" class="headerlink" title="CDN 服务器"></a>CDN 服务器</h3><p>可以用 Nginx 搭建 CDN 服务器。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>Nginx 的 <code>ngx_http_limit_req_module</code> 模块可以限制访问频率和并发连接数。</p><p>HttpLimit zone：<a href="https://www.nginx.cn/doc/standard/httplimitzone.html" target="_blank" rel="noopener">HttpLimit zone</a></p><p>HttpLimitReqest：<a href="https://www.nginx.cn/doc/standard/httplimitrequest.html" target="_blank" rel="noopener">HttpLimitReqest</a></p><h3 id="黑-白名单"><a href="#黑-白名单" class="headerlink" title="黑/白名单"></a>黑/白名单</h3><p>可以禁止某些 IP 访问，或允许指定 IP 访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    deny 8.8.8.8;</span><br><span class="line">    allow 9.9.9.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>以 Ajax 方式访问非本站点的链接时，浏览器出于安全考虑会禁止访问，也就是跨域问题（HTTP 访问限制，CORS）。</p><p>在 Nginx 中只需要配置允许访问的来源类型即可解决跨域问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 允许访问的来源，* 指的是全部，可以是 IP 地址或者域名</span><br><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line"># 允许请求的类型</span><br><span class="line">add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line"># 允许请求的方法</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br></pre></td></tr></table></figure><h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>Nginx 提供了邮件代理服务，具体参照官方文档：<a href="https://www.nginx.cn/doc/mail/mailcore.html" target="_blank" rel="noopener">Nginx - MailCore</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的反射</title>
      <link href="/php-reflex/"/>
      <url>/php-reflex/</url>
      
        <content type="html"><![CDATA[<h2 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h2><p>反射原本指的是一种光学现象，光在传播时照射在物体上会产生返回原物体的现象。在 PHP 中，反射的作用类似光的传播，PHP 可以通过反射机制拿到代码本身，也就是通过代码得到代码，反射一词十分形象。</p><p>通过反射机制可以获取类中的变量、方法名称甚至是注释等等，在正常的开发环境中几乎不会用到，一般都是在框架设计时使用，目的是增加框架的扩展性。</p><p>Laravel、Swoft 框架都用到了反射机制，Swoft 注解的实现原理就是使用反射机制来实现的。</p><p>一些 API 文档插件可以通过注释来编译生成 API 文档，其原理同样是使用了 PHP 的反射机制。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义一个类，类里面有常量、私有属性（private 声明的变量）、类的注释和方法的注释等等。</p><p>思考下面几个业务中几乎不会用到的问题：</p><p>如果我们要获取类里面的所有常量，应该怎么做？</p><p>如果我们要获取方法的注释，或者类的注释，应该怎么做？</p><p>如果我们要获得类的命名空间，又该怎么做？</p><p>此时习惯了做业务的我们肯定一脸懵逼，PHP 中的反射就是为了解决这一类的问题，通过反射提供的 API 可以拿到一个类的所有信息。</p><p>通过下面的代码举例，你马上就会弄懂什么是反射了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 类的注释</span><br><span class="line"> *&#x2F;</span><br><span class="line">class User</span><br><span class="line">&#123;</span><br><span class="line">    const BOY &#x3D; 1;</span><br><span class="line">    const GIRL &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    private $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name) &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;hello!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class &#x3D; new ReflectionClass(&#39;User&#39;);  &#x2F;&#x2F; 将类名User作为参数，即可建立User类的反射类</span><br><span class="line">$properties &#x3D; $class-&gt;getProperties();  &#x2F;&#x2F; 获取User类的所有属性，返回ReflectionProperty的数组</span><br><span class="line">$property &#x3D; $class-&gt;getProperty(&#39;name&#39;); &#x2F;&#x2F; 获取User类的属性ReflectionProperty</span><br><span class="line">$methods &#x3D; $class-&gt;getMethods();   &#x2F;&#x2F; 获取User类的所有方法，返回ReflectionMethod数组</span><br><span class="line">$method &#x3D; $class-&gt;getMethod(&#39;sayHello&#39;);  &#x2F;&#x2F; 获取User类的方法的ReflectionMethod</span><br><span class="line">$constants &#x3D; $class-&gt;getConstants();   &#x2F;&#x2F; 获取所有常量，返回常量定义数组</span><br><span class="line">$constant &#x3D; $class-&gt;getConstant(&#39;BOY&#39;);   &#x2F;&#x2F; 获取常量</span><br><span class="line">$namespace &#x3D; $class-&gt;getNamespaceName();  &#x2F;&#x2F; 获取类的命名空间</span><br><span class="line">$comment_class &#x3D; $class-&gt;getDocComment();  &#x2F;&#x2F; 获取User类的注释文档，即定义在类之前的注释</span><br><span class="line">$comment_method &#x3D; $class-&gt;getMethod(&#39;sayHello&#39;)-&gt;getDocComment();  &#x2F;&#x2F; 获取User类中方法的注释文档</span><br><span class="line"></span><br><span class="line">var_dump($comment_method);</span><br></pre></td></tr></table></figure><p>上面的代码会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(39) &quot;&#x2F;**</span><br><span class="line">     * 我是方法注释</span><br><span class="line">     *&#x2F;&quot;</span><br></pre></td></tr></table></figure><h2 id="反射-API"><a href="#反射-API" class="headerlink" title="反射 API"></a>反射 API</h2><p>PHP 官方手册：<a href="https://www.php.net/reflection" target="_blank" rel="noopener">https://www.php.net/reflection</a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>反射机制会打破类的封装性，日常业务也不需要获取代码的注释。</p><p>因此在日常开发中几乎不会直接用到，但是在框架或者插件的设计上却能发挥很大的作用。</p><h3 id="生成-API-文档"><a href="#生成-API-文档" class="headerlink" title="生成 API 文档"></a>生成 API 文档</h3><p>由于反射可以拿到类的属性、方法，就可以自动生成类的文档。</p><p>典型例子：<a href="https://apidocjs.com/" target="_blank" rel="noopener">API DOC</a></p><p>通过在方法名称上添加注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;get&#125; &#x2F;user&#x2F;:id Request User information</span><br><span class="line"> * @apiName GetUser</span><br><span class="line"> * @apiGroup User</span><br><span class="line"> *</span><br><span class="line"> * @apiParam &#123;Number&#125; id Users unique ID.</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccess &#123;String&#125; firstname Firstname of the User.</span><br><span class="line"> * @apiSuccess &#123;String&#125; lastname  Lastname of the User.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>然后运行编译程序就可以直接生成一个美观、排版整齐的 API 文档。</p><p><img src="https://apidocjs.com/img/example.png" alt="APIDOC"></p><p>一些 IDE 提示工具也利用反射获取类的注释，然后实现提示的功能，注释时需要根据一定的规范。</p><p>注释示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试方法</span><br><span class="line"> * @param $a</span><br><span class="line"> * @param $b</span><br><span class="line"> *&#x2F;</span><br><span class="line">function test($a,$b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量复刻文件"><a href="#批量复刻文件" class="headerlink" title="批量复刻文件"></a>批量复刻文件</h3><p>既然可以拿到类的所有成员，那么以类为母版，克隆出子类文件轻而易举，在一些框架或插件中经常用到。</p><p>Laravel 框架可以使用 <code>php artisan make:controller UserController</code> 命令创建一个控制器类的模板，还可以加上参数 <code>-r</code> 生成一个 RESTful 风格的 API 控制器类。</p><p>还有数据库迁移工具（Laravel 内置了此插件），可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php vendor&#x2F;bin&#x2F;phinx create MyMigration</span><br></pre></td></tr></table></figure><p>直接生成一个数据库迁移文件。</p><p>直接用命令的方式生成文件，可以少写很多重复的代码。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>先不需要知道依赖注入是什么，看下面的例子，Laravel 很普通的控制器类的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct(UserService $service)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service &#x3D; $service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users &#x3D; $this-&gt;service-&gt;getAllUsers();</span><br><span class="line">        </span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过构造函数赋予了属性 <code>$service</code>，但问题是——控制器类并没有被实例化！</p><p>一般情况下，我们需要这样把参数传给构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$service &#x3D; new UserService();</span><br><span class="line">$user &#x3D; new UserController($service);</span><br></pre></td></tr></table></figure><p>上面的例子并没有 <code>UserController</code> 的实例化操作，而且在 PHP 中参数前面加上类名称，只是起到变量类型限制的作用。</p><p>到底是哪里传来实例化的 <code>UserService</code> 呢？</p><p>其实是通过反射机制实现的，通过反射获取到了控制器类的构造方法，然后将这个控制器所需要<strong>依赖</strong>的类实例化后生成的对象<strong>注入</strong>到控制器里，所以这个叫做依赖注入。</p><p>依赖注入这个概念是从 Java 中传过来的，并非 Laravel 特有。</p><p>假设不使用反射机制注入依赖，那么我们的控制器是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use App\Service\UserService;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public $service;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;service &#x3D; new UserService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $users &#x3D; $this-&gt;service-&gt;getAllUsers();</span><br><span class="line"></span><br><span class="line">        dd($users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯……？代码量好像差不多！</p><p>依赖注入是一种设计模式，运行的结果没有差别。</p><p>其实在学 Laravel 的时候，我发现了一个很奇怪的地方。</p><p>比如存在路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;&#x2F;users&#39;, &#39;UserController@index&#39;)-&gt;name(&#39;users.index&#39;);</span><br><span class="line">Route::get(&#39;&#x2F;users&#x2F;&#123;id&#125;&#39;, &#39;UserController@show&#39;)-&gt;name(&#39;users.show&#39;);</span><br></pre></td></tr></table></figure><p>然后控制器的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function show(Request $request, $id)</span><br><span class="line">    &#123;</span><br><span class="line">        dd($request, $id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index 方法的第一个<code>Illuminate\Http\Request</code> 类型的参数，我们在路由中没有任何参数，既然不是通过匹配路由得到的参数，这个参数又是怎么来的呢？</p><p>更不可思议的是第二个路由的 show 方法，我们在声明路由的时候只指明了一个参数 <code>/users/{id}</code>，但我们现在却在方法中写了两个参数，又是怎么精确地匹配到 ID 值的？</p><p>其实同样是用了依赖注入的方法实现的，在学习了反射之后，它们的原理就大概知道了。</p><p>首先通过反射得到一个方法的参数，如果这个参数定义了某些类型，就将其实例化后再传递给该方法，在 Laravel 中有专门的解析类在处理这些参数。</p><h3 id="通过注释生成路由"><a href="#通过注释生成路由" class="headerlink" title="通过注释生成路由"></a>通过注释生成路由</h3><p>Swoft 框架把注释当做定义路由的方法，称为“注解”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use Swoft\Http\Message\Request;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\Controller;</span><br><span class="line">use Swoft\Http\Server\Annotation\Mapping\RequestMapping;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Class Home</span><br><span class="line"> *</span><br><span class="line"> * @Controller(prefix&#x3D;&quot;home&quot;)</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Home</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 该方法路由地址为 &#x2F;home&#x2F;index</span><br><span class="line">     *</span><br><span class="line">     * @RequestMapping(route&#x3D;&quot;&#x2F;index&quot;, method&#x3D;&quot;post&quot;)</span><br><span class="line">     *</span><br><span class="line">     * @param Request $request</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function index(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 PHP 的反射机制可以做一些奇奇怪怪的事，这也算是 Swoft 独特的风格吧。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的魔术方法</title>
      <link href="/php-magic-methods/"/>
      <url>/php-magic-methods/</url>
      
        <content type="html"><![CDATA[<h2 id="魔术方法是什么？"><a href="#魔术方法是什么？" class="headerlink" title="魔术方法是什么？"></a>魔术方法是什么？</h2><p>魔术方法是 PHP 类中特殊的方法，以双下划线 <code>__</code> 开头，具有特殊用途，比如我们常用的 <code>__construct</code> 构造函数就属于魔术方法，构造函数的作用是类实例化自动调用的方法。</p><p>魔术方法的名称都是系统预定义的，无法修改，我们在写 PHP 代码的时候，为了避免与系统预定义函数相同，不建议用双下划线 <code>__</code> 作为函数的前缀。</p><p>魔术方法的作用可以归纳为：<strong>对象在 xxx 的时候，应该实现的功能。</strong></p><p>比如，上述构造函数可以理解为：对象在“实例化”的时候，应该实现的功能。</p><p>除此之外，与构造函数相对的 <strong>析构函数</strong> <code>__destruct</code> 可以在对象被回收时自动调用。</p><p>如果有 Java 基础，你可以发现类默认有一种 <code>toString</code> 方法，可以把对象转化成字符串。其实 PHP 中也存在同样的魔术方法 <code>__toString</code>，当类的对象被当做字符串调用时会自动执行此方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;Just a dog.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>执行的结果会输出：Just a dog.</p><p>为什么在上述代码中，echo 可以输出一个对象呢？</p><p>这是因为我们设置了 <code>__toString</code> 方法，当对象被当做字符串调用时会自动触发 <code>__toString</code> 方法。</p><p>换而言之，<strong>魔术方法是一类由系统预定义了函数名称，在某些情况下被动触发的函数</strong>。</p><p>所有的魔术方法都不是用来主动调用的，如下错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误示范</span><br><span class="line">$obj &#x3D; new MyClass();</span><br><span class="line">$obj-&gt;__construct();</span><br></pre></td></tr></table></figure><p>魔术方法也是类的方法，上述代码逻辑上没有问题而且可以运行且不会报错。不会报错不代表这么写没问题，魔术方法中<strong>不应该</strong>放入业务逻辑相关的代码。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>魔术方法大都用于框架且与设计模式关联紧密，日常业务除了构造方法之外几乎很少接触到其他魔术方法。<br>Laravel 框架将魔术方法用到了极致，被称为“优雅”的框架。</p><h2 id="PHP-中的魔术方法"><a href="#PHP-中的魔术方法" class="headerlink" title="PHP 中的魔术方法"></a>PHP 中的魔术方法</h2><p>下面介绍 PHP 常见的魔术方法以及应用场景和示例代码。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p>俗称类的构造方法，当类被实例化为对象时自动调用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;Just a dog.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br></pre></td></tr></table></figure><p>输出：Just a dog.</p><blockquote><p>void __construct ([ mixed $args [, $… ]] )</p></blockquote><p>构造函数的几大特征：</p><ul><li>构造函数可以接受参数，能够在创建对象时赋值给对象属性</li><li>构造函数可以调用类方法或其他函数</li><li>构造函数可以调用其他类的构造函数</li><li>构造函数的权限可以被修改</li></ul><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;This is animal.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 父类构造函数不会自动调用，需要手动进行调用</span><br><span class="line">        parent::__construct();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对象赋值</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用类中的方法</span><br><span class="line">        $this-&gt;jump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function jump()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name . &#39; jump.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog(&#39;小白&#39;);</span><br></pre></td></tr></table></figure><p>最后一条：<strong>构造函数的权限可以被修改。</strong></p><p>在设计模式中会用到，例如单例模式，为了防止子类被实例化，会将构造函数限制为 <code>private</code> 私有化。</p><p>一个比较标准的单例模式示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 私有属性，用于保存实例</span><br><span class="line">    private static $instance;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构造方法私有化，防止外部创建实例</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 公有方法，用于获取实例</span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        &#x2F;&#x2F; 没有的话创建实例并返回，有的话直接返回</span><br><span class="line">        if(!(self::$instance instanceof self))&#123;</span><br><span class="line">            self::$instance &#x3D; new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 克隆方法私有化，防止复制实例</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h3><p>俗称析构函数，当对象被回收时自动调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;The dog is dead.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">unset($dog);</span><br></pre></td></tr></table></figure><p>输出：The dog is dead.</p><blockquote><p>void __destruct ( void )</p></blockquote><p>析构函数的特征：</p><ul><li>析构函数不能接受参数</li><li>析构函数不能抛出异常</li></ul><p>由于析构函数在对象被回收时触发，因此如果抛出异常将无法被捕获，抛出异常情况下将报出致命错误。</p><p>和构造函数一样，父类的析构函数不会被隐式调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用： <code>parent::__destruct();</code></p><h3 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h3><p>当调用对象中不存在的属性时，自动触发该方法。</p><p>Laravel 框架里几乎随处可见，如 Model 对象调用表的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::find(1);</span><br><span class="line">echo $user-&gt;name;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：NULL</p><p>通常情况下，如果直接调用对象中不存在的属性会产生报错，但是设置了 <code>__get</code> 方法后，如果调用了不存在的属性则会转而调用这个方法处理。通常 <code>__get</code> 要结合 <code>__set</code> 一起使用。</p><h3 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h3><p>当设置对象中不存在的属性时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $attrs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isset($this-&gt;attrs[$name])) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;attrs[$name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __set($name, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;attrs[$name] &#x3D; $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;name &#x3D; &#39;小白&#39;;</span><br><span class="line">var_dump($dog-&gt;name);</span><br></pre></td></tr></table></figure><p>输出：string(6) “小白”</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h3><p>当对象被当成字符串调用时，自动触发该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;Dog name is &#39; . $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog(&#39;小黑&#39;);</span><br><span class="line">echo $dog;</span><br></pre></td></tr></table></figure><p>输出：Dog name is 小黑</p><p>这个魔术方法在调试的时候非常有用，可以把对象中的参数信息打印出来，记录到日志里。</p><h3 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h3><p>当对象调用了一个类中不存在的方法或者没有权限调用的方法时，自动触发。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function aPrivateMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;Im private.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;fly(&#39;666&#39;);</span><br><span class="line">$dog-&gt;aPrivateMethod();</span><br></pre></td></tr></table></figure><p>第一个 fly 方法，不存在 Dog 类中；第二个 aPrivateMethod 是私有方法，不能直接被对象调用，因而触发了 <code>__call</code> 方法。</p><p>在 Laravel 中也可以看到许多 <code>__call</code> 应用的场景，还是 Model 类的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::whereName(&#39;xiaobai&#39;)-&gt;first();</span><br><span class="line">dd($user);</span><br></pre></td></tr></table></figure><p>这里的 where 后面接大驼峰方式的参数，相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user &#x3D; User::where(&#39;name&#39;, &#39;xiaobai&#39;)-&gt;first();</span><br></pre></td></tr></table></figure><p>通过 <code>__call</code> 方法实现简写的目的。</p><p><code>__call</code> 方法接收两个参数，第一个参数是调用方法的名称，第二个参数是调用方法时传入的参数，数组格式。</p><h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic"></a>__callStatic</h3><p>当对象调用了一个不存在的静态方法时，自动触发。</p><p><code>__callStatic</code> 与 <code>__call</code> 的作用基本相似，只不过 <code>__callStatic</code> 针对的是静态方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public static function __callStatic($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($name,$arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog::whatsYourProblem();</span><br></pre></td></tr></table></figure><p>这样的设计在 Laravel 框架中也能看到，依然是 Model 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users &#x3D; User::all();</span><br><span class="line">$items &#x3D; Item::where(&#39;price&#39;, &#39;&gt;&#39;, 100)-&gt;paginate(20);</span><br></pre></td></tr></table></figure><p>Laravel 中的 Model 并不是把方法真的当做静态方法，而是利用 <code>__callStatic</code> 让你产生“静态调用”的错觉。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h3><p>当尝试以调用方法的形式来调用一个对象时，自动触发该方法。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    public function __invoke($parm1, $parm2)</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($parm1,$parm2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog(&#39;小白&#39;,&#39;小黑&#39;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">string(6) &quot;小黑&quot;</span><br></pre></td></tr></table></figure><p><code>__invoke</code> 可以接收自定义的任意参数，与函数的形参规则一致。</p><p>我们知道这种方法有点奇怪，谁也不会把一个对象当成方法来用吧？</p><p>让我们来康康 Laravel 框架是怎么利用 <code>__invoke</code> 让代码变得更“优雅”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、指定路由及对应的方法</span><br><span class="line">Route::get(&#39;&#x2F;user&#39;, &#39;UserController@index&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、不指定对应的方法，自动调用 __invoke</span><br><span class="line">Route::get(&#39;&#x2F;user&#x2F;default&#39;, &#39;UserController&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1、&#x2F;user 调用 index 方法</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2、&#x2F;user&#x2F;default 没有指定方法，自动调用 __invoke</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不指定具体的方法时，Laravel 的路由会把对象当做方法来执行，从而调用 <code>__invoke</code> 方法，简化了路由部分的代码。</p><h3 id="clone"><a href="#clone" class="headerlink" title="__clone"></a>__clone</h3><p>当对象被克隆时，自动调用。</p><p>PHP 中存在一个关键词 clone 可以复制对象，并且复制出来的对象为独立的个体，与原对象不存在互相影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;new dog birth.&#39; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog &#x3D; new Dog();</span><br><span class="line">$dog-&gt;name &#x3D; &#39;小白&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 克隆出来的对象属性与原对象一模一样</span><br><span class="line">$cloneDog &#x3D; clone $dog;</span><br><span class="line">var_dump($cloneDog-&gt;name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改克隆对象的属性，不会影响原对象</span><br><span class="line">$cloneDog-&gt;name &#x3D; &#39;小黑&#39;;</span><br><span class="line">var_dump($dog, $cloneDog);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new dog birth.</span><br><span class="line">string(6) &quot;小白&quot;</span><br><span class="line">object(Dog)#1 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]&#x3D;&gt;</span><br><span class="line">  string(6) &quot;小白&quot;</span><br><span class="line">&#125;</span><br><span class="line">object(Dog)#2 (1) &#123;</span><br><span class="line">  [&quot;name&quot;]&#x3D;&gt;</span><br><span class="line">  string(6) &quot;小黑&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，克隆出来的对象修改了属性，但是原来对象的属性保持不变，它们是互相独立的个体，也就是说并非引用关系，clone 会开辟一块新的内存来存储复制出来的新对象。</p><p><code>__clone</code> 方法在 clone 出新对象时自动调用。</p><p>clone 业务中用得比较少，应用场景能想到的一个是重构代码，我们需要增加一个新的接口来应对新的需求，但同时又不希望破坏旧接口的内部结构，也不希望直接在旧接口的代码上修改，此时可以使用 clone，既可以向下兼容作用，又能在旧接口上添加新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class NewDogAction</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 新接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OldDogAction</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 旧版接口代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 动作类对象</span><br><span class="line">    private $action;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action &#x3D; new OldDogAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;action &#x3D; new NewDogAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 clone 出来的时候，action 被替换成新的接口代码。</p><p>换成比较形象的例子：</p><p>鸣人使用多重影分身之术，可以看成是 clone 出很多个分身，但是这些分身并不能 100% 继承本体的能力，本体的能力可以看成上面的 <code>oldDogAction</code>，而分身的能力则是 <code>newDogAction</code>，分身除了 action 属性之外其他的地方与本体并无差异。</p><h2 id="更多的魔术方法"><a href="#更多的魔术方法" class="headerlink" title="更多的魔术方法"></a>更多的魔术方法</h2><p>如果有兴趣了解全部的魔术方法，请访问 <a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">PHP：魔术方法</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理工具 Supervisord</title>
      <link href="/supervisord/"/>
      <url>/supervisord/</url>
      
        <content type="html"><![CDATA[<h2 id="Supervisord-是什么？"><a href="#Supervisord-是什么？" class="headerlink" title="Supervisord 是什么？"></a>Supervisord 是什么？</h2><p>Supervisord 是一个进程管理工具，它可以用来执行一些需要在后台持续存在的进程（守护进程）的启动命令。</p><p>比如前端的 Nuxt 框架使用 SSR（服务端渲染），需要启动服务端的进程，会使用 pm2 来管理进程的启动。</p><p>Supervisord 同样是一种进程管理工具。</p><p>下文将演示 Supervisord 管理 Laravel 的队列任务进程。 </p><h2 id="安装-Supervisord"><a href="#安装-Supervisord" class="headerlink" title="安装 Supervisord"></a>安装 Supervisord</h2><p>以 Centos 为例，直接使用 yum 安装即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、安装 epel-release</span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"># 2、安装 supervisor</span><br><span class="line">yum install -y supervisor</span><br><span class="line"></span><br><span class="line"># 3、将 supervisor 设置为开机启动</span><br><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure><p>以上就安装完成了，但是还没有启动 supervisor，先不用着急启动。</p><h2 id="Supervisor-配置文件"><a href="#Supervisor-配置文件" class="headerlink" title="Supervisor 配置文件"></a>Supervisor 配置文件</h2><p>supervisor 的配置文件默认路径为：<code>/etc/supervisor/supervisord.conf</code>，使用 <code>vim</code> 命令编辑，大致可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod&#x3D;0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">&quot;&#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf&quot; 28L, 1178C                 8,1           Top</span><br><span class="line">; supervisor config file</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod&#x3D;0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</span><br><span class="line">                                                                                                                                                                                          19,36         All</span><br></pre></td></tr></table></figure><p>如果不一样说明版本不同，通过下面的命令可以查看自己安装的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 版本</span><br><span class="line">supervisord -v</span><br><span class="line"></span><br><span class="line"># 我下载的版本是 3.3.5</span><br></pre></td></tr></table></figure><p>需要注意的地方只有最底下的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</span><br></pre></td></tr></table></figure><p>在一些旧的版本这里会有差别，这里的意思是说包含了路径 <code>/etc/supervisor/conf.d</code> 文件夹里面所有后缀为 <code>.conf</code> 的文件，现在不需要改动这个文件。</p><p><code>/etc/supervisor/conf.d/</code> 文件夹下默认是空的，我们要自己创建新的配置文件。</p><p>使用命令：<code>vim /etc/supervisor/conf.d/my.conf</code>，编辑并保存如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:myprogram]</span><br><span class="line">process_name&#x3D;%(program_name)s_%(process_num)02d</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php &#x2F;www&#x2F;myproject&#x2F;artisan queue:work --quiet --tries&#x3D;3 --sleep&#x3D;3</span><br><span class="line">directory&#x3D;&#x2F;www&#x2F;myproject</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">user&#x3D;www-data</span><br><span class="line">numprocs&#x3D;1</span><br><span class="line">redirect_stderr&#x3D;true</span><br></pre></td></tr></table></figure><p>这里我们启动了一个守护进程，用来执行 Laravel 的队列任务：<code>php artisan queue:work</code>。</p><p>配置项说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># program:&lt;进程名字&gt;</span><br><span class="line">[program:myprogram]</span><br><span class="line"></span><br><span class="line"># 进程的名字规则，按照下面的配置就可以了</span><br><span class="line">process_name&#x3D;%(program_name)s_%(process_num)02d</span><br><span class="line"></span><br><span class="line"># 执行的命令 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php 是 PHP 二进制文件位置，相当于在 Laravel 下执行 php artisan 一样</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php &#x2F;www&#x2F;myproject&#x2F;artisan queue:work --quiet --tries&#x3D;3 --sleep&#x3D;3</span><br><span class="line"></span><br><span class="line"># 项目所在目录，注意这里一定要填，网上搜的教程很多都忽略了这个字段</span><br><span class="line">directory&#x3D;&#x2F;www&#x2F;myproject</span><br><span class="line"></span><br><span class="line"># 是否在 supervisor 启动的时候自动启动进程</span><br><span class="line">autostart&#x3D;true</span><br><span class="line"></span><br><span class="line"># 当进程在 running 状态下 exit 时，是否自动重启</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line"></span><br><span class="line"># 这里一定要填对，如果你是用 Laravel 执行队列任务，那跟我填的一样就可以，如果你执行其他任务，请填写所属的用户组，不然会有权限问题</span><br><span class="line">user&#x3D;www-data</span><br><span class="line"></span><br><span class="line"># 启动多少个子进程，一般启动 1 个就够了</span><br><span class="line">numprocs&#x3D;1</span><br><span class="line"></span><br><span class="line"># 设置为 true 时，将进程报错的输出内容写到 supervisor 的输出文件 stdout 里，建议为 true，这样报错了可以查错误信息</span><br><span class="line">redirect_stderr&#x3D;true</span><br></pre></td></tr></table></figure><blockquote><p>注意把上面的 myproject 替换成自己项目的路径</p></blockquote><p>保存好配置文件后，就可以启动 supervisor 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种方法皆可启动 supervisor</span><br><span class="line"></span><br><span class="line"># 1、指定配置文件的方式启动 supervisor（推荐）</span><br><span class="line">supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line"># 2、服务的方式启动</span><br><span class="line">systemctl start supervisord</span><br></pre></td></tr></table></figure><p>执行成功的情况下，你会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unlinking stale socket &#x2F;var&#x2F;run&#x2F;supervisor.sock</span><br></pre></td></tr></table></figure><p>如果不是这个信息，说明你的配置文件有问题，检查一下 <code>command</code> 和 <code>directory</code> 路径是否填写正确，99% 启动不成功都是这两个字段填写不正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 supervisor 进程</span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line"># 可以看到下面的输出结果</span><br><span class="line">myproject:myprogram                 RUNNING   pid 17, uptime 0:01:40</span><br></pre></td></tr></table></figure><p>显示为 <code>RUNNING</code> 则说明正常运行，如果不是这个状态就是配置文件出错了。</p><p>如果修改了配置文件，或者创建了新的配置文件，需要重载才能读取到新的配置，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重新读取配置文件</span><br><span class="line">supervisorctl reread</span><br><span class="line"></span><br><span class="line"># 更新运行状态</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h2 id="Laravel-队列任务无法写入-Log-日志问题"><a href="#Laravel-队列任务无法写入-Log-日志问题" class="headerlink" title="Laravel 队列任务无法写入 Log 日志问题"></a>Laravel 队列任务无法写入 Log 日志问题</h2><p>用 supervisor 执行队列任务时发现 Laravel 的日志系统 Log 竟然无法写入日志文件，查了下也没有任何报错信息，问题的原因是所在用户组没有权限。</p><p>也就是配置文件中的，user 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user&#x3D;www-data</span><br></pre></td></tr></table></figure><p>这里一定要填写运行程序的用户组，比如 PHP 的用户组是 <code>www-data</code>，如果你填的是 <code>root</code>，这样就没有权限操作日志文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervisord </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序猿提升自我修养的网站推荐</title>
      <link href="/programmer-recommend-website/"/>
      <url>/programmer-recommend-website/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为程序猿，阅读其他人分享的技术文章除了学习新的技术之外，对于提升自己的思维能力也有很大的帮助。比起自己摸爬滚打尝试出来所耗费的时间，也许别人一句简单的提醒就能使你豁然开朗。</p><p>当然，对于一些刚刚入坑的新人来说，也许依赖别人不是一个好的建议，自己摸索可以提升自学能力，作为新入道途的小司机来说，在听取别人的建议后，别忘了加入自己的思考。</p><p>对老司机老说，关键的学习能力和处理问题的能力已经在日常业务中得到锻炼，与其不断摸索不如听取建议以最快的速度解决问题。然后再细细回味其中的道理。</p><p>下面推荐一些自己平时经常去的论坛或社区，自己在早晨上班的时候都会花 30 分钟左右去阅（mo）读（yu）别人分享的文章，虽然不一定能学到什么，但这种无差别的阅读会成为你知识的积淀，说不定在哪一刻你突然听到同事谈到某个专业术语，你会惊奇的发现——这不是我早上读的那篇文章提到的东西吗！？</p><h2 id="前端人员"><a href="#前端人员" class="headerlink" title="前端人员"></a>前端人员</h2><p>前端人员不能满足于当个切图仔只会网页布局和 CSS 样式，JS 用的 JQuery 别的就不懂了。其实现在前后端的区分度已经不大了，从 nodeJS 出现以后，前端的格局就改变了，不要把自己的思维局限在“前端只是做网页样式”而已，如果你还保留这种思想，建议早点舍弃。前端学点后端的思维跟后端学点 HTML、CSS 都是很普通的事情。</p><p>除了 WEB 前端，安卓前端、IOS 前端同理。</p><p>下面的推荐顺序没有排名，纯粹是想到什么就写下来。</p><h3 id="掘金社区"><a href="#掘金社区" class="headerlink" title="掘金社区"></a>掘金社区</h3><p>前端技术有一个比较火的社区，而且里面也有许多大佬，这个社区叫做“掘金”：</p><p>传送门：<a href="https://juejin.im/" target="_blank" rel="noopener">大佬之家 - 掘金社区</a></p><p>掘金社区会有大佬发布技术相关的文章，也会有人告诉你面试的技巧 <strong>（还能相亲）</strong> 。</p><p>但是里面有一个地方我建议不要点开，那就是“沸点”，要是沉迷在沸点就跟刷微博差不多了。</p><p>前不久还上线了“掘金小册”，可以将自己的知识进行变现。</p><p>掘金是一个前端大佬云集的地方。</p><h3 id="V2EX"><a href="#V2EX" class="headerlink" title="V2EX"></a>V2EX</h3><p>这也是一个神奇的社区，不过内容比较综合，各种东西都会有，偶尔还有大佬出现，也有人喜欢在这里刷帖摸鱼，鱼龙混杂的地方。</p><p>V2EX 可以让你发现许多黑科技，提升自己的姿势水平，偶尔会有人把自己异想天开的想法发到这里进行讨论，还有一些企业的黑幕（如暴力裁员等黑料）。</p><p>总之，在这里更多的是提升自己的阅历。</p><p>传送门：<a href="https://v2ex.com/" target="_blank" rel="noopener">八卦与涨姿势的地方 - V2EX</a></p><p>这个社区的名字究竟是何义至今不明。</p><h3 id="思否-amp-stackOverFlow"><a href="#思否-amp-stackOverFlow" class="headerlink" title="思否 &amp; stackOverFlow"></a>思否 &amp; stackOverFlow</h3><p>思否是国内比较大的交流讨论社区，应该是致敬国外的 stackOverFlow，从 UI 看起来两者非常相似。</p><p>可以把思否当做国内版的 stackOverFlow。</p><p>先来介绍国外的 stackOverFlow。</p><p>传送门：<a href="https://stackoverflow.com/" target="_blank" rel="noopener">解决问题的宝库 - stackOverFlow</a></p><p>根据个人阅读的帖子来看，这里主要是解决问题的帖子居多，很多时候你搜索某个报错信息，跳出来的就是这个网站的帖子，而且你经常可以从帖子里找到解决问题的方法。</p><p>所以，这个网站给我的感觉是一个可以帮助你快速查错和解决问题的平台。如果遇到开发上的难题或者不明的报错信息，可以到这个平台上搜索看看（对英文稍有要求），大多数情况下都可以找到解决问题的方法。</p><p>接着是我们国内的思否，个人非常喜欢这个社区，因为这边文章详情页的排版、字体、背景颜色十分协调，可以拥有十分良好的阅读体验。</p><p>传送门：<a href="https://segmentfault.com/" target="_blank" rel="noopener">享受阅读的乐趣 - Segmentfault</a></p><p>这个社区同样也有许多解决问题的帖子，同时还有许多分享技术的帖子，也有人把这个平台当做了自己个人博客记录的地方。</p><p>思否上面提供了“视频课程”，价格上来看还算蛮便宜的，比起报培训班流水线式的作业，倒不如拿那些钱支持一些真正有技术的作者。</p><h2 id="后端人员"><a href="#后端人员" class="headerlink" title="后端人员"></a>后端人员</h2><p>其实前面介绍的几个也有后端的文章，后端开发也可以去逛逛。</p><p>因为我的本职是 PHP 开发，所以这里推荐的是偏向 PHP 的社区。</p><h3 id="Laravel-China"><a href="#Laravel-China" class="headerlink" title="Laravel - China"></a>Laravel - China</h3><p>现在更名为 LearnKu 了，PHP 较为出名的一个社区，也是 Laravel 框架最大的交流论坛之一。</p><p>传送门：<a href="https://learnku.com/" target="_blank" rel="noopener">刻意学习，与日精进 - LearnKu</a></p><p>LearnKu 社区是 Summer 个人开发的 Laravel 技术论坛，如今已经扩展了更多的板块，不再局限于 Laravel 或是 PHP 语言，诸如 Python、Java 等语言也拥有独立的板块了。</p><p>LearnKu 里面比较有意思的一个地方是可以翻译国外的文档，然后留下你的大名，虽然本人的英文水平不咋样，但是也曾翻译过几篇文章的段落，成就感十足！</p><p>除此之外，个人感觉要学习 Laravel 框架的话，首选 LearnKu，因为这里有最全、最新的 Laravel 文档（并且阅读体验良好）。</p><p>LearnKu 的前身 Laravel - China 曾经是国内最早一批提供 Composer 国内镜像源的地方，个人感觉 Summer 在推动 Laravel 框架在国内的推广做出了十分巨大的贡献，如果没有翻译国外的文档和提供 Composer 国内镜像源，想要入门这个“优雅”的框架可不容易。</p><p>LearnKu 是集文档、技术分享、问题提问的综合社区，想要入门 Laravel 的萌新，选择 LearnKu 准没错！</p><p>LearnKu 这个名字听起来怪怪的，难道是 learn Kungfu 的缩写！？</p><h3 id="Laravel-学院"><a href="#Laravel-学院" class="headerlink" title="Laravel 学院"></a>Laravel 学院</h3><p>现在改名为学院君（感觉之前的名字更好）。</p><p>Laravel 学院也是学习 Laravel 的好去处，只不过这里比较偏向于查阅资料的地方，虽然提供了“问题”的板块，但是讨论的氛围还是偏向于冷清。</p><p>传送门：<a href="https://xueyuanjun.com/" target="_blank" rel="noopener">优质的 Laravel 中文学习资料 - 学院君</a></p><p>Laravel 学院也为 Laravel 在国内的推广做出了重要贡献，在搜索 Laravel 相关问题的时候，经常能搜到 Laravel 学院的网站，而且从中找到解决问题的方法。</p><p>所以，个人感觉 Laravel 学院偏向于查资料与搜索问题。</p><p>本站点的起源本人尚不清楚，但是从文档的分享者来看居然全部都是同一个人——学院君。</p><p>只凭借网站本身的力量竟然能够整理出如此众多的文档，令人钦佩。</p><p>Laravel 学院除了文档之外，还有项目的实践教程，而且每一步都十分详细甚至还有配图，萌新想学不会都难！</p><h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p>一个略微神奇的网站，咋看之下是文人墨客记录生活情感的地方，然而程序猿却在这开辟出一片属于自己的天地。</p><p>传送门：<a href="https://www.jianshu.com/" target="_blank" rel="noopener">众多教程 - 简书</a></p><p>简书上面记录得比较多的是一些软件的安装教程和使用方法。</p><p>目前开通了钻石系统，口号是：“能让创作变现”。</p><p>如果有技术大佬喜欢写文章的，可以到这个平台试试，分享技术还能赚点小钱，不亦乐乎！</p><p>简书有不少女性作家，说不定还有意外的邂逅（笑）。</p><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p>“你们以后找工作，如果面试官问你经常去看哪些网站，你就说 CSDN。”</p><p>这是我大学老师跟我们说的一句话。</p><p>但是现在，我去面试的时候是绝对不会提 CSDN 的。</p><p>因为它已经完全变质了，也许在我老师的那个年代这是一个大神聚集的社区，但如今在我看来，它只不过是一个盗版成灾的地方，而且百度给的权重还很高，CSDN 的搜索结果总是置于前几名。</p><p>这里把 CSDN 列举出来是为了点名批评的。</p><p>盗版文章是对原作者版权不尊重；其次，我们搜索问题是为了找到解决方法的，但是 CSDN 盗版的文章经常还存在重复，造成我们搜索结果里面有很多条都是 CSDN 的文章而且还不能解决问题，CSDN 出现在搜索结果里大大增加了我们解决问题的时间成本。</p><blockquote><p>小技巧：使用百度搜索时在关键词后面加上 -csdn 可以排除所有 CSDN 网站的结果</p></blockquote><p>CSDN 做的恶不仅仅只是盗版文章。</p><p>还有盗版资源。</p><p>相信大家都有这样的体验：在百度搜索一个资源时，跳出的是 CSDN 的下载地址，点进去发现还要积分。而这些资源大都是从其他技术分享者那里拿到的，转手就成为了谋取利益的手段。</p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer配置参数详解</title>
      <link href="/composer-config/"/>
      <url>/composer-config/</url>
      
        <content type="html"><![CDATA[<h2 id="composer-json"><a href="#composer-json" class="headerlink" title="composer.json"></a>composer.json</h2><p>Composer 使用配置文件 <code>composer.json</code> 来指明依赖关系或者包信息。</p><p>一个简单的 <code>composer.json</code> 配置文件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;require-dev&quot;: &#123;</span><br><span class="line">    &quot;robmorgan&#x2F;phinx&quot;: &quot;^0.10.8&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\Library\\&quot;: &quot;application&#x2F;library&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发配置项"><a href="#开发配置项" class="headerlink" title="开发配置项"></a>开发配置项</h2><p>如果你不打算将自己的包开源，或者这个配置文件并不是一个库，而是你的项目依赖第三方包的配置文件，那么许多字段都是不需要用到的，以下是几个比较核心的配置字段。</p><h3 id="require-项目依赖关系"><a href="#require-项目依赖关系" class="headerlink" title="require : 项目依赖关系"></a>require : 项目依赖关系</h3><p>执行 <code>composer install</code> 或者 <code>composer update</code> 将会下载依赖的包。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们声明了我们需要下载安装的包 <code>phpmailer/phpmailer</code> 和对应的版本信息 <code>^6.0</code>。</p><p><code>require</code> 也可以用来指明 PHP 的版本信息。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">   &quot;php&quot;: &quot;&gt;&#x3D;5.5.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它要求使用者的 PHP 版本至少是 5.5.0 以上的。</p><h3 id="require-dev-只在开发环境的依赖"><a href="#require-dev-只在开发环境的依赖" class="headerlink" title="require-dev : 只在开发环境的依赖"></a>require-dev : 只在开发环境的依赖</h3><p>有时候，我们可能需要一些帮助我们调试的第三方包，但是线上环境并不需要用到这些包，这个时候可以将它们放在 <code>require-dev</code> 中进行声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require-dev&quot;: &#123;</span><br><span class="line">    &quot;phpmailer&#x2F;phpmailer&quot;: &quot;^6.0&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线上环境</strong>在执行 <code>composer install</code> 或者 <code>composer update</code> 的时候，<strong>需要添加 <code>--no-dev</code> 参数</strong>来跳过 <code>require-dev</code> 依赖的包。</p><p>如果直接使用 <code>composer install</code>，则 <code>require-dev</code> 依赖的包也会被安装。</p><h3 id="autoload-自动加载"><a href="#autoload-自动加载" class="headerlink" title="autoload : 自动加载"></a>autoload : 自动加载</h3><p>通过配置 <code>autoload</code> 可以实现类的自动加载。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;App\\Library\\&quot;: &quot;application&#x2F;library&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用了 <code>psr-4</code> 的自动加载规范来加载 <code>library</code> 中的类。</p><p>除了 <code>psr-4</code> 还有几种可选的类型：</p><ul><li>psr-0</li><li>classmap</li><li>files</li></ul><h3 id="repositories-仓库地址"><a href="#repositories-仓库地址" class="headerlink" title="repositories : 仓库地址"></a>repositories : 仓库地址</h3><p>声明依赖所在仓库的地址，默认情况下使用 Packagist 官方网站：<a href="https://packagist.org。" target="_blank" rel="noopener">https://packagist.org。</a></p><p>国内镜像源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阿里</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Composer 中文网</span><br><span class="line">https:&#x2F;&#x2F;packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><p>此外，还可以搭建自己的仓库地址。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>支持以下类型（type）的包资源库：</p><ul><li>composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和/或 source 信息。这个 packages.json 文件是用一个 PHP 流加载的。你可以使用 options 参数来设定额外的流信息。</li><li>vcs: 从 git、svn 和 hg 取得资源。</li><li>pear: 从 pear 获取资源。</li><li>package: 如果你依赖于一个项目，它不提供任何对 composer 的支持，你就可以使用这种类型。你基本上就只需要内联一个 composer.json 对象。</li></ul><h2 id="开源项目配置项"><a href="#开源项目配置项" class="headerlink" title="开源项目配置项"></a>开源项目配置项</h2><p>如果你的包希望上传到 Packagist 提供给他人使用，需要提供包的基本信息，如作者、包的描述等等。</p><p>一个开源的项目，<a href="https://github.com/PHPMailer/PHPMailer/blob/master/composer.json" target="_blank" rel="noopener">PHPMailer</a> 的配置文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;phpmailer&#x2F;phpmailer&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;library&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;PHPMailer is a full-featured email creation and transfer class for PHP&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Marcus Bointon&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;phpmailer@synchromedia.co.uk&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Jim Jagielski&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;jimjag@gmail.com&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Andy Prevost&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;codeworxtech@users.sourceforge.net&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Brent R. Matzelle&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;php&quot;: &quot;&gt;&#x3D;5.5.0&quot;,</span><br><span class="line">        &quot;ext-ctype&quot;: &quot;*&quot;,</span><br><span class="line">        &quot;ext-filter&quot;: &quot;*&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;require-dev&quot;: &#123;</span><br><span class="line">        &quot;friendsofphp&#x2F;php-cs-fixer&quot;: &quot;^2.2&quot;,</span><br><span class="line">        &quot;phpdocumentor&#x2F;phpdocumentor&quot;: &quot;2.*&quot;,</span><br><span class="line">        &quot;phpunit&#x2F;phpunit&quot;: &quot;^4.8 || ^5.7&quot;,</span><br><span class="line">        &quot;zendframework&#x2F;zend-serializer&quot;: &quot;2.7.*&quot;,</span><br><span class="line">        &quot;doctrine&#x2F;annotations&quot;: &quot;1.2.*&quot;,</span><br><span class="line">        &quot;zendframework&#x2F;zend-eventmanager&quot;: &quot;3.0.*&quot;,</span><br><span class="line">        &quot;zendframework&#x2F;zend-i18n&quot;: &quot;2.7.3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;suggest&quot;: &#123;</span><br><span class="line">        &quot;psr&#x2F;log&quot;: &quot;For optional PSR-3 debug logging&quot;,</span><br><span class="line">        &quot;league&#x2F;oauth2-google&quot;: &quot;Needed for Google XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;hayageek&#x2F;oauth2-yahoo&quot;: &quot;Needed for Yahoo XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;stevenmaguire&#x2F;oauth2-microsoft&quot;: &quot;Needed for Microsoft XOAUTH2 authentication&quot;,</span><br><span class="line">        &quot;ext-mbstring&quot;: &quot;Needed to send email in multibyte encoding charset&quot;,</span><br><span class="line">        &quot;symfony&#x2F;polyfill-mbstring&quot;: &quot;To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;PHPMailer\\PHPMailer\\&quot;: &quot;src&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;autoload-dev&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;PHPMailer\\Test\\&quot;: &quot;test&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;license&quot;: &quot;LGPL-2.1-only&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="name-包名"><a href="#name-包名" class="headerlink" title="name : 包名"></a>name : 包名</h3><p>包的名称，它包括供应商名称和项目名称，使用 / 分隔，左边为供应商名称，右边为项目名称。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monolog&#x2F;monolog</span><br><span class="line">igorw&#x2F;event-source</span><br></pre></td></tr></table></figure><p>对于需要发布的包（库），这是必须填写的。</p><h3 id="description-描述"><a href="#description-描述" class="headerlink" title="description : 描述"></a>description : 描述</h3><p>一个包的简短描述，通常用来描述包的功能，最长只有一行。</p><p>对于需要发布的包（库），这是必须填写的。</p><h3 id="version-版本"><a href="#version-版本" class="headerlink" title="version : 版本"></a>version : 版本</h3><p>version 不是必须的，并且建议忽略。</p><p>它应该符合 ‘X.Y.Z’ 或者 ‘vX.Y.Z’ 的形式， -dev、-patch、-alpha、-beta 或 -RC 这些后缀是可选的。在后缀之后也可以再跟上一个数字。</p><p>示例：</p><ul><li>1.0.0</li><li>1.0.2</li><li>1.0.0-dev</li><li>1.0.0-alpha3</li><li>1.0.0-beta2</li><li>1.0.0-RC5</li></ul><h3 id="type-安装类型"><a href="#type-安装类型" class="headerlink" title="type : 安装类型"></a>type : 安装类型</h3><p>包的安装类型，默认为 library。</p><p>composer 原生支持以下4种类型：</p><ul><li>library: 这是默认类型，它会简单的将文件复制到 vendor 目录。</li><li>project: 这表示当前包是一个项目，而不是一个库。例：框架应用程序 Symfony standard edition，内容管理系统 SilverStripe installer 或者完全成熟的分布式应用程序。使用 IDE 创建一个新的工作区时，这可以为其提供项目列表的初始化。</li><li>metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。</li><li>composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。详细请查看 自定义安装类型。<br>仅在你需要一个自定义的安装逻辑时才使用它。建议忽略这个属性，采用默认的 library。</li></ul><h3 id="keywords-关键字"><a href="#keywords-关键字" class="headerlink" title="keywords : 关键字"></a>keywords : 关键字</h3><p><strong>非必选，但建议填写。</strong> 该包相关的关键词的数组，可用于搜索和过滤，相当于在 composer 中的 SEO，有助于让更多的人搜索到你的包。</p><h3 id="homepage-项目主页"><a href="#homepage-项目主页" class="headerlink" title="homepage : 项目主页"></a>homepage : 项目主页</h3><p>该项目网站的 URL 地址，可选。</p><h3 id="time-版本发布时间"><a href="#time-版本发布时间" class="headerlink" title="time : 版本发布时间"></a>time : 版本发布时间</h3><p>必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式，可选。</p><h3 id="license-许可协议"><a href="#license-许可协议" class="headerlink" title="license : 许可协议"></a>license : 许可协议</h3><p>包的许可协议，它可以是一个字符串或者字符串数组。</p><p>最常见的许可协议的推荐写法：</p><ul><li>Apache-2.0</li><li>BSD-2-Clause</li><li>BSD-3-Clause</li><li>BSD-4-Clause</li><li>GPL-2.0</li><li>GPL-2.0+</li><li>GPL-3.0</li><li>GPL-3.0+</li><li>LGPL-2.1</li><li>LGPL-2.1+</li><li>LGPL-3.0</li><li>LGPL-3.0+</li><li>MIT</li></ul><p>可选，但强烈建议提供此内容。</p><h3 id="authors-作者"><a href="#authors-作者" class="headerlink" title="authors : 作者"></a>authors : 作者</h3><p>包的作者，这是一个对象数组。</p><p>这个对象必须包含以下属性：</p><ul><li>name: 作者的姓名，通常使用真名。</li><li>email: 作者的 email 地址。</li><li>homepage: 作者主页的 URL 地址。</li><li>role: 该作者在此项目中担任的角色（例：开发人员 或 翻译）。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Nils Adermann&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;naderman@naderman.de&quot;,</span><br><span class="line">            &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;www.naderman.de&quot;,</span><br><span class="line">            &quot;role&quot;: &quot;Developer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Jordi Boggiano&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;j.boggiano@seld.be&quot;,</span><br><span class="line">            &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;seld.be&quot;,</span><br><span class="line">            &quot;role&quot;: &quot;Developer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选，但强烈建议提供此内容。</p><h3 id="support-支持信息"><a href="#support-支持信息" class="headerlink" title="support : 支持信息"></a>support : 支持信息</h3><p>获取项目支持的向相关信息对象。</p><p>这个对象必须包含以下属性：</p><ul><li>email: 项目支持 email 地址。</li><li>issues: 跟踪问题的 URL 地址。</li><li>forum: 论坛地址。</li><li>wiki: Wiki 地址。</li><li>irc: IRC 聊天频道地址，类似于 irc://server/channel。</li><li>source: 网址浏览或下载源。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;support&quot;: &#123;</span><br><span class="line">        &quot;email&quot;: &quot;support@example.org&quot;,</span><br><span class="line">        &quot;irc&quot;: &quot;irc:&#x2F;&#x2F;irc.freenode.org&#x2F;composer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选。</p><h3 id="minimum-stability-root-only"><a href="#minimum-stability-root-only" class="headerlink" title="minimum-stability (root-only)"></a>minimum-stability (root-only)</h3><p>这定义了通过稳定性过滤包的默认行为。默认为 stable（稳定）。因此如果你依赖于一个 dev（开发）包，你应该明确的进行定义。</p><p>对每个包的所有版本都会进行稳定性检查，而低于 minimum-stability 所设定的最低稳定性的版本，将在解决依赖关系时被忽略。对于个别包的特殊稳定性要求，可以在 require 或 require-dev 中设定。</p><p>可用的稳定性标识：dev、alpha、beta、RC、stable。</p><h3 id="prefer-stable-root-only"><a href="#prefer-stable-root-only" class="headerlink" title="prefer-stable (root-only)"></a>prefer-stable (root-only)</h3><p>当此选项被激活时，Composer 将优先使用更稳定的包版本。</p><p>使用 “prefer-stable”: true 来激活它。</p>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始开发自己的Composer包</title>
      <link href="/composer-package/"/>
      <url>/composer-package/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 <code>composer</code> 的时候，我们几乎都是在用其他人分享出来的包，久而久之，难免会产生开发自己包的想法，不仅可以加深对 <code>composer</code> 的理解程度，同时还可以把自己常用的功能封装起来，作为自己的“小金库”储备起来。</p><blockquote><p>使用 <code>composer</code> 开发依赖包是一项非常考验能力的事情，它涉及到一个微型系统的架构，阅读<strong>设计模式</strong>有助于帮助我们开发一个优秀的 <code>composer</code> 依赖包。</p></blockquote><h2 id="开发自己的第一个-Composer-包"><a href="#开发自己的第一个-Composer-包" class="headerlink" title="开发自己的第一个 Composer 包"></a>开发自己的第一个 Composer 包</h2><p><code>composer.json</code> 是 <code>composer</code> 的基础，文件夹目录下存在 <code>composer.json</code> 文件，那么这个文件夹就是一个<strong>资源包</strong>。</p><p>我们可以手动创建 <code>composer.json</code> 文件，不过，我们推荐使用 <code>composer init</code> 命令。</p><blockquote><p>composer init 命令帮助我们自动生成 composer.json，文件可以修改，不必担心按错了什么会产生不好的影响。</p></blockquote><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p><code>composer.json</code> 配置项的字段较多，后续步骤如果对配置文件的字段抱有疑问，可以返回此处查看：<a href="/composer-config">composer.json 详解</a>。</p><p>现在，不需要了解这些。</p><h3 id="创建包目录"><a href="#创建包目录" class="headerlink" title="创建包目录"></a>创建包目录</h3><p>我们的操作是在命令行界面操作的，如果是 Windows 系统，则需要进入 CMD 界面，进入到你的工作磁盘目录下，使用快捷键 <code>Shift + 鼠标右键</code>，在菜单栏中选择进入命令行（DOS 界面）。</p><p>首先，我们需要创建一个包的目录 <code>packagist</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Mac OS 系统</span><br><span class="line">mkdir packagist</span><br><span class="line"></span><br><span class="line"># Windows 系统(可以直接右键创建）</span><br><span class="line">md packagist</span><br><span class="line"></span><br><span class="line"># 创建完成后进入文件夹</span><br><span class="line">cd packagist</span><br></pre></td></tr></table></figure><h3 id="输入包的名字"><a href="#输入包的名字" class="headerlink" title="输入包的名字"></a>输入包的名字</h3><p>在 <code>packagist</code> 目录下，执行 <code>composer init</code>，<code>composer</code> 会提示我们设置配置参数信息，如下图：</p><p><img src="https://i.loli.net/2019/08/24/NSPn6GYuE83jcs1.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package name (&lt;vendor&gt;&#x2F;&lt;name&gt;) [firerabbit&#x2F;packagist]:</span><br></pre></td></tr></table></figure><p>提示让你输入包的名字，格式为 <code>&lt;vendor&gt;/&lt;name&gt;</code>，<code>vendor</code> 为服务商名字，个人开发可以使用自己在 GitHub 中使用的昵称，<code>name</code> 为包的名字，<code>&lt;vendor&gt;/&lt;name&gt;</code> 不能存在同名，这里设置的名字即后面使用 <code>composer require</code> 的名字。</p><p>中括号内的 <code>[firerabbit/packagist]</code> 是默认值，直接按回车的话就会使用这个名字。</p><h3 id="输入包的描述信息"><a href="#输入包的描述信息" class="headerlink" title="输入包的描述信息"></a>输入包的描述信息</h3><p>包名输入完成后，接下来需要设置 <code>Description</code> （描述）字段，这个字段是包的功能性描述，作为练习包就随便输入啦：</p><p><img src="https://i.loli.net/2019/08/24/y6EWBMhGbZ1V3Qt.png" alt="image.png"></p><h3 id="输入作者信息"><a href="#输入作者信息" class="headerlink" title="输入作者信息"></a>输入作者信息</h3><p>接下来设置 <code>Author</code> (作者信息)，格式为 <code>name example@email.com</code>，输入 n 可以跳过：</p><p><img src="https://i.loli.net/2019/08/24/V7UsaPQpm5LyKqu.png" alt="image.png"></p><h3 id="minimum-stability-最小稳定版本"><a href="#minimum-stability-最小稳定版本" class="headerlink" title="minimum-stability 最小稳定版本"></a>minimum-stability 最小稳定版本</h3><p>通过设置 <code>minimum-stability</code> 的值，来告诉 <code>Composer</code> 当前开发的项目的依赖要求的包的全局稳定性级别，它的值包括：dev、alpha、beta、RC、stable，stable 是默认值。</p><p><img src="https://i.loli.net/2019/08/24/IFecMfkGXYgWU9T.png" alt="image.png"></p><p>稳定性介绍：<a href="https://learnku.com/php/t/9929/understanding-composers-stability-stability-identity" target="_blank" rel="noopener">理解 Composer 的稳定性（Stability）标识</a></p><p>我们直接按回车默认值即可。</p><h3 id="Package-Type-包类型"><a href="#Package-Type-包类型" class="headerlink" title="Package Type 包类型"></a>Package Type 包类型</h3><p>接下来设置包的类型：</p><p><img src="https://i.loli.net/2019/08/24/4PMEiWuaXIb2Zyd.png" alt="image.png"></p><p>composer 原生支持以下4种类型：</p><ul><li>library: 默认类型，它会简单的将文件复制到 vendor 目录。</li><li>project: 一个项目，而不是一个库。</li><li>metapackage: 空的包，包含依赖并且需要触发依赖的安装。</li><li>composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。</li></ul><p>这里我们直接按回车，采用默认的 library。</p><h3 id="License-许可协议"><a href="#License-许可协议" class="headerlink" title="License 许可协议"></a>License 许可协议</h3><p>接下来输入包的许可协议：</p><p><img src="https://i.loli.net/2019/08/24/UW2StviLwyIO9ef.png" alt="image.png"></p><p>包的许可协议，它可以是一个字符串或者字符串数组。</p><p>最常见的许可协议的推荐写法：</p><ul><li>Apache-2.0</li><li>BSD-2-Clause</li><li>BSD-3-Clause</li><li>BSD-4-Clause</li><li>GPL-2.0</li><li>GPL-2.0+</li><li>GPL-3.0</li><li>GPL-3.0+</li><li>LGPL-2.1</li><li>LGPL-2.1+</li><li>LGPL-3.0</li><li>LGPL-3.0+</li><li>MIT</li></ul><p>这里我们输入 MIT （开源许可协议）。</p><h3 id="定义依赖项"><a href="#定义依赖项" class="headerlink" title="定义依赖项"></a>定义依赖项</h3><p>接下来设置依赖项：</p><p><img src="https://i.loli.net/2019/08/24/6iHFcMvR8UK7o2O.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Define your dependencies.</span><br><span class="line"></span><br><span class="line">Would you like to define your dependencies (require) interactively [yes]?</span><br></pre></td></tr></table></figure><p>我们的练习项目不需要设置此项，输入 no。</p><h3 id="dev-依赖项"><a href="#dev-依赖项" class="headerlink" title="dev 依赖项"></a>dev 依赖项</h3><p>设置 dev 环境依赖项：</p><p><img src="https://i.loli.net/2019/08/24/LEelWoaq4dwNts2.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like to define your dev dependencies (require-dev) interactively [yes]?</span><br></pre></td></tr></table></figure><p>同上，输入 no。</p><h3 id="最后一步：确认信息"><a href="#最后一步：确认信息" class="headerlink" title="最后一步：确认信息"></a>最后一步：确认信息</h3><p>最后一步，确认包的信息：</p><p><img src="https://i.loli.net/2019/08/24/fDkiBObK9QXo1aJ.png" alt="image.png"></p><p>输入 yes，回车，然后查看当前目录即可看到 <code>composer.json</code> 文件。</p><p><code>composer init</code> 命令帮助你自动生成文件，实际上你可以直接在<strong>包的目录下</strong>创建 <code>composer.json</code>，并且输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;huotu&#x2F;test&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个包。&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;火兔兔子&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上两种方式都是一样的。</p><h2 id="依赖包的基本结构"><a href="#依赖包的基本结构" class="headerlink" title="依赖包的基本结构"></a>依赖包的基本结构</h2><p>一个 <code>composer</code> 依赖包的基本结构，以我们上面的 <code>packagist</code> 为例：</p><ul><li>packagist<ul><li>src<ul><li>类文件</li><li>…</li></ul></li><li>tests<ul><li>单元测试文件</li><li>… </li></ul></li><li>README.md</li><li>composer.json</li><li>LICENSE</li></ul></li></ul><h3 id="src-文件夹"><a href="#src-文件夹" class="headerlink" title="src 文件夹"></a>src 文件夹</h3><p><code>src</code> 是包所在的路径，一般我们都会将其命名为 <code>src</code>（业界共识），不建议改成其他的名字。</p><p>开发包的工作就是在这个目录下进行的，你可以在这个目录下创建更多的文件夹来划分不同功能的类。</p><h3 id="tests-文件夹"><a href="#tests-文件夹" class="headerlink" title="tests 文件夹"></a>tests 文件夹</h3><p><code>tests</code> 文件夹用来存放单元测试的，如果你不写的话，这个文件夹可以不要。</p><h3 id="README-md-文件"><a href="#README-md-文件" class="headerlink" title="README.md 文件"></a>README.md 文件</h3><p><code>README.md</code> 是包描述的 Markdown 语法的介绍文档，在 GitHub 中将会自动解析这个文件并且展示出来，每一个包都<strong>应该</strong>要包含 <code>README.md</code> 文件，用来介绍这个包的基本信息和操作方法。</p><p>创建 <code>README.md</code> 文件的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Mac OS</span><br><span class="line">vim README.md</span><br><span class="line"></span><br><span class="line"># Windows 系统</span><br><span class="line">创建 README.txt，保存后改成 .md</span><br><span class="line">如需编辑，右键以文本文档打开即可</span><br></pre></td></tr></table></figure><h3 id="composer-json-文件"><a href="#composer-json-文件" class="headerlink" title="composer.json 文件"></a>composer.json 文件</h3><p>包的配置信息。</p><h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p>许可协议文本，文本格式。</p><p>练习项目中，我们只需要 <code>src</code> 和 <code>README.md</code> 即可。</p><p>推荐使用 <code>PHPstorm</code> 作为编辑工具，最后我们的包目录结构如图所示：</p><p><img src="https://i.loli.net/2019/08/24/he9UfyOz2W6Z5Qi.png" alt="image.png"></p><h2 id="配置自动加载规则"><a href="#配置自动加载规则" class="headerlink" title="配置自动加载规则"></a>配置自动加载规则</h2><p>为了防止命名空间冲突，开发的包需要配置自动加载，修改 <code>composer.json</code> 添加 <code>autoload</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;Huotu\\Test\\&quot;: &quot;src&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们采用 <code>psr-4</code> 的规范来自动加载包目录下 <code>src</code> 文件夹内的类文件，这里的 <code>&quot;Huotu\\Test\\&quot;</code> 是我们使用的命名空间，<code>\\</code> 不能写成 <code>\</code>，一般而言，命名空间以包的名字来命名。</p><p>完整的 <code>composer.json</code> 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;huotu&#x2F;test&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个包。&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;火兔兔子&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;huoshaotuzi@icloud.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;require&quot;: &#123;&#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;Huotu\\Test\\&quot;: &quot;src&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建包的类文件"><a href="#创建包的类文件" class="headerlink" title="创建包的类文件"></a>创建包的类文件</h3><p>在 <code>src</code> 目录下创建 <code>Robot.php</code> 文件，我们希望写一个可以自动打招呼的机器人（类）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Huotu\Test;</span><br><span class="line"></span><br><span class="line">class Robot</span><br><span class="line">&#123;</span><br><span class="line">    public function sayHello($name) &#123;</span><br><span class="line">        echo &#39;hello,&#39; . $name . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了一个依赖包的开发，使用者只需要引入这个包就可以调用 <code>Robot</code> 的 <code>sayHello</code> 方法。</p><h2 id="测试包的功能"><a href="#测试包的功能" class="headerlink" title="测试包的功能"></a>测试包的功能</h2><p>我们现在已经写好了一个包，但是开发过程以及准备发布的时候，我们都需要对功能进行调试，你可以在目录下创建一个 <code>test.php</code>，然后运行 <code>php test.php</code> 来测试，不过这样总是不太方便的，尤其是某些有其他依赖的操作（如需要连接数据库、Redis）等等。最好的方法是将包文件放在一个真实的项目里进行测试，下面模拟创造一个 <code>project</code> 来作为我们实际的项目。</p><p>在 <code>packagist</code> 同级目录下，创建一个文件夹 <code>project</code>。</p><p>由于我们本地开发的包并未上传的 Packagist，无法通过 <code>composer require</code> 进行安装，因此我们必须手动配置加载目录，进入 project 文件夹，创建 <code>composer.json</code>：</p><ul><li>project<ul><li>composer.json</li></ul></li></ul><p>编辑 <code>composer.json</code>，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;autoload&quot;: &#123;</span><br><span class="line">    &quot;psr-4&quot;: &#123;</span><br><span class="line">      &quot;Huotu\\Test\\&quot;: &quot;..&#x2F;packagist&#x2F;src&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后，我们需要执行 <code>composer dump-autoload</code> 来生成自动加载文件。</p><blockquote><p>如果对依赖包添加了新的类或者删除了类，涉及到类文件数量、名称改变的，都需要重新执行 composer dump-autoload，否则无法读取到最新的类文件</p></blockquote><p>执行完成后，在当前目录下生成了 <code>vendor</code> 文件夹，这个文件夹里即包含了我们依赖包的自动加载信息。</p><p><img src="https://i.loli.net/2019/08/24/nCVmNxviFpfJUw5.png" alt="image.png"></p><p>接着一个文件用来测试结果 <code>test.php</code>：</p><ul><li>project<ul><li>composer.json</li><li>test.php</li><li>vendor<ul><li>composer<ul><li>…</li></ul></li><li>autoload.php </li></ul></li></ul></li></ul><p>输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">require &#39;.&#x2F;vendor&#x2F;autoload.php&#39;;</span><br><span class="line"></span><br><span class="line">use Huotu\Test\Robot;</span><br><span class="line"></span><br><span class="line">$robot &#x3D; new Robot();</span><br><span class="line">$robot-&gt;sayHello(&#39;IDCE.COM&#39;);</span><br></pre></td></tr></table></figure><p>终端中输入 <code>php test.php</code> 执行结果：</p><p><img src="https://i.loli.net/2019/08/24/BYavLTK2W9JDncZ.png" alt="image.png"></p><p>可以看到我们成功调用自己开发的包了！</p><p>必须将 <code>autoload</code> 引入才能实现自动加载，如果提示找不到类可能就是没有正确引入的关系或者 <code>composer.json</code> 配置的 <code>psr-4</code> 路径不正确。</p><h2 id="上传到-GitHub"><a href="#上传到-GitHub" class="headerlink" title="上传到 GitHub"></a>上传到 GitHub</h2><p>开发完成后，我们需要把包文件上传到 <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>，如果没有账号则注册一个。</p><p>进入个人主页，在左侧的 Repositories（仓库）选择 New 创建一个新的仓库：</p><p><img src="https://i.loli.net/2019/08/24/ISdkXipUAeLfv2c.png" alt="image.png"></p><p>仓库信息，权限要选择 <code>public</code>（公开的），完成后点击 <code>Create repository</code>：</p><p><img src="https://i.loli.net/2019/08/24/FuyLgqBpdAH3W8R.png" alt="image.png"></p><p>创建好的项目：</p><p><img src="https://i.loli.net/2019/08/24/WZdpEtnvL3qCeVX.png" alt="image.png"></p><p>GitHub 十分友好的提示了上传文件的步骤，我们只需要执行以下几个步骤即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;huoshaotuzi&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>返回 <code>packagist</code> 目录下，我们按照 GitHub 上提示的内容，执行 <code>git init</code>，并添加文件：</p><p><img src="https://i.loli.net/2019/08/24/B1vg4hK95lz2VkC.png" alt="image.png"></p><blockquote><p>注！由于 ide 产生的文件是必须添加 .gitigonre 排除的</p></blockquote><p>然后添加上传的仓库信息，并执行 <code>push</code> 推送到 GitHub 的仓库：</p><p><img src="https://i.loli.net/2019/08/24/FK5Gz1rpVluQLgn.png" alt="image.png"></p><p>返回 GitHub 仓库，刷新页面即可看到上传文件的信息：</p><p><img src="https://i.loli.net/2019/08/24/IbWEe8VnKwmZhCP.png" alt="image.png"></p><h2 id="上传到-Packagist"><a href="#上传到-Packagist" class="headerlink" title="上传到 Packagist"></a>上传到 Packagist</h2><p>如果希望自己的包被其他人安装，就需要将包上传到 Packagist 官网上。</p><p>Packagist 官网：<a href="https://packagist.org/" target="_blank" rel="noopener">https://packagist.org/</a></p><p><img src="https://i.loli.net/2019/08/24/sX6AxhSyfEC9pVg.png" alt="image.png"></p><p>如果没有账号可以注册一个，或者直接使用 GitHub 登录（推荐）。</p><p>登录后，选择右上角的 <code>Submit</code>（提交）：</p><p><img src="https://i.loli.net/2019/08/24/8zhUPTDwsbOt5fa.png" alt="image.png"></p><p>在提交页面会提示你输入 GitHub 上仓库的地址：</p><p><img src="https://i.loli.net/2019/08/24/GQSMnub7JdOxWjH.png" alt="image.png"></p><p>输入刚才创建的仓库地址，点击 <code>Check</code>：</p><p><img src="https://i.loli.net/2019/08/24/qeuQ6oEsWdLl2cF.png" alt="image.png"></p><p>这边会提示一些同名的包，并且出现了 <code>Submit</code> 按钮，我们直接点击 <code>Submit</code>，此时会进入包页面，<code>update</code> 会进入转圈圈状态，表示正在同步包信息，稍等一会刷新页面即可看到包信息。</p><p>到目前为止，已经将包上传到 Packagist 官网了，但是我们还没有设置版本信息，需要返回到包目录下，给这个包打上标签。</p><p>输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m &quot;初始版本&quot;</span><br><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure><p>然后返回 Packagist 官网，点击 <code>update</code> 同步包信息，然后刷新页面就能看到刚刚提交的版本信息了。</p><p>现在，用户可以使用 <code>composer require</code> 命令下载你的包了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require huotu&#x2F;test:1.0</span><br></pre></td></tr></table></figure><h2 id="自动同步版本更新"><a href="#自动同步版本更新" class="headerlink" title="自动同步版本更新"></a>自动同步版本更新</h2><p>每次更新包都需要手动点击 <code>update</code> 十分不便，实际上 GitHub 提供了钩子可以用来推送更新信息到 Packagist，默认情况下已经帮助我们打开了自动更新功能。</p><p>回到 GitHub 的仓库地址，选择 <code>Setting</code>，左侧菜单 <code>Webhook</code>，可以看到配置的推送信息：</p><p><img src="https://user-images.githubusercontent.com/28209810/63644830-3432b800-c724-11e9-98c1-8ee55b76825c.png" alt="webhook"></p><p>每当我们推送新的版本标签到 GitHub 时，Packagist 就会接收到一个 GitHub 的 Hook（钩子）发出的 POST 请求，这样 Packagist 上的包就会与 GitHub 上的同步了。</p><p>如果你不需要自动更新功能，可以点击右侧的 <code>Delete</code> 将其删除，删除后每次更新包都要前往 Packagist 点击 <code>Update</code> 手动进行更新。</p><p>开启自动更新情况下，每次 <code>push</code> 标签后都会自动同步到 Packagist，刷新页面即可看到最新提交的版本：</p><p><img src="https://user-images.githubusercontent.com/28209810/63644872-eff3e780-c724-11e9-9507-f722204a1422.png" alt="new version"></p><h2 id="依赖包编写小建议"><a href="#依赖包编写小建议" class="headerlink" title="依赖包编写小建议"></a>依赖包编写小建议</h2><p>开发依赖包需要要丰富的开发经验，可以多参考其他开源包，尤其是具有团队进行维护的，观察他们是如何区分目录和封装类的，可以学到很多知识。</p><p>推荐阅读：<a href="https://learnku.com/docs/php-design-patterns/2018" target="_blank" rel="noopener">PHP 设计模式</a></p><p>编写依赖包能得到锻炼和成长的机会，开源自己的包也是一件十分具有成就感的事。</p><blockquote><p>分享，是最好的学习方式 —— IDCE.COM</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密登录原理及方法</title>
      <link href="/ssh-no-password-method/"/>
      <url>/ssh-no-password-method/</url>
      
        <content type="html"><![CDATA[<h2 id="SSH-命令"><a href="#SSH-命令" class="headerlink" title="SSH 命令"></a>SSH 命令</h2><p>使用 <code>ssh 用户名@服务器IP</code> 可以连接到服务器，这样做的缺点是每次都要输入密码，一方面是不安全，另一方面是麻烦。</p><h2 id="SSH-免密登录服务器"><a href="#SSH-免密登录服务器" class="headerlink" title="SSH 免密登录服务器"></a>SSH 免密登录服务器</h2><p>在本地主机上使用 <code>ssh-keygen -t rsa</code> 生成密匙对，这里的 <code>-t rsa</code> 指的是用 <code>rsa</code> 加密方式生成密匙：</p><p><img src="https://i.loli.net/2019/08/31/wpMU4vaBQfOoej8.png" alt="image.png"></p><p>第一步，输入密匙存放目录，使用默认路径直接按回车即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure><p>第二步，输入密码，建议直接回车使用空密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p>如果输入了密码则需要再输入一次确认密码。这里的密码不是指远程登录主机的密码，而是使用密匙时的密码，既然我们是希望免密登录了，自然不希望再输入任何密码，因此此处填空即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---[RSA 2048]----+</span><br><span class="line">|    ..    .      |</span><br><span class="line">|    o. . . o     |</span><br><span class="line">|   o...+* +      |</span><br><span class="line">|    .o+*+O       |</span><br><span class="line">|    . &#x3D;+So+o     |</span><br><span class="line">| . . . @.*B.     |</span><br><span class="line">|  o . . Eoo.     |</span><br><span class="line">|   o   * ..      |</span><br><span class="line">|    ..o o.       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>上面会生成 <code>randomart image</code> 图案，这个图案是根据密匙生成的，因此每个人看到的都不同。</p><blockquote><p>趣味小科普：为什么要生成这种图案呢？这是由于密匙对是一个很长的随机字符串，比起加密的字符串人们更容易接受图片，可以说是很贴心了</p></blockquote><p>生成的密匙包含一对，<strong>公钥和私匙</strong>（<strong>其实叫做私钥</strong>，但感觉这样比较有意思所以就这么写）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub.</span><br></pre></td></tr></table></figure><p>我们根据路径可以找到文件所在位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_8_centos ~]# cd &#x2F;root&#x2F;.ssh</span><br><span class="line">[root@VM_0_8_centos .ssh]# ls</span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p>这两个密匙文件分别是：</p><ul><li>id_rsa 生成的私钥文件</li><li>id_rsa.pub 生成的公钥文件</li></ul><p>另外一个 <code>authorized_keys</code> 是保存远程免密登录公钥的文件，主要通过这个文件记录多台机器的公钥，我们要做的就是把本机的公钥发送到服务器主机的这个文件里。</p><p>接着，把公钥发到需要登录的服务器主机上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub 服务器IP地址:&#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>接着会要求你输入一次密码，输入完成后就可以实现免密登录了。</p><p>在本机上执行 <code>ssh 用户名@服务器IP</code>，不再需要输入密码验证。</p><h2 id="SSH-添加别名"><a href="#SSH-添加别名" class="headerlink" title="SSH 添加别名"></a>SSH 添加别名</h2><p>网络上的教程一般到上一步就结束了，在这里传授一个小技巧可以事半功倍。</p><p>虽然我们现在跳过了输入密码这个步骤，但是每次都要输入 IP 也是很蛋疼的一件事，<strong>我们甚至想要不输入 IP 就能登录到远程服务器</strong> ？</p><p>这也能做到！</p><p>在本地进入 <code>.ssh</code> 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 进入 .ssh 目录</span><br><span class="line">FireRabbitdeMacBook-Pro:.ssh firerabbit$ cd ~&#x2F;.ssh</span><br></pre></td></tr></table></figure><p>使用 <code>vim config</code> 编辑文件并且输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host dev</span><br><span class="line">HostName 127.0.0.1</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure><p>这里的 <code>dev</code> 是我们给远程主机起的别名，<code>127.0.0.1</code> 是远程主机的地址，请替换成你的服务器 IP，<code>User</code> 即登录的用户名，<code>Port</code> 为服务器访问端口，如果修改了端口在这里也要修改。</p><p>现在我们的目录应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FireRabbitdeMacBook-Pro:.ssh firerabbit$ ls</span><br><span class="line">configid_rsaid_rsa.pubknown_hosts</span><br></pre></td></tr></table></figure><p><code>known_hosts</code> 是连接过的主机记录，可以随意删除。</p><p>接着在命令行输入：<code>ssh dev</code> 即可连接到服务器！</p><blockquote><p>阅读至此，恭喜你！Linux Exp + 1</p></blockquote><h2 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h2><p>如果出现如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: ERROR: ssh: Could not resolve hostname xxx:&#x2F;root&#x2F;.ssh&#x2F;authorized_keys: nodename nor servname provided, or not known</span><br></pre></td></tr></table></figure><p>网上查了下，大都是说 hosts 文件的问题。</p><p>可以尝试修改 <code>/etc/hosts</code> 看看是否有如下行，如果没有则添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br></pre></td></tr></table></figure><p>经过本人尝试结果无效，可用别的方法。</p><p>那就是——手动上传！！！</p><p>编辑本地主机的密匙文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>把密匙内容全部拷贝下来。</p><p>接着先用 <code>ssh root@远程主机IP</code> 用密码登录进去，然后在远程主机中 <code>vim /root/.ssh/authorized_keys</code>。</p><p>把复制的密钥直接粘贴下来就可以啦！</p><h2 id="免密登录原理"><a href="#免密登录原理" class="headerlink" title="免密登录原理"></a>免密登录原理</h2><p>网上的教程一般都是直接贴出代码和操作步骤，但这样我们根本不清楚它的原理是什么。</p><p>我们希望能像侦探一样追根究底，查清楚它的原理是什么。</p><blockquote><p>真正理解后的知识才能永远刻入你的脑海里</p></blockquote><p>上面的步骤，我们在本机生成一个密匙对，一共包含两个文件，一个是公钥，一个是私匙，公钥是发送到服务器主机的，私匙是留在本地的。</p><p>这样包含一对公钥私匙的加密叫做“<strong>非对称加密</strong>”。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在了解非对称加密之前需要先了解对称加密，所有新事物的出现必然伴随着某种需求。</p><p>小红和小明私底下正在交往，但又不希望被别人发现，于是他们约定了一种加密算法，每个字母向后移动一位，如 a 往后移一位是 b，b 往后移一位是 c……z往后移是 a。</p><p>那么，<code>ni hao</code> 就变成了 <code>oj ibp</code>。</p><p>由于双方约定好了同样的加密算法，所以小红发给小明消息时，就可以按照约定好的算法进行解密。</p><p>于是他们大胆的在班级群里用加密后的消息进行聊天，其他同学一脸茫然的看着不明觉厉的消息。</p><p>但是此时，<strong>名侦探小刚</strong>破解了他们约定好的加密算法，并且截获了（截获很简单，毕竟他们公然秀恩爱）他们互通的消息，此时小红和小明的聊天记录就被小刚一清二楚的知道了！</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>聊天记录被小刚公开后，小明和小红十分尴尬，于是机智的小明想出了一种方法，把前面约定的加密算法做了一些小的改进，小明告诉小红，我发给你一个密匙串，你用这个给消息进行加密（某种加密算法），你发给我消息后，<strong>我再用我这边的密匙进行解密，我发给你的密匙和我本地的密匙是不同的，只有我本地的密匙才能解密你加密过的内容。</strong></p><blockquote><p>问题又来了……现在只有小明破解小红的消息，小明用公钥加密消息发给小红，小红是解密不了的；如果需要双向沟通的话，自然是用同样的方法，小红也给小明一个密匙，小红本地存有另外一个用来解密的密匙。但是 Linux 免密登录是本机免密登录到服务器，属于单向的沟通，如果你希望服务器也能免密登录本机（一般不会有这种需求），就在服务器用同样的方法生成密匙，把密匙发生到本机就可以了。</p></blockquote><p>接下来的日子，小刚也无法破解他们的聊天记录，恼羞成怒的小刚带着三名小弟放学后去堵小红，逼迫小红把小明给她的加密密匙交出来，小红无奈之下将密匙交出，然而，即使拿到密匙，小刚依然无法破解小红的密码，因为，<strong>还需要小明手里的密匙才能解密小红的消息</strong>。</p><p>非对称加密的存在就是为了避免加密算法被第三者知道，导致密码泄露。上面的故事中小明交给小红的加密串叫做<strong>公钥</strong>，公钥可以让任何第三者知道，公钥加密过的密码只有小明手里的加密串——<strong>私匙</strong>才能解密，对于加密和解密使用不同的加密策略，叫做<strong>非对称加密</strong>。</p><h3 id="使用公钥实现免密登录"><a href="#使用公钥实现免密登录" class="headerlink" title="使用公钥实现免密登录"></a>使用公钥实现免密登录</h3><p>我们通过 <code>ssh-keygen -t rsa</code> 生成了公钥和私匙对，接着我们把公钥发送到服务器上，当连接的时候，服务端会发送一个用公钥加密的字符串过来，本地再使用私匙进行解密，实现了登录验证，从而不需要输入密码就能进行登录。</p><p>用盗来的一张图解释：</p><p><img src="https://i.loli.net/2019/08/31/pk2cFyIrHoVAJYE.png" alt="image.png"></p><h2 id="RSA-非对称加密算法"><a href="#RSA-非对称加密算法" class="headerlink" title="RSA 非对称加密算法"></a>RSA 非对称加密算法</h2><p>参考：<a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fromtitle=RSA&fromid=210678&fr=aladdin" target="_blank" rel="noopener">百度百科 - RSA</a></p><p>只做兴趣了解，不需要掌握原理，因为我们的研究方向不是这个。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Gitlab</title>
      <link href="/centos-install-gitlab/"/>
      <url>/centos-install-gitlab/</url>
      
        <content type="html"><![CDATA[<h2 id="1、安准基础依赖"><a href="#1、安准基础依赖" class="headerlink" title="1、安准基础依赖"></a>1、安准基础依赖</h2><p>安装 Gitlab 所需依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br></pre></td></tr></table></figure><p>启动 ssh 服务并设置开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo systemctl enable sshd</span><br></pre></td></tr></table></figure><h2 id="2、安装邮件服务"><a href="#2、安装邮件服务" class="headerlink" title="2、安装邮件服务"></a>2、安装邮件服务</h2><p>Postfix 是一个邮件服务器，GitLab 发送邮件需要用到。</p><p>安装 postfix：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y postfix</span><br></pre></td></tr></table></figure><p>启动 postfix 并设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start postfix</span><br><span class="line">sudo systemctl enable postfix</span><br></pre></td></tr></table></figure><h2 id="3、开放-ssh-以及-http-服务（80-端口）"><a href="#3、开放-ssh-以及-http-服务（80-端口）" class="headerlink" title="3、开放 ssh 以及 http 服务（80 端口）"></a>3、开放 ssh 以及 http 服务（80 端口）</h2><p>查看防火墙是否启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>以下为我的服务器上的防火墙状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-86c0 ~]# systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:firewalld(1)</span><br></pre></td></tr></table></figure><p>如果看到 Active: inactive (dead)，表示防火墙没有启动，执行下面的命令启动防火墙并且设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p>此时，在查看防火墙状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-86c0 ~]# systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 一 2019-09-02 17:56:23 CST; 2s ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 26477 (firewalld)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;firewalld.service</span><br><span class="line">           └─26477 &#x2F;usr&#x2F;bin&#x2F;python -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld --nofork --nopid</span><br></pre></td></tr></table></figure><p><code>Active: active (running)</code> 表示防火墙正常运行。</p><p>开放 ssh、http 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-service&#x3D;ssh --permanent</span><br><span class="line">sudo firewall-cmd --add-service&#x3D;http --permanent</span><br></pre></td></tr></table></figure><blockquote><p>只有防火墙开启状态才能执行上述命令，否则会报 FirewallD is not running 错误</p></blockquote><p>重新加载防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="4、安装-Gitlab"><a href="#4、安装-Gitlab" class="headerlink" title="4、安装 Gitlab"></a>4、安装 Gitlab</h2><p>我们使用 Gitlab 的社区版：gitlab-ce，如果需要使用商业版，则安装：gitlab-ee。</p><h3 id="4-1、添加-Gitlab-社区版资源包"><a href="#4-1、添加-Gitlab-社区版资源包" class="headerlink" title="4.1、添加 Gitlab 社区版资源包"></a>4.1、添加 Gitlab 社区版资源包</h3><p>默认情况下 yum 源没有 gitlab-ce 软件包，需要手动下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlab-ce&#x2F;script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><h3 id="4-2、使用-yum-安装-gitlab-ce"><a href="#4-2、使用-yum-安装-gitlab-ce" class="headerlink" title="4.2、使用 yum 安装 gitlab-ce"></a>4.2、使用 yum 安装 gitlab-ce</h3><p>在这里强烈推荐阅读：<a href="https://idce.com/document/VO4j" target="_blank" rel="noopener">Centos 系统更新 yum 源为国内镜像源</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gitlab-ce</span><br></pre></td></tr></table></figure><p>软件包的安装大小足足有 1.4 G，更换镜像后只需要数十秒就下载完了。</p><p><img src="https://i.loli.net/2019/09/02/eAobTa7M8LyECUn.png" alt="image.png"></p><p>安装成功后可以看到一个类似“狐狸头像”的图案：</p><p><img src="https://i.loli.net/2019/09/02/PcAFUhG7LDm4TfJ.png" alt="image.png"></p><h3 id="4-3、配置-Gitlab-访问地址"><a href="#4-3、配置-Gitlab-访问地址" class="headerlink" title="4.3、配置 Gitlab 访问地址"></a>4.3、配置 Gitlab 访问地址</h3><p>Gitlab 安装完成后，配置文件所在路径为 <code>/etc/gitlab/gitlab.rb</code>，编辑配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</span><br></pre></td></tr></table></figure><p>将 <code>external_url</code> 字段修改为你的域名信息，如果没有域名可以改成 <code>IP:端口</code> 的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## GitLab configuration settings</span><br><span class="line">##! This file is generated during initial installation and **is not** modified</span><br><span class="line">##! during upgrades.</span><br><span class="line">##! Check out the latest version of this file to know about the different</span><br><span class="line">##! settings that can be configured by this file, which may be found at:</span><br><span class="line">##! https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;omnibus-gitlab&#x2F;raw&#x2F;master&#x2F;files&#x2F;gitlab-config-template&#x2F;gitlab.rb.template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## GitLab URL</span><br><span class="line">##! URL on which GitLab will be reachable.</span><br><span class="line">##! For more details on configuring external_url see:</span><br><span class="line">##! https:&#x2F;&#x2F;docs.gitlab.com&#x2F;omnibus&#x2F;settings&#x2F;configuration.html#configuring-the-external-url-for-gitlab</span><br><span class="line">external_url &#39;http:&#x2F;&#x2F;gitlab.example.com&#39;</span><br></pre></td></tr></table></figure><h3 id="4-4、启动-Gitlab"><a href="#4-4、启动-Gitlab" class="headerlink" title="4.4、启动 Gitlab"></a>4.4、启动 Gitlab</h3><p>重新载入配置并启动 Gitlab（如果修改了配置文件需要再运行此命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>翻车现场：</p><p><img src="https://i.loli.net/2019/09/02/6kpd51B8TZqHyGD.png" alt="image.png"></p><p>报错原文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Running handlers:</span><br><span class="line">There was an error running gitlab-ctl reconfigure:</span><br><span class="line"></span><br><span class="line">Multiple failures occurred:</span><br><span class="line">* Chef::Exceptions::MultipleFailures occurred in chef run: Multiple failures occurred:</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: ruby_block[restart_log_service] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 69) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: ruby_block[reload_log_service] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 77) had an error: Errno::ENOMEM: ruby_block[wait for logrotate service socket] (&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;cookbooks&#x2F;cache&#x2F;cookbooks&#x2F;runit&#x2F;libraries&#x2F;provider_runit_service.rb line 266) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line"></span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 408) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: service[gitaly] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: runit_service[gitaly] (gitaly::enable line 75) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br><span class="line">* Errno::ENOMEM occurred in delayed notification: service[gitlab-workhorse] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br></pre></td></tr></table></figure><p>%&gt;_&lt;%</p><p>原来是我的测试机内存（1G）不够！</p><blockquote><p>穷人没有资格安装 Gitlab （╯‵□′）╯︵┴─┴ </p></blockquote><h3 id="4-5、访问-Gitlab"><a href="#4-5、访问-Gitlab" class="headerlink" title="4.5、访问 Gitlab"></a>4.5、访问 Gitlab</h3><p>如果不出意外，输入 <code>external_url</code> 配置的地址，即可看到 Gitlab 页面。</p><p>第一次登陆 Gitlab 时需要设置 root 密码，然后就可以愉快的创建项目了。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再战！Docker 安装 Gitlab</title>
      <link href="/docker-install-gitlab/"/>
      <url>/docker-install-gitlab/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次因为服务器配置太低翻车了，现在重新挑战一次。</p><h2 id="Gitlab-硬件要求"><a href="#Gitlab-硬件要求" class="headerlink" title="Gitlab 硬件要求"></a>Gitlab 硬件要求</h2><p>Gitlab 十分吃机器的配置，Gitlab 官方推荐 2核 4G，最低建议 1 核 2G，再低的话可能会像我上次那样直接翻车或者运行起来十分卡顿。</p><p>由于是个人学习，就不打算将其部署到线上的服务器上了，这一次我采用在本地安装的方式搭建 Gitlab。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>拉取 Gitlab 官方最新版本镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab&#x2F;gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>由于镜像较大，建议换成国内镜像提高下载速度。</p><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>下载完成后，再执行 <code>run</code> 启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname localhost \</span><br><span class="line">    --publish 4443:443 --publish 999:80 --publish 22:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume ~&#x2F;docker&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab \</span><br><span class="line">    --volume ~&#x2F;docker&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \</span><br><span class="line">    --volume ~&#x2F;docker&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \</span><br><span class="line">    gitlab&#x2F;gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><code>run</code> 参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--detach：让容器在后台运行</span><br><span class="line">--hostname：主机地址，本地使用 localhost，可以换成域名</span><br><span class="line">--publish：宿主机的端口映射到容器的端口，由于我本地已经有其他容器使用了 443 和 80 端口，因此我改成了 4443 和 999 端口。</span><br><span class="line">--name：自定义容器的名称</span><br><span class="line">--restart：容器重启策略，在退出时容器应该如何重启或不应该重启，always 始终重启 </span><br><span class="line">--volume：宿主机映射到容器的卷，用来做容器数据的持久化，这里我将卷的目录设置为 ~&#x2F;docker&#x2F;gitlab</span><br></pre></td></tr></table></figure><p><code>run</code> 命令执行后，可以执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;docker&#x2F;gitlab</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以看到自动生成了以下几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configdatalogs</span><br></pre></td></tr></table></figure><p>这些文件就是宿主机与容器之间通过卷映射的文件（容器数据持久化）。</p><p>执行 <code>docker ps</code> 可以看到容器运行状态：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143262-d0a23c00-ce41-11e9-81d3-4b727313dacf.png" alt="image"></p><h3 id="Gitlab-初始化"><a href="#Gitlab-初始化" class="headerlink" title="Gitlab 初始化"></a>Gitlab 初始化</h3><p>容器启动后，需要稍等几分钟，然后再访问 <code>127.0.0.1:999</code>，如果直接访问的话可能 Gitlab 还未完全启动，这个时候是访问不了的。</p><p>第一次访问时，需要设置管理员（root 用户）密码：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143324-10692380-ce42-11e9-98a9-f7372dc57b02.png" alt="image"></p><p>初始化密码设置完成后，返回到登录页面，使用账户 root 以及刚才设置的密码进行登录：</p><p><img src="https://user-images.githubusercontent.com/28209810/64143342-31317900-ce42-11e9-98df-6ea83f67a14a.png" alt="image"></p><p>登录成功后，就可以操作界面啦！</p><p><img src="https://user-images.githubusercontent.com/28209810/64143494-dba99c00-ce42-11e9-864a-861c4a2adacc.png" alt="image"></p><h3 id="添加-SSH-key"><a href="#添加-SSH-key" class="headerlink" title="添加 SSH key"></a>添加 SSH key</h3><p>在开始使用之前，需要添加 <code>ssh key</code> 才能拉取或者推送到仓库，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>查看是否生成过 <code>ssh key</code>，如果当前目录下没有文件，则需要创建新的 <code>ssh key</code>，执行以下命令生成 <code>ssh key</code>，<code>-C</code> 参数后面是你的邮箱地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>完成后在当前目录下会生成 <code>ssh key</code>，包含两个文件，这是一对密匙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id_rsaid_rsa.pub</span><br></pre></td></tr></table></figure><p>其中，<code>id_rsa.pub</code> 是公钥，我们需要的就是这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的密匙字符串复制下来（注意是把所有的内容都复制下来，包括邮箱）。</p><p><img src="https://user-images.githubusercontent.com/28209810/64162429-dca5f200-ce71-11e9-8812-5d3a965ea569.png" alt="image"></p><p>接着返回 Gitlab，点击左上角个人头像，选择 <code>Settings</code>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64161700-a320b700-ce70-11e9-8444-2370d88bff56.png" alt="image"></p><p>选择左侧菜单 <code>SSH Keys</code>，将你的 <code>ssh key</code> 黏贴到方框内，然后点击 <code>Add key</code> 即可：</p><p><img src="https://user-images.githubusercontent.com/28209810/64162574-27276e80-ce72-11e9-95e6-e2e23ca57098.png" alt="image"></p><p>接下来就可以愉快的开始使用 Gitlab 啦！</p><h2 id="为什么安装后的-Gitlab-可以直接访问？"><a href="#为什么安装后的-Gitlab-可以直接访问？" class="headerlink" title="为什么安装后的 Gitlab 可以直接访问？"></a>为什么安装后的 Gitlab 可以直接访问？</h2><p>这是由于 Gitlab 内置了 nginx 服务器，所以才能在安装完成后通过地址进行访问。</p><p>完结撒花～ ҉٩(<em>´︶`</em>)۶҉ ??</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab + Satis 搭建私有 Composer 仓库</title>
      <link href="/install-gitlab-satis-composer/"/>
      <url>/install-gitlab-satis-composer/</url>
      
        <content type="html"><![CDATA[<h2 id="Satis-介绍"><a href="#Satis-介绍" class="headerlink" title="Satis 介绍"></a>Satis 介绍</h2><p>Satis 是开源的静态 Composer 仓库生成器，可用于托管公司私有包的元数据。</p><p>环境要求：PHP &gt;= 7.2</p><h2 id="安装-Gitlab"><a href="#安装-Gitlab" class="headerlink" title="安装 Gitlab"></a>安装 Gitlab</h2><p>Centos 搭建 Gitlab：<a href="/centos-install-gitlab">Centos 系统安装 Gitlab</a><br>Docker 搭建 Gitlab：<a href="/docker-install-gitlab">再战！Docker 安装 Gitlab</a></p><h2 id="上传-Composer-包"><a href="#上传-Composer-包" class="headerlink" title="上传 Composer 包"></a>上传 Composer 包</h2><p>Composer 包开发教程：<a href="/composer-package">从零开始开发自己的 Composer 包</a></p><p>在 Gitlab 新建一个仓库，把自己开发完成的包上传到这个仓库，上传完成后的仓库如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/64165187-204f2a80-ce77-11e9-9532-fbe4a9239a37.png" alt="image"></p><p>包的配置文件 <code>composer.json</code> 如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/64166482-c7cd5c80-ce79-11e9-8b25-7719a08c156e.png" alt="image"></p><p>包的名字叫做：<code>huotu/test</code>，我们后面需要用到。</p><p>这个仓库的地址就是我们私有包的地址，接下来拿这个包作为演示。</p><h2 id="安装-Satis"><a href="#安装-Satis" class="headerlink" title="安装 Satis"></a>安装 Satis</h2><p>可以使用两种方式安装 Satis。</p><h3 id="1、Composer-安装"><a href="#1、Composer-安装" class="headerlink" title="1、Composer 安装"></a>1、Composer 安装</h3><p>可以直接使用 <code>composer</code> 命令安装 Satis： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project composer&#x2F;satis --stability&#x3D;dev --keep-vcs</span><br></pre></td></tr></table></figure><h3 id="2、从-GitHub-下载"><a href="#2、从-GitHub-下载" class="headerlink" title="2、从 GitHub 下载"></a>2、从 GitHub 下载</h3><p>使用 <code>git clone</code> 将 Satis 下载到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;composer&#x2F;satis.git</span><br></pre></td></tr></table></figure><h2 id="添加-Satis-配置文件"><a href="#添加-Satis-配置文件" class="headerlink" title="添加 Satis 配置文件"></a>添加 Satis 配置文件</h2><p>在下载好的 satis 目录下，创建 <code>satis.json</code> 配置文件，一个示例的配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;packages.example.org&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;mycompany&#x2F;privaterepo&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;svn.example.org&#x2F;private&#x2F;repo&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;mycompany&#x2F;privaterepo2&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;require&quot;: &#123;</span><br><span class="line">    &quot;company&#x2F;package&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;company&#x2F;package2&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;company&#x2F;package3&quot;: &quot;2.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name：仓库的名字，将会展示在页面上</li><li>homepage：satis 访问地址</li><li>repositories：包所在的地址</li><li>require：获取指定的包</li><li>require-all：如果为 true 表示获取所有包</li></ul><p>根据自己的情况进行配置，这里我们拿刚刚上传到 Gitlab 的包演示，配置如下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>http://satis.com</code> 为 satis 访问页面地址，<code>http://gitlab.com/huotu/test</code> 为私有包所在地址。</p><h2 id="Composer-配置"><a href="#Composer-配置" class="headerlink" title="Composer 配置"></a>Composer 配置</h2><p>由于我们使用 <code>http</code>，在这里需要修改设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g secure-http false</span><br></pre></td></tr></table></figure><h2 id="生成-Satis-索引页面"><a href="#生成-Satis-索引页面" class="headerlink" title="生成 Satis 索引页面"></a>生成 Satis 索引页面</h2><p>在 satis 目录下执行命令 <code>composer install</code> 安装所需依赖，然后再执行如下命令生成 satis 页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">php bin&#x2F;satis build &lt;configuration file&gt; &lt;build dir&gt;</span><br><span class="line"></span><br><span class="line"># 示例 ：</span><br><span class="line">php bin&#x2F;satis build satis.json public&#x2F;</span><br><span class="line"></span><br><span class="line"># 跳过 Gitlab 密码验证</span><br><span class="line">php bin&#x2F;satis build -n satis.json public&#x2F;</span><br></pre></td></tr></table></figure><p>执行完命令后，在当前目录生成了 public 文件夹，接着配置 nginx，将域名指向这个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name satis.com;</span><br><span class="line">    root &#x2F;www&#x2F;satis&#x2F;public;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 nginx，不出意外就可以通过域名访问 satis 了！</p><blockquote><p>使用域名记得添加解析到服务器</p></blockquote><p>访问 <code>http://satis.com</code>（这个是你配置的域名）：</p><p><img src="https://user-images.githubusercontent.com/28209810/64164278-8044d180-ce75-11e9-8b1a-9e81d905418c.png" alt="image"></p><h2 id="Composer-使用私有仓库"><a href="#Composer-使用私有仓库" class="headerlink" title="Composer 使用私有仓库"></a>Composer 使用私有仓库</h2><p>我们现在完成了 Satis + Gitlab 的全部安装，接下来我们的项目就可以使用自己搭建的私有 Composer 源了。</p><p>新建一个 test 文件夹，在 test 目录下创建 <code>compsoer.json</code>，编辑 <code>composer.json</code> 添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;huotu&#x2F;test&quot;: &quot;*&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;repositories&quot;: [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存，然后在当前目录下执行 <code>composer install</code>：</p><p><img src="https://user-images.githubusercontent.com/28209810/64166283-58576d00-ce79-11e9-9cf3-233193e4963e.png" alt="image"></p><p>成功把自己私有仓库的包下载下来了。</p><p>如果有多个包，则添加多个仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;My Repository&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;,</span><br><span class="line">  &quot;repositories&quot;: [</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test2&quot; &#125;,</span><br><span class="line">    &#123; &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;gitlab.com&#x2F;huotu&#x2F;test3&quot; &#125;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;require-all&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存包资源"><a href="#缓存包资源" class="headerlink" title="缓存包资源"></a>缓存包资源</h2><p>可以把所需要的包都缓存在本地 Satis 上，这样可以避免每次都需要从仓库中 clone，在 <code>satis.json</code> 添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;archive&quot;: &#123;</span><br><span class="line">        &quot;directory&quot;: &quot;dist&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;tar&quot;,</span><br><span class="line">        &quot;prefix-url&quot;: &quot;http:&#x2F;&#x2F;satis.com&quot;,</span><br><span class="line">        &quot;skip-dev&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>archive</code> 参数：</p><ul><li>directory: 表示生成的压缩包存放的目录，会在我们 build 时的目录中</li><li>format: 压缩包格式，zip（默认） tar</li><li>prefix-url: 下载链接的前缀的 Url, 默认从 homepage 中取</li><li>skip-dev: 默认为 false，是否跳过开发分支</li><li>absolute-directory: 可选，包文件存储到绝对路径的目录</li><li>whitelist: 可选，如果设置为包名称列表，则只会转储这些包的 dist 文件</li><li>blacklist: 可选，如果设置为包名称列表，则不会转储这些包的 dist 文件</li><li>checksum: 可选，默认情况下为 true，禁用时（false）不会为 dist 文件提供 sha1 校验 启用后，所有下载（包括来自 GitHub 和 BitBucket 的下载） 将替换为本地版本。</li></ul><p>添加 <code>archive</code> 后，配置的包信息就会下载到本地 Satis 目录下 dist 文件夹中，从 Satis 下载依赖时将从这个文件夹获取资源。</p><h2 id="定期更新-Satis"><a href="#定期更新-Satis" class="headerlink" title="定期更新 Satis"></a>定期更新 Satis</h2><p>需要定期执行 <code>php bin/satis build satis.json public/</code> 命令来生成最新的 Composer 包信息，可以将此命令作为定期任务执行，或是增加一个钩子 push 来更新 Satis。</p>]]></content>
      
      
      <categories>
          
          <category> composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> docker </tag>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的抽奖是否应该有保底机制？</title>
      <link href="/game-draw-card-mechanism/"/>
      <url>/game-draw-card-mechanism/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏中的抽奖机制是几乎所有游戏都要面临的问题，在一定程度上来说，抽奖机制可以决定游戏的命运。</p><p>当一个打算弃坑的玩家，想在最后抽个爽，结果却出了许多氪金大佬都没有的神宠！在游戏广播下，世界频道异口同声的喊起“狗托”，豹子头“零充”玩家心情自然不言而喻，十有八九会享受万众羡慕的眼神继续愉快的玩耍。</p><p>反之，一个氪金大佬怒抽 100 连，砸了 N 个 648 结果还不出货，正气急败坏，却看楼上那位零氪玩家的广播 <strong>XXX 玩家抽到 XXX</strong>，试问氪金大佬此时作何感想？</p><p>当然，上面的情景仅为 YY，实际上可能并没有那么夸张，举例只是为了说明在某些特定情况下可以决定玩家是否继续玩下去。</p><h2 id="游戏中的抽奖机制"><a href="#游戏中的抽奖机制" class="headerlink" title="游戏中的抽奖机制"></a>游戏中的抽奖机制</h2><p>游戏中的抽奖机制经过不断演变，发展为两种比较常见的形式：<strong>无保底机制</strong> 与 <strong>保底机制</strong>。</p><h3 id="无保底机制"><a href="#无保底机制" class="headerlink" title="无保底机制"></a>无保底机制</h3><p>如字面意思，无论抽几次，概率都是一样。</p><p>这种模型会造成某些玩家运气好，尤其是零元党在抽到好东西的时候很喜欢在 <strong>贴吧秀</strong>，对包括零氪、土豪玩家造成暴击伤害，“脸帝”是玩家公敌。</p><p>无保底机制的弊端会造成游戏过于依赖运气成分。</p><p>脸黑玩家可能永远抽不到，土豪玩家可能连砸 N 个 648 依然得不到。</p><p>站在游戏开发者的角度，希望绝大多数玩家可以体验到游戏绝大多数内容，而不是单纯的靠运气决定，这个时候就可以依靠俗话说的“努力就会有回报”。</p><h3 id="保底机制"><a href="#保底机制" class="headerlink" title="保底机制"></a>保底机制</h3><p>玩家通过抽奖，达到一定次数就能得到最好的奖励，这就是保底奖励。</p><p>保底奖励又有两种形式。</p><h4 id="积分兑换"><a href="#积分兑换" class="headerlink" title="积分兑换"></a>积分兑换</h4><p>第一种是以累计 <strong>“积分”</strong> 的形式，玩家可以用积分在商店兑换到最好的奖励。</p><p>这种方式的好处是，玩家可以 <strong>明确的知道</strong> 抽几次一定可以拿到大奖，虽然可能会损失几分惊喜的感觉，但是会让玩家心里感到踏实。即使失败也不会有太大的负面影响，因为失败也会累计积分作为补偿。</p><h4 id="幸运值"><a href="#幸运值" class="headerlink" title="幸运值"></a>幸运值</h4><p>第二种是通过抽奖累计 <strong>“幸运值”</strong>，每次抽奖都可以使下次抽到大奖的几率提高，幸运值达到满时必定抽到。比如王者荣耀的水晶/积分抽奖，玩家可以通过日常获得的钻石去抽奖，即使没抽到也可以积累幸运值，慢慢积累直到抽到水晶然后兑换韩信这个英雄。有些游戏的强化系统也采用这种形式，每次强化失败，下一次强化的成功几率就会提高。</p><p>这种方式的好处是可以让玩家 <strong>保持对于抽奖的期待</strong>，因为概率不断提高，玩家的内心就会觉得可能下一次就中了，而且有保底满幸运值必中的结果，玩家对于失败的感觉就很淡然了，现在的抽奖已经变为 <strong>“可以让我省多少钱”</strong>，越早抽到，玩家反而会觉得赚到了。</p><h2 id="游戏的抽奖该不该保底？"><a href="#游戏的抽奖该不该保底？" class="headerlink" title="游戏的抽奖该不该保底？"></a>游戏的抽奖该不该保底？</h2><p>回到标题，让我们思考下面几个问题：</p><ul><li><p>游戏的抽奖该不该保底？</p></li><li><p>开发商会因为保底而亏损吗？</p></li><li><p>保底抽奖机制到底对哪种类型的玩家更有好处？</p></li></ul><p><strong>1、个人的看法是游戏抽奖以保底机制更好</strong></p><p>我是一个游戏开发者，我希望玩家可以体验到游戏的更多内容（毕竟是我亲自设计的），故意吊玩家的胃口，让某些神宠只让个别人拥有，固然可以提高玩家对神宠的追求，但如果一个永远无法达成的目标，只会让玩家失望，累积越来越多的失望最终就会失去玩家。</p><p><strong>2、不会因为保底抽奖而亏损</strong><br>首先保底机制可以减少玩家的流失，这是其一；其二，保底机制也让土豪玩家更有动力去充钱，以上面的积分模型为例，土豪玩家如果想要得到所有最好的奖励，“最坏”的结果已经可以通过计算明确知道了，当人知道最坏结果时，对失败的承担能力就会越强，而且土豪也可以通过计算推出自己 <strong>应该充多少钱</strong> 才能拿到所有的奖励，土豪并不差钱，但是土豪并不想被 <strong>概率</strong> 忽悠。</p><p>策划也可以通过 <strong>临界值</strong> 来诱使玩家进行充值，这个方法十分见效，我自己就上过很多次当。</p><p>下面是我被网易坑的血泪史（┭┮﹏┭┮）：</p><p>网易新出的游戏百闻牌，里面故意设计红玉和蓝玉兑换机制，让玩家误以为充值的就是红玉，其实充值的是蓝玉，需要再兑换成红玉才能抽奖。</p><p>（<strong>这种欺骗玩家或者诱导玩家错觉的行为极其不可取！</strong>）</p><p>抽奖处显示抽 10 次就可以得到妖刀姬，我就充了 30（计算得出只要充 30 就可以抽 10 次奖），结果发现充值的是蓝玉，兑换之后只有 5 次抽奖机会（真是神坑！）</p><p>好吧，现在已经抽了 5 次，再抽 5 次才能抽到，那我是抽还是不抽呢？这里还涉及到沉默成本，后文介绍。</p><p>当然是选择继续抽，而且这次还充了 68，原因是首充有额外赠送。</p><p>落入策划步步设计的深坑 ┭┮﹏┭┮</p><p>然后又抽了 5 次才拿到妖刀姬。</p><p>这里，由于我之前已经累积了 5 次，只要再抽 5 次就可以拿到大奖，因此我会有驱动力去继续抽下去，如果是在临界值，这个动力就会更强，例如：299/300 的时候，只需要再一次就可以抽到！</p><p>接下来谈一谈 <strong>沉默成本</strong>。</p><p>沉默成本是经济学里面的概念（我大学也是学过经济学的2333）。</p><p>比如你投一只股票，当天亏损了 5 万，你会卖掉还是等明天看看？</p><p>很多人都会留着看看，因为这样白白亏损很不甘心。</p><p>但实际上，你亏损的 5 万已经成为了事实，已经无法改变，不应该影响下一步的决策。</p><p>就像上面我充了 30，结果发现只抽了 5 次，但此时我损失 30 块钱已经是板上钉钉子的事了，但是我的心里面就会想：“我已经充了 30，再充 30 就可以拿到想要的了，不能让之前充的白白浪费”。</p><p>这里就是沉默成本在作怪。</p><p>实际上，沉默成本也是决定游戏命运至关重要的要素，如果一个策划可以让玩家在游戏里投入更多的时间，那玩家就会越来越难以失去这个游戏，甚至以为是“情怀”什么的，比如魔兽玩家经常会说，“那不是游戏，而是我逝去的青春”，可以说是沉默成本非常形象的说明了。</p><p><strong>3、保底机制更利于氪金玩家</strong><br>由于保底机制，只要无限氪金 <strong>必然可以得到一切</strong>，也就造成了有钱可以为所欲为的情况，难道开发商不希望土豪充更多的钱吗？所以，开发商是绝对不会亏的，这一点可以保证。</p><p>由于氪金玩家可以不断充钱得到所有的奖励，如果不是保底机制呢？氪金玩家投入将是无底洞，无论投入多少钱，也许永远都得不到想要的一只英雄或者宠物。</p><p>其次，对于零氪玩家来说也是极好的，只是提升的程度没有土豪玩家那么大而已。</p><p>保底机制对“脸帝”来说是最大的威胁，由于保底，这样他们根本 <strong>秀不起来</strong>，他们由于脸好得到的神宠已经是人手可得的普通宠物了，晒这样的宠物已经无法满足他们日渐膨胀的虚荣心。</p><p>作为贴吧 13 级的大水比，已经见惯了秀脸贴。</p><p>“萌新求问 XXX 有用吗？”</p><h2 id="抽奖中的暗箱操作"><a href="#抽奖中的暗箱操作" class="headerlink" title="抽奖中的暗箱操作"></a>抽奖中的暗箱操作</h2><p>之前看了一期游戏抽奖的视频，介绍了游戏抽奖中的各种暗箱操作。</p><p>其中之一是最坑的，下面用一个故事来说明。</p><p>隔壁老王有一颗价值 1 万的钻石，他想了一个办法，可以让这颗钻石赚到更多钱。</p><p>他做了 300 个空盒子，接着把钻石放在其中一个盒子，其他 299 个盒子都放一颗与钻石等重的碎玻璃，然后他开始在大街上摆摊吆喝：300 个盒子里有一颗价值 1 万的钻石，其他都是玻璃，每个盒子卖 50 块，买盒子的人不能说出自己开到什么东西。</p><p>众人听到，纷纷想以 50 博 1 万，结果所有的盒子都卖出去了，老王共得 1.5 万，比直接出售钻石还多赚了 5000。</p><p>在这里有一个很坑的点，假设第一个买盒子的人开到钻石，那后面 299 个人必定无法开到钻石，也就是必定亏损的，但是由于 <strong>“不能说出自己开到什么”</strong> 导致后面来买盒子的人仍然抱有期待，因而继续购买盒子。</p><p>在一些游戏中，由于玩家并不能知道游戏的抽奖机制是什么，因此就会有策划想出这种“歪点子”，有些游戏里的大奖每天只会发放一份（或者固定份数），而后续的玩家永远抽不到。</p><p>除此之外，还有另一种暗箱操作——奖池机制。</p><p>这种方式的特点是全服玩家共享一个奖池，上面的例子也可以归为此类，只不过奖池机制有些不同。</p><p>奖池是彩票或者棋牌游戏中的概念，所有玩家一起打牌，每轮都要下赌资，赌资全部汇集到奖池中，直到某个玩家开牌，牌面最大的玩家得到所有奖池的钱。</p><p>游戏抽奖机制也存在这种情况，所有玩家都在一个奖池里抽奖，玩家的每次抽奖相当于 <strong>“投入赌资”</strong>，只有抽奖次数达到一定水平时才会出现大奖，大奖被一个玩家得到以后，奖池清空，开启下一轮的奖池，以此类推。</p><p>所以在某些游戏中，垫子之类的说法存在一定道理，一个服务器里面抽奖的玩家越多，抽到大奖的几率就越高，在鬼区没人抽奖的情况下，甚至有可能抽奖几率为负数。</p><h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>在这里写一下个人的想法。</p><p>假如作为开发商，自然希望玩家能多充钱，因为开发商开发游戏的目的很明确就是为了赚钱。</p><p>作为游戏制作者，我希望玩家可以体验到更多的游戏内容，而不是靠运气和财富差距造成严重游戏体验偏差。至于钱，目前并没有太大的想法，现在只是单纯的因为喜欢游戏而做游戏，也许以后会为了钱设计坑玩家的套路，但是赚到钱（维持生计）的同时，一定会并行开发一款自己真正想做的游戏（单机游戏）。</p><p>作为玩家，希望策划别坑！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴子都能学会的hexo博客安装教程</title>
      <link href="/easy-to-start-hexo/"/>
      <url>/easy-to-start-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h2><p>hexo 是一款开源博客项目。</p><p>即使是小白借助 hexo 也能轻松搭建属于自己的博客。</p><p>根据下面的教程，你能学会搭建个人博客，并且其他人可以通过外网访问到你的博客！</p><p>hexo 官网：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></p><p>官方中文文档：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></p><p>【FAQ】</p><p>需要买服务器和域名吗？</p><p>通过 Github Pages 可以白嫖域名和服务器，所以不用买。</p><p>当然，如果你的钱包预算足够，买一款心仪的域名和自己的服务器那就更完美了！</p><p>话不多说，接下来直接进入教学篇。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本教程主要基于 Linux 系统，如果是 Window 系统也不用急，只是增加一个配置环境变量的步骤，机智的你一定懂得怎么做！</p><p>代码编辑器：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a></p><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>hexo 依赖于 node，首先需要安装 node 环境。</p><h3 id="1、安装-Nodejs"><a href="#1、安装-Nodejs" class="headerlink" title="1、安装 Nodejs"></a>1、安装 Nodejs</h3><p><strong>Windows 系统</strong></p><p>nodejs 官网下载：<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p>如果确实是小白，建议下载 Windows 安装包 (.msi)，msi 安装包会自动配置环境变量，真正实现小白式操作。</p><p><strong>Linux 系统</strong></p><p>Linux 版本众多，在这里只介绍 Centos 的安装方法。</p><p>第一步：安装 node 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ openssl-devel epel-release</span><br></pre></td></tr></table></figure><p>第二步：安装 nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><p>安装完成后，在控制台输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果可以看得到版本信息说明安装成功。</p><p>安装完 node 之后，即可使用 npm 命令，由于 npm 的源是国外网站，速度会很慢，为了节省时间我们可以更换淘宝提供的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用 <code>cnpm</code> 命令了，在后续的操作用 cnpm 来代替 npm。</p><h3 id="2、安装-Git"><a href="#2、安装-Git" class="headerlink" title="2、安装 Git"></a>2、安装 Git</h3><p>Git 是代码托管工具，整个过程 Git 的戏份很少，不懂的小白也不用担心，安装好就对了！</p><ul><li>Windows：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a>.</li><li>Mac：使用 Homebrew, MacPorts 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：sudo apt-get install -y git-core</li><li>Linux (Fedora, Red Hat, CentOS)：sudo yum install -y git-core</li></ul><blockquote><p>Mac 用户请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。</p></blockquote><h3 id="3、安装-hexo"><a href="#3、安装-hexo" class="headerlink" title="3、安装 hexo"></a>3、安装 hexo</h3><p>使用 cnpm 命令一键安装 hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，在控制台输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo</span><br></pre></td></tr></table></figure><p>如果看得到如下信息说明安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  help     Get help on a command.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages in the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#39;hexo help [command]&#39; for the detailed information</span><br><span class="line">or you can check the docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><h2 id="搭建博客！"><a href="#搭建博客！" class="headerlink" title="搭建博客！"></a>搭建博客！</h2><p>现在开始搭建博客项目，运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个 blog 是文件夹的名字，你可以随意取，在这里我把它取名 blog。</p><p>执行完这个命令会自动在当前目录下创建一个 blog 文件夹，使用命令 <code>cd blog</code> 进入这个文件夹，接着再执行 <code>cnpm install</code>。</p><p>安装完成后，文件夹的目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>需要注意两个主要的配置文件：</p><h3 id="1、-config-yml"><a href="#1、-config-yml" class="headerlink" title="1、_config.yml"></a>1、_config.yml</h3><p>网站的配置信息，比如网站的名字什么的，都在这里进行配置。</p><h3 id="2、package-json"><a href="#2、package-json" class="headerlink" title="2、package.json"></a>2、package.json</h3><p>网站依赖的包（小白不用管这个东西），默认已经帮你配置好常用的包了。</p><p>以上，你的博客已经搭建完啦！</p><h2 id="访问博客！"><a href="#访问博客！" class="headerlink" title="访问博客！"></a>访问博客！</h2><p>什么鬼！？这就搭建完了？？</p><p>yes，我们打开控制台，在博客目录下执行命令启动博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619193-9a0c6a80-5bb3-11ea-88af-f8ea2b22b051.png" alt="启动hexo博客"></p><p>然后打开浏览器，输入 <code>http://localhost:4000</code> 或 <code>127.0.0.1:4000</code>。</p><p>你就可以看到搭建好的博客啦！</p><p>如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619228-6716a680-5bb4-11ea-99c2-d121aba9338f.png" alt="hexo博客"></p><h2 id="写下第一篇博文！"><a href="#写下第一篇博文！" class="headerlink" title="写下第一篇博文！"></a>写下第一篇博文！</h2><p>好吧，其实你的第一篇博客已经被系统写好了，也就是你在上图看到的标题为 Hello World 的博文。</p><p>接下来我们要手动创建第一篇博客！</p><p>使用命令 <code>hexo n &lt;博文标题&gt;</code> 来创建一篇新的博文。</p><p>控制台下输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的第一篇博客&quot;</span><br></pre></td></tr></table></figure><p>执行完命令后，可以看到生成了一个 .md 格式的文件 <code>/blog/source/_posts/我的第一篇博客.md</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619292-13588d00-5bb5-11ea-9ff2-4833965a8456.png" alt="image"></p><p>这个文件就是我们的博文内容，进入 <code>/blog/source/_posts/</code> 然后打开 <code>我的第一篇博客.md</code>， 可以看到默认内容类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2020-03-01 10:49:10</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>开头的部分不要动，在结尾部分写自己想写的文章即可，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2020-03-01 10:49:10</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 兔子的日记</span><br><span class="line"></span><br><span class="line">今天的天气真好！</span><br></pre></td></tr></table></figure><p>如果你用的是 Markdown 还能看到预览效果！</p><p>Markdown 编辑器推荐：<a href="http://note.youdao.com/semdl/markdown.html" target="_blank" rel="noopener">有道云笔记</a></p><p>（你可以在其他地方编辑好文章，然后复制过来）</p><p>我用的是 PHPstorm，预览效果如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619349-c5905480-5bb5-11ea-89d2-d2abf88cdef4.png" alt="hexo第一篇博文"></p><p>文章内容已经写好了，接下来要生成静态页面，按 <code>Ctrl+C</code> 把刚才启动的博客关掉：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619390-2ae44580-5bb6-11ea-8835-12430e945e21.png" alt="关闭hexo服务"></p><p>然后依次运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清空数据库，如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619432-8d3d4600-5bb6-11ea-9985-a56c65a7cf48.png" alt="hexo clean"></p><p>接着输入 <code>hexo g</code> 重新编译生成静态页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619447-c4135c00-5bb6-11ea-827b-28be7914d84c.png" alt="hexo 生成博文"></p><p>最后，再启动 hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>浏览器输入：<code>127.0.0.1:4000</code> 就可以看到自己刚才写的那篇文章了。</p><p>如图所示：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619492-5451a100-5bb7-11ea-9af3-c25af149898f.png" alt="hexo第一篇博文"></p><p>至此，hexo 的基本操作已经 OK 了。</p><p>再来总结一下怎么发一篇博文。</p><p>1、执行 <code>hexo n &lt;标题&gt;</code> 创建博文文件</p><p>2、在 Markdown 编辑器完成博文书写，把内容复制到上面生成的博文文件里</p><p>3、执行 <code>hexo clean</code> 清空数据</p><p>4、执行 <code>hexo g</code> 重新编译生成静态文件</p><p>此外，本地调试用 <code>hexo s</code> 开启本地服务，在浏览器输入 <code>127.0.0.1:4000</code> 访问博客项目。</p><p>要记住这些步骤和命令对小白来说十分吃力，这是很正常的事情。</p><p>如果忘记了怎么操作，回头多看几遍本博文，熟能生巧！</p><h2 id="自定义主题！"><a href="#自定义主题！" class="headerlink" title="自定义主题！"></a>自定义主题！</h2><p>默认博客页面太丑，想换一个怎么办？</p><p>网上找到其他人分享的主题：<a href="https://github.com/zhvala/hexo-material-x-black" target="_blank" rel="noopener">https://github.com/zhvala/hexo-material-x-black</a></p><p>然后把它下载下来，点击右侧 Clone or download：</p><p>下载下来并且解压，把解压后的文件复制到博客项目的 themes 目录下。</p><p>或者直接 clone 到 themes 目录下并且命名为 material-x：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-material-x themes&#x2F;material-x</span><br></pre></td></tr></table></figure><p>主题文件都很大，等下载完成就可以了。</p><p>主题下载下来以后，目录结构如下：</p><p><img src="https://s2.ax1x.com/2020/03/01/3g86hV.png" alt="3g86hV.png"></p><p>themes 下面的文件夹都是主题。</p><p>接着编辑 .config.yml，拉到底部，修改 theme 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: material-x</span><br></pre></td></tr></table></figure><p>theme 默认是 landscape，改成刚刚下载的主题 material-x（即文件夹的名字）。</p><p>然后安装主题所需的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts</span><br></pre></td></tr></table></figure><p>接着执行下面几个命令（如果之前启动了博客项目，记得按 Ctrl+C 先关掉）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:4000</code>，可以发现主题已经被更换成新的了。</p><p>在 Github 上还有更多主题可以选择：<a href="https://github.com/search?q=hexo+theme&type=Repositories" target="_blank" rel="noopener">点击此处获取更多主题</a></p><h2 id="发布博客！"><a href="#发布博客！" class="headerlink" title="发布博客！"></a>发布博客！</h2><p>上面的步骤只能在自己的电脑打开博客项目，现在我们要把博客发到外网去，让别人来参观你的博客！</p><p>— 小剧场 —</p><p>你是想要节操，还是想白嫖域名和服务器？</p><p>我是想要节操还把域名和服务器嫖了！</p><p>嫖不成。</p><p>啪一声，你把 300 块大洋拍在桌子上。</p><p>这个能不能换来节操？</p><p>能，但是钱包空了。</p><p>啪一声，你把节操拍在桌子上，300 块大洋收回兜里。</p><p>嫖谁的？</p><p>GitHub 的！</p><p>就那个全球最大同性交流社区？</p><p>正是。</p><p>敢问君为何方神圣？</p><p>GitHub 基佬是也。</p><p>— 小剧场（完） —</p><p>没错，我们要白嫖 GitHub 提供的免费域名和空间——GitHub Pages！</p><p>GitHub Pages 提供了免费的服务可以让我们部署博客项目。</p><p>Github：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>注册一个账户并登陆。</p><p>接着点击左侧 Repositories 旁边的按钮 New 创建一个新的仓库，如图：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619699-608b2d80-5bba-11ea-8bff-2570abd32650.png" alt="image"></p><p>仓库的配置有两点需要注意，如果你没按照下面的要求，你的博客就访问不了：</p><p>1、仓库名称必须为：你的 GitHub 用户名.github.io，比如我的 Github 用户名是 huoshaotuzi，那么仓库的名字就是：huoshaotuzi.github.io</p><p>2、仓库必须为 Public 公开权限，如果选择 Private，就不能白嫖了，这也是上面的小剧场所说的出卖节操的原因，一旦公开权限，你的仓库 <strong>任何人都能访问</strong>，你的仓库设置成 Public，相当于你光着屁股暴露在 Github 几百万基佬面前，知道啥意思了吧？</p><p>创建好仓库后，可以看到如下的仓库信息：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619801-8107b780-5bbb-11ea-9b9b-77f1eb0b4078.png" alt="image"><br>（xxoo 是随便取的名字，不要问 xxoo 是什么意思，问了也不会告诉你。）</p><p>在这里把 SSH 后面的仓库地址复制下来，后面会用到。</p><p>接着返回到你博客的目录下，执行命令安装 git 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>安装完成后，编辑根目录下的 _config.yml，拉到最底部，deploy 后面添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;huoshaotuzi&#x2F;xxoo.git（填你自己的）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里的 repo 填入上面说的仓库地址：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619912-0fc90400-5bbd-11ea-9636-1d7bbc7310ce.png" alt="image"></p><p>保存配置文件后，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行命令后开始自动编译并且上传到 GitHub 仓库，然后会提示要输入 Github 的账号跟密码。</p><p>为了避免每次上传都要重复输入账号密码，你可以输入下面的命令记住密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>上传成功后，返回仓库就能看到上传好的代码。</p><p>然后就可以通过仓库名称访问到你的博客了！</p><p>我的仓库名称是：huoshaotuzi.github.io</p><p>在浏览器输入：huoshaotuzi.github.io</p><p>刚刚部署上去的时候，需要等几分钟才能看到博客，不然会出现 404 或者其他问题。</p><p>白嫖党只能使用 GitHub 提供的域名，接下来给大家介绍如何指定域名进行访问。</p><p>比如我的网站是：<a href="https://blog.huotuyouxi.com" target="_blank" rel="noopener">blog.huotuyouxi.com</a></p><p>这是怎么实现的呢?</p><h2 id="指定域名！"><a href="#指定域名！" class="headerlink" title="指定域名！"></a>指定域名！</h2><p>首先，你得有一个域名。</p><p>万网阿里云、百度云、腾讯云、京东云、华为云、国外的 GoDaddy……诸如此类域名服务提供商，任选一家即可。</p><p>建议购买 .com 后缀的域名，域名的名称就按照你自己喜欢的挑选了。</p><p>比如张三：zhangsan.com</p><p>皮卡丘博客：pikachublog.com</p><p>简单好记的域名，这个没什么要求的，选你喜欢的就好。</p><p>域名买好之后，在仓库主页的菜单栏，选择 Settings：</p><p><img src="https://user-images.githubusercontent.com/28209810/75619981-0be9b180-5bbe-11ea-8b71-1a5cc2f906df.png" alt="image"></p><p>拉到下面，直到看到 GitHub Pages，然后点击 Choose a theme 选择一个主题：</p><p><img src="https://ae01.alicdn.com/kf/Hb6adf75de5bb405396b8991dcab4ccf2d.png" alt="image"></p><p>主题按照你喜欢的随便选一个就好：</p><p><img src="https://ae01.alicdn.com/kf/Hdad8baba745a4a5698426e9b386d9606a.png" alt="image"></p><p>比如选第一个，然后点击右下角 Select theme。</p><p>接着返回 Github Pages 配置域名：</p><p><img src="https://ae01.alicdn.com/kf/Ha7c7c267f4594459854b89d8782cf9366.png" alt="image"></p><p>在 Custom domain 栏处填写你购买的域名，然后点击 Save。</p><p>如果需要启用 https 域名，把 Enforce HTTPS 勾选即可，刚部署时需要等待几分钟 Enforce HTTPS 才会显示可选，并且勾选完成后也需要等待几分钟，Github 会为你免费提供 SSL 证书。</p><p>然后打开你购买域名的网站，例如阿里云，登录后打开右上角控制台-点击左上角展开菜单-选择域名：</p><p><img src="https://ae01.alicdn.com/kf/H59ae77f519c645c486feacd4c8e68ff8d.png" alt="image"></p><p>在域名右侧选择解析：</p><p><img src="https://ae01.alicdn.com/kf/H0f6fb6011e264e39a694159c9deac969C.png" alt="域名解析"></p><p>点击“添加记录”，记录类型 CNAME，主机记录 @，记录值填你自己仓库的名字：</p><p><img src="https://ae01.alicdn.com/kf/Hfa26d74adaf24408aba88ef049091802E.png" alt=""></p><p>如果你希望可以用 www 访问，那就再添加一条记录，主机记录填 www，其他跟上面的一样：</p><p><img src="https://ae01.alicdn.com/kf/H638380f92dbf4ff0bd97f57117e225fcv.png" alt=""></p><p>完成这一步你就可以通过购买的域名访问到博客了！</p><h2 id="指定服务器！"><a href="#指定服务器！" class="headerlink" title="指定服务器！"></a>指定服务器！</h2><p>不想出卖节操，就买台服务器自己安装环境，这样可以保证代码不被其他基佬看到。</p><h3 id="1、域名和服务器的选择"><a href="#1、域名和服务器的选择" class="headerlink" title="1、域名和服务器的选择"></a>1、域名和服务器的选择</h3><p>选服务器可是很有讲究的，看你网站的受众，如果是面向海外用户，就选国外的服务器；如果面向国内用户，那就买国内的服务器。服务器放在哪很大程度上会影响你网站的打开速度。</p><p>再者，如果你选国内服务器，还需要注意域名备案的问题。</p><p>想要搭建博客，最好提前买个域名进行备案。</p><p>没有备案的域名只能选择国外主机。</p><p>只建议购买：com、cn、net 这三个老牌域名。</p><p>非主流域名即使能备案，搜索引擎也很难收录，所以不推荐。</p><p>有条件或者嫌备案麻烦的，可以购买香港或者台湾地区的服务器，靠近大陆，延迟相对低一点，域名即买即用。</p><h3 id="2、服务器环境"><a href="#2、服务器环境" class="headerlink" title="2、服务器环境"></a>2、服务器环境</h3><p>服务器推荐 Centos 系统，如果是小白也可以选 Windows Server。</p><p>要让网站解析到服务器，首先需要安装 Web 服务器，老牌的 Web 服务器软件有 Apache，Windows 的 IIS。</p><p>这两个本人几乎没用过，就不在这里介绍了。</p><p>推荐使用 Nginx。</p><p>以 Centos 为例，安装十分简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装完成后，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;blog.conf</span><br></pre></td></tr></table></figure><p>按下 i 键插入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name blog.huotuyouxi.com;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;blog;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按 Esc，输入 <code>wq!</code> 保存。</p><p>接着重启 Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>在这里，<code>server_name</code> 是你的域名。</p><p><code>root</code> 是你的博客项目路径，可以下载 FileZilla 把博客上传到服务器，或者直接使用 <code>git clone</code> 下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www</span><br><span class="line">git clone &lt;你的博客仓库地址&gt;</span><br></pre></td></tr></table></figure><p>然后你在哪买的域名，就登录到控制台把域名解析到服务器的公网 IP。</p><p>解析的方法在上面已经有介绍了，这里不再重复。</p><p>3、更新博客内容</p><p>前面的文章介绍了如何编写和更新博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>更新博客内容并且推送到 Github 上面，你就可以回到服务器上，然后执行 <code>git pull</code> 把最新的博客内容拉取下来，实现博客的更新。</p><p>其中，<code>hexo g</code> 和 <code>hexo d</code> 两个命令可以简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的可以去了解一下 Git 自动构建，延伸的内容太多了，本文写不下</p></blockquote><h3 id="4、博客代码备份"><a href="#4、博客代码备份" class="headerlink" title="4、博客代码备份"></a>4、博客代码备份</h3><p>使用 <code>hexo d</code> 上传到 Github 的只是编译后的静态文件，博客的代码并没有上传到仓库里。</p><p>这样一旦你的博客代码丢失，你就无法继续更新了。</p><p>为了避免这种情况，我们要把博客代码也上传到仓库里，最好是上传到同一个仓库。</p><p>回到本地的博客项目，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b develop</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure><p>这两个步骤，第一个是切换到新的分支 <code>develop</code>（名字可以随便取），然后把新的分支推送到远程仓库。</p><p>如此一来，你的博客代码也被保存至仓库里。</p><p>前往 Github 查看，点击 Branch 即可看到新的分支：</p><p><img src="https://s2.ax1x.com/2020/03/01/3g2BzF.png" alt="git 分支"></p><p>还记得最早我们在 _config.yml 设置的 Github 仓库地址吗？</p><p><img src="https://s2.ax1x.com/2020/03/01/3g2gd1.png" alt="hexo github 配置"></p><p>这里我们把静态文件的分支设置成 master，因此我们可以专注于在 develop 分支上写博文，然后用 <code>hexo d -g</code> 进行推送，不需要进行分支切换，十分方便！</p><p>把博客代码上传到远程仓库，即使你在另一台电脑上面也可以把项目克隆下来，然后执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p>切换到 develop 分支上去写博文。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>借助 hexo 可以快速搭建属于自己的博客，平时学习到新东西的时候就可以记录下来，养成良好的习惯有助于学习成果的积累。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
